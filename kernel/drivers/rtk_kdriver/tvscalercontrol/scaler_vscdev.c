//Kernel Header file
#include <linux/interrupt.h>
#include <linux/sched.h>
#include <linux/delay.h>
#include <generated/autoconf.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/device.h>
#include <linux/cdev.h>
#include <linux/slab.h>
#include <linux/fs.h>
#include <linux/platform_device.h>
#include <linux/mtd/mtd.h>
#include <linux/uaccess.h>
#include <asm/cacheflush.h>
#include <rtk_kdriver/RPCDriver.h>
#include <linux/pageremap.h>
#include <linux/kthread.h>
#include <uapi/linux/const.h>
#include <linux/mm.h>
#include <linux/string.h>/*memset*/
#include <linux/wait.h>//For wake_up and wait
#include <linux/spinlock_types.h>/*For spinlock*/
#include <rbus/dma_vgip_reg.h>
#include <linux/poll.h>
#include <rtk_dc_mt.h>
#include <tvscalercontrol/vip/localcontrast.h>
#include <rbus/ldspi_reg.h>
#include <linux/hrtimer.h>
#include <linux/version.h>
#include <mach/platform.h>

#ifdef CONFIG_RTK_KDRV_PWM
#include <rtk_kdriver/rtk_pwm.h>
#endif
#ifdef CONFIG_RTK_KDRV_QOS_CONTROL
#include <rtk_kdriver/rtk_qos_export.h>
#endif

// FixMe
//#include "../rtk_gdma_export.h"
//#include "../rtk_osdcomp_driver.h"

//#ifndef CONFIG_KDRIVER_USE_NEW_COMMON
//#include <rtk_kdriver/gal/rtk_gdma_export_user.h>
//#endif
#include <tvscalercontrol/scaler/scalerlib.h>

//#include <tvscalercontrol/i3ddma/i3ddma.h>
//#include <tvscalercontrol/i3ddma/i3ddma_drv.h>

#include <rbus/sub_vgip_reg.h>
#include <rbus/onms_reg.h>
#include <rbus/timer_reg.h>
#include <rbus/hsd_dither_reg.h>
#include <rbus/osdovl_reg.h>
#include <rbus/h3ddma_reg.h>
#include <rbus/rgb2yuv_reg.h>
#include <rbus/mdomain_cap_reg.h>
#include <rbus/abl_reg.h>
#include <rbus/iedge_smooth_reg.h>
#include <rbus/mdomain_disp_reg.h>
#include <rbus/vgip_reg.h>
#include <rbus/hdr_all_top_reg.h>
#include <rbus/dm_reg.h>
#include <rbus/vgip_reg.h>
#include <rbus/sub_vgip_reg.h>
#include <rbus/rgb2yuv_reg.h>
#include <rbus/ppoverlay_reg.h>
#include <rbus/onms_reg.h>
#include <rbus/mdomain_cap_reg.h>
#include <rbus/mdomain_disp_reg.h>
#include <rbus/scaleup_reg.h>
#include <rbus/scaledown_reg.h>
//#include <rbus/hdr_all_top_reg.h>
#include <rbus/dm_reg.h>
#include <rbus/misc_reg.h>
//#include <rbus/rbus_DesignSpec_MISC_GPIOReg.h>
#include <rbus/tvsb2_reg.h>
#include <rbus/sfg_reg.h>
#include <rbus/vdtop_reg.h>
#include <rbus/pst_i2rnd_reg.h>

#include <tvscalercontrol/io/ioregdrv.h>
#include <tvscalercontrol/scaler/source.h>
#include <tvscalercontrol/scalerdrv/scalerdrv.h>
#include <tvscalercontrol/scalerdrv/scalermemory.h>
#include <tvscalercontrol/scalerdrv/scalerclock.h>
#include <tvscalercontrol/scalerdrv/overscanTable.h>

#include <tvscalercontrol/pcbsource/pcbSource.h>
#include <tvscalercontrol/scalerdrv/scalerdisplay.h>
#include <tvscalercontrol/scalerdrv/syncproc.h>
#include <tvscalercontrol/scalerdrv/auto.h>
#include <tvscalercontrol/scalerdrv/mode.h>
#include <tvscalercontrol/scalerdrv/scalerip.h>
#include <tvscalercontrol/scalerdrv/framesync.h>
#include <tvscalercontrol/panel/panelapi.h>
#include <tvscalercontrol/adcsource/ypbpr.h>
#include <tvscalercontrol/adcsource/vga.h>
#include <tvscalercontrol/adcsource/adcctrl.h>
#include <tvscalercontrol/hdmirx/hdmifun.h>
#include <tvscalercontrol/vip/ultrazoom.h>
#include <tvscalercontrol/vip/di_ma.h>
#include <tvscalercontrol/vip/scalerColor.h>
#include <tvscalercontrol/vip/ST2094.h>
#include <rtk_kdriver/tvscalercontrol/hdmirx/hdmi_vfe.h>
#include <tvscalercontrol/scaler/scalercolorlib.h>
#include <tvscalercontrol/scalerdrv/adjust.h>
#include <tvscalercontrol/scalerdrv/scaler_2dcvt3d_ctrl.h>
#include <tvscalercontrol/vo/rtk_vo.h>
#include <tvscalercontrol/scalerdrv/zoom_smoothtoggle.h>
#include <tvscalercontrol/scalerdrv/zoom_smoothtoggle_lib.h>
#include <tvscalercontrol/scalerdrv/pipmp.h>
#include <tvscalercontrol/scalerdrv/power.h>
#include <tvscalercontrol/scalerdrv/inprocvideo.h>
#include <tvscalercontrol/scalerdrv/scaler_i2rnd.h>
#include <tvscalercontrol/scalerdrv/scaler_pst.h>
#ifdef CONFIG_KDRIVER_USE_NEW_COMMON
	#include <VideoRPC_System.h>
#else
	#include <rpc/VideoRPC_System.h>
#endif
#include <vgip_isr/scalerAI.h>
#include <tvscalercontrol/vip/scalerColor_tv006.h>
#include <tvscalercontrol/i3ddma/i3ddma.h>
#include <tvscalercontrol/i3ddma/i3ddma_drv.h>
#include <tvscalercontrol/scaler_drv_verify/scaler_verify_common.h>

#include "scaler_vfedev.h"
#include "scaler_vscdev.h"
#include "scaler_vbedev.h"
#include "scaler_vtdev.h"
#include <tvscalercontrol/avd/avdctrl.h>
#include <rbus/vgip_reg.h>
#include "scaler_vpqmemcdev.h"
#include <linux/freezer.h>
#ifdef CONFIG_ENABLE_VD_27MHZ_MODE
#include <tvscalercontrol/scaler/scalervideo.h>
#include <tvscalercontrol/avd/avdctrl.h>
#include "scaler_vfedev.h"
static UINT8 read_buffer_first_flag = 0;
static UINT8 sub_read_buffer_first_flag = 0;

#endif

#if 1//(defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)||defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT))
#include <tvscalercontrol/scalerdrv/scaler_hdr_ctrl.h>
#endif

#ifdef CONFIG_RTK_KDRV_DV
#ifndef	CONFIG_DOLBY_IDK_1_6_1_1
#include "../dolbyvision_edr/dolbyvisionEDR_export.h"
#include "../dolbyvision_edr/dolby_flowCtrl.h"
#endif
#endif

#include <tvscalercontrol/vdc/video.h>
#include <rbus/abl_reg.h>
#include <scaler/vipRPCCommon.h>	/* in common*/

#include <mach/rtk_log.h>

#ifdef CONFIG_COMPAT
#include <linux/compat.h>
#define to_user_ptr(x)          compat_ptr((unsigned int)x)
#else
#define to_user_ptr(x)          ((void* __user)(x)) // convert 32 bit value to user pointer
#endif

static DEFINE_SPINLOCK(orbit_timer_update_spinlock);/* This spinlock is for control wait_orbit_ready*/
void ScalerForceUpdateOrbit(unsigned char force_update);
unsigned char ScalerCheckOrbitFinish(void);

extern unsigned char vbe_disp_oled_orbit_enable;
static DECLARE_COMPLETION(vsc_scaler_tsk_completion);

//#define ENABLE_FORCE_PC_MODE 1

#ifdef ENABLE_SCALER_DUMP_FRAME_INFO
  // VO frame CRC dump
  #ifdef CONFIG_KDRIVER_USE_NEW_COMMON
	#include <VideoRPC_System.h>
  #else
	#include <rpc/VideoRPC_System.h>
  #endif
  #include <linux/kthread.h>

  #include <tvscalercontrol/vdc/yc_separation_vpq.h>
#include <rtk_kdriver/rtk_qos_export.h>

extern void scaler_SendDispSize(StructSrcRect outregion);
extern HDMI_COLOR_SPACE_T drvif_Hdmi_GetRawColorSpace(void);
extern unsigned char drvif_Hdmi_GetFrlMode(void);
extern HDMI_bool drvif_Hdmi_SetClkPixelMode(unsigned char pixel_mode);
extern bool Scaler_AVD_GetHalVscConnect(unsigned char a_ucChannel);
extern HDMI_bool drvif_Hdmi_EnableBypassYUV420Engine(unsigned char enable);


#if 0
  extern struct file *file_open(const char *path, int flags, int rights);
  extern int file_write(struct file *file, unsigned long long offset, unsigned char *data, unsigned int size);
  extern void file_close(struct file *file);
#else
static struct file * file_open(const char *path, int flags, int rights)
{
    struct file* filp = NULL;
    mm_segment_t oldfs;
    int err = 0;

    oldfs = get_fs();
    set_fs(get_ds());
    filp = filp_open(path, flags, rights);
    set_fs(oldfs);
    if(IS_ERR(filp)) {
        err = PTR_ERR(filp);
        return NULL;
    }
    return filp;
}

static void file_close(struct file *file)
{
    filp_close(file, NULL);
}

static int file_write(struct file *file, unsigned long long offset, unsigned char *data, unsigned int size)
{
#ifndef DISABLE_FILE_RW
    mm_segment_t oldfs;
    int ret;

    oldfs = get_fs();
    set_fs(get_ds());

    ret = vfs_write(file, data, size, &offset);

    set_fs(oldfs);
    return ret;
#else
	return 0;
#endif
}
#endif
  static void rtkscaler_dump_init(void);
#endif
#define TAG_NAME_VSC "VSC"
#define TAG_NAME_NEW_GAME_MODE "NEW_GAME_MODE"

enum{
	NOT_EQUAL = 0,
	ALL_EQUAL,
	ONLY_SHIFT_XY,
	ONLY_SHIFT_X,
	ONLY_SHIFT_Y,
};
static unsigned int vsc_task_status = 0;//record vsc task current status

static DEFINE_SPINLOCK(MAIN_BBD_STAGE_SPINLOCK);
static DEFINE_SPINLOCK(SUB_BBD_STAGE_SPINLOCK);

static unsigned char main_bbd_stage = BBD_FUNCTION_DONE;
static unsigned char sub_bbd_stage = BBD_FUNCTION_DONE;

static KADP_VSC_HDR_TYPE_T MAIN_VSC_HDRTYPE = KADP_VSC_HDR_MAXN;//KADP_VSC_HDR_MAXN is SDR //AP set the hdr type
void scaler_set_I2D_tracking_in_slow_mode(unsigned char bEnable);//True for fll use old flow

//#include <rtk_kdriver/rtk_platform.h>
void reset_any_srcrect(StructSrcRect *p_srcrect);
void trigger_mute_off(unsigned char display, unsigned char no_delay);

//#define _PRINT_VSC_COST_TIME_AFTER_MUTE_OFF
static struct semaphore GameMode_SCALER_SYNC_Semaphore;//for game mode and scaler sync Semaphore
static struct semaphore VSC_Semaphore;
static struct semaphore MagMsg_Semaphore;
static struct semaphore Magnifier_Semaphore;
static struct semaphore DM_HDR_Semaphore;
static struct semaphore Force_Run_Idma_Semaphore;
static struct semaphore Low_Delay_Semaphore;
static struct semaphore Double_buffer_Semaphore;
static struct semaphore GameMode_Check_Semaphore;
static struct semaphore set_vsc_film_mode_semaphore;
extern struct semaphore VBE_LowDelay_Semaphore;
static unsigned int check_atv_stable_count =0;

static DEFINE_SPINLOCK(muteoff_main_ctrl_flag_Spinlock);/* This spinlock is for DbgSclrFlgTkr.Main_Request_ForceBG_ctrl for */
#ifdef CONFIG_DUAL_CHANNEL
static DEFINE_SPINLOCK(muteoff_sub_ctrl_flag_Spinlock);/* This spinlock is for DbgSclrFlgTkr.Main_Request_ForceBG_ctrl for */
#endif

#ifdef CONFIG_HDR_SDR_SEAMLESS
void dynamic_change_hdr_setting(unsigned char hdr_enable, I3DDMA_COLOR_SPACE_T color_format);
void dynamic_change_hdr_setting_hdmi_position(unsigned char hdr_enable, I3DDMA_COLOR_SPACE_T color_format, unsigned char hdr_type);
void dynamic_change_hdr_setting_hdmi_finish(unsigned char hdr_enable, I3DDMA_COLOR_SPACE_T color_format, unsigned char hdr_type);

unsigned char rtk_hal_vsc_SetRGB444Mode(bool bonoff);

static struct semaphore HDR_Setting_Semaphore;//this is for HDR V top setting Semaphore
#endif
static struct semaphore HDMI_4K120_MEMORY_PROTECTION_Semaphore;//For 4k120 se buffer protection

#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG
extern void reset_pst_sharemem_buffer(unsigned char display);//set pst sharememocry buffer data for chnage source
extern void set_pst_active_state(unsigned char display, unsigned short state);//set pst active state
#endif


unsigned char vdo0_connect = FALSE;//means connect vo0 //add by will for live zoom
unsigned char vdo1_connect = FALSE;//means connect vo1 //add by will for live zoom

#ifdef CONFIG_ORBIT_PIXEL_SHIFT_ALGO
static struct semaphore Orbit_algo_Semaphore;
#endif
#ifdef _PRINT_VSC_COST_TIME_AFTER_MUTE_OFF
static unsigned int cost_time;
#endif
static struct semaphore SetMainOutPutRegion_Semaphore;/*For main set output region Semaphore*/
static struct semaphore Main_ResetMode_Semaphore;/*For main reset mode Semaphore*/

#ifdef CONFIG_DUAL_CHANNEL
static struct semaphore SetSubOutPutRegion_Semaphore;/*For sub set output region Semaphore*/
static struct semaphore Sub_ResetMode_Semaphore;/*For sub reset mode Semaphore*/

#endif

extern DEBUG_SCALER_VSC_STRUCT DbgSclrFlgTkr; // debug scaler flag tracker
extern unsigned int rotatedisconnecten;
extern StructSrcRect Scaler_intputRegion_base_scalerTiming[MAX_DISP_CHANNEL_NUM];
extern void drvif_color_Set_DRV_SNR_Clock(SCALER_DISP_CHANNEL display, unsigned char En_flag);
extern void Scaler_AVD_SetHalVscConnect(unsigned char a_ucChannel,bool AvdVscConnect);


//int sub_window_type = 0;
//int subWin_LGowner = 0;
int ATV_forcei3ddma = 0;

//These are for mute on to wait memc already blck video
#define MAX_MEMC_DELAY_BUFFER 45//4.4 frame buffer
unsigned char sync_memc_ready = FALSE;//if TRUE. when mute on to wait memc buffer
void wait_memc_ready(void);

int main_InputRegion_0000 = 0;
#ifdef CONFIG_I3DDMA_PATTERN_MEASUREMENT
//unsigned char vsc_video_latency_pattern_enable = 0;
//KADP_VIDEO_RECT_T video_latency_pattern_size = {0, 0, 0, 0};
VSC_VIDEO_LATENCY_PATTERN_T hal_video_latency_pattern_info = {0, 0, {0, 0, 0 ,0}};//record hal info
unsigned char latency_pattern_change = FALSE;//record paramter is change or not
unsigned char latency_pattern_self_test = FALSE;//record paramter is change or not
static DEFINE_SPINLOCK(latency_pattern_spinlock);/*Spin lock no context switch. for control lenterncy info*/
spinlock_t* get_latency_pattern_spinlock(void)
{//this is for  latency_pattern control protection
	return &latency_pattern_spinlock;
}
#endif
#ifdef CONFIG_RTK_KDRV_DV
#ifdef	CONFIG_DOLBY_IDK_1_6_1_1
#include <dolby_idk_1_6_1_1/dolby_adapter.h>
#else
extern volatile unsigned int g_picModeUpdateFlag;
#endif
#endif

#ifdef ENABLE_SCALER_DUMP_FRAME_INFO
  /* dump VO CRC info to file */
  SCALER_MALLOC_STRUCT scaler_g_pDumpCRC_Send ;
  SCALER_MALLOC_STRUCT scaler_g_pDumpCRC ;
  SCALER_DUMP_STRUCT scaler_DumpCRC_Config;
  struct file *scalerfile_DumpCRC = 0 ;
  static struct task_struct *rtkscaler_dumpcrc_tsk;
  static int data;
  static int rtkscaler_dumpcrc_thread(void *arg);
  static unsigned long long f_offset_dumpcrc = 0 ;
  static int rtkscaler_dumpCRC_enable(const char *pattern, int length);
  static void rtkscaler_dumpCRC_disable(void);
  #define SCALAR_DUMP_NEW_FLL_I2D_DLY_ADD_LINE_MAX 30
  #define SCALAR_DUMP_NEW_FLL_I2D_DLY_SUB_LINE_MAX 0
#endif

//static unsigned char VSC_Device_Init_Done = FALSE;
//static unsigned char LivezoomMainRerunFlag = FALSE;
//unsigned char DataFramesynclivezoom = FALSE;
//static unsigned char check_only_xy_shift_same_region = FALSE;
//static unsigned char LivezoomOffKeepMainForceBG = FALSE;
//static unsigned char multiview_sub_interlace_flag = 0;//add HDMI sub channel field control @Crixus 20151203

//static unsigned short main_inputregion_x_pre = 0;
//static unsigned short main_inputregion_w_pre = 0;
//static unsigned short main_inputregion_x_ori_pre = 0;
//static unsigned short main_inputregion_w_ori_pre = 0;
//static unsigned char main_check_pre_flag = 0;

//static unsigned char DI_low_delay_flag = FALSE;

//static unsigned char g_ucCheckAVDandWebOSInfoCount = 0xff;

//unsigned char g_ucVSCCheckATVChanelChange;
//unsigned char g_ucVSCATVChanelChangeStart;
//unsigned char g_ucVSCATVSetWinBlankCount;
//unsigned char g_ucVDCDetectStage;

//#define CONFIG_FIXED_VD_27MHZ_960_TO_UZU 1
//#define CONFIG_MDOMAIN_COMPRESSION_ENBLE 1

#define VSC_PROFILE 0
#define LiveZoom_PROFILE 0
#define _RGB2YUV_m11				0x00
#define _RGB2YUV_m12				0x01
#define _RGB2YUV_m13				0x02
#define _RGB2YUV_m21				0x03
#define _RGB2YUV_m22				0x04
#define _RGB2YUV_m23				0x05
#define _RGB2YUV_m31				0x06
#define _RGB2YUV_m32				0x07
#define _RGB2YUV_m33				0x08
#define _RGB2YUV_Yo_even			0x09
#define _RGB2YUV_Yo_odd			0x0a
#define _RGB2YUV_Y_gain				0x0b
#define _RGB2YUV_sel_RGB			0x0c
#define _RGB2YUV_set_Yin_offset		0x0d
#define _RGB2YUV_set_UV_out_offset	0x0e
#define _RGB2YUV_sel_UV_off			0x0f
#define _RGB2YUV_Matrix_bypass		0x10
#define _RGB2YUV_Enable_Y_gain		0x11

#define REDUCE_DI_BANDWIDTH_LIMIT_THRESHOLD 	1920//960//1440


#define CHECK_AVD_WEBOS_INFO_TIMEOUT (30)

#define MSPG_AUTO_TEST
#define MSPG_AUTO_TEST_REGISTER 0xB8022700
#define MSPG_AUTO_TEST_START 0x00000001
#define MSPG_AUTO_TEST_SUCCESS 0x00000003
#define MSPG_AUTO_TEST_FAIL 0x00000007

#define FILM_DETECT_TO 30 // set film mode detect timeout to 600ms, for as avsync video latency
#define HDMI_WIDTH_THRESHOLD 4096
//#define  _Mantis_74135
//#define  _Mantis_80057
//#define  _Mantis_72744
#define CONFIG_COMPRESSION_MODE_TEST
//#define WIN_DELAY_CALLBACK_PROFILE 1

int drivf_I3DDMA_3D_config(void);
#ifdef CONFIG_FORCE_RUN_I3DDMA
unsigned char drivf_i3ddma_config(unsigned char display, unsigned char src);
#endif
void drvif_I3DDMA_Init(void);
void I3DDMA_Parse_HDMI3D_pattern(void);
static void set_default_mcap_format(unsigned char display, VSC_INPUT_TYPE_T inputSrctype);//M Cap 444 or 422
//unsigned char Scaler_Set3DMode(unsigned char message, bool muteAudio);
unsigned char wait_atv_stable_for_bg(unsigned char display,char const* pfunc,unsigned int line);


#ifdef CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT
unsigned char rtk_hal_vsc_SetHdr10IdmaEnable(unsigned char bEnable);
#endif

#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG
static void update_arc_cmd_to_ring_buffer_sharemem(unsigned char display, KADP_VIDEO_RECT_T inregion, KADP_VIDEO_RECT_T originalInput, KADP_VIDEO_RECT_T outregion);
static DECLARE_WAIT_QUEUE_HEAD(ARC_CONTROL_WAIT_QUEUE);
static unsigned char main_arc_change_flag = FALSE;//main path arc change run scaler
static DEFINE_SPINLOCK(Main_ARC_Parm_Spinlock);/*Spin lock no context switch. This is for copy paramter*/
#ifdef CONFIG_DUAL_CHANNEL
static unsigned char sub_arc_change_flag = FALSE;//sub path arc change run scaler
static DEFINE_SPINLOCK(Sub_ARC_Parm_Spinlock);/*Spin lock no context switch. This is for copy paramter*/
#endif
#endif//#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG
static DECLARE_WAIT_QUEUE_HEAD(HDMI_4K120_SE_WAIT_QUEUE);
static unsigned char hdmi_4k120_se_trigger_flag = FALSE;

KADP_VSC_ROTATE_T ap_rotate_type_parm;//for new input output. ap parameter from new hal //for main path
KADP_VIDEO_RECT_T ap_main_inregion_parm;//for new input output. main path ap parameter  from new hal
KADP_VIDEO_RECT_T ap_main_originalInput_parm;//for new input output. main path ap input resolution parameter from new hal
KADP_VIDEO_RECT_T ap_main_outregion_parm;//for new input output. main path ap input resolution parameter from new hal
static struct semaphore new_input_output_main_sem;//for main path new input out ap parameter semaphore
#ifdef CONFIG_DUAL_CHANNEL
KADP_VIDEO_RECT_T ap_sub_inregion_parm;//for new input output sub path ap parameter from new hal
KADP_VIDEO_RECT_T ap_sub_originalInput_parm;//for new input output. sub path ap input resolution parameter from new hal
KADP_VIDEO_RECT_T ap_sub_outregion_parm;//for new input output. sub path ap input resolution parameter from new hal
static struct semaphore new_input_output_sub_sem;//for sub path new input out ap parameter semaphore
#endif//#ifdef CONFIG_DUAL_CHANNEL

KADP_VIDEO_RECT_T air_mode_save_outregion_parm[MAX_DISP_CHANNEL_NUM];//for air mode save origin output.
unsigned char sub_hidden = FALSE;//for output = 0 sub hidden

#define VDC_DETECT_STAGE_FINAL 0xff
//static void apvr_request_run_main_path(void);//This api is for apvr need to run main path again
int sub_shape_type = VSC_MGF_TYPE_RECTANGLE;
static int sub_mode_type = KADP_VSC_SUB_MODE_PIP;//PIP: Live zoom, magnifire //PBP: Multiview
static int sub_livezoom_type = KADP_VSC_SUB_CONNECT_TYPE_NONE;//PIP: Live zoom, magnifire //PBP: Multiview
unsigned char Scaler_CalWindowZoominForAVD(SCALER_DISP_CHANNEL display,VIDEO_RECT_T *inregion, VIDEO_RECT_T *outregion);
unsigned char Scaler_DispWindowZoominForAVD(SCALER_DISP_CHANNEL display, VIDEO_RECT_T inputwin, VIDEO_RECT_T outputwin, unsigned char changetomain);
extern unsigned char check_ott_dolby_update_run(void);
extern void Set_Reply_Zero_Timing_Flag(unsigned char src, unsigned char flag);
extern void modestate_set_display_timing(unsigned char dclk_is_max);
extern unsigned char modestate_decide_display_timing(void);
extern void memc_setting_displayDtiming_framerate(void);
extern unsigned char LiveZoom_MEMCClose_Flag;
extern unsigned char AspectRation_Zoom_MEMCClose_Flag;
extern struct semaphore* get_livezoom_memcclose_Semaphore(void);
extern void Scaler_AVD_EnableVD27MMode(VD_27M_OVERSAMPLING_MODE mode);
//===Test NN =================
#ifdef CONFIG_ENABLE_HDMI_NN
extern int h3ddma_get_NN_read_buffer(unsigned int *a_pulYAddr, unsigned int *a_pulCAddr, unsigned int *a_pulCropYAddr, unsigned int *a_pulCropCAddr);
extern void h3ddma_get_NN_read_buffer_test(unsigned int *a_pulYAddr, unsigned int *a_pulCAddr);
extern void I3DDMA_ResetCap0(void);
extern void I3DDMA_ResetCap1(void);
extern int i3ddma_dump_data_to_file(void);
extern void h3ddma_nn_set_crop_size(unsigned int x, unsigned int y, unsigned int w, unsigned int h);
extern void h3ddma_nn_set_sub_path_enable(unsigned char enable);
extern unsigned char h3ddma_nn_get_sub_path_enable(void);
#endif
//====End of Test NN=========================

extern void vsc_adaptivestream_calc_outregion(unsigned char display);

unsigned char scaler_atv_force_run_idma(void);

static dev_t vsc_devno = 0;//vsc device number
static struct cdev vsc_cdev;
//Eric@0809
unsigned char VSC_OUTPUT_VENC_MODE_FLAG = FALSE;
unsigned short virtual_x=0,virtual_y=0,virtual_w=0,virtual_h=0;
unsigned short true_wide=0,true_high=0;
unsigned short shape_wide=0,shape_high=0;

//Game mode cmd checking flow @Cixus 20161204
unsigned int game_mode_cmd_check = 0;
VIDEO_WID_T BLK_WID = 0;
static unsigned char game_mode_ignore_cmd_check = 0;

unsigned int smooth_toggle_game_mode_timeout_trigger_flag = 0;
unsigned int smooth_toggle_game_mode_check_cnt = 0;

extern unsigned int disp_smooth_variable_setting_flag;
KADP_SCALER_WIN_CALLBACK_DELAY_INFO g_scaler_win_delay_cb_info;
UINT8 g_scalerForceUpdate_CB_by_InputOutput_Region_Flag = 0;

unsigned int mdomain_input_fast_flag = 0;
#ifdef BRING_UP_I2RND
unsigned char i2rnd_brungup_setting_done = 0;
#endif
struct vsc_film_mode_parameter_t film_mode_parameter = {0,0,0};
unsigned int game_mode_cmd_pre = 0;
unsigned int st_game_mode_cmd_pre = 0;
extern unsigned int ori_voclk_ratio_num;
unsigned int idomain_vfreq_pre = 0;
extern SCALER_DATA_FS_ALGO_RESULT g_tDataFsAlgoResult;
unsigned char scaler_RGB444Mode_pre = 0;
unsigned char vsc_force_rerun_main_scaler = 0;
void drvif_scaler_enable_frc2fsync_HW_speedup_vtotal(unsigned char bEnable);

static int counter_hdrtype_change;

void reset_hdrtype_change_counter(void)
{
	counter_hdrtype_change = 0;
}

void increase_hdrtype_change_counter(void)
{
	++counter_hdrtype_change;
}

bool check_hdrtype_change(void)
{
	return (counter_hdrtype_change != 0);
}

#ifdef WIN_DELAY_CALLBACK_PROFILE
typedef struct _SCALER_WIN_CALLBACK_GLOBAL_PROFILE {//for scaler to check av sync
	UINT32 _90k_cnt;
	KADP_VIDEO_RECT_T  OutputRegion;
	UINT32 uzulcnt;
} _SCALER_WIN_CALLBACK_GLOBAL_PROFILE;

_SCALER_WIN_CALLBACK_GLOBAL_PROFILE gCallback_profile = {0};
#endif

//unsigned int main_opensourceID = _UNKNOWN_INPUT;
//#ifdef CONFIG_DUAL_CHANNEL
//unsigned int sub_opensourceID = _UNKNOWN_INPUT;
//#endif
//static unsigned char main_VO_smoothtoggle_need_presetting = FALSE;

DECLARE_WAIT_QUEUE_HEAD(FORCEBG_WAIT_QUEUE);

void update_vsc_task_status(unsigned char ctrl, unsigned int status)
{//ctrl: 1  set    0: clear
    if(ctrl)
    {
        vsc_task_status = vsc_task_status | status;
    }
    else
    {
        vsc_task_status = vsc_task_status & (~status);
    }
}


unsigned int get_vsc_task_running_status(void)
{
    return vsc_task_status;
}

//Below is used to check run scaler source already change or not
static struct semaphore vsc_src_verify_num_ctrl_sem;
static unsigned char source_connect_verify_num[MAX_DISP_CHANNEL_NUM] =
{//record vsc connect number. verify used. confirm vsc source connect numebt
	0,
#ifdef CONFIG_DUAL_CHANNEL
	0
#endif
};


void set_latency_pattern_info(VSC_VIDEO_LATENCY_PATTERN_T set_video_latency_pattern)
{
#ifdef CONFIG_I3DDMA_PATTERN_MEASUREMENT
	if(memcmp(&hal_video_latency_pattern_info, &set_video_latency_pattern, sizeof(VSC_VIDEO_LATENCY_PATTERN_T)))
	{//different parameter
		unsigned long flags;//for spin_lock_irqsave
		//Eric@20180626 vdec source no need enable dma vgip isr
		if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) != VSC_INPUTSRC_VDEC){
			if(!((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && (get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1)))
			{
				dma_vgip_dma_vgip_ctrl_RBUS dma_vgip_chn1_ctrl_reg;
				dma_vgip_chn1_ctrl_reg.regValue = IoReg_Read32(DMA_VGIP_DMA_VGIP_CTRL_reg);
				if(!dma_vgip_chn1_ctrl_reg.dma_vact_start_ie)
				{
					dma_vgip_chn1_ctrl_reg.dma_vact_start_ie = 1;
					IoReg_Write32(DMA_VGIP_DMA_VGIP_CTRL_reg, dma_vgip_chn1_ctrl_reg.regValue);
				}
			}
		}
		spin_lock_irqsave(&latency_pattern_spinlock, flags);
		memcpy(&hal_video_latency_pattern_info, &set_video_latency_pattern, sizeof(VSC_VIDEO_LATENCY_PATTERN_T));
		latency_pattern_change = TRUE;
		spin_unlock_irqrestore(&latency_pattern_spinlock, flags);
	}
#endif
}

void set_latency_pattern_self_test(unsigned char b_On)
{
	latency_pattern_self_test = b_On;
}

void latency_pattern_self_test_run(void)
{
	static unsigned char latency_pattern_self_test_pre = 0;
	static unsigned char pattern_type = KADP_VSC_PATTERN_BLACK;
	VSC_VIDEO_LATENCY_PATTERN_T set_video_latency_pattern;

	if(latency_pattern_self_test_pre != latency_pattern_self_test){
		if(latency_pattern_self_test==0){
			set_video_latency_pattern.bOnOff = 0;
			set_video_latency_pattern.bPatternType = KADP_VSC_PATTERN_BLACK;
			set_video_latency_pattern.overlayWindow.x = 0;
			set_video_latency_pattern.overlayWindow.y = 0;
			set_video_latency_pattern.overlayWindow.w = 3840;
			set_video_latency_pattern.overlayWindow.h = 2160;
			set_latency_pattern_info(set_video_latency_pattern);
			pattern_type = set_video_latency_pattern.bPatternType;
		}
		latency_pattern_self_test_pre = latency_pattern_self_test;
	}

	if(latency_pattern_self_test){
		set_video_latency_pattern.bOnOff = 1;
		if(pattern_type == KADP_VSC_PATTERN_BLACK){
			set_video_latency_pattern.bPatternType = KADP_VSC_PATTERN_WHITE;
			printk(KERN_EMERG "videolatency white\n");
		}else{
			set_video_latency_pattern.bPatternType = KADP_VSC_PATTERN_BLACK;
			printk(KERN_EMERG "videolatency black\n");
		}
		set_video_latency_pattern.overlayWindow.x = 0;
		set_video_latency_pattern.overlayWindow.y = 0;
		set_video_latency_pattern.overlayWindow.w = 3840;
		set_video_latency_pattern.overlayWindow.h = 2160;
		set_latency_pattern_info(set_video_latency_pattern);
		pattern_type = set_video_latency_pattern.bPatternType;
		msleep(1000);
	}
}

static unsigned char cur_main_vsc_src_num = 0;//currently run scaler main path vsc source num
static unsigned char cur_sub_vsc_src_num = 0;//currently run scaler sub path vsc source num

void sync_pc_mode_info(void)
{//currently only decide yuv422 and enable pc mode or not
	pc_mode_sync_info* pc_mode_info = NULL;

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "src=%x, color space=%x, get_vsc_run_pc_mode=%x\n", Get_DisplayMode_Src(SLR_MAIN_DISPLAY), Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_SPACE), get_vsc_run_pc_mode());
	pc_mode_info = (pc_mode_sync_info *)Scaler_GetShareMemVirAddr(SCALERIOC_PC_MODE_INFO);
	if(pc_mode_info)
	{
		if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && get_vsc_run_pc_mode())
		{
			if((drvif_Hdmi_GetColorSpace() == COLOR_RGB) || (drvif_Hdmi_GetColorSpace() == COLOR_YUV444))
			{
				pc_mode_info->input444_pc_mode = 1;
				pc_mode_info->input422_pc_mode = 0;
			}
			else
			{
				pc_mode_info->input444_pc_mode = 0;
				pc_mode_info->input422_pc_mode = 1;
			}
		}
		else
		{
			pc_mode_info->input444_pc_mode = 0;
			pc_mode_info->input422_pc_mode = 0;
		}
	}

#ifdef ENABLE_FORCE_PC_MODE
	// Test PC mode
	pr_info("force input444_pc_mode = 1\n");
	pc_mode_info->input444_pc_mode = 1;
#endif
}

unsigned char pc_mode_run_422(void)
{
	pc_mode_sync_info* pc_mode_info = NULL;
	pc_mode_info = (pc_mode_sync_info *)Scaler_GetShareMemVirAddr(SCALERIOC_PC_MODE_INFO);
	if(pc_mode_info)
	{
		return pc_mode_info->input422_pc_mode;
	}
	return 0;
}

unsigned char pc_mode_run_444(void)
{
	pc_mode_sync_info* pc_mode_info = NULL;
	pc_mode_info = (pc_mode_sync_info *)Scaler_GetShareMemVirAddr(SCALERIOC_PC_MODE_INFO);


#ifdef ENABLE_FORCE_PC_MODE
	pc_mode_info->input444_pc_mode = 1;
	return 1;
#else
	if(pc_mode_info)
	{
		return pc_mode_info->input444_pc_mode;
	}
	return 0;
#endif
}

unsigned char get_source_connect_verify_num(unsigned char display)
{
#ifndef CONFIG_DUAL_CHANNEL
	if(display != SLR_MAIN_DISPLAY)
	{
		pr_err("\r\n get_source_connect_verify_num display(%d) error", display);
		return 0;
	}
#else
	if((display != SLR_MAIN_DISPLAY) && (display != SLR_SUB_DISPLAY))
	{
		pr_err("\r\n get_source_connect_verify_num display(%d) error", display);
		return 0;
	}
#endif
		return source_connect_verify_num[display];
}

void increase_source_connect_verify_num(unsigned char display)
{
	#define max_source_verify_num 200
#ifndef CONFIG_DUAL_CHANNEL
	if(display != SLR_MAIN_DISPLAY)
	{
		pr_err("\r\n increase_source_connect_verify_num display(%d) error", display);
		return;
	}
#else
	if((display != SLR_MAIN_DISPLAY) && (display != SLR_SUB_DISPLAY))
	{
		pr_err("\r\n increase_source_connect_verify_num display(%d) error", display);
		return;
	}
#endif
	down(&vsc_src_verify_num_ctrl_sem);
	if(source_connect_verify_num[display] == max_source_verify_num)
		source_connect_verify_num[display] = 0;
	else
		source_connect_verify_num[display] =  source_connect_verify_num[display] + 1;
	up(&vsc_src_verify_num_ctrl_sem);
}

void set_current_scaler_source_num(unsigned char display)
{//set cur_vsc_src_num form get_source_connect_verify_num
#ifndef CONFIG_DUAL_CHANNEL
	if(display != SLR_MAIN_DISPLAY)
	{
		pr_err("\r\n set_cur_sclaer_source_num display(%d) error", display);
		return;
	}
#else
	if((display != SLR_MAIN_DISPLAY) && (display != SLR_SUB_DISPLAY))
	{
		pr_err("\r\n set_cur_sclaer_source_num display(%d) error", display);
		return;
	}
#endif
	down(&vsc_src_verify_num_ctrl_sem);
	if(display == SLR_MAIN_DISPLAY)
		cur_main_vsc_src_num = source_connect_verify_num[display];
	else
		cur_sub_vsc_src_num = source_connect_verify_num[display];
	up(&vsc_src_verify_num_ctrl_sem);

}

unsigned char compare_rerify_vsc_source_num_result(unsigned char display)
{//return TRUE: source not change.  return false: source change
#ifndef CONFIG_DUAL_CHANNEL
	if(display != SLR_MAIN_DISPLAY)
	{
		pr_err("\r\n rerify_vsc_source_num_result display(%d) error", display);
		return TRUE;
	}
#else
	if((display != SLR_MAIN_DISPLAY) && (display != SLR_SUB_DISPLAY))
	{
		pr_err("\r\n set_cur_sclaer_source_num display(%d) error", display);
		return TRUE;
	}
#endif
	down(&vsc_src_verify_num_ctrl_sem);
	if(display == SLR_MAIN_DISPLAY)
	{
		if(cur_main_vsc_src_num == source_connect_verify_num[display])
		{
			up(&vsc_src_verify_num_ctrl_sem);
			return TRUE;
		}
		else
		{
			up(&vsc_src_verify_num_ctrl_sem);
			return FALSE;
		}
	}
	else
	{
		if(cur_sub_vsc_src_num == source_connect_verify_num[display])
		{
			up(&vsc_src_verify_num_ctrl_sem);
			return TRUE;
		}
		else
		{
			up(&vsc_src_verify_num_ctrl_sem);
			return FALSE;
		}
	}
}
//Above is used to check run scaler source already change or not


unsigned char rtk_hal_vsc_GetOutputRegion(KADP_VIDEO_WID_T wid, KADP_VIDEO_RECT_T * poutregion);

static SCALER_VSC_INPUT_REGION_TYPE hal_main_InputRegionType =  INPUT_BASE_ON_TIMING;
static StructSrcRect main_dispwin;//Temp record main output info
StructSrcRect main_input_size;
static StructSrcRect main_input_timing;
static StructSrcRect main_dispwin_pre = {0, 0, 0, 0};//Record previous main output info
static StructSrcRect main_input_size_pre = {0, 0, 0, 0};//Record previous main output info
static StructSrcRect main_input_timing_pre = {0, 0, 0, 0};//Record previous main input timing info
static StructSrcRect main_dispwin_for_only_xy = {0, 0, 0, 0};//Record previous main output info for apply_only_xy_shift

static KADP_VSC_INPUT_SRC_INFO_T DisplayModeInputInfo = {KADP_VSC_INPUTSRC_MAXN,0,0};
static KADP_VSC_INPUT_SRC_INFO_T VencModeInputInfo = {KADP_VSC_INPUTSRC_MAXN,0,0};
static KADP_VSC_INPUT_SRC_INFO_T MemoryModeInputInfo = {KADP_VSC_INPUTSRC_MAXN,0,0};
static KADP_VSC_INPUT_SRC_INFO_T AveModeInputInfo = {KADP_VSC_INPUTSRC_MAXN,0,0};

static DIRECT_VO_FRAME_ORIENTATION rotate_mode = DIRECT_VO_FRAME_ORIENTATION_DEFAULT; //this is the current rotate mode from webos
static DIRECT_VO_FRAME_ORIENTATION rotate_mode_pre = DIRECT_VO_FRAME_ORIENTATION_DEFAULT; //this is the last rotate mode from webos

//static unsigned char OuputDisplayMode = FALSE;
//static unsigned char OutputVencMode = FALSE;
//static unsigned char OutputMemoryMode = FALSE;
//static unsigned char OutputAveMode = FALSE;
//static unsigned char RGB444Mode = TRUE;
//static unsigned char VscMuteStatus = FALSE;
extern UINT8 TV006_WB_Pattern_En;
unsigned char OutpuLocalDimmingPatMode = FALSE;
unsigned char LocalDimmingDemoCtrlMode = FALSE;
unsigned char LocalDimmingDemoCtrlType = 0;


//static unsigned char Main_AutoRunScaler = FALSE;//Mean when running scaler and set output again. let it auto run scaler. For ATV
//static char Main_Run_Scaler_flag = FALSE;//Mean that Scaler task to run main scaler
//static char Main_Output_Set_flag = FALSE;//Mean that set main setoutput region
//static char Main_force_frc_flag = FALSE;
//static char Main_force_frc_fs_flag = FALSE;
//static char Main_Scaler_Stop_flag = FALSE;//Mean that don't let task run main scaler. Because disconnet
//static char Main_ATV_Go_Smooth_Toggle_flag = FALSE;//Mean ATV current no mute, so can run smooth toggle
//static char Main_smooth_toggle_set_flag = FALSE;//Mean that Scaler task to run smooth toggle
//static char Main_ATV_PassThrought_output_flag = FALSE;//Mean ATV pass throught set output region. Let set winblank off work directly
//static char Main_SetOutput_request_muteoff_smooth_toggle_set_flag = FALSE;//Mean that wait mute off to set Main_smooth_toggle_set_flag
//static char Main_Request_ForceBG_ctrl = FALSE;//Mean webos call set main winblank on/off
//static char Main_Reset_Mode_flag = FALSE;//Run Mode Reset mode
//static unsigned char Main_Reset_Mode_flag = FALSE;//Record during runing scaler. Can not mute off
#ifdef CONFIG_DUAL_CHANNEL
static SCALER_VSC_INPUT_REGION_TYPE hal_sub_InputRegionType;
static StructSrcRect sub_dispwin;//Temp record sub output info
static StructSrcRect sub_input_size;
static StructSrcRect sub_input_timing = {0, 0, 0, 0};
static StructSrcRect sub_dispwin_pre = {0, 0, 0, 0};//Record previour sub output info
static StructSrcRect sub_input_size_pre = {0, 0, 0, 0};//Record previour sub output info
#ifdef NEW_INPUT_REGION_BASE_ON_HAL_ORIGINAL_INPUT
static StructSrcRect sub_input_timing_pre = {0, 0, 0, 0};//Record previour sub input timing info
#endif

static KADP_VSC_INPUT_SRC_INFO_T Sub_DisplayModeInputInfo = { KADP_VSC_INPUTSRC_MAXN, 0, 0 };
static KADP_VSC_INPUT_SRC_INFO_T Sub_VencModeInputInfo = { KADP_VSC_INPUTSRC_MAXN, 0, 0 };
static KADP_VSC_INPUT_SRC_INFO_T Sub_MemoryModeInputInfo = { KADP_VSC_INPUTSRC_MAXN, 0, 0 };
static KADP_VSC_INPUT_SRC_INFO_T Sub_AveModeInputInfo = { KADP_VSC_INPUTSRC_MAXN, 0, 0 };

//static unsigned char Sub_OuputDisplayMode = FALSE;
//static unsigned char Sub_OutputVencMode = FALSE;
//static unsigned char Sub_OutputMemoryMode = FALSE;
//static unsigned char Sub_OutputAveMode = FALSE;
//static char Sub_Run_Scaler_flag = FALSE;//Mean that Scaler task to run Sub scaler
//static char Sub_Output_Set_flag = FALSE;//Mean that set sub setoutput region
//static char Sub_Scaler_Stop_flag = FALSE;//Mean that don't let task run sub scaler. Because disconnet
//static unsigned char Sub_AutoRunScaler = FALSE;//Mean when running scaler and set output again. let it auto run scaler. For ATV
//static char Sub_ATV_Go_Smooth_Toggle_flag = FALSE;//Mean ATV current no mute, so can run smooth toggle
//static char Sub_Request_ForceBG_ctrl = FALSE;//Mean webos call set sub winblank on/off
//static char Sub_Reset_Mode_flag = FALSE;//Run SUB Reset mode

#endif

extern unsigned short Main_InputRegion_x;
extern unsigned short Main_InputRegion_y;
extern unsigned short Main_InputRegion_w;
extern unsigned short Main_InputRegion_h;
#ifdef CONFIG_DUAL_CHANNEL
extern unsigned short Sub_InputRegion_x;
extern unsigned short Sub_InputRegion_y;
extern unsigned short Sub_InputRegion_w;
extern unsigned short Sub_InputRegion_h;
#endif

extern StructSrcRect Scaler_intputRegion[MAX_DISP_CHANNEL_NUM];
extern StructSrcRect Scaler_intputTiming[MAX_DISP_CHANNEL_NUM];


//unsigned short Main_ATV_InputRegion_x_pre;
//unsigned short Main_ATV_InputRegion_y_pre;
//unsigned short Main_ATV_InputRegion_w_pre;
//unsigned short Main_ATV_InputRegion_h_pre;
#ifdef CONFIG_DUAL_CHANNEL
//unsigned short Sub_ATV_InputRegion_x_pre;
//unsigned short Sub_ATV_InputRegion_y_pre;
//unsigned short Sub_ATV_InputRegion_w_pre;
//unsigned short Sub_ATV_InputRegion_h_pre;
#endif


//unsigned short Main_ATV_OutputRegion_x_pre;
//unsigned short Main_ATV_OutputRegion_y_pre;
//unsigned short Main_ATV_OutputRegion_w_pre;
//unsigned short Main_ATV_OutputRegion_h_pre;
#ifdef CONFIG_DUAL_CHANNEL
//unsigned short Sub_ATV_OutputRegion_x_pre;
//unsigned short Sub_ATV_OutputRegion_y_pre;
//unsigned short Sub_ATV_OutputRegion_w_pre;
//unsigned short Sub_ATV_OutputRegion_h_pre;
#endif

//unsigned char main_winfreeze;


//unsigned char JPEG_Scaler_SM;
extern void ADC_set_detect_flag(unsigned char enable);
extern void VDC_set_detect_flag(unsigned char enable);
extern unsigned char VDC_get_detect_flag(void);
extern void HDMI_set_detect_flag(unsigned char enable);
extern struct semaphore* get_adc_adjustsemaphore(void);
extern struct semaphore *get_adc_detectsemaphore(void);
extern struct semaphore *get_vdc_detectsemaphore(void);
extern struct semaphore *get_hdmi_detectsemaphore(void);
extern struct semaphore *get_setsource_semaphore(void);
extern struct semaphore* get_scaler_fll_running_semaphore(void);
extern StructDisplayInfo * Get_ADC_Dispinfo(void);
extern StructDisplayInfo * Get_AVD_ScalerDispinfo(void);
extern ModeInformationType *Get_AVD_ScalerTiminginfo(void);
extern StructDisplayInfo * Get_VO_Dispinfo(unsigned char);
extern struct semaphore* get_vo_infosemaphore(void);
extern unsigned char get_vo_change_flag(unsigned char);
extern void set_vo_change_flag(unsigned char, unsigned char);
extern unsigned char ADC_Check_VSC_VFE_ConnectSrc_Match(unsigned int vsc_src);
extern unsigned char Check_DisplayFrame_isRightColorbar(void);
unsigned char init_source_proc(unsigned char display, VSC_INPUT_TYPE_T sourcetype, unsigned char sourceport);
//void set_vsc_SetCircle_OutputRegion(VIDEO_RECT_T outregion, unsigned short W, unsigned short H, UINT32 num);
void wait_game_mode_frame_delay_done(void);
extern void UpdateDataFsAlgoRsult(void);

//unsigned int  sub_zoom_disp_hpos = 0;//For Scaler use
//unsigned int  sub_zoom_disp_vpos = 0;//For Scaler use
//unsigned int  sub_zoom_disp_hsize = 0;//For Scaler use
//unsigned int  sub_zoom_disp_vsize = 0;//For Scaler use
//static unsigned char sub_wind0000 = FALSE;
//static unsigned char main_wind0000 = FALSE;

//static unsigned char adaptive_stream;
//static unsigned char adaptive_stream_pre = ADAPTIVE_STREAM_INIT;
//static unsigned char line_cnt_no_run_hdmi_check = 0;

//unsigned char hdmi_dolby_vision_flag = FALSE; //for dm function to adjust hdmi dolby vision detect result

struct semaphore Memc_Realcinema_Semaphore;/*For adaptive streaming info Semaphore*/
//char memc_realcinema_run_flag = FALSE;//Run memc mode
extern void memc_realcinema_framerate(void);

struct semaphore Iv2dv_Slow_Tuning_Semaphore;
//char run_iv2dv_slow_tuning_flag = FALSE;//Run iv2dv slow tuning flag
extern void drv_run_GameMode_iv2dv_slow_tuning(void);
static UINT8 enable_VSC_GameMode = _DISABLE;

struct semaphore VPQ_ld_running_Semaphore;/*For adaptive streaming info Semaphore*/

struct semaphore VPQ_DeXC_MEM_Semaphore;/*For Dexc MEM*/

//I2RND semaphore
struct semaphore I2RND_display_Semaphore;
struct semaphore I2RND_Semaphore;
#if 0
#ifdef CONFIG_I2RND_ENABLE
static unsigned char run_i2rnd_flag = 0;
#endif
#endif

//static unsigned char vpq_ld_first_boot = FALSE; //dc off/on condition, set at resume
extern unsigned char vpq_ld_running_flag;
extern unsigned char vpq_led_LDEnable;
extern unsigned int ld_time_tick;
extern void drvif_HAL_VPQ_LED_LDEnable(unsigned char bCtrl);
extern unsigned char  fwif_color_get_black_detection_info_tv006(VIP_BlackDetectionInfo* BlackDetectionInfo);
extern unsigned char modestate_decide_display_timing(void);

#ifdef CONFIG_ORBIT_PIXEL_SHIFT_ALGO
//struct timer_list OrbitTimerList;
void Scaler_Orbit_Timer_Init(void);
void OrbitTimer(void);
void Scaler_Orbit_Timer_Delete(void);

/* timer init*/
/* init_timer(&OrbitTimerList); */
/* OrbitTimerList.data = ((unsigned long) 0); */
/* OrbitTimerList.function = (void *)OrbitTimer; */
/* OrbitTimerList.expires = jiffies + ORBIT_TIME*HZ; */
DEFINE_TIMER(OrbitTimerList, (void *)OrbitTimer, 0, 0);
static unsigned char g_ucTimerInitCount = 0;

#endif

#ifndef CONFIG_DOLBY_IDK_1_6_1_1
// For Dolby letter box DTG change
extern spinlock_t* dolby_letter_box_spinlock(void);
extern unsigned int dolby_proverlay_background_h_start_end;//For letter box use.Record h start and end
extern unsigned int dolby_proverlay_background_v_start_end;//For letter box use. Record V start and end
extern unsigned char letter_box_black_flag;//For letter box use. Need force BG black
extern unsigned char request_letter_dtg_change;//For letter box use. Requesttsk to run
#endif
//
#ifdef CONFIG_I2RND_ENABLE
unsigned char vsc_i2rnd_sub_stage = I2RND_STAGE_DISABLE;
unsigned char vsc_i2rnd_sub_output_mode = 0;
unsigned char vsc_i2rnd_sub_input_type = 0;
unsigned char vsc_i2rnd_sub_input_port = 0;
static unsigned char vsc_i2rnd_initial_done = _DISABLE;
unsigned char vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_DISABLE; //for APVR and ATV channel changing stage, avoid the race condition issue. @Crixus 20160823
unsigned char vsc_i2rnd_dualvo_sub_stage = I2RND_DUALVO_STAGE_SUB_DISABLE;
extern SLR_VOINFO i2rnd_main_voinfo;
extern SLR_VOINFO i2rnd_sub_voinfo;
extern SLR_VOINFO i2rnd_empty_voinfo;
extern unsigned char vo_timing_change_for_adaptive;
//unsigned char i2r_main_pre_resourceIndex = 0;
//unsigned char i2r_sub_pre_resourceIndex = 0;
#ifdef CONFIG_PST_ENABLE
static unsigned char vsc_pst_initial_done = _DISABLE;
#endif
#endif

//k4lp new hal api - mute off callback. When mute off to callback api
unsigned char main_muteoff_cb_trigger = FALSE;
unsigned char sub_muteoff_cb_trigger = FALSE;
struct semaphore muteoff_cb_sem;
DEFINE_SPINLOCK(delay_info_cb_spinlock);

unsigned char delay_info_cb_trigger = FALSE;

static DECLARE_WAIT_QUEUE_HEAD(MUTEOFF_CB_WAIT_QUEUE);
static DECLARE_WAIT_QUEUE_HEAD(WIN_DELAY_CB_WAIT_QUEUE);

SCALER_VSC_INPUT_REGION_TYPE getInputRegionType(unsigned char display)
{

	SCALER_VSC_INPUT_REGION_TYPE regionType = INPUT_BASE_ON_TIMING;

	switch(display)
	{
		case SLR_MAIN_DISPLAY:
			regionType = hal_main_InputRegionType;
			break;
#ifdef CONFIG_DUAL_CHANNEL
		case SLR_SUB_DISPLAY:
			regionType = hal_sub_InputRegionType;
			break;
#endif
		default:
			regionType = INPUT_BASE_ON_TIMING;
			break;
	}

	return regionType;

}

void setInputRegionType(unsigned char display, SCALER_VSC_INPUT_REGION_TYPE regionType)
{

	switch(display)
	{
		case SLR_MAIN_DISPLAY:
			hal_main_InputRegionType = regionType;
			break;
#ifdef CONFIG_DUAL_CHANNEL
		case SLR_SUB_DISPLAY:
			hal_sub_InputRegionType = regionType;
			break;
#endif
		default:
			pr_emerg("[%s %d] display is error display:%d\n", __FUNCTION__, __LINE__, display);
			break;
	}

	pr_emerg("[%s %d]display:%d, regionType:%d\n", __FUNCTION__, __LINE__, display, regionType);

}
StructSrcRect get_main_dispwin(void)
{
	return main_dispwin;
}

StructSrcRect get_main_input_size(void)
{
	return main_input_size;
}

void set_shiftxy_main_inputpre(StructSrcRect input_size )
{
	main_input_size_pre=input_size;
}

void set_shiftxy_main_dispwinpre(StructSrcRect out_size )
{
	main_dispwin_for_only_xy=out_size;
}

unsigned int vsc_poll(struct file *filp, struct poll_table_struct *wait){
/*
       poll_wait(filp, &mute_off_callback, wait);
       return POLLIN | POLLRDNORM;
*/
		return 0;
}

spinlock_t* get_delay_info_cb_spin_lock(void)
{//this is for delay_info_cb_trigger flag protection
	return &delay_info_cb_spinlock;
}


void update_win_apply_delay_info_for_cb(unsigned char display, KADP_SCALER_WIN_CALLBACK_DELAY_INFO *p_scaler_win_delay_cb_info)
{
	if(display == SLR_MAIN_DISPLAY)
	{
		if(g_scalerForceUpdate_CB_by_InputOutput_Region_Flag){
			memcpy((void*) p_scaler_win_delay_cb_info, (void*) &g_scaler_win_delay_cb_info, sizeof(KADP_SCALER_WIN_CALLBACK_DELAY_INFO));
			Scaler_Reset_ForceUpdate_Callback_Delay_Info();
		}else{
			Scaler_Fulfill_Callback_Delay_Info(p_scaler_win_delay_cb_info);
		}
		if(p_scaler_win_delay_cb_info->delayTime > 200)
			p_scaler_win_delay_cb_info->delayTime = 16;


#ifdef WIN_DELAY_CALLBACK_PROFILE
		if((p_scaler_win_delay_cb_info->OutputRegion.x == gCallback_profile.OutputRegion.x) &&
			(p_scaler_win_delay_cb_info->OutputRegion.y == gCallback_profile.OutputRegion.y) &&
			(p_scaler_win_delay_cb_info->OutputRegion.w == gCallback_profile.OutputRegion.w) &&
			(p_scaler_win_delay_cb_info->OutputRegion.h == gCallback_profile.OutputRegion.h))
		{
			unsigned int current_90K=0;

			current_90K = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);

			rtd_printk(KERN_ERR, TAG_NAME_VSC,  "[PROFILE_CALLBACK] c90k=%x. 90k=%x, diff=%d, (%d.%d.%d.%d)(line:%d) \n", current_90K, gCallback_profile._90k_cnt, (current_90K-gCallback_profile._90k_cnt)/90,
				gCallback_profile.OutputRegion.x, gCallback_profile.OutputRegion.y, gCallback_profile.OutputRegion.w, gCallback_profile.OutputRegion.h,
				gCallback_profile.uzulcnt);
		}else{
			rtd_printk(KERN_ERR, TAG_NAME_VSC,  "[PROFILE_CALLBACK] Cannot Match!! (%d.%d.%d.%d) / (%d.%d.%d.%d)\n",
				p_scaler_win_delay_cb_info->OutputRegion.x, p_scaler_win_delay_cb_info.->OutputRegion.y, p_scaler_win_delay_cb_info->OutputRegion.w, p_scaler_win_delay_cb_info->OutputRegion.h,
				gCallback_profile.OutputRegion.x, gCallback_profile.OutputRegion.y, gCallback_profile.OutputRegion.w, gCallback_profile.OutputRegion.h);
		}
#endif
	}
}


void wakeup_mute_off_callback(unsigned char display)
{//this is wake up to call webos callback function to notice mute off
#ifdef CONFIG_SCALER_ENABLE_V4L2
	extern void vsc_v4l2_muteoff_event_wakeup(unsigned char display);
	vsc_v4l2_muteoff_event_wakeup(display);//mute off event wake up
#endif
	if(display == SLR_MAIN_DISPLAY)
	{
		down(&muteoff_cb_sem);
		main_muteoff_cb_trigger = TRUE;
		up(&muteoff_cb_sem);
	}
	else
	{
		down(&muteoff_cb_sem);
		sub_muteoff_cb_trigger = TRUE;
		up(&muteoff_cb_sem);
	}
	wake_up(&MUTEOFF_CB_WAIT_QUEUE);
}

void wakeup_window_delay_info_callback(unsigned char display, unsigned char call_by_isr)
{//this is wake up to call webos callback function to notice mute off
#ifdef CONFIG_SCALER_ENABLE_V4L2
	extern void vsc_v4l2_win_apply_done_event_wakeup(unsigned char display);
	if(display == SLR_MAIN_DISPLAY)
	{
		vsc_v4l2_win_apply_done_event_wakeup(display);
	}
#endif
#if 0
	unsigned long flags;
	if(display == SLR_MAIN_DISPLAY)
	{
		//if call by isr, need use spin_lock/spin_unlock
		//if call by task, need use spin_lock_irqsave/spin_unlock_irqrestore
		if(call_by_isr){
			spin_lock(get_delay_info_cb_spin_lock());//lock delay_info_cb_trigger spinlock
			delay_info_cb_trigger = TRUE;
			spin_unlock(get_delay_info_cb_spin_lock());//unlock delay_info_cb_trigger spinlock
		}
		else{
			spin_lock_irqsave(get_delay_info_cb_spin_lock(), flags);//lock delay_info_cb_trigger spinlock
			delay_info_cb_trigger = TRUE;
			spin_unlock_irqrestore(get_delay_info_cb_spin_lock(), flags);//unlock delay_info_cb_trigger spinlock
		}
	}
	wake_up(&WIN_DELAY_CB_WAIT_QUEUE);
#endif
}

struct semaphore* get_gamemode_check_semaphore(void)
{
	return &GameMode_Check_Semaphore;
}


unsigned char force_i3ddma_enable = false;

void set_force_i3ddma_enable(UINT8 enable)
{
	force_i3ddma_enable = enable;
}

UINT8 get_force_i3ddma_enable(unsigned char display)
{
	if(display == SLR_MAIN_DISPLAY)
		return force_i3ddma_enable;
	else
		return 0;
}


void wait_memc_ready(void)
{
	unsigned int sleep_time = 0;
	unsigned int output_framerate = 0;

	if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) &&  Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAC_FS_REMOVE_RATIO)
		&& Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAC_FS_MULTIPLE_RATIO))
		output_framerate = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) * Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAC_FS_MULTIPLE_RATIO) / (10 * Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAC_FS_REMOVE_RATIO));
	else
		output_framerate = 60;


	sleep_time = MAX_MEMC_DELAY_BUFFER * 100 / output_framerate;
	msleep(sleep_time);
	printk(KERN_NOTICE "\r\n#### func:%s wait_time:%d framerate:(%d %d %d)####\r\n",__FUNCTION__, sleep_time, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ),  Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAC_FS_REMOVE_RATIO), Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAC_FS_MULTIPLE_RATIO));
}


void wait_game_mode_finish(void)
{//if game mode switch. scaler need to wait finish
	unsigned char count = 100;//1000 ms
	down(&GameMode_SCALER_SYNC_Semaphore);
	while(count && DbgSclrFlgTkr.game_mode_dynamic_flag)
	{
		count--;
		msleep(0);//wait 10ms
	}
	up(&GameMode_SCALER_SYNC_Semaphore);
	if(count != 100)
	{
		printk(KERN_NOTICE "\r\n## func:%s count:%d####\r\n",__FUNCTION__, count);
	}
}

KADP_VSC_SUB_MODE_T get_sub_mode(void)
{
//Get sub current mode
//PIP: Live zoom, magnifire
//PBP: Multiview
//default mode is pip
	return (KADP_VSC_SUB_MODE_T)sub_mode_type;
}

VSC_SUB_SHAPE_T get_shape_mode(void)
{

	return (VSC_SUB_SHAPE_T)sub_shape_type;
}

StructSrcRect Scaler_SubDispWindowGet(void)
{
	StructSrcRect subWindow;
	subWindow.srcx = DbgSclrFlgTkr.sub_zoom_disp_hpos;
	subWindow.srcy = DbgSclrFlgTkr.sub_zoom_disp_vpos;
	subWindow.src_wid = DbgSclrFlgTkr.sub_zoom_disp_hsize;
	subWindow.src_height = DbgSclrFlgTkr.sub_zoom_disp_vsize;
	return subWindow;
}

void Scaler_SubDispWindowSet(StructSrcRect subWindow)
{
	DbgSclrFlgTkr.sub_zoom_disp_hpos = subWindow.srcx;
	DbgSclrFlgTkr.sub_zoom_disp_vpos = subWindow.srcy;
	DbgSclrFlgTkr.sub_zoom_disp_hsize = subWindow.src_wid;
	DbgSclrFlgTkr.sub_zoom_disp_vsize = subWindow.src_height;
}

unsigned char get_sub_OutputVencMode(void)
{
	return DbgSclrFlgTkr.Sub_OutputVencMode;
}

unsigned char get_main_OutputVencMode(void)
{
	return DbgSclrFlgTkr.OutputVencMode;
}

void set_atv_go_smooth_toggle_flag(unsigned char display, unsigned char flag)
{
	if (display == SLR_MAIN_DISPLAY)
		DbgSclrFlgTkr.Main_ATV_Go_Smooth_Toggle_flag = flag;
#ifdef CONFIG_DUAL_CHANNEL
	else
		DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag = flag;
#endif
}
void SET_BBD_STAGE(unsigned char display, unsigned char stage)
{
	unsigned long flags;//for spin_lock_irqsave
	if (display == SLR_MAIN_DISPLAY)
	{
		spin_lock_irqsave(&MAIN_BBD_STAGE_SPINLOCK, flags);
		if(stage == BBD_FUNCTION_REQ_VGIP_DRIVER)
		{
			if(main_bbd_stage == BBD_FUNCTION_REQ_ENABLE)
			{
				main_bbd_stage = BBD_FUNCTION_REQ_VGIP_DRIVER;
			}
		}
		else
		{
			main_bbd_stage = stage;
		}
		spin_unlock_irqrestore(&MAIN_BBD_STAGE_SPINLOCK, flags);
	}
	else
	{
		spin_lock_irqsave(&SUB_BBD_STAGE_SPINLOCK, flags);
		if(stage == BBD_FUNCTION_REQ_VGIP_DRIVER)
		{
			if(sub_bbd_stage == BBD_FUNCTION_REQ_ENABLE)
			{
				sub_bbd_stage = BBD_FUNCTION_REQ_VGIP_DRIVER;
			}
		}
		else
		{
			sub_bbd_stage = stage;
		}
		spin_unlock_irqrestore(&SUB_BBD_STAGE_SPINLOCK, flags);
	}
}

unsigned char GET_BBD_STAGE(unsigned char display)
{
	if (display == SLR_MAIN_DISPLAY)
	{
		return main_bbd_stage;
	}
	else
	{
		return sub_bbd_stage;
	}
}


void check_bdb_vgip_driver_request(unsigned char display)
{
	extern void set_bbd_vgip_driver(unsigned char display, StructDisplayInfo* VFEDispInfo);
	static unsigned short wait_vo1_timeout = 0;
	static unsigned short wait_vo2_timeout = 0;
	if (display == SLR_MAIN_DISPLAY)
	{
		if((main_bbd_stage != BBD_FUNCTION_DONE) && (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC))
		{
			if(main_bbd_stage == BBD_FUNCTION_REQ_ENABLE)
			{
				wait_vo1_timeout = 300;//6 second
				SET_BBD_STAGE(SLR_MAIN_DISPLAY, BBD_FUNCTION_REQ_VGIP_DRIVER);
			}
			if(main_bbd_stage == BBD_FUNCTION_REQ_VGIP_DRIVER)
			{
				if(get_vo_change_flag(0) || (wait_vo1_timeout == 0))
				{//main
					if(wait_vo1_timeout == 0)
					{
						SET_BBD_STAGE(SLR_MAIN_DISPLAY, BBD_FUNCTION_DONE);
						printk(KERN_ERR "\r### error func:%s main wait vo timeout ###\r\n", __FUNCTION__);
						return;
					}
					down(&VSC_Semaphore);
					drvif_mode_resetmode(display);
					Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FAILURECOUNT, 0);
					down(get_vo_infosemaphore());
					set_bbd_vgip_driver(display,  Get_VO_Dispinfo(0));
					up(get_vo_infosemaphore());
					up(&VSC_Semaphore);
					SET_BBD_STAGE(SLR_MAIN_DISPLAY, BBD_FUNCTION_DONE);
				}
				else
				{
					wait_vo1_timeout--;
				}
			}
		}
	}
	else if (display == SLR_SUB_DISPLAY)
	{
		if((sub_bbd_stage != BBD_FUNCTION_DONE) && (Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_VDEC))
		{
			if(sub_bbd_stage == BBD_FUNCTION_REQ_ENABLE)
			{
				wait_vo2_timeout = 300;//6 second
				SET_BBD_STAGE(SLR_SUB_DISPLAY, BBD_FUNCTION_REQ_VGIP_DRIVER);
			}
			if(sub_bbd_stage == BBD_FUNCTION_REQ_VGIP_DRIVER)
			{
				if(get_vo_change_flag(1) || (wait_vo2_timeout == 0))
				{//sub
					if(wait_vo2_timeout == 0)
					{
						SET_BBD_STAGE(SLR_SUB_DISPLAY, BBD_FUNCTION_DONE);
						printk(KERN_ERR "\r### error func:%s sub wait vo timeout ###\r\n", __FUNCTION__);
						return;
					}
					down(&VSC_Semaphore);
					drvif_mode_resetmode(display);
					Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_FAILURECOUNT, 0);
					down(get_vo_infosemaphore());
					set_bbd_vgip_driver(display,  Get_VO_Dispinfo(1));
					up(get_vo_infosemaphore());
					up(&VSC_Semaphore);
					SET_BBD_STAGE(SLR_SUB_DISPLAY, BBD_FUNCTION_DONE);
				}
				else
				{
					wait_vo2_timeout--;
				}
			}
		}
	}

}

unsigned char rtk_rerun_scaler(SCALER_DISP_CHANNEL channel);

VSC_INPUT_TYPE_T Get_DisplayMode_Src(unsigned char display)
{
#ifdef CONFIG_DUAL_CHANNEL
	if (display == SLR_MAIN_DISPLAY) {
		if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN){
#ifdef CONFIG_I2RND_ENABLE
			if((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1) || (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)){
				return Sub_DisplayModeInputInfo.type; //i2r sub re-run main case need to use sub src
			}
#endif
			return DisplayModeInputInfo.type;
		}
		else if (VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return VencModeInputInfo.type;
		else if (MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return  MemoryModeInputInfo.type;
		else if (AveModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return AveModeInputInfo.type;
		else{
#ifdef CONFIG_I2RND_ENABLE
			if((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1) || (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)){
				return Sub_DisplayModeInputInfo.type; //i2r sub re-run main case need to use sub src
			}
#endif
			return DisplayModeInputInfo.type;
		}
	} else {
		if(Sub_DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return Sub_DisplayModeInputInfo.type;
		else if (Sub_VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return Sub_VencModeInputInfo.type;
		else if (Sub_MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return  Sub_MemoryModeInputInfo.type;
		else if (Sub_AveModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return Sub_AveModeInputInfo.type;
		else
			return Sub_DisplayModeInputInfo.type;
}
#else
	if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		return DisplayModeInputInfo.type;
	else if (VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		return VencModeInputInfo.type;
	else if (MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		return  MemoryModeInputInfo.type;
	else if (AveModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		return AveModeInputInfo.type;
	else
		return DisplayModeInputInfo.type;
#endif
}

unsigned char Get_DisplayMode_Port(unsigned char display)
{
#ifdef CONFIG_DUAL_CHANNEL
	if (display == SLR_MAIN_DISPLAY) {
		if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
#ifdef CONFIG_FORCE_RUN_I3DDMA
			if((DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_VDEC) && (DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_JPEG))
			{
				return 0;//Vo port is always 0 for all source go i3ddma
			}
#else
			if(DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_HDMI)
			{
				if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_THROUGH_I3DDMA))
				{
					return 0;//Vo port is always 0 for hdmi hdr case
				}
			}
#endif
			return DisplayModeInputInfo.resourceIndex;
		}
		else if (VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return VencModeInputInfo.resourceIndex;
		else if (MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return  MemoryModeInputInfo.resourceIndex;
		else if (AveModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return AveModeInputInfo.resourceIndex;
		else{
			return DisplayModeInputInfo.resourceIndex;
		}
	} else {
		if(Sub_DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return Sub_DisplayModeInputInfo.resourceIndex;
		else if (Sub_VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return Sub_VencModeInputInfo.resourceIndex;
		else if (Sub_MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return  Sub_MemoryModeInputInfo.resourceIndex;
		else if (Sub_AveModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			return Sub_AveModeInputInfo.resourceIndex;
		else
			return Sub_DisplayModeInputInfo.resourceIndex;
}
#else
	if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
#ifdef CONFIG_FORCE_RUN_I3DDMA
		if((DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_VDEC) && (DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_JPEG))
		{
			return 0;//Vo port is always 0 for all source go i3ddma
		}
#else
		if(DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_HDMI)
		{
			if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_THROUGH_I3DDMA))
			{
				return 0;//Vo port is always 0 for hdmi hdr case
			}
		}
#endif
		return DisplayModeInputInfo.resourceIndex;
	}
	else if (VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		return VencModeInputInfo.resourceIndex;
	else if (MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		return  MemoryModeInputInfo.resourceIndex;
	else if (AveModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		return AveModeInputInfo.resourceIndex;
	else
		return DisplayModeInputInfo.resourceIndex;
#endif
}

unsigned char get_output_set_flag(unsigned char display)
{
#ifdef CONFIG_DUAL_CHANNEL
	return ((display == SLR_MAIN_DISPLAY) ? DbgSclrFlgTkr.Main_Output_Set_flag : DbgSclrFlgTkr.Sub_Output_Set_flag);
#else
	return DbgSclrFlgTkr.Main_Output_Set_flag;
#endif
}

unsigned char get_scaler_stop_flag(unsigned char display)
{
#ifdef CONFIG_DUAL_CHANNEL
#ifdef CONFIG_I2RND_ENABLE
	//i2r case, sub re-run main stage nned to check sub flag @Crixus 20180103
	if((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE)
		&& ((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1) || (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC))){
		display = SLR_SUB_DISPLAY;
	}
#endif
	return ((display == SLR_MAIN_DISPLAY) ? DbgSclrFlgTkr.Main_Scaler_Stop_flag : DbgSclrFlgTkr.Sub_Scaler_Stop_flag);
#else
	return DbgSclrFlgTkr.Main_Scaler_Stop_flag;
#endif
}

void reset_support_vo_force_v_top(void)
{
	VO_FORCE_V_TOP_DATA *vo_force_v_top = (VO_FORCE_V_TOP_DATA *)Scaler_GetShareMemVirAddr(SCALERIOC_VO_FORCE_V_TOP);

	if (vo_force_v_top)
		vo_force_v_top->vo_force_v_top_enable = 0;
}


void set_support_vo_force_v_top(bool enable, unsigned int func_flag)
{
	VO_FORCE_V_TOP_DATA *vo_force_v_top = (VO_FORCE_V_TOP_DATA *)Scaler_GetShareMemVirAddr(SCALERIOC_VO_FORCE_V_TOP);

	if (vo_force_v_top) {
		if (enable)
			vo_force_v_top->vo_force_v_top_enable |= func_flag;
		else
			vo_force_v_top->vo_force_v_top_enable &= ~func_flag;
	}
}

bool get_support_vo_force_v_top(unsigned int func_flag)
{
	VO_FORCE_V_TOP_DATA *vo_force_v_top = (VO_FORCE_V_TOP_DATA *)Scaler_GetShareMemVirAddr(SCALERIOC_VO_FORCE_V_TOP);

	return vo_force_v_top ? (vo_force_v_top->vo_force_v_top_enable) & func_flag : false;
}

static void reset_all_top_dolby_mode(void)
{
	hdr_all_top_top_ctl_RBUS hdr_all_top_top_ctl_reg;
	hdr_all_top_top_d_buf_RBUS top_d_buf_reg;

	hdr_all_top_top_ctl_reg.regValue = IoReg_Read32(HDR_ALL_TOP_TOP_CTL_reg);

	if (get_support_vo_force_v_top(support_sdr_max_rgb)) {
		hdr_all_top_top_ctl_reg.dolby_mode = 1;
	} else {
		hdr_all_top_top_ctl_reg.dolby_mode = 0;
	}

	top_d_buf_reg.regValue = IoReg_Read32(HDR_ALL_TOP_TOP_D_BUF_reg);
	top_d_buf_reg.dolby_double_en = 1;
	rtd_outl(HDR_ALL_TOP_TOP_D_BUF_reg, top_d_buf_reg.regValue);//enable double buffer

	IoReg_Write32(HDR_ALL_TOP_TOP_CTL_reg, hdr_all_top_top_ctl_reg.regValue);//Disable dolby mode
}

void reset_ARC_cmd(unsigned char display)
{//clear arc command // for unstable use
	if(display == SLR_MAIN_DISPLAY)
	{
		down(&SetMainOutPutRegion_Semaphore);
		DbgSclrFlgTkr.Main_Output_Set_flag = FALSE;
		DbgSclrFlgTkr.Main_Run_Scaler_flag = FALSE;
		up(&SetMainOutPutRegion_Semaphore);
	}
}
void scaler_overscan_vertical_size(unsigned char display,unsigned int progressive,unsigned int source_height,unsigned int *height,unsigned int *v_start)
{
	*v_start =0;
	*height = 0;
	if (get_current_driver_pattern(DRIVER_FREERUN_PATTERN) == 1) {
		down(&SetMainOutPutRegion_Semaphore);
		if (DbgSclrFlgTkr.Main_Run_Scaler_flag || DbgSclrFlgTkr.Main_Output_Set_flag || (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)) {
			if (((0 == progressive) && (main_dispwin.src_height <  _DISP_LEN)) ||
				((1 == progressive) && (main_dispwin.src_height <  _DISP_LEN))) {

			} else {
				*height = (source_height *main_input_size.src_height * 100/main_input_timing.src_height + 50)/100;
				*v_start = (source_height *main_input_size.srcy * 100/main_input_timing.src_height + 50)/100;
			}
		}
		up(&SetMainOutPutRegion_Semaphore);
	}
}

void check_ARC_status(unsigned char display, KADP_VSC_INPUT_TYPE_T source)
{
	StructSrcRect outdispwin = {0, 0, _DISP_WID, _DISP_LEN};
	StructSrcRect indispwin = {0, 0, 0, 0};
	unsigned char isatv = FALSE;
	isatv = ((source ==KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV)) ? TRUE : FALSE;

	if(display == SLR_MAIN_DISPLAY)
	{
		down(&SetMainOutPutRegion_Semaphore);
		if((DbgSclrFlgTkr.Main_Run_Scaler_flag || DbgSclrFlgTkr.Main_Output_Set_flag || DbgSclrFlgTkr.rotate_run_scaler_flag || DbgSclrFlgTkr.rotate_muteoff_request_flag || (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
			&& !isatv)
		{
			DbgSclrFlgTkr.Main_Run_Scaler_flag = FALSE;
			DbgSclrFlgTkr.Main_Output_Set_flag = FALSE;
			DbgSclrFlgTkr.rotate_run_scaler_flag = FALSE;
			DbgSclrFlgTkr.rotate_muteoff_request_flag = FALSE;
            vsc_force_rerun_main_scaler = FALSE;
            set_input_for_vgip(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
			set_input_for_crop(SLR_MAIN_DISPLAY, main_input_size);
			set_input_timing_for_crop(SLR_MAIN_DISPLAY, main_input_timing);
			Scaler_InputRegionType_Set(SLR_MAIN_DISPLAY,getInputRegionType(SLR_MAIN_DISPLAY));

			Scaler_DispWindowSet(main_dispwin);


#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE

            set_ori_rotate_mode(get_rotate_mode());
            set_rotate_mode(rotate_mode);

            if((display == SLR_MAIN_DISPLAY)
            	&&((get_rotate_mode() == DIRECT_VO_FRAME_ORIENTATION_ROTATE_90)
            	||(get_rotate_mode() == DIRECT_VO_FRAME_ORIENTATION_ROTATE_270)))
            {
            	Set_rotate_function(TRUE);
            } else if ((display == SLR_MAIN_DISPLAY)
                && (get_rotate_mode() == DIRECT_VO_FRAME_ORIENTATION_ROTATE_180)
	            && Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE))
            {
            	Set_rotate_function(TRUE);
            }
            else
            {
            	Set_rotate_function(FALSE);
            }
			//set_ori_rotate_mode(get_rotate_mode());
#endif
			//Fixed ATV all direction zoom non-working issue. @Crixus 20160829
			if(!((source == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))){
				//printk(KERN_EMERG"[%s][%d]\n", __FUNCTION__, __LINE__);
				zoom_record_input_output_pre_size(display,main_input_size, main_input_timing, main_dispwin);
			}
			set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, FALSE);
			pr_notice("\r\n### func:%s apply ARC size (%d %d %d %d)#####\r\n",__FUNCTION__, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid,  main_input_size.src_height);

		}
		else
		{//no over scan and full panel size
//fill size condition
			StructSrcRect inputTiming ;
			reset_any_srcrect(&main_dispwin_for_only_xy);
            vsc_force_rerun_main_scaler = FALSE;
            indispwin.src_wid = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE);
			if(Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE))
			{
				indispwin.src_height = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE)*2;
				set_input_for_vgip(SLR_MAIN_DISPLAY, 0, 0, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE), Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE)*2);
			}
			else
			{
				indispwin.src_height = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE);
				set_input_for_vgip(SLR_MAIN_DISPLAY, 0, 0, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE), Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE));
			}
			inputTiming = indispwin;
			set_input_for_crop(SLR_MAIN_DISPLAY, inputTiming);
			set_input_timing_for_crop(SLR_MAIN_DISPLAY, inputTiming);
			Scaler_InputRegionType_Set(SLR_MAIN_DISPLAY,INPUT_BASE_ON_HAL_ORIGINAL_INPUT);
#if 0//this is for debug new flow
			set_input_for_vgip(SLR_MAIN_DISPLAY, 0, 0, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE)/2, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE)/2);
			indispwin.src_wid = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE)/2;
			indispwin.src_height = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE)/2;
#endif
			Scaler_DispWindowSet(outdispwin);
			if(!((source == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))){
				//printk(KERN_EMERG"[%s][%d]\n", __FUNCTION__, __LINE__);
				zoom_record_input_output_pre_size(SLR_MAIN_DISPLAY, indispwin, inputTiming,outdispwin);//for smooth toggle use
			}
			pr_notice("\r\n### func:%s apply full size w:%d h:%d#####\r\n",__FUNCTION__, indispwin.src_wid, indispwin.src_height);
		}
		up(&SetMainOutPutRegion_Semaphore);
	}

}

unsigned char check_input_and_output_the_same(unsigned char display)
{//True: The same. False: The different
	unsigned char result = TRUE;
	if(display == SLR_MAIN_DISPLAY) {
		if((main_input_size_pre.srcx != main_input_size.srcx) || (main_input_size_pre.srcy != main_input_size.srcy) ||
			(main_input_size_pre.src_height != main_input_size.src_height) || (main_input_size_pre.src_wid != main_input_size.src_wid)) {
			result = FALSE;
			main_input_size_pre.srcx = main_input_size.srcx;
			main_input_size_pre.srcy = main_input_size.srcy;
			main_input_size_pre.src_height = main_input_size.src_height;
			main_input_size_pre.src_wid = main_input_size.src_wid;
		}
		#ifdef NEW_INPUT_REGION_BASE_ON_HAL_ORIGINAL_INPUT
		if((main_input_timing_pre.srcx != main_input_timing.srcx) || (main_input_timing_pre.srcy != main_input_timing.srcy) ||
			(main_input_timing_pre.src_height != main_input_timing.src_height) || (main_input_timing_pre.src_wid != main_input_timing.src_wid)) {
			result = FALSE;
			main_input_timing_pre.srcx = main_input_timing.srcx;
			main_input_timing_pre.srcy = main_input_timing.srcy;
			main_input_timing_pre.src_height = main_input_timing.src_height;
			main_input_timing_pre.src_wid = main_input_timing.src_wid;
		}
		#endif
		if((main_dispwin_pre.srcx != main_dispwin.srcx) || (main_dispwin_pre.srcy != main_dispwin.srcy) ||
			(main_dispwin_pre.src_height != main_dispwin.src_height) || (main_dispwin_pre.src_wid != main_dispwin.src_wid)) {
			result = FALSE;
			main_dispwin_pre.srcx = main_dispwin.srcx;
			main_dispwin_pre.srcy = main_dispwin.srcy;
			main_dispwin_pre.src_height = main_dispwin.src_height;
			main_dispwin_pre.src_wid = main_dispwin.src_wid;
		}
	}

#ifdef CONFIG_DUAL_CHANNEL
	else
	{
		if((sub_input_size_pre.srcx != sub_input_size.srcx) || (sub_input_size_pre.srcy != sub_input_size.srcy) ||
			(sub_input_size_pre.src_height != sub_input_size.src_height) || (sub_input_size_pre.src_wid != sub_input_size.src_wid)) {
			result = FALSE;
			sub_input_size_pre.srcx = sub_input_size.srcx;
			sub_input_size_pre.srcy = sub_input_size.srcy;
			sub_input_size_pre.src_height = sub_input_size.src_height;
			sub_input_size_pre.src_wid = sub_input_size.src_wid;
		}
		#ifdef NEW_INPUT_REGION_BASE_ON_HAL_ORIGINAL_INPUT
		if((sub_input_timing_pre.srcx != sub_input_timing.srcx) || (sub_input_timing_pre.srcy != sub_input_timing.srcy) ||
			(sub_input_timing_pre.src_height != sub_input_timing.src_height) || (sub_input_timing_pre.src_wid != sub_input_timing.src_wid)) {
			result = FALSE;
			sub_input_timing_pre.srcx = sub_input_timing.srcx;
			sub_input_timing_pre.srcy = sub_input_timing.srcy;
			sub_input_timing_pre.src_height = sub_input_timing.src_height;
			sub_input_timing_pre.src_wid = sub_input_timing.src_wid;
		}
		#endif
		if((sub_dispwin_pre.srcx != sub_dispwin.srcx) || (sub_dispwin_pre.srcy != sub_dispwin.srcy) ||
			(sub_dispwin_pre.src_height != sub_dispwin.src_height) || (sub_dispwin_pre.src_wid != sub_dispwin.src_wid)) {
			result = FALSE;
			sub_dispwin_pre.srcx = sub_dispwin.srcx;
			sub_dispwin_pre.srcy = sub_dispwin.srcy;
			sub_dispwin_pre.src_height = sub_dispwin.src_height;
			sub_dispwin_pre.src_wid = sub_dispwin.src_wid;
		}
	}
#else
	result = FALSE;
#endif
	return result;
}

void source_disconnect_reset_input(unsigned char display)
{//for issue WOSQRTK-11401
	unsigned long flags;//for spin_lock_irqsave
	if (display == SLR_MAIN_DISPLAY) {
		down(&new_input_output_main_sem);//lock semaphore
		spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
		//copy input region
		ap_main_inregion_parm.x = 0;
		ap_main_inregion_parm.y = 0;
		ap_main_inregion_parm.w = 0;
		ap_main_inregion_parm.h = 0;

		//copy original input region
		ap_main_originalInput_parm.x = 0;
		ap_main_originalInput_parm.y = 0;
		ap_main_originalInput_parm.w = 0;
		ap_main_originalInput_parm.h = 0;
		spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
		up(&new_input_output_main_sem);//lock semaphore
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if(display == SLR_SUB_DISPLAY)
	{
		down(&new_input_output_sub_sem);//lock semaphore
		spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
		//copy input region
		ap_sub_inregion_parm.x = 0;
		ap_sub_inregion_parm.y = 0;
		ap_sub_inregion_parm.w = 0;
		ap_sub_inregion_parm.h = 0;

		//copy original input region
		ap_sub_originalInput_parm.x = 0;
		ap_sub_originalInput_parm.y = 0;
		ap_sub_originalInput_parm.w = 0;
		ap_sub_originalInput_parm.h = 0;
		spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);
		up(&new_input_output_sub_sem);//unlock semaphore
	}
#endif
}

void reset_any_srcrect(StructSrcRect *p_srcrect)
{
	if(p_srcrect) {
		p_srcrect->srcx = 0;
		p_srcrect->srcy = 0;
		p_srcrect->src_height = 0;
		p_srcrect->src_wid = 0;
	}
}

void set_source_info_forPQ(unsigned char display)
{
	KADP_VSC_OUTPUT_MODE_T outputMode;
	KADP_VSC_INPUT_TYPE_T inputType = KADP_VSC_INPUTSRC_MAXN;
	unsigned char inputPort = 0;

	if (display == SLR_MAIN_DISPLAY) {
		if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_DISPLAY_MODE;
			inputType = DisplayModeInputInfo.type;
			inputPort = DisplayModeInputInfo.resourceIndex;
		}
		else if(VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_VENC_MODE;
			inputType = VencModeInputInfo.type;
			inputPort = VencModeInputInfo.resourceIndex;
		}
		else if(MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_MEMORY_MODE;
			inputType = MemoryModeInputInfo.type;
			inputPort = MemoryModeInputInfo.resourceIndex;
		}
		else
		{
			return;
		}
		//Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);//No need
		if (DbgSclrFlgTkr.main_opensourceID == _UNKNOWN_INPUT) {
			if (init_source_proc(SLR_MAIN_DISPLAY, inputType, inputPort) == FALSE) {
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"\r\n######init_source_proc fail fail#####\r\n");
				DbgSclrFlgTkr.main_opensourceID = _UNKNOWN_INPUT;
				return;
			}
		}
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if (display == SLR_SUB_DISPLAY){
		if(Sub_DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_DISPLAY_MODE;
			inputType = Sub_DisplayModeInputInfo.type;
			inputPort = Sub_DisplayModeInputInfo.resourceIndex;
		}
		else if(Sub_VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_VENC_MODE;
			inputType = Sub_VencModeInputInfo.type;
			inputPort = Sub_VencModeInputInfo.resourceIndex;
		}
		else if(Sub_MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_MEMORY_MODE;
			inputType = Sub_MemoryModeInputInfo.type;
			inputPort = Sub_MemoryModeInputInfo.resourceIndex;
		}
		else
		{
			return;
		}

		//Scaler_SetCurrentDispInfo(SLR_SUB_DISPLAY);//No need
		if (DbgSclrFlgTkr.sub_opensourceID == _UNKNOWN_INPUT) {
			if (init_source_proc(SLR_SUB_DISPLAY, inputType, inputPort) == FALSE) {
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"\r\n######init_source_proc fail fail#####\r\n");
				DbgSclrFlgTkr.sub_opensourceID = _UNKNOWN_INPUT;
				return;
			}
		}
	}
#endif
}


unsigned judge_scaler_break_case(unsigned char display)
{//Return True: break. False:No break
	unsigned char src;
	KADP_VSC_INPUT_TYPE_T webos_src;
	webos_src = Get_DisplayMode_Src(display);
	src = Scaler_InputSrcGetType(display);
	if((display == SLR_MAIN_DISPLAY) && (webos_src == KADP_VSC_INPUTSRC_ADC))
	{
		if(check_verify_mode_enable())//adc verify mode
			return FALSE;
	}
    if((display == SLR_MAIN_DISPLAY) && (webos_src == KADP_VSC_INPUTSRC_HDMI))
    {
        if(vbe_disp_get_VRR_timingMode_flag() != drvif_Hdmi_GetVRREnable())
        {
            rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"\r HDMI VRR (%d %d) not match so break !!!####\r\n", vbe_disp_get_VRR_timingMode_flag(), drvif_Hdmi_GetVRREnable());
            return TRUE;
        }
        if(vbe_disp_get_freesync_mode_flag() != drvif_Hdmi_GetAMDFreeSyncEnable())
        {
            rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"\r HDMI freesync (%d %d) not match so break !!!####\r\n", vbe_disp_get_freesync_mode_flag(), drvif_Hdmi_GetAMDFreeSyncEnable());
            return TRUE;
        }

    }

#ifdef CONFIG_I2RND_ENABLE
	//Eric@20170817 do not break in dual vo sub rerun case
	if(!((Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1))
	&& !((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)))
	{
		if (get_scaler_stop_flag(display))
		{
			rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "\r\n####channel:%d vsc already disconnect !!!####\r\n", display);
			return TRUE;
		}
		else if(!compare_rerify_vsc_source_num_result(display))
		{
			rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "### judge_scaler_break_case source(%d) already change###\r\n", display);
			return TRUE;
		}

	}
#else
	if (get_scaler_stop_flag(display)) {
		rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "\r\n####channel:%d vsc already disconnect !!!####\r\n", display);
		return TRUE;
	}
	else if(!compare_rerify_vsc_source_num_result(display))
	{
		rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "### judge_scaler_break_case source(%d) already change###\r\n", display);
		return TRUE;
	}
	else if((webos_src == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
	{
		return FALSE;//ATV don't check online status
	}
#endif
	else if((display == SLR_MAIN_DISPLAY) &&
		(webos_src == KADP_VSC_INPUTSRC_HDMI) && (get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1)
	)
	{
		if(drvif_mode_check_onlinemeasure_status(display) == FALSE) {
			rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "\r\n####channel:%d online error status:%08x!!!####\r\n", display, IoReg_Read32(ONMS_onms1_status_reg));
			return TRUE;
		}

	}
#ifdef CONFIG_FORCE_RUN_I3DDMA
	else if((display == SLR_MAIN_DISPLAY) &&
		((webos_src == KADP_VSC_INPUTSRC_ADC) ||(webos_src == KADP_VSC_INPUTSRC_AVD) || (webos_src == KADP_VSC_INPUTSRC_HDMI))
	)
	{
		if((webos_src == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
		{
			return FALSE;//ATV don't check dma online status
		}
		else if(drvif_mode_check_dma_onlinemeasure_status() == FALSE) {
			rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "\r\n####dma online error status:%08x!!!####\r\n", IoReg_Read32(ONMS_onms3_status_reg));
			return TRUE;
		}
		else if(webos_src == KADP_VSC_INPUTSRC_HDMI)
		{
			if(get_ori_HDMI_HDR_mode() != get_HDMI_HDR_mode()){
				if((get_ori_HDMI_HDR_mode() == HDR_DOLBY_HDMI) || (get_HDMI_HDR_mode() == HDR_DOLBY_HDMI))
				{//only dolby need to do this
					rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"\r\nHDMI HDR (%d %d) not match so break !!!####\r\n", get_ori_HDMI_HDR_mode(), get_HDMI_HDR_mode());
					return TRUE;
				}
			}

			if (check_hdrtype_change() && ((get_ori_HDMI_HDR_mode() == HDR_DOLBY_HDMI) || (get_HDMI_HDR_mode() == HDR_DOLBY_HDMI))) {
				reset_hdrtype_change_counter();

				rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"HDMI HDR type had changed !!!####\n");
				return TRUE;
			}

			if(vsc_force_rerun_main_scaler == TRUE){
				rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"\r\nCondition changed, force re-run scaler so break !!!####\r\n");
				return TRUE;
			}
		}
	}
#endif
	else if(src == _SRC_VO) {
#ifdef CONFIG_I2RND_ENABLE
		//Eric@20170817 do not break in dual vo sub rerun case
		if(!((Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1))
				&& !((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)))
#endif
		{
			if(get_vo_change_flag(Get_DisplayMode_Port(display))) {
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####channel:%d vo already update !!!####\r\n", display);
				return TRUE;
			}
		}
#ifndef CONFIG_FORCE_RUN_I3DDMA
		if((display == SLR_MAIN_DISPLAY) && (webos_src == KADP_VSC_INPUTSRC_HDMI))
    	{
    		if(get_ori_HDMI_HDR_mode() != get_HDMI_HDR_mode()){
                rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"\r\nHDMI HDR (%d %d) not match so break !!!####\r\n", get_ori_HDMI_HDR_mode(), get_HDMI_HDR_mode());
			    return TRUE;
            }
        }
#endif
	} else {
#ifdef CONFIG_I2RND_ENABLE
		if((display == SLR_SUB_DISPLAY) &&(webos_src == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
		{
			return FALSE;//ATV don't check dma online status
		}
#endif
		if(drvif_mode_check_onlinemeasure_status(display) == FALSE) {
			rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "\r\n####channel:%d online error status:%08x!!!####\r\n", display, IoReg_Read32(ONMS_onms1_status_reg));
			return TRUE;
		}
#ifndef CONFIG_FORCE_RUN_I3DDMA
		if((display == SLR_MAIN_DISPLAY) && (webos_src == KADP_VSC_INPUTSRC_HDMI))
    	{
    		if(get_ori_HDMI_HDR_mode() != get_HDMI_HDR_mode()){
                rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"\r\nHDMI HDR (%d %d) not match so break !!!####\r\n", get_ori_HDMI_HDR_mode(), get_HDMI_HDR_mode());
			    return TRUE;
            }
        }
#endif
	}
	return FALSE;
}

void Scaler_Dolby_HDR_reset(void){
	//Reset DM control
	drvif_Dolby_HDR_disable_DM_LUT();//disable DM LUT @Crixus 20160313
}
void reset_hdr_mode(unsigned char display)
{
	if(display == SLR_MAIN_DISPLAY)
	{
		hdr_all_top_top_ctl_RBUS hdr_all_top_top_ctl_reg;
	//Disable v top setting
#ifdef CONFIG_HDR_SDR_SEAMLESS
		if(livezoom_run_scaler_case())//livezoom enter or leave caondition
		{
			return;
		}
#endif
		hdr_all_top_top_ctl_reg.regValue = IoReg_Read32(HDR_ALL_TOP_TOP_CTL_reg);
		//top_ctl_reg.dolby_v_read_sel = 1;
		if (get_support_vo_force_v_top(support_sdr_max_rgb)) {
			hdr_all_top_top_ctl_reg.dolby_mode = 1;
		} else {
			hdr_all_top_top_ctl_reg.dolby_mode = 0;
		}
		hdr_all_top_top_ctl_reg.hdr1_in_sel = 0;//0: vo case  1: hdmi
		//hdr_all_top_top_ctl_reg.hdr_yuv444_en = 0;//reset yuv 444 enable
		IoReg_Write32(HDR_ALL_TOP_TOP_CTL_reg, hdr_all_top_top_ctl_reg.regValue);//Disable dolby mode
		IoReg_SetBits(HDR_ALL_TOP_TOP_D_BUF_reg, _BIT1);//Enable doublue buffer

		//reset HDR RGB swap
		drvif_color_set_HDR_RGB_swap(0);

#ifdef CONFIG_RTK_KDRV_QOS_CONTROL
		//skip qos reset mode
		pr_debug("[QoS] %s:skip qos reset\n", __FUNCTION__);
		//rtk_qos_set_mode(RTK_QOS_NORMAL_MODE);
#endif
	}
	else
	{//sub case
	}

}

static void decide_qos_mode(void)
{
#ifdef CONFIG_RTK_KDRV_QOS_CONTROL
	if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC)
	{
		if (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE) >= 3800) // 4K
			rtk_qos_set_mode(RTK_QOS_DECODER_4K_MODE);
#if 0 // Use same QoS for all 2K video now, add/change mode only if we find 2K60 or 2K120 needs different QoS setting
		else if (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) >= 490) // 2K freq > 50, apply 4k qos
			rtk_qos_set_mode(RTK_QOS_DECODER_4K_MODE);
#endif
		else
			rtk_qos_set_mode(RTK_QOS_DECODER_2K_MODE);
	}
	else if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_JPEG)
	{
		if (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE) >= 3800)
			rtk_qos_set_mode(RTK_QOS_DECODER_4K_MODE);
		else
			rtk_qos_set_mode(RTK_QOS_DECODER_2K_MODE);
	}
	else if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)
	{
		if (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE) >= 3800)
			rtk_qos_set_mode(RTK_QOS_HDMI_4K_MODE);
		else
			rtk_qos_set_mode(RTK_QOS_HDMI_2K_MODE);
	}
	else
	{
		rtk_qos_set_mode(RTK_QOS_NORMAL_MODE);
	}
#endif
}

void qos_mode_switch(unsigned int is_bad_edit)
{
#ifdef CONFIG_RTK_KDRV_QOS_CONTROL
	if (is_bad_edit) {
		rtk_qos_set_bad_edit(1);
		rtk_qos_set_mode(RTK_QOS_DECODER_BAD_EDIT_MODE);
	}
	else {
		rtk_qos_set_bad_edit(0);
		decide_qos_mode();
	}
#endif
}

#ifdef CONFIG_HDR_SDR_SEAMLESS
void dynamic_change_hdr_setting(unsigned char hdr_enable, I3DDMA_COLOR_SPACE_T color_format)
{//This is for vgip isr setting //vdec source
	bool sdr_force_vtop = FALSE;
	unsigned char decide_final_hdr_enable;//decide final hdr enable or disable
	hdr_all_top_top_ctl_RBUS hdr_all_top_top_ctl_reg;
	sdr_force_vtop = get_support_vo_force_v_top(support_sdr_max_rgb);
	decide_final_hdr_enable = (hdr_enable || sdr_force_vtop);

	IoReg_ClearBits(HDR_ALL_TOP_TOP_D_BUF_reg, _BIT0);		//disable double buffer

	hdr_all_top_top_ctl_reg.regValue = IoReg_Read32(HDR_ALL_TOP_TOP_CTL_reg);
	if(hdr_enable || decide_final_hdr_enable)
	{
		hdr_all_top_top_ctl_reg.en_422to444_1 = 0;//hdr don't enable 422 to 444
	}
	else
	{
		if(color_format == I3DDMA_COLOR_YUV422)
			hdr_all_top_top_ctl_reg.en_422to444_1 = 1;
		else if(color_format == I3DDMA_COLOR_YUV444)
			hdr_all_top_top_ctl_reg.en_422to444_1 = 0;
	}
	IoReg_Write32(HDR_ALL_TOP_TOP_CTL_reg, hdr_all_top_top_ctl_reg.regValue); //Set vtop setting
	IoReg_SetBits(HDR_ALL_TOP_TOP_D_BUF_reg, _BIT1);//apply doublue buffer

	Scaler_hdr_setting_SEAMLESS(hdr_enable || decide_final_hdr_enable);

	IoReg_SetBits(HDR_ALL_TOP_TOP_D_BUF_reg, _BIT0);			//enable double buffer
}

void dynamic_change_hdr_setting_hdmi_position(unsigned char hdr_enable, I3DDMA_COLOR_SPACE_T color_format, unsigned char hdr_type)
{//This is for vgip isr setting. hdr type is from PQ_HDR_TYPE

	hdr_all_top_top_ctl_RBUS hdr_all_top_top_ctl_reg;
	hdr_all_top_top_ctl_reg.regValue = IoReg_Read32(HDR_ALL_TOP_TOP_CTL_reg);
	if(hdr_enable)
	{
		hdr_all_top_top_ctl_reg.en_422to444_1 = 0;//hdr don't enable 422 to 444
	}
	else
	{
		if(color_format == I3DDMA_COLOR_YUV422)
			hdr_all_top_top_ctl_reg.en_422to444_1 = 1;
		else if(color_format == I3DDMA_COLOR_YUV444)
			hdr_all_top_top_ctl_reg.en_422to444_1 = 0;
	}
	IoReg_Write32(HDR_ALL_TOP_TOP_CTL_reg, hdr_all_top_top_ctl_reg.regValue); //Set vtop setting
	IoReg_SetBits(HDR_ALL_TOP_TOP_D_BUF_reg, _BIT1);//apply doublue buffer

	Scaler_hdr_setting_SEAMLESS_hdmi_position(hdr_enable, hdr_type);

}

void dynamic_change_hdr_setting_hdmi_finish(unsigned char hdr_enable, I3DDMA_COLOR_SPACE_T color_format, unsigned char hdr_type)
{//This is for vgip isr setting. PQ_HDR_TYPE

	Scaler_hdr_setting_SEAMLESS_hdmi_finish(hdr_enable, hdr_type);
}


void reset_seamless_trigger_flag(void)
{//reset HDMI and vdec seamless trigger related flag. This is for run scaler
	extern unsigned char hdmi_position_seamless;//for hdr sdr seamless condition for vgip start
   	extern unsigned char hdmi_finish_seamless;//for hdr sdr seamless condition for vgip end
	unsigned long flags;//for spin_lock_irqsave
    seamless_change_sync_info *seamless_info_sharememory = NULL;
    seamless_info_sharememory = (seamless_change_sync_info *)Scaler_GetShareMemVirAddr(SCALERIOC_SEAMLESS_CHANGE_SHAREMEMORY_INFO_SYNC_FLAG);
	if(seamless_info_sharememory)
	{
	    seamless_info_sharememory->hdmi_trigger_vo_change_flag = Scaler_ChangeUINT32Endian(0);
		seamless_info_sharememory->hdmi_not_ready = 0;
	}
    spin_lock_irqsave(get_i3ddma_change_spinlock(), flags);//lock i3ddma change spinlock
    set_i3ddma_change_format_flag(FALSE);
	hdmi_position_seamless = FALSE;
	hdmi_finish_seamless = FALSE;
    spin_unlock_irqrestore(get_i3ddma_change_spinlock(), flags);//unlock i3ddma change  spinlock
    spin_lock_irqsave(get_vdec_seamless_change_spinlock(), flags);//lock vdec semaless change spinlock
    set_vdec_seamless_change_flag(FALSE);
    spin_unlock_irqrestore(get_vdec_seamless_change_spinlock(), flags);//unlock vdec semaless change  spinlock
    set_hdr_semaless_active(FALSE);
}

#endif
#if 0
static void apvr_request_run_main_path(void)
{//This api is for apvr need to run main path again

	//reset i2rnd and pst write point when rerun scaler flow @Crixus 20180819
#ifdef CONFIG_I2RND_ENABLE
	//enable I2rnd
	if (Scaler_I2rnd_get_enable()) {
		Scaler_i2rnd_write_default_cmd_num();
		Scaler_I2rnd_set_read_cmd_num(0);
	}
#endif
#ifdef CONFIG_PST_ENABLE
	//enable pst
	if (Scaler_main_md_pst_get_enable()) {
		Scaler_pst_main_md_write_default_cmd_num();
		Scaler_pst_main_md_set_read_cmd_num(0);
	}
#endif

	if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE)
	{
		mute_control(SLR_MAIN_DISPLAY, TRUE);/*Auto BG. Add by Will*/
	}
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);//Let main path to search state. In order to request VO
	down(&SetMainOutPutRegion_Semaphore);
	DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;//Let main path run scaler again
	up(&SetMainOutPutRegion_Semaphore);
}
#endif
unsigned char get_vsc_mutestatus(void)
{
	return DbgSclrFlgTkr.VscMuteStatus;
}

void Scaler_SET_VSCDispinfo_WithVFEHMDI(unsigned char display, vfe_hdmi_timing_info_t vfehdmitiminginfo)
{
	//Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_ADC_CLOCK, VFEDispInfo->INPUT_ADC_CLOCK);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_LEN_PRE, vfehdmitiminginfo.active.h);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_STA_PRE, vfehdmitiminginfo.active.y+vfehdmitiminginfo.y_offset);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_IPH_ACT_WID_PRE, vfehdmitiminginfo.active.w);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_IPH_ACT_STA_PRE, vfehdmitiminginfo.active.x+vfehdmitiminginfo.x_offset);

	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_HSYNC, vfehdmitiminginfo.hsync);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_VSYNC, vfehdmitiminginfo.vsync);

	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MODE_CURR, vfehdmitiminginfo.mode_id);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MODE_TABLE_INDEX, vfehdmitiminginfo.mode_table_index);

	//Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_AFD, VFEDispInfo->afd);

	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_POLARITY, vfehdmitiminginfo.polarity);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_H_FREQ, vfehdmitiminginfo.h_freq);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_V_FREQ, vfehdmitiminginfo.v_freq);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_H_LEN, vfehdmitiminginfo.h_total);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_V_LEN, vfehdmitiminginfo.v_total);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_H_COUNT, vfehdmitiminginfo.h_total);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_V_COUNT, vfehdmitiminginfo.v_total);
	//Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_IHSYNCPULSECOUNT, VFEDispInfo->IHSyncPulseCount);
	if((display == SLR_MAIN_DISPLAY) && (vfehdmitiminginfo.color_space==VFE_HDMI_COLOR_YUV422) && (get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1))
	{
		Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_COLOR_SPACE, VFE_HDMI_COLOR_YUV444);//two pixel mode force vtop, so scaler is yuv 444
		Scaler_DispSetStatus(display, SLR_DISP_422, 0);
	}
	else
	{
		Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_COLOR_SPACE, vfehdmitiminginfo.color_space);
		Scaler_DispSetStatus(display, SLR_DISP_422, (vfehdmitiminginfo.color_space==VFE_HDMI_COLOR_YUV422) ? 1 : 0);
	}
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_COLOR_DEPTH, vfehdmitiminginfo.color_depth);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_COLOR_IMETRY, vfehdmitiminginfo.color_imetry);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_IVSYNCPULSECOUNT, vfehdmitiminginfo.IVSyncPulseCount);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_V_SYNC_HIGH_PERIOD, vfehdmitiminginfo.polarity);

	Scaler_DispSetStatus(display, SLR_DISP_INTERLACE,  (!vfehdmitiminginfo.scan_type));
	//Scaler_DispSetStatus(display, SLR_DISP_INTERLACE,FALSE);

#if 0//frank@20141103 mark below code to reduce time
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_ADC_CLOCK:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_ADC_CLOCK));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_IPV_ACT_LEN_PRE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN_PRE));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_IPV_ACT_STA_PRE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_STA_PRE));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_IPH_ACT_WID_PRE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_IPH_ACT_STA_PRE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_STA_PRE));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_HSYNC:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_HSYNC));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_VSYNC:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_VSYNC));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_MODE_CURR:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_MODE_TABLE_INDEX:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_MODE_TABLE_INDEX));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_AFD:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_AFD));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_POLARITY:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_POLARITY));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_H_FREQ:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_H_FREQ));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_V_FREQ:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_H_LEN:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_H_LEN));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_V_LEN:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_LEN));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_H_COUNT:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_H_COUNT));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_V_COUNT:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_COUNT));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_IHSYNCPULSECOUNT:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IHSYNCPULSECOUNT));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_COLOR_SPACE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_COLOR_SPACE));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_COLOR_DEPTH:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_COLOR_DEPTH));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_COLOR_IMETRY:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_COLOR_IMETRY));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_DISP_422:%d\n", Scaler_DispGetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_422));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_DISP_INTERLACE:%d\n", Scaler_DispGetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_INTERLACE));
#endif
}

void Scaler_SET_VSCSubDispinfo_Withmain(void)
{
	//Scaler_DispSetInputInfo(SLR_INPUT_ADC_CLOCK, VFEDispInfo->INPUT_ADC_CLOCK);
	Scaler_DispSetInputInfo(SLR_INPUT_IPV_ACT_LEN_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE));
	Scaler_DispSetInputInfo(SLR_INPUT_IPV_ACT_STA_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_STA_PRE));
	Scaler_DispSetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE));
	Scaler_DispSetInputInfo(SLR_INPUT_IPH_ACT_STA_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_STA_PRE));

	Scaler_DispSetInputInfo(SLR_INPUT_HSYNC, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_HSYNC));
	Scaler_DispSetInputInfo(SLR_INPUT_VSYNC, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_VSYNC));

	Scaler_DispSetInputInfo(SLR_INPUT_MODE_CURR, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_CURR));
	Scaler_DispSetInputInfo(SLR_INPUT_MODE_TABLE_INDEX, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_TABLE_INDEX));

	//Scaler_DispSetInputInfo(SLR_INPUT_AFD, VFEDispInfo->afd);

	Scaler_DispSetInputInfo(SLR_INPUT_POLARITY, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_POLARITY));
	Scaler_DispSetInputInfo(SLR_INPUT_H_FREQ, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_H_FREQ));
	Scaler_DispSetInputInfo(SLR_INPUT_V_FREQ, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ));
	Scaler_DispSetInputInfo(SLR_INPUT_H_LEN, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_H_LEN));
	Scaler_DispSetInputInfo(SLR_INPUT_V_LEN, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_LEN));
	Scaler_DispSetInputInfo(SLR_INPUT_H_COUNT, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_H_COUNT));
	Scaler_DispSetInputInfo(SLR_INPUT_V_COUNT, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_COUNT));
	//Scaler_DispSetInputInfo(SLR_INPUT_IHSYNCPULSECOUNT, VFEDispInfo->IHSyncPulseCount);

	Scaler_DispSetInputInfo(SLR_INPUT_COLOR_SPACE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_SPACE));
	Scaler_DispSetInputInfo(SLR_INPUT_COLOR_DEPTH, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_DEPTH));
	Scaler_DispSetInputInfo(SLR_INPUT_COLOR_IMETRY, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_IMETRY));

	Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_422, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422));
	Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_INTERLACE, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE));
	//Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY),SLR_DISP_INTERLACE,FALSE);

#if 0//frank@20141103 mark below code to reduce time
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_ADC_CLOCK:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_ADC_CLOCK));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_IPV_ACT_LEN_PRE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN_PRE));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_IPV_ACT_STA_PRE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_STA_PRE));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_IPH_ACT_WID_PRE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_IPH_ACT_STA_PRE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_STA_PRE));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_HSYNC:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_HSYNC));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_VSYNC:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_VSYNC));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_MODE_CURR:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_MODE_TABLE_INDEX:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_MODE_TABLE_INDEX));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_AFD:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_AFD));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_POLARITY:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_POLARITY));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_H_FREQ:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_H_FREQ));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_V_FREQ:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_H_LEN:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_H_LEN));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_V_LEN:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_LEN));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_H_COUNT:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_H_COUNT));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_V_COUNT:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_COUNT));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_IHSYNCPULSECOUNT:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_IHSYNCPULSECOUNT));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_COLOR_SPACE:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_COLOR_SPACE));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_COLOR_DEPTH:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_COLOR_DEPTH));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_COLOR_IMETRY:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_COLOR_IMETRY));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC timing info from VFE:SLR_DISP_422:%d\n", Scaler_DispGetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_422));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC timing info from VFE:SLR_DISP_INTERLACE:%d\n", Scaler_DispGetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_INTERLACE));
#endif
}

void Scaler_SET_VSCDispinfo_WithVFEHMDIHDR( vfe_hdmi_timing_info_t vfehdmitiminginfo)
{
	//Scaler_DispSetInputInfo(SLR_INPUT_ADC_CLOCK, VFEDispInfo->INPUT_ADC_CLOCK);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE, vfehdmitiminginfo.active.h);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_STA_PRE, vfehdmitiminginfo.active.y+vfehdmitiminginfo.y_offset);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE, vfehdmitiminginfo.active.w);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_STA_PRE, vfehdmitiminginfo.active.x+vfehdmitiminginfo.x_offset);

	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_HSYNC, vfehdmitiminginfo.hsync);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_VSYNC, vfehdmitiminginfo.vsync);

	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_CURR, vfehdmitiminginfo.mode_id);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_TABLE_INDEX, vfehdmitiminginfo.mode_table_index);

	//Scaler_DispSetInputInfo(SLR_INPUT_AFD, VFEDispInfo->afd);

	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_POLARITY, vfehdmitiminginfo.polarity);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_H_FREQ, vfehdmitiminginfo.h_freq);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ, vfehdmitiminginfo.v_freq);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_H_LEN, vfehdmitiminginfo.h_total);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_LEN, vfehdmitiminginfo.v_total);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_H_COUNT, vfehdmitiminginfo.h_total);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_COUNT, vfehdmitiminginfo.v_total);
	//Scaler_DispSetInputInfo(SLR_INPUT_IHSYNCPULSECOUNT, VFEDispInfo->IHSyncPulseCount);

	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_SPACE, vfehdmitiminginfo.color_space);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_DEPTH, vfehdmitiminginfo.color_depth);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_IMETRY, vfehdmitiminginfo.color_imetry);

	Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422, (vfehdmitiminginfo.color_space == VFE_HDMI_COLOR_YUV422) ? 1 : 0);
	Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE,  (!vfehdmitiminginfo.scan_type));
	//Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_INTERLACE,FALSE);

#if 0//frank@20141103 mark below code to reduce time
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_ADC_CLOCK:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_ADC_CLOCK));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_IPV_ACT_LEN_PRE:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_IPV_ACT_STA_PRE:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_STA_PRE));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_IPH_ACT_WID_PRE:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_IPH_ACT_STA_PRE:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_STA_PRE));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_HSYNC:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_HSYNC));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_VSYNC:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_VSYNC));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_MODE_CURR:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_CURR));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_MODE_TABLE_INDEX:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_TABLE_INDEX));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_AFD:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_AFD));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_POLARITY:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_POLARITY));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_H_FREQ:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_H_FREQ));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_V_FREQ:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_H_LEN:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_H_LEN));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_V_LEN:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_LEN));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_H_COUNT:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_H_COUNT));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_V_COUNT:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_COUNT));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_IHSYNCPULSECOUNT:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IHSYNCPULSECOUNT));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_COLOR_SPACE:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_SPACE));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_COLOR_DEPTH:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_DEPTH));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_INPUT_COLOR_IMETRY:%d\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_COLOR_IMETRY));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_DISP_422:%d\n", Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "VSC timing info from VFE:SLR_DISP_INTERLACE:%d\n", Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE));
#endif
}

unsigned char VSC_Check_Signal_Lock(unsigned char display)
{
	VSC_INPUT_TYPE_T src_type;
	unsigned char port;
#ifndef CONFIG_DUAL_CHANNEL
	display = SLR_MAIN_DISPLAY;
	if(DisplayModeInputInfo.type != VSC_INPUTSRC_MAXN) {
		src_type = DisplayModeInputInfo.type;
		port = DisplayModeInputInfo.resourceIndex;
	} else if (VencModeInputInfo.type != VSC_INPUTSRC_MAXN) {
		src_type = VencModeInputInfo.type;
		port = VencModeInputInfo.resourceIndex;
	} else if (MemoryModeInputInfo.type != VSC_INPUTSRC_MAXN) {
		src_type =  MemoryModeInputInfo.type;
		port = MemoryModeInputInfo.resourceIndex;
	} else if (AveModeInputInfo.type != VSC_INPUTSRC_MAXN) {
		src_type = AveModeInputInfo.type;
		port = AveModeInputInfo.resourceIndex;
	} else {
		src_type = DisplayModeInputInfo.type;
		port = DisplayModeInputInfo.resourceIndex;
	}
#else
	if (display == SLR_MAIN_DISPLAY)
	{
		if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
			src_type = DisplayModeInputInfo.type;
			port = DisplayModeInputInfo.resourceIndex;
		} else if (VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
			src_type = VencModeInputInfo.type;
			port = VencModeInputInfo.resourceIndex;
		} else if (MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
			src_type =	MemoryModeInputInfo.type;
			port = MemoryModeInputInfo.resourceIndex;
		} else if (AveModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
			src_type = AveModeInputInfo.type;
			port = AveModeInputInfo.resourceIndex;
		} else {
			src_type = DisplayModeInputInfo.type;
			port = DisplayModeInputInfo.resourceIndex;
		}
	}
	else
	{
		if(Sub_DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
			src_type = Sub_DisplayModeInputInfo.type;
			port = Sub_DisplayModeInputInfo.resourceIndex;
		} else if (Sub_VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
			src_type = Sub_VencModeInputInfo.type;
			port = Sub_VencModeInputInfo.resourceIndex;
		} else if (Sub_MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
			src_type =  Sub_MemoryModeInputInfo.type;
			port = Sub_MemoryModeInputInfo.resourceIndex;
		} else if (Sub_AveModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN) {
			src_type = Sub_AveModeInputInfo.type;
			port = Sub_AveModeInputInfo.resourceIndex;
		} else {
			src_type = Sub_DisplayModeInputInfo.type;
			port = Sub_DisplayModeInputInfo.resourceIndex;
		}
	}
#endif

	switch(src_type)
	{
		case KADP_VSC_INPUTSRC_ADC:
		case KADP_VSC_INPUTSRC_AVD:
		case KADP_VSC_INPUTSRC_HDMI:
			 if((Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) && drvif_mode_check_onlinemeasure_status(display))
			 	return TRUE;
			 else
			 	return FALSE;

		case VSC_INPUTSRC_VDEC:
		case VSC_INPUTSRC_JPEG:
			if(get_vo_change_flag(port) == FALSE && Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
			{
				return TRUE;
			}
			else
			{
				return FALSE;
			}

		default:
			return FALSE;

	}
}
unsigned char Scaler_get_data_framesync(unsigned char display)
{
	unsigned int len_temp=Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_IPV_ACT_LEN_PRE);
	SLR_VOINFO *pVOInfo = Scaler_VOInfoPointer(Scaler_Get_CurVoInfo_plane());
	VSC_INPUT_TYPE_T srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
	if (Scaler_InputSrcGetType(display)==_SRC_VO) {
		if((pVOInfo == NULL) ||(pVOInfo->src_v_len ==0))
		{
			pr_emerg("Scaler_get_data_framesync get vo timinginfo error\n");

		} else {
			len_temp = pVOInfo->src_v_len;
		}
	}
	if (display == SLR_MAIN_DISPLAY) {
#ifdef ENABLE_VR360_DATA_FS_FLOW
		if(get_vt_EnableFRCMode() == FALSE){
			//Enter VR360 Data Fs Mode
			INPUT_TIMING_INDEX index = get_current_pattern_index();
			if(index == VO_4K2K_60){
				rtd_printk(KERN_NOTICE, TAG_NAME_VSC," vr360 go data fs\n");
				return TRUE;
			}
		}
#endif

#ifdef CONFIG_MEMC_BYPASS
		if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_PIXEL_MODE) == PIXEL_MODE_2_PIXEL){
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "[CONFIG_MEMC_BYPASS][2 pixel] go data FRC@%d\n", __LINE__);
			return FALSE;
		}
#endif
		if (get_current_driver_pattern(DRIVER_FREERUN_PATTERN) == 1) {
			if ((srctype != VSC_INPUTSRC_VDEC) && (srctype != VSC_INPUTSRC_JPEG) && (Scaler_InputSrcGetType(display)!=_SRC_VO)) {
				pr_notice("==== External src GO data frc ====\n");
				return FALSE;
			}
			if (Get_rotate_function() && (get_rotate_mode()!=(DIRECT_VO_FRAME_ORIENTATION)ROTATE_MODE_0)) {
				pr_notice("====rotate go data frc ====\n");
				return FALSE;
			}
	#ifndef ENABLE_VBY1_TO_HDMI_4K2K_DATA_FS
			if (Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_HDMI ||
				Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_LVDS_TO_HDMI ||
		    		Get_DISPLAY_PANEL_TYPE() == P_LVDS_TO_HDMI) {
		    		pr_notice("====converter hdmi board go data frc ====\n");
				return FALSE;
			}
	#endif

			if (Scaler_DispGetStatus(display,SLR_DISP_INTERLACE)) {
				len_temp = len_temp *2;
			}
		#if 0
			if (vsc_get_adaptivestream_flag()) {
				if (Scaler_DispWindowGet().src_height < (_DISP_LEN)) {
					return FALSE;
				} else
				{
					return TRUE;
				}
			} else
		#endif
			{
			//	if (scaler_vsc_get_adaptive_pst_lowdelay_mode()) {
			//		pr_notice("====pst lowdelay mode go data frc====\n");
			//		return FALSE;
			//	}
				if (Scaler_DispWindowGet().src_height <  (_DISP_LEN-20)) {// && Scaler_DispWindowGet().src_height <  len_temp) {
					pr_notice("====display len<source go data frc====\n");
					return FALSE;
				} else if (vsc_get_adaptivestream_flag(display) && (pVOInfo->progressive== 0)) {
					pr_notice("  adaptive interlace go data frc====\n");
					return FALSE;
				} else if (scaler_vsc_get_gamemode_force_framerate_lowdelay_mode()){
					pr_notice("  game mode force framerate go data frc====\n");
					return FALSE;
				} else {
					pr_notice("====display len>=source or full size go data fs====\n");
					return TRUE;
				}
			}
		} else {
			if(vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY) && pVOInfo->is2KCP)
				pr_notice("====cp 2k timing run data frc====\n");
			return FALSE;
		}
	} else {
		return FALSE;
	}
}

unsigned char get_displayinfo_proc(unsigned char display, VSC_INPUT_TYPE_T inputSrctype)//This is for driver base implement open source
{
	unsigned int *p_sourceID = NULL;
//	SLR_VOINFO* pVOInfo;
	extern UINT8 TV006_WB_Pattern_En;
	extern unsigned int get_current_driver_pattern(DRIVER_LIST_INFO info);
	SLR_VOINFO* pVOInfo = Scaler_VOInfoPointer(Scaler_Get_CurVoInfo_plane());

	if(display == SLR_SUB_DISPLAY) {
		p_sourceID = &DbgSclrFlgTkr.sub_opensourceID;
	} else {
		p_sourceID = &DbgSclrFlgTkr.main_opensourceID;
	}
#ifdef CONFIG_FORCE_RUN_I3DDMA
	if(
		((inputSrctype != VSC_INPUTSRC_VDEC) && (inputSrctype != VSC_INPUTSRC_JPEG) && (display == SLR_MAIN_DISPLAY) && (get_hdmi_4k_hfr_mode() != HDMI_4K120_2_1) &&
		((get_line_alternative_3d_mode_enable() == TRUE)
		#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
			|| (Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT)
		#endif
			|| get_force_i3ddma_enable(SLR_MAIN_DISPLAY))) /*&& inputSrctype == KADP_VSC_INPUTSRC_HDMI*/
#ifdef CONFIG_I2RND_ENABLE
			|| ((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC))
#endif
	)
	{

//		fw_scaler_set_vgip(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL),VGIP_SRC_VODMA1, VGIP_MODE_ANALOG);
		fw_scaler_set_vgip(display, VGIP_SRC_VODMA1, VGIP_MODE_ANALOG);

		if(get_force_i3ddma_enable(display) &&
			((inputSrctype != VSC_INPUTSRC_HDMI) || (get_HDMI_HDR_mode() == HDR_MODE_DISABLE))
		)
		{
			//drvif_mode_enable_dma_onlinemeasure();
		}
	}
	else if(inputSrctype == VSC_INPUTSRC_ADC)//ypp,VGA
#else
	if(inputSrctype == VSC_INPUTSRC_ADC)//ypp,VGA
#endif
	{
		if(ADC_Check_VSC_VFE_ConnectSrc_Match(*p_sourceID) == FALSE)
		{
			return FALSE;
		}
		down(get_adc_detectsemaphore());
		Scaler_SET_VSCDispinfo_WithVFEDispinfo(display, Get_ADC_Dispinfo());//now for test, only for ypp timing info
		if(vsc_timinginfo_check() == FALSE)
		{
			up(get_adc_detectsemaphore());
			rtd_printk(KERN_ERR, TAG_NAME_VSC,"#####[%s(%d)] adc vsc_timinginfo_check no signal error\n",__func__,__LINE__);
			return FALSE;
		}
		if(Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) > 2000)//mean 4095 no support
		{
			up(get_adc_detectsemaphore());
			rtd_printk(KERN_ERR, TAG_NAME_VSC,"#####[%s(%d)] adc vsc_timinginfo_check no support error\n",__func__,__LINE__);
			return FALSE;
		}
		ADC_set_detect_flag(FALSE);
		up(get_adc_detectsemaphore());

		// Scart RGB
		if(get_ADC_Input_Source() == _SRC_SCART_RGB)
		{
//			fw_scaler_set_vgip(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), VGIP_SRC_ATV, VGIP_MODE_ANALOG);
			fw_scaler_set_vgip(display, VGIP_SRC_ATV, VGIP_MODE_ANALOG);
		}
		// YPP and VGA
		else
		{
//			fw_scaler_set_vgip(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), VGIP_SRC_ADC, VGIP_MODE_ANALOG);
			fw_scaler_set_vgip(display, VGIP_SRC_ADC, VGIP_MODE_ANALOG);
//			fw_scaler_set_sample(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), _ENABLE);
			fw_scaler_set_sample(display, _ENABLE);
		}

		rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"#####[%s(%d)] call ADC_VSC_Setting\n",__func__,__LINE__);
		ADC_VSC_Setting(get_ADC_Input_Source());
		fw_scaler_adc_nolock_wdg_ctrl(display, FALSE);//Disable adc_nolock_wdg
		drvif_mode_enableonlinemeasure(display);//Enable online measure
#ifdef CONFIG_SUPPORT_SRC_VGA
		if(get_ADC_Input_Source() == _SRC_VGA){
			if(drvif_mode_online_result_check(Get_ADC_Dispinfo()) == false){
				reset_adc_timing_ready();
				ADC_OnlineMeasureError_Handler(get_ADC_Input_Source());
				return FALSE;
			}
		}
#endif
	}
	else if(inputSrctype == VSC_INPUTSRC_AVD)
	{
		down(get_vdc_detectsemaphore());
		Scaler_SET_VSCDispinfo_WithVFEDispinfo(display, Get_AVD_ScalerDispinfo());
		if(vsc_timinginfo_check() == FALSE)
		{
			up(get_vdc_detectsemaphore());
			return FALSE;
		}
		//VDC_set_detect_flag(FALSE);//Will temp add. Need to check.
		up(get_vdc_detectsemaphore());
//		fw_scaler_set_vgip(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), VGIP_SRC_ATV, VGIP_MODE_ANALOG);
		fw_scaler_set_vgip(display, VGIP_SRC_ATV, VGIP_MODE_ANALOG);
		drvif_mode_enableonlinemeasure(display);//Enable online measure
	}
#if 0//defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
	else if(((get_line_alternative_3d_mode_enable() == TRUE) || (Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT)) && inputSrctype == VSC_INPUTSRC_HDMI)
	{

		if ((Get_Live_zoom_mode() == LIVE_ZOOM_ON) && (display == SLR_SUB_DISPLAY)) {
			/*qiangzhou:hdmi hdr source should support livezoom , sub should run ormal*/
			drvif_mode_disableonlinemeasure(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
		} else {
			//USER:Lewislee DATE:2015/09/29
			//PIP no 3D
			if(SLR_SUB_DISPLAY == display)
			{
				return FALSE;
			}
			else if(get_line_alternative_3d_mode_enable() == TRUE)
			{
				if((TRUE == DbgSclrFlgTkr.Sub_OuputDisplayMode) || (TRUE == DbgSclrFlgTkr.Sub_OutputVencMode) || (TRUE == DbgSclrFlgTkr.Sub_OutputMemoryMode) || (TRUE == DbgSclrFlgTkr.Sub_OutputAveMode))
					return FALSE;
			}
		}

//		fw_scaler_set_vgip(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL),VGIP_SRC_VODMA1, VGIP_MODE_ANALOG);
		fw_scaler_set_vgip(display, VGIP_SRC_VODMA1, VGIP_MODE_ANALOG);
	}
#endif
	else if(inputSrctype == VSC_INPUTSRC_HDMI)
	{
		if ((Get_Live_zoom_mode() == LIVE_ZOOM_ON) && (display == SLR_SUB_DISPLAY))
		{
			//tmp code
			Scaler_SET_VSCSubDispinfo_Withmain();
//			fw_scaler_set_vgip(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), VGIP_SRC_TMDS, VGIP_MODE_ANALOG);
			fw_scaler_set_vgip(display, VGIP_SRC_TMDS, VGIP_MODE_ANALOG);
			drvif_mode_disableonlinemeasure(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
		} else {
			vfe_hdmi_timing_info_t vfehdmitiminginfo;
			down(get_hdmi_detectsemaphore());
			if(0 != vfe_hdmi_drv_get_display_timing_info(&vfehdmitiminginfo, display))
			{
				up(get_hdmi_detectsemaphore());
				return FALSE;
			}
			Scaler_SET_VSCDispinfo_WithVFEHMDI(display, vfehdmitiminginfo);

			if(get_field_alternative_3d_mode_enable() == TRUE)
			{
				//USER:Lewislee DATE:2015/09/29
				//PIP no 3D
				if(SLR_SUB_DISPLAY == display)
				{
					up(get_hdmi_detectsemaphore());
					return FALSE;
				}
				else// if(SLR_MAIN_DISPLAY == display)
				{
					if((TRUE == DbgSclrFlgTkr.Sub_OuputDisplayMode) || (TRUE == DbgSclrFlgTkr.Sub_OutputVencMode) || (TRUE == DbgSclrFlgTkr.Sub_OutputMemoryMode) || (TRUE == DbgSclrFlgTkr.Sub_OutputAveMode))
					{
						up(get_hdmi_detectsemaphore());
						return FALSE;
					}
				}

//				Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_INTERLACE, TRUE);
				Scaler_DispSetStatus(display, SLR_DISP_INTERLACE, TRUE);
			}
			if(vsc_timinginfo_check() == FALSE)
			{
				up(get_hdmi_detectsemaphore());
				return FALSE;
			}

			HDMI_set_detect_flag(FALSE);
			if(display == SLR_MAIN_DISPLAY)
			{
				if(get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1)
				{//enable hdmi two pixel mode
					drvif_Hdmi_SetClkPixelMode(1);
				}
				else
				{//disable hdmi two pixel mode
					drvif_Hdmi_SetClkPixelMode(0);
				}
			}
			up(get_hdmi_detectsemaphore());
			if(Get_PANEL_3D_DISPLAY_SUPPORT_ENABLE() && drvif_scaler3d_decide_HDMI_framePacking_auto_status(display))
			{
				modestate_HDMI_3D_format_auto_detection(display);

				//USER:Lewislee DATE:2015/09/29
				//PIP no 3D
				if(SLR_SUB_DISPLAY == display)
				{
					if(SLR_3DMODE_3D_AUTO == Scaler_Get3DMode(SLR_SUB_DISPLAY))
					{
						if(Scaler_Disp3dGetInfo((SCALER_DISP_CHANNEL)display, SLR_DISP_3D_3DTYPE) >= HDMI3D_2D_ONLY)
						{
							//bypass
						}
						else
						{
//							up(get_hdmi_detectsemaphore());
							return FALSE;
						}
					}
				}
				else// if(SLR_MAIN_DISPLAY == display)
				{
					if((TRUE == DbgSclrFlgTkr.Sub_OuputDisplayMode) || (TRUE == DbgSclrFlgTkr.Sub_OutputVencMode) || (TRUE == DbgSclrFlgTkr.Sub_OutputMemoryMode) || (TRUE == DbgSclrFlgTkr.Sub_OutputAveMode))
					{
						if(SLR_3DMODE_3D_AUTO == Scaler_Get3DMode(SLR_MAIN_DISPLAY))
						{
							if(Scaler_Disp3dGetInfo((SCALER_DISP_CHANNEL)display, SLR_DISP_3D_3DTYPE) >= HDMI3D_2D_ONLY)
							{
								//bypass
							}
							else
							{
//								up(get_hdmi_detectsemaphore());
								return FALSE;
							}
						}
					}
				}
			}
			fw_scaler_set_vgip(display, ((display == SLR_MAIN_DISPLAY) && (get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1))? VGIP_SRC_VODMA1 : VGIP_SRC_TMDS, VGIP_MODE_ANALOG);
			drvif_mode_enableonlinemeasure(display);//Enable online measure
		}
	}
	else if((inputSrctype == VSC_INPUTSRC_VDEC) || (inputSrctype == VSC_INPUTSRC_JPEG)) {

		if (Scaler_Get_CurVoInfo_VoVideoPlane(display) == VO_VIDEO_PLANE_V2)
			fw_scaler_set_vgip(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL),VGIP_SRC_VODMA2, VGIP_MODE_ANALOG);
		else
			fw_scaler_set_vgip(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL),VGIP_SRC_VODMA1, VGIP_MODE_ANALOG);
	} else {
		return FALSE;
	}

#ifdef SPEEDUP_NEW_SCALER_FLOW
	if(((inputSrctype == VSC_INPUTSRC_ADC) || (inputSrctype == VSC_INPUTSRC_HDMI) || (inputSrctype == VSC_INPUTSRC_VDEC) || (inputSrctype == VSC_INPUTSRC_JPEG) ||
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
		(inputSrctype == VSC_INPUTSRC_AVD)
#else
		((inputSrctype == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() != _SRC_TV))
#endif
		)

	//sub re-run main case, no need to check main arc @Crixus 20180112
#ifdef CONFIG_I2RND_ENABLE
	&& !((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && ((vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC) || (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1)))
#endif
	)
	{
		if(display == SLR_MAIN_DISPLAY)
		{//active state mean already run scaler
			check_ARC_status(display, inputSrctype);
		}
	}
#endif

#ifdef CONFIG_FORCE_RUN_I3DDMA
	if((((inputSrctype == VSC_INPUTSRC_VDEC)||(inputSrctype == VSC_INPUTSRC_JPEG) ||(get_line_alternative_3d_mode_enable() == TRUE)
		#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
		|| (Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT)
		#endif
		|| get_force_i3ddma_enable(display))&&(SLR_MAIN_DISPLAY == display))
#ifdef CONFIG_I2RND_ENABLE
		||((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC))
#endif
		)
#else
	if(((inputSrctype == VSC_INPUTSRC_VDEC)||(inputSrctype == VSC_INPUTSRC_JPEG) ||(get_line_alternative_3d_mode_enable() == TRUE)
		#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
		|| (Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT)
		#endif
		)&&(SLR_MAIN_DISPLAY == display))
#endif
	{
		//unsigned char smooth_toggle_mode=SLR_DISPLAY_DEFAULT;
		unsigned char plane=Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_VODMA_PLANE);
		if (Scaler_get_data_framesync(display)) {
			Scaler_DispSetInputInfo(SLR_INPUT_FRAMESYNC, TRUE);
		} else {
			Scaler_DispSetInputInfo(SLR_INPUT_FRAMESYNC, FALSE);
		}
        if ((get_current_driver_pattern(DRIVER_FREERUN_PATTERN) == 1) && (inputSrctype == VSC_INPUTSRC_VDEC))
            scaler_SendDispSize(Scaler_DispWindowGet());
		rtd_printk(KERN_EMERG, TAG_NAME_VSC, "data FS/FRC@%d\n", Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC));
		plane = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_VODMA_PLANE);
		if (inputSrctype == VSC_INPUTSRC_VDEC) {
			if (get_vo_open_smooth_toggle_enable(display) && (!Get_vo_smoothtoggle_timingchange_flag(display))
				/*pause-open livezoom could not close di,so livezoom case not run here*/
				&&(Get_Live_zoom_mode() == LIVE_ZOOM_OFF)
				&&(Get_LivezoomOffMainRunScaler() == FALSE)
				&&((get_rotate_mode()==get_ori_rotate_mode())|| (get_ori_rotate_mode()==DIRECT_VO_FRAME_ORIENTATION_DEFAULT))
				/*&& (display == SLR_MAIN_DISPLAY)*/) {
					Set_direct_vo_smoothtoggle_enable(1, /*smooth_toggle_mode,*/ display,plane); //open smooth toggle go data frc
			} else if (Get_vo_smoothtoggle_timingchange_flag(display)) {
				set_vo_smoothtoggle_state(SLR_SMOOTH_TOGGLE_INIT, display,plane);
				//vo_force_data_mode_set_enable(smooth_toggle_mode, display);
			} else if(vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY)){
				Set_direct_vo_smoothtoggle_enable(1, /*smooth_toggle_mode,*/ display,plane); //open smooth toggle go data frc
			}
		}

	#if 1
		if(get_3D_mode_enable() == TRUE)
		{
			if(get_vo_3d_mode() == VO_3D_SIDE_BY_SIDE_HALF )
			{
				Scaler_Disp3dSetInfo((SCALER_DISP_CHANNEL)display, SLR_DISP_3D_3DTYPE, SLR_3D_SIDE_BY_SIDE_HALF);
				Scaler_Set3DMode_Attr((SCALER_DISP_CHANNEL)display, SLR_3DMODE_3D_SBS);
			}
			else if(get_vo_3d_mode() == VO_3D_TOP_AND_BOTTOM)
			{
				Scaler_Disp3dSetInfo((SCALER_DISP_CHANNEL)display, SLR_DISP_3D_3DTYPE, SLR_3D_TOP_AND_BOTTOM);
				Scaler_Set3DMode_Attr((SCALER_DISP_CHANNEL)display, SLR_3DMODE_3D_TB);
			}
			else if(get_vo_3d_mode() == VO_3D_FRAME_PACKING)
			{
				Scaler_Disp3dSetInfo((SCALER_DISP_CHANNEL)display, SLR_DISP_3D_3DTYPE, SLR_3D_FRAME_PACKING);
				Scaler_Set3DMode_Attr((SCALER_DISP_CHANNEL)display, SLR_3DMODE_3D_FP);
			}
		}
		else
		{
			Scaler_Disp3dSetInfo((SCALER_DISP_CHANNEL)display, SLR_DISP_3D_3DTYPE,SLR_3D_2D_ONLY);
			Scaler_Set3DMode_Attr((SCALER_DISP_CHANNEL)display, SLR_3DMODE_2D);
		}
	#endif
	}
	else if(SLR_SUB_DISPLAY == display)
	{
		Scaler_DispSetInputInfo(SLR_INPUT_FRAMESYNC, FALSE);
		if (inputSrctype == VSC_INPUTSRC_VDEC) {
			unsigned char plane=Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_VODMA_PLANE);
			if (get_vo_open_smooth_toggle_enable(display) && (!Get_vo_smoothtoggle_timingchange_flag(display))
				/*pause-open livezoom could not close di,so livezoom case not run here*/
				&&(Get_Live_zoom_mode() == LIVE_ZOOM_OFF)
				&&(Get_LivezoomOffMainRunScaler() == FALSE)
				&&((get_rotate_mode()==get_ori_rotate_mode())|| (get_ori_rotate_mode()==DIRECT_VO_FRAME_ORIENTATION_DEFAULT))
				/*&& (display == SLR_MAIN_DISPLAY)*/) {
					Set_direct_vo_smoothtoggle_enable(1, /*smooth_toggle_mode,*/ display,plane); //open smooth toggle go data frc
			} else if (Get_vo_smoothtoggle_timingchange_flag(display)) {
				set_vo_smoothtoggle_state(SLR_SMOOTH_TOGGLE_INIT, display,plane);
				//vo_force_data_mode_set_enable(smooth_toggle_mode, display);
			} else if(vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY)){
				Set_direct_vo_smoothtoggle_enable(1, /*smooth_toggle_mode,*/ display,plane); //open smooth toggle go data frc
			}
		}
	}
	else
	{
		Scaler_DispSetInputInfo(SLR_INPUT_FRAMESYNC, FALSE);
		//vo_force_data_mode_set_enable(SLR_DISPLAY_DATA_FRC, display);
	}

	if(get_hdmi_4k_hfr_mode() != HDMI_NON_4K120)
	{//hmdi 4k2k 120 application force go data frc
		Scaler_DispSetInputInfo(SLR_INPUT_FRAMESYNC, FALSE);
	}
    else if((Get_DISPLAY_REFRESH_RATE() == 120) && (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && (vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag()))
    {
        //hmdi 4k2k 120 vrr/freesync go data frc
        Scaler_DispSetInputInfo(SLR_INPUT_FRAMESYNC, FALSE);
    }

		//Scaler_DispSetInputInfo(SLR_INPUT_FRAMESYNC, FALSE);//temp to go data frc. sync is not ready



#ifdef CONFIG_FORCE_RUN_I3DDMA
	if((inputSrctype == VSC_INPUTSRC_VDEC) || (inputSrctype == VSC_INPUTSRC_JPEG) || (get_line_alternative_3d_mode_enable() == TRUE)
		#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
		|| (Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT)
		#endif
		|| get_force_i3ddma_enable(display)
#ifdef CONFIG_I2RND_ENABLE
		|| ((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC))
#endif
		)
#else
	if((inputSrctype == VSC_INPUTSRC_VDEC) || (inputSrctype == VSC_INPUTSRC_JPEG) || (get_line_alternative_3d_mode_enable() == TRUE)
		#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
		|| (Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT)
		#endif
		)
#endif
	{
		Scaler_DispSetStatus(display, SLR_DISP_VFLIP3, FALSE);

	}
	else
	{
		if (Get_PANEL_VFLIP_ENABLE())
			Scaler_DispSetStatus(display, SLR_DISP_VFLIP3, TRUE);
		else
			Scaler_DispSetStatus(display, SLR_DISP_VFLIP3, FALSE);
	}

	set_default_mcap_format(display, inputSrctype);//Set default m cap 422 or 444

	#ifdef HDMI_NO_PQDC_TEST
		set_vsc_run_pc_mode(TRUE);
		printk(KERN_EMERG" HDMI_NO_PQDC_TEST  set_vsc_run_pc_mode(TRUE);\n");
	#endif

	if ((get_sub_OutputVencMode() && (display == SLR_SUB_DISPLAY)) || (get_main_OutputVencMode() && (display == SLR_MAIN_DISPLAY)) || (Get_Live_zoom_mode() == LIVE_ZOOM_ON)) {
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n######DbgSclrFlgTkr.OutputVencMode force to 422capture######\r\n");
		Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);
#if 1
		if((Get_Live_zoom_mode() == LIVE_ZOOM_ON)&&(display == SLR_MAIN_DISPLAY)){
			if (DbgSclrFlgTkr.RGB444Mode == TRUE)
				set_LiveZoomPcmodeDiableRTNR(TRUE);
			else
				set_LiveZoomPcmodeDiableRTNR(FALSE);
		}
#endif
	} else if((get_vsc_run_pc_mode() == TRUE) && ((inputSrctype == VSC_INPUTSRC_ADC) || (inputSrctype == VSC_INPUTSRC_HDMI) || (inputSrctype == VSC_INPUTSRC_JPEG))) {
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n######get_vsc_run_pc_mode() is true force to 444capture######\r\n");
		if(display == SLR_SUB_DISPLAY)
			Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);//sub only run 422 format
		else
			Scaler_DispSetStatus(display, SLR_DISP_422CAP, FALSE);
	}

	if(Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC)) {
#ifdef CONFIG_DATA_FRAMESYNC_FORCE_422_CAP
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n######framesync is true force to 422capture######\r\n");
		Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);
#else
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n######framesync is true force to 444capture######\r\n");
		Scaler_DispSetStatus(display, SLR_DISP_422CAP, FALSE);
#endif
	} else if(get_3D_overscan_enable()) {
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n######get_3D_overscan_enable is true force to 444capture######\r\n");
		Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);
	}
	if((display == SLR_MAIN_DISPLAY) && pc_mode_run_444() && (inputSrctype == VSC_INPUTSRC_HDMI))
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n######RGB444 PC mode force to 444capture######\r\n");
		Scaler_DispSetStatus(display, SLR_DISP_422CAP, FALSE);
	}
#ifdef FORCE_BYPASS_DI_RTNR
//Debug use. Interlace timing don't go rtnr and DI
	if(display == SLR_MAIN_DISPLAY)
		Scaler_DispSetStatus(display, SLR_DISP_INTERLACE, FALSE);//force to set no interlace
#endif

	if (TV006_WB_Pattern_En == 0)
		IoReg_ClearBits(SCALEUP_D_UZU_Globle_Ctrl_reg, _BIT0|_BIT1);//clear uzu pattern gen
	// FixMe
	//Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL),SLR_DISP_10BIT,FALSE);//let all source go 10bit mode
#if 1
	if ((Get_Live_zoom_mode() == LIVE_ZOOM_ON)&& (display == SLR_MAIN_DISPLAY)) {
		Scaler_DispSetStatus(display, SLR_DISP_10BIT, FALSE);
	}else
#endif
	if((Scaler_InputSrcGetMainChType() == _SRC_VO) && (get_vo_vp9_flag(Get_DisplayMode_Port(display)))) {
		Scaler_DispSetStatus(display, SLR_DISP_10BIT, FALSE);//VP9 case use 8 bits setting @ Crixus 20160407
#ifdef CONFIG_I2RND_ENABLE
	}else if((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)){
		Scaler_DispSetStatus(display, SLR_DISP_10BIT, FALSE);
#endif
	} else if (display == SLR_MAIN_DISPLAY) {
		Scaler_DispSetStatus(display, SLR_DISP_10BIT, TRUE);//let all source go 10bit mode
	} else if(display == SLR_SUB_DISPLAY) {
		Scaler_DispSetStatus(display, SLR_DISP_10BIT, TRUE);// sub go 10 bit
	}

	if (display == SLR_MAIN_DISPLAY)
	{
#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
		if (TRUE == Get_rotate_function())
			Scaler_DispSetStatus(display, SLR_DISP_10BIT, FALSE);
#endif
		if(Get_Factory_SelfDiagnosis_Mode() == TRUE)
			Scaler_DispSetStatus(display, SLR_DISP_10BIT, FALSE);
	}

	//Eric@20181016 check direct vdec low latency mode
	if((inputSrctype == VSC_INPUTSRC_VDEC)&&(SLR_MAIN_DISPLAY == display) && vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY) && (pVOInfo->lowdelay == _ENABLE)){
		drv_memory_set_vdec_direct_low_latency_mode(_ENABLE);
		printk(KERN_EMERG"[vo low delay][%s]enable vdec direct low delay mode\n", __FUNCTION__);
	}
	else{
		drv_memory_set_vdec_direct_low_latency_mode(_DISABLE);
		printk(KERN_EMERG"[vo low delay][%s]Disable vdec direct low delay mode\n", __FUNCTION__);
				pr_notice("[%s][%d][LowDelayMode]", __FUNCTION__, __LINE__);
		vpq_memc_set_lowDelayMode(_DISABLE);	//reset MEMC low delay mode
	}

	if((inputSrctype == VSC_INPUTSRC_VDEC)&&(SLR_MAIN_DISPLAY == display) && !vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY))
		drvif_Hdmi_OutputDisable(1); //willychou fixed KTASKWBS-9866

#ifdef CONFIG_COMPRESSION_MODE_TEST
	if(SLR_SUB_DISPLAY == display)
	{
		if(get_sub_OutputVencMode())
		{
			dvrif_memory_compression_set_enable(SLR_SUB_DISPLAY, FALSE);//disable compress
			Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_10BIT, FALSE);// disable compress sub go 8 bit
		}
		else
		{
			if(get_hdmi_4k_hfr_mode() == HDMI_NON_4K120)
			{
				//sub pqdc setting conflict with main 2step uzu,so go 422 8 bit
				dvrif_memory_compression_set_enable(SLR_SUB_DISPLAY, FALSE);//disable compress
				Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_10BIT, FALSE);// disable compress sub go 8 bit
				Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_422CAP, TRUE);
			}else{
				dvrif_memory_compression_set_enable(SLR_SUB_DISPLAY, TRUE);//enable compress
				dvrif_memory_set_compression_mode(SLR_SUB_DISPLAY, COMPRESSION_FRAME_MODE);
				dvrif_memory_set_compression_bits(SLR_SUB_DISPLAY, COMPRESSION_12_BITS);//444 go 12 bits
				Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_422CAP, FALSE);
			}
		}
	}
	//self-dianosis need disable compression, rzhen@2016-09-01
	else if ((SLR_MAIN_DISPLAY == display)
		&&(Get_Live_zoom_mode() == LIVE_ZOOM_OFF )
		/*&&(drv_memory_get_game_mode() == _DISABLE)*/ //keep compression in game mode @Crixus 20170527
		&&(Get_Factory_SelfDiagnosis_Mode() == FALSE)
#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
		&&(FALSE == Get_rotate_function())
#endif
		)
	{
		#ifdef ENABLE_DE_CONTOUR_I2R // TEST -- de-contour test
            if(rtd_inl(0xb8022288) & _BIT20){
                // IDMA source chroma is 422 (encfmt = 2, 3)
                Scaler_DispSetStatus(display, SLR_DISP_422CAP, VODMA_VODMA_V1CHROMA_FMT_get_encfmt(rtd_inl(VODMA_VODMA_V1CHROMA_FMT_reg)) < 4? TRUE: FALSE);

                printk(KERN_EMERG"[COMP] IDMA source 10bit/emcf=%d/%d\n", VODMA_VODMA_V1_DCFG_get_seq_data_width(rtd_inl(VODMA_VODMA_V1_DCFG_reg)),
                    VODMA_VODMA_V1CHROMA_FMT_get_encfmt(rtd_inl(VODMA_VODMA_V1CHROMA_FMT_reg)));

                dvrif_memory_compression_set_enable(SLR_MAIN_DISPLAY, FALSE);
        	   dvrif_memory_set_compression_mode(SLR_MAIN_DISPLAY, COMPRESSION_NONE_MODE);
            }else
#endif
            {
		//Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);//compress force 422. need to check

		#ifdef HDMI_NO_PQDC_TEST
			printk(KERN_EMERG" HDMI_NO_PQDC_TEST  dvrif_memory_compression_set_enable(SLR_MAIN_DISPLAY, FALSE);\n");
			dvrif_memory_compression_set_enable(SLR_MAIN_DISPLAY, FALSE);
		#else
			dvrif_memory_compression_set_enable(SLR_MAIN_DISPLAY, TRUE);
		#endif

		if((Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422CAP) == FALSE) && (!vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY))) {
			dvrif_memory_set_compression_bits(SLR_MAIN_DISPLAY, COMPRESSION_16_BITS); //K5X M-domain + DI = 51M, so only can use 16bit for PQC //444 go 20 bit for K4 PQC @Crixus 20170718
			//printk(KERN_EMERG"[crixus]M-domain Compression RGB444 20bits Enable!!\n");
		}
		else{
			if(inputSrctype == VSC_INPUTSRC_VDEC){
				dvrif_memory_set_compression_bits(SLR_MAIN_DISPLAY, COMPRESSION_10_BITS);//VDEC go 10 bits @crixus 20170724
			}
			else{
				dvrif_memory_set_compression_bits(SLR_MAIN_DISPLAY, COMPRESSION_12_BITS);//422 go 12 bits
			}
			//printk(KERN_EMERG"[crixus]M-domain Compression Enable!!\n");
		}
		//vflip need to use line mode @Crixus 20171102
		//Eric@20181016 direct vdec low latency mode use compression line mode
		//VRR need to use line mode @ Eric 20181107
		if (Get_PANEL_VFLIP_ENABLE() || drv_memory_get_vdec_direct_low_latency_mode()|| ((vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag()) && (Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC) == FALSE)))
			dvrif_memory_set_compression_mode(SLR_MAIN_DISPLAY, COMPRESSION_LINE_MODE);
		else
			dvrif_memory_set_compression_mode(SLR_MAIN_DISPLAY, COMPRESSION_FRAME_MODE);
	}
		//rtd_printk(KERN_EMERG, TAG_NAME_VSC,"[crixus]M-domain Compression Enable!!\n");
	}
	else
	{
		dvrif_memory_compression_set_enable(SLR_MAIN_DISPLAY, FALSE);

		//rtd_printk(KERN_EMERG, TAG_NAME_VSC,"[crixus]M-domain Compression Disable!!\n");
	}

	if(inputSrctype == VSC_INPUTSRC_HDMI)
	{
		rtd_printk(KERN_EMERG, TAG_NAME_VSC, "###Finally fsync:%d 422:%d comp(%d %d) disp(%d) hfr:%d###\r\n", Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC), Scaler_DispGetStatus(display, SLR_DISP_422CAP), dvrif_memory_compression_get_enable(display), dvrif_memory_get_compression_bits(display), display, get_hdmi_4k_hfr_mode());
	}
	else
	{
		rtd_printk(KERN_EMERG, TAG_NAME_VSC, "###Finally fsync:%d 422:%d comp(%d %d) disp(%d)###\r\n", Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC), Scaler_DispGetStatus(display, SLR_DISP_422CAP), dvrif_memory_compression_get_enable(display), dvrif_memory_get_compression_bits(display), display);
	}
	//re-run sclar flow, reset game mode status.
	if((display == SLR_MAIN_DISPLAY)){
		drv_memory_set_game_mode(_DISABLE);
        DbgSclrFlgTkr.game_mode_rerun_scaler_flag = FALSE;
		game_mode_ignore_cmd_check = _ENABLE;//run scaler case, do not check game mode cmd to reduce the mute time.
		smooth_toggle_game_mode_timeout_trigger_flag = _DISABLE;//reset smooth_toggle_game_mode_timeout_trigger_flag
		game_mode_cmd_pre = game_mode_cmd_check;//update game_mode_cmd_pre
		st_game_mode_cmd_pre = smooth_toggle_game_mode_check_cnt;//update st_game_mode_cmd_pre flag
		set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_GameMode, FALSE);//reset game mode fbg mask
		rtd_printk(KERN_EMERG, TAG_NAME_NEW_GAME_MODE,"reset game mode status when run scaler flow!!\n");

        drv_set_vrr_mode_dynamic(_DISABLE);
		drv_set_vrr_low_delay_mode_dynamic(_DISABLE);
		drv_set_freesync_mode_dynamic(_DISABLE);
    }

	//limit mode setting
	drv_memory_set_limit_boundary_mode(display, _ENABLE);

	if((SLR_MAIN_DISPLAY == display) && (get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1))
	{//copy from main for sub m domain
		dvrif_memory_compression_set_enable(SLR_SUB_DISPLAY, dvrif_memory_compression_get_enable(SLR_MAIN_DISPLAY));
		dvrif_memory_set_compression_bits(SLR_SUB_DISPLAY, dvrif_memory_get_compression_bits(SLR_MAIN_DISPLAY));
		dvrif_memory_set_compression_mode(SLR_SUB_DISPLAY, dvrif_memory_get_compression_mode(SLR_MAIN_DISPLAY));
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_10BIT, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_10BIT));
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_422CAP, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422CAP));
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_VFLIP3, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_VFLIP3));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_FRAMESYNC, 0);
		drv_memory_set_limit_boundary_mode(SLR_SUB_DISPLAY, _ENABLE);
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_V_FREQ, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ));
	}

#ifdef CONFIG_I2RND_ENABLE
	if(Scaler_I2rnd_get_display() == I2RND_MAIN_S0_TABLE)
#endif
	drvif_memory_compression_rpc(display);

#endif
	return TRUE;
}

void close_livezoom_doublebuffer(void)
{
	mdomain_disp_ddr_mainsubctrl_RBUS mdomain_disp_ddr_mainsubctrl_Reg;
	ppoverlay_double_buffer_ctrl_RBUS ppoverlay_double_buffer_ctrl_Reg;
	scaleup_dm_uzu_db_ctrl_RBUS scaleup_dm_uzu_db_ctrl_Reg;
	scaleup_ds_uzu_db_ctrl_RBUS scaleup_ds_uzu_db_ctrl_Reg;
	unsigned long flags;//for spin_lock_irqsave

	//IoReg_SetBits(MDOMAIN_DISP_DDR_MainSubCtrl_reg, _BIT17);
	mdomain_disp_ddr_mainsubctrl_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
	mdomain_disp_ddr_mainsubctrl_Reg.disp2_double_enable = 0;
	mdomain_disp_ddr_mainsubctrl_Reg.disp1_double_enable = 0;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, mdomain_disp_ddr_mainsubctrl_Reg.regValue);

	down(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
	//IoReg_SetBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT6);//Enable dtg double buffer register
	spin_lock_irqsave(get_DBreg_spinlock(SLR_MAIN_DISPLAY), flags);//lock double buffer spinlock
	ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
	ppoverlay_double_buffer_ctrl_Reg.dsubreg_dbuf_en = 0;
	ppoverlay_double_buffer_ctrl_Reg.dreg_dbuf_en = 0;
	IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);
	spin_unlock_irqrestore(get_DBreg_spinlock(SLR_MAIN_DISPLAY), flags);//unlock double buffer spinlock
	up(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
	//IoReg_SetBits(SCALEUP_DS_UZU_DB_CTRL_reg, _BIT2);//Enable uzu double buffer register
	scaleup_ds_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DS_UZU_DB_CTRL_reg);
	scaleup_ds_uzu_db_ctrl_Reg.db_en = 0;
	IoReg_Write32(SCALEUP_DS_UZU_DB_CTRL_reg, scaleup_ds_uzu_db_ctrl_Reg.regValue);

	//IoReg_SetBits(SCALEUP_DM_UZU_DB_CTRL_reg, _BIT2);//Enable uzu double buffer register
	scaleup_dm_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DM_UZU_DB_CTRL_reg);
	scaleup_dm_uzu_db_ctrl_Reg.db_en = 0;
	IoReg_Write32(SCALEUP_DM_UZU_DB_CTRL_reg, scaleup_dm_uzu_db_ctrl_Reg.regValue);

}

unsigned char init_source_proc(unsigned char display, VSC_INPUT_TYPE_T sourcetype, unsigned char sourceport)
{
	unsigned short vfesource;
	unsigned int *p_sourceID = NULL;

	int i= 0, size;
	//unsigned int srcid = MainOpenSourceID;
	StructSourceInput *srcinput_pt = NULL;
	//rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "%s.%d\n", __FUNCTION__, __LINE__);


	if(get_zoom_reset_double_state(display) == _ENABLE){
		set_zoom_reset_double_state(_DISABLE,display);
 	}

#ifdef CONFIG_DUAL_CHANNEL
		if (display == SLR_MAIN_DISPLAY) {
			p_sourceID = &DbgSclrFlgTkr.main_opensourceID;
		} else {
			p_sourceID = &DbgSclrFlgTkr.sub_opensourceID;
		}
#else
		if (display == SLR_MAIN_DISPLAY) {
			p_sourceID = &DbgSclrFlgTkr.main_opensourceID;
		} else {
			return FALSE;
		}

#endif

	switch(sourcetype)
	{
		case KADP_VSC_INPUTSRC_AVD:
		{
			down(get_setsource_semaphore());
			vfesource = get_AVD_Input_Source();
			up(get_setsource_semaphore());
			switch (vfesource) {
			case _SRC_TV://atv
			{
				if(sourceport == 0) {
					*p_sourceID = _TV_INPUT1;
				} else if (sourceport == 1) {
					*p_sourceID = _TV_INPUT2;
				} else if (sourceport == 2) {
					*p_sourceID = _TV_INPUT3;
				} else {
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "init_source_proc AVD ATV port = %d is invalid!!!!!!!!!!!!!!!1\n", sourceport);
					return FALSE;
				}
				if (display == SLR_MAIN_DISPLAY) {
					DbgSclrFlgTkr.Main_AutoRunScaler = TRUE;
				}
#ifdef CONFIG_DUAL_CHANNEL
				else {
					DbgSclrFlgTkr.Sub_AutoRunScaler = TRUE;
				}
#endif
				break;
			}
			case _SRC_CVBS://cvbs
			{
				if(sourceport == 0) {
					*p_sourceID = _AV_INPUT1;
				} else if (sourceport == 1) {
					*p_sourceID = _AV_INPUT2;
				} else if (sourceport == 2) {
					*p_sourceID = _AV_INPUT3;
				} else {
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "init_source_proc AVD CVBS port = %d is invalid!!!!!!!!!!!!!!!1\n", sourceport);
					return FALSE;
				}

				break;
			}
			case _SRC_SCART://SCART
			{
				if(sourceport == 0) {
					*p_sourceID = _SCART_INPUT1;
				} else if (sourceport == 1) {
					*p_sourceID = _SCART_INPUT2;
				} else if (sourceport == 2) {
					*p_sourceID = _SCART_INPUT3;
				} else {
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "init_source_proc AVD SCART RGB port = %d is invalid!!!!!!!!!!!!!!!1\n", sourceport);
					return FALSE;
				}
				break;
			}

			default:
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "init_source_proc AVD VFE not connect!!!!!!!!!!!!!!!1\n");
				return FALSE;
			}
			break;
		}
		case KADP_VSC_INPUTSRC_ADC:
		{
			down(get_setsource_semaphore());
			vfesource = get_ADC_Input_Source();
			up(get_setsource_semaphore());
			switch (vfesource) {
			case _SRC_YPBPR://ypp
			{
				if (sourceport == 0) {
					*p_sourceID = _YPBPR_INPUT1;
				} else if (sourceport == 1) {
					*p_sourceID = _YPBPR_INPUT2;
				} else if (sourceport == 2) {
					*p_sourceID = _YPBPR_INPUT3;
				} else {
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "init_source_proc ADC YPP port = %d is invalid!!!!!!!!!!!!!!!1\n", sourceport);
					return FALSE;
				}

				break;
			}
			case _SRC_VGA://VGA
			{
				if (sourceport == 0) {
					*p_sourceID = _VGA_INPUT1;
				} else if(sourceport == 1) {
					*p_sourceID = _VGA_INPUT2;
				} else if(sourceport == 2) {
					*p_sourceID = _VGA_INPUT3;
				} else {
					rtd_printk(KERN_INFO, TAG_NAME_VSC, "init_source_proc ADC VGA port = %d is invalid!!!!!!!!!!!!!!!1\n", sourceport);
					return FALSE;
				}
				break;
			}
			case _SRC_SCART_RGB://SCARTRGB
			{
				if (sourceport == 0) {
					*p_sourceID = _SCART_RGB_INPUT1;
				} else if(sourceport == 1) {
					*p_sourceID = _SCART_RGB_INPUT2;
				} else if(sourceport == 2) {
					*p_sourceID = _SCART_RGB_INPUT3;
				} else {
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "init_source_proc ADC SCART_RGB port = %d is invalid!!!!!!!!!!!!!!!1\n", sourceport);
					return FALSE;
				}
				break;
			}
			default:
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "init_source_proc ADC VFE not connect!!!!!!!!!!!!!!!1\n");
				return FALSE;
			}
			break;
		}
		case KADP_VSC_INPUTSRC_HDMI:
		{

			if (sourceport == 0) {
				*p_sourceID = _HDMI_INPUT1;
			} else if(sourceport == 1) {
				*p_sourceID = _HDMI_INPUT2;
			} else if(sourceport == 2) {
				*p_sourceID = _HDMI_INPUT3;
			} else if(sourceport == 3) {
				*p_sourceID = _HDMI_INPUT4;
			} else {
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "init_source_proc HDMI port%d is invalid!!!!!!!!!!!!!!!1\n", sourceport);
				return FALSE;
			}
			break;
		}

		case VSC_INPUTSRC_VDEC:
		{
            *p_sourceID = _VO_INPUT1;
			break;
		}
		case VSC_INPUTSRC_JPEG:
		{
            *p_sourceID = _VO_INPUT1;
			break;
		}
		default:
		{
			return FALSE;
			break ;
		}
	}
	if(get_hdmi_4k_hfr_mode() != HDMI_4K120_2_1)
	{
#ifdef CONFIG_FORCE_RUN_I3DDMA
		if((display == SLR_MAIN_DISPLAY)||((display == SLR_SUB_DISPLAY)&&(Get_Live_zoom_mode() != LIVE_ZOOM_OFF))/* && (sourcetype != KADP_VSC_INPUTSRC_AVD || vfesource != _SRC_TV)*/)
#else
		if(get_line_alternative_3d_mode_enable() == TRUE
			#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
			|| Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT
			#endif
			)
#endif
		{
			  *p_sourceID = _VO_INPUT1;
		}
	}

#ifdef CONFIG_I2RND_ENABLE
	//i2r case, sub will force to use port 1, need to use TV1. @Crixus 20171208
	if((display == SLR_SUB_DISPLAY) && (sourcetype == VSC_INPUTSRC_AVD) && (vfesource == _SRC_TV)){
		*p_sourceID = _TV_INPUT1;
	}
#endif

	size = PcbSource_GetTableSize();
	srcinput_pt = Scaler_InputSrc(0);

	for(i = 0; i < size; i++)
	{
		if(srcinput_pt->src_index == *p_sourceID) break;
		srcinput_pt++;
	}
	if(i == size)
	{
		rtd_printk(KERN_ERR, TAG_NAME_VSC, "\r\n###### source not found#######\r\n");
		return FALSE;
	}
	Scaler_DispSetInputInfoByDisp((SCALER_DISP_CHANNEL)display, SLR_INPUT_INPUT_SRC, i);
	Scaler_DispSetInputInfoByDisp((SCALER_DISP_CHANNEL)display, SLR_INPUT_DATA_ARRAY_IDX, i);//For m_screenModeCurrInfo table
	Scaler_DispSetInputInfoByDisp((SCALER_DISP_CHANNEL)display, SLR_INPUT_OSD_INPUT_SRC, i);
	Scaler_SetUserInputSrc((SCALER_DISP_CHANNEL)display, i);
	return TRUE;

}

static void set_default_mcap_format(unsigned char display, VSC_INPUT_TYPE_T inputSrctype)
{//Set M Cap 444 or 422
#ifndef CONFIG_DUAL_CHANNEL
	display = SLR_MAIN_DISPLAY;
#endif
	switch(inputSrctype) {
	case KADP_VSC_INPUTSRC_ADC:
	Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);
	break;

	case KADP_VSC_INPUTSRC_HDMI:
#ifdef CONFIG_RTK_KDRV_DV_IDK_DUMP
	Scaler_DispSetStatus(display, SLR_DISP_422CAP, FALSE);
#else
	Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);
#endif
	break;

	case KADP_VSC_INPUTSRC_AVD:
	Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);
	break;

	case VSC_INPUTSRC_VDEC:
	case VSC_INPUTSRC_JPEG:
#ifdef CONFIG_RTK_KDRV_DV_IDK_DUMP
	Scaler_DispSetStatus(display, SLR_DISP_422CAP, FALSE);
#else
	Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);
#endif

	break;

	default:
	Scaler_DispSetStatus(display, SLR_DISP_422CAP, TRUE);
	break;
	}
}

static unsigned char modestate_set_vgip(StructDisplayInfo* info)
{

	unsigned char result = TRUE;
    //extern unsigned int vpq_project_id;
#if 0
	// restore original signa's info
#ifdef CONFIG_DUAL_CHANNEL  // There are two channels
	IoReg_WriteByte0(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) ? SUB_VGIP_VGIP_CHN2_DELAY_reg : VGIP_VGIP_CHN1_DELAY_reg, Scaler_DispGetInputInfo(SLR_INPUT_IPV_DLY_PRE));
#else
	IoReg_WriteByte0(/*Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) ? SUB_VGIP_VGIP_CHN2_DELAY_reg : */VGIP_VGIP_CHN1_DELAY_reg, Scaler_DispGetInputInfo(SLR_INPUT_IPV_DLY_PRE));
#endif
#endif

#ifdef CONFIG_ENABLE_3D_SETTING
	modestate_decide3D_for_vdc();
#endif

	//If source is FR, handle display ratio at movie or caption
	if(!fw_scaler_cal_vgip_capture(info->display))
		return FALSE;
#if 0
    if (0){//(vpq_project_id == 0x00010000) {
        stDISPLAY_OVERSCAN_DATA scan_data={0};
        stVGIP_ADJUSTMENT_INFO adj_data={0};
        scan_data.HStart = Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_STA);
        scan_data.HWidth = Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID);
        scan_data.VStart = Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_STA);
        scan_data.VHeight = Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN);
        Mode_scaler_overscan(&scan_data,0);
        Mode_scaler_VGIP_Adjustment(&adj_data,0);

        Scaler_DispSetInputInfo(SLR_INPUT_IPH_ACT_STA,scan_data.HStart+adj_data.h_start);
        Scaler_DispSetInputInfo(SLR_INPUT_IPH_ACT_WID,scan_data.HWidth+adj_data.h_width);
        Scaler_DispSetInputInfo(SLR_INPUT_IPV_ACT_STA,scan_data.VStart+adj_data.v_start);
        Scaler_DispSetInputInfo(SLR_INPUT_IPV_ACT_LEN,scan_data.VHeight+adj_data.v_length);
    }
#endif
	if (((Get_Live_zoom_mode() == LIVE_ZOOM_ON)||Get_sub_from_DI_mux_path()) && (info->display== SLR_SUB_DISPLAY)) {
		//tmp code
		return result;
	}
	if(DbgSclrFlgTkr.magnifier_mainscaler_run_livezoom == TRUE || (Get_LivezoomOffMainRunScaler() == TRUE && Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) <= 3000)) {
		/*no need run vgip to di for livezoom main*/
		return result;
	}
	/* setup capture window */
	fw_scaler_set_vgip_capture(info->display);

	// Attention: This bit may be set as enable again in memory_3ddma_control()
	fw_scaler_set_vgip_3d_mode(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), _DISABLE);

#if 1
	//USER:Lewis DTAE:2015/09/29
	//PIP no 3D
	if(SLR_MAIN_DISPLAY == info->display)
	{
		if((TRUE == DbgSclrFlgTkr.Sub_OuputDisplayMode) || (TRUE == DbgSclrFlgTkr.Sub_OutputVencMode) || (TRUE == DbgSclrFlgTkr.Sub_OutputMemoryMode) || (TRUE == DbgSclrFlgTkr.Sub_OutputAveMode))
		{
			fw_scaler_set_vgip_frame_packing_3d_mode(_FALSE);
		}
		else// if(((FALSE == DbgSclrFlgTkr.Sub_OuputDisplayMode) && (FALSE == DbgSclrFlgTkr.Sub_OutputVencMode) && (FALSE == DbgSclrFlgTkr.Sub_OutputMemoryMode) && (FALSE == DbgSclrFlgTkr.Sub_OutputAveMode)))
		{
			if(Get_PANEL_3D_DISPLAY_SUPPORT_ENABLE() && Get_PANEL_3D_LINE_ALTERNATIVE_SUPPORT_ENABLE()){
				if(Scaler_Disp3dGetInfo((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_3D_3DTYPE) == SLR_3D_FRAME_PACKING)
					fw_scaler_set_vgip_frame_packing_3d_mode(_TRUE);
				else
					fw_scaler_set_vgip_frame_packing_3d_mode(_FALSE);
			}
#ifdef ENABLE_SG_3D_SUPPORT_ALL_SOURCE_3D_MODE // [SG] HDMI FP video in M-domain frame sequence 3D output mode
			else if(Get_PANEL_3D_DISPLAY_SUPPORT_ENABLE() && (Get_PANEL_3D_LINE_ALTERNATIVE_SUPPORT_ENABLE() == FALSE)
				&& (Scaler_Disp3dGetInfo((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_3D_3DTYPE) == SLR_3D_FRAME_PACKING) && (drvif_scaler3d_decide_3d_SG_Disable_IDMA(SLR_3D_FRAME_PACKING) == TRUE))
				fw_scaler_set_vgip_frame_packing_3d_mode(_TRUE);
#endif // [SG] MVC 3D data FRC path (M-domain data FRC sequence 3D output)
			else if(Get_PANEL_3D_DISPLAY_SUPPORT_ENABLE() && modestate_get_vo3d_in_framePacking_FRC_mode())
				fw_scaler_set_vgip_frame_packing_3d_mode(_TRUE);
			else
				fw_scaler_set_vgip_frame_packing_3d_mode(_FALSE);
		}
	}
	else// if(SLR_SUB_DISPLAY == info->display)
	{
		fw_scaler_set_vgip_frame_packing_3d_mode(_FALSE);
	}
#else //#if 1
	if(Get_PANEL_3D_DISPLAY_SUPPORT_ENABLE() && Get_PANEL_3D_LINE_ALTERNATIVE_SUPPORT_ENABLE()){
		if(Scaler_Disp3dGetInfo((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_3D_3DTYPE) == SLR_3D_FRAME_PACKING)
			fw_scaler_set_vgip_frame_packing_3d_mode(_TRUE);
		else
			fw_scaler_set_vgip_frame_packing_3d_mode(_FALSE);
		}
#ifdef ENABLE_SG_3D_SUPPORT_ALL_SOURCE_3D_MODE // [SG] HDMI FP video in M-domain frame sequence 3D output mode
	else if(Get_PANEL_3D_DISPLAY_SUPPORT_ENABLE() && (Get_PANEL_3D_LINE_ALTERNATIVE_SUPPORT_ENABLE() == FALSE)
		&& (Scaler_Disp3dGetInfo((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_3D_3DTYPE) == SLR_3D_FRAME_PACKING) && (drvif_scaler3d_decide_3d_SG_Disable_IDMA(SLR_3D_FRAME_PACKING) == TRUE))
		fw_scaler_set_vgip_frame_packing_3d_mode(_TRUE);
#endif // [SG] MVC 3D data FRC path (M-domain data FRC sequence 3D output)
	else if(Get_PANEL_3D_DISPLAY_SUPPORT_ENABLE() && modestate_get_vo3d_in_framePacking_FRC_mode())
		fw_scaler_set_vgip_frame_packing_3d_mode(_TRUE);
	else
		fw_scaler_set_vgip_frame_packing_3d_mode(_FALSE);
#endif //#if 1

	return result;
}
#if 0
// move to fw_scalerip_set_di
static void modestate_check_prtnr(void)
{
	di_im_di_rtnr_new_control_RBUS rtnr_new_Ctrl;
	rtnr_new_Ctrl.regValue = IoReg_Read32(DI_IM_DI_RTNR_NEW_CONTROL_reg);
	if(Scaler_DispGetInputInfo(SLR_INPUT_DI_WID)>1920){
		rtnr_new_Ctrl.prtnr_4k2k = 0x1;		//4K2K support
	}else{
		rtnr_new_Ctrl.prtnr_4k2k = 0x0;
	}
	IoReg_Write32(DI_IM_DI_RTNR_NEW_CONTROL_reg, rtnr_new_Ctrl.regValue);
}
#endif
static void modestate_decide_rtnr(void)
{
#ifdef CONFIG_RTK_KDRV_DV_IDK_DUMP
	if(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY)
        {
                Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);//don't go rtnr
		return;
        }
#endif

	//SLR_VOINFO* pVOInfo;

#ifdef HDMI_NO_PQDC_TEST
	return;
#endif
	if (Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_SUB_DISPLAY) {
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_RTNR, FALSE);
		return;
	}

#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
	//Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
	//return;
#endif

#ifdef FORCE_BYPASS_DI_RTNR
//Debug use. Interlace timing don't go rtnr and DI
	if(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY)
	{
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);//don't go rtnr
		return;
	}
#endif

	if(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY)
	{
		if(get_hdmi_4k_hfr_mode() != HDMI_NON_4K120)
		{
			Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);//don't go rtnr
			return;
		}
	}



	if(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY)
	{
		// flow for livezoom
		if(Get_Live_zoom_mode()== LIVE_ZOOM_ON)
		{//4
			if (Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) > 3000) {
				//case and Livezoom. We disable RTNR
				Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
				rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "[4k2k] RTNR OFF in 4k2k Livezoom case\n");
				return;
			}
			if (get_LiveZoomPcmodeDiableRTNR()){
				//case and Livezoom and pc mode. We disable RTNR
				Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
				rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "[4k2k] RTNR OFF in 4k2k Livezoom case\n");
				return;
			}

		}
	}

	if(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY)
	{
		//RGB444 & 4k2k disable RTNR @Crixus 20160902
		if((get_vsc_run_pc_mode()) &&
            ((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) || (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_JPEG)))
        {
			Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
			printk(KERN_EMERG"[crixus]RGB444 disable RTNR\n");
			return;
		}
	}

	if( Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY )
	{
		if( vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY))
		{
			Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);//don't go rtnr
			rtd_printk(KERN_INFO, TAG_NAME_VSC, "Decide RTNR, RTNR OFF\n");
			return;
		}
	}

	/* in Main channel, RTNR is controlled by AP , AP controlled table priority is higher than others*/
	if ((Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY) && (get_current_driver_pattern(DRIVER_RTNR_PATTERN) == DI_RTNR_OFF)) {
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
		rtd_printk(KERN_INFO, TAG_NAME_VSC, "Decide RTNR, RTNR OFF by AP table\n");
	}else if (drv_memory_get_vdec_direct_low_latency_mode() && !((Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_HDMI) || (Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_LVDS_TO_HDMI))) {
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
		rtd_printk(KERN_INFO, TAG_NAME_VSC, "Decide RTNR, RTNR OFF by vdec low delay\n");
	}else {
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, TRUE);
		rtd_printk(KERN_INFO, TAG_NAME_VSC, "Decide RTNR, RTNR ON by AP table\n");
	}



	return;
#if 0
	/* in Main channel, RTNR is controlled by AP , AP controlled table priority is higher than others*/
	if ((Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY) && (get_current_driver_pattern(DRIVER_RTNR_PATTERN) == DI_RTNR_OFF)) {
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
		rtd_printk(KERN_INFO, TAG_NAME_VSC, "Decide RTNR, RTNR OFF by AP table\n");
	} else {
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, TRUE);
		rtd_printk(KERN_EMERG, TAG_NAME_VSC, "Decide RTNR, RTNR ON by AP table\n");
	}

	if (Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY) {
	       modestate_check_prtnr();
	}
	return;
#endif
#if 0
	if(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY)
	{
		//RGB444 & 4k2k disable RTNR @Crixus 20160902
		if((Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422CAP) == FALSE) &&
            ((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) || (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_JPEG)))
        {
			Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
			//printk(KERN_EMERG"[crixus]RGB444 disable RTNR\n");
			return;
		}
	}
	//20151124 roger, sub don't open RTNR
	if (Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY) {
	       modestate_check_prtnr();
	}

	pVOInfo = Scaler_VOInfoPointer(Scaler_Get_CurVoInfo_plane());

	// frank@0207 disable DI/RTNR to reduce bandwidth usage
	if (Scaler_InputSrcGetMainChType() == _SRC_VO)
	{
//		if((Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN) > 1080))		//4k2k
//			Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
//		else
		#ifdef SMOOTH_TOGGLE_DATAFRCFS_TEST
		if(vbe_disp_get_adaptivestream_fs_mode()==1){
			if((Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE)>3000) && (Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)>495)){
				Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
			}else{
				Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, TRUE);
			}
			return;
			#if 0
			if(Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE)>3000)
			{
				if ((Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC)==1 || Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)<500) ||vsc_get_adaptivestream_flag()) 	//	FRAMESYNC mode
					Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, TRUE);
				else
					Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
				return;
			}
			else
			{
				Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, TRUE);//Vo always enable RTNR
				return;
			}
			#endif
		} else if(Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE)>1920)
		#else
		if(Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE)>1920)
		#endif
		{
#if 0
			if ((Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC)==1 || Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)<500) ||vsc_get_adaptivestream_flag())		//  FRAMESYNC mode
			{
				Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, TRUE);
			}else{
				Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, TRUE);
			}
#endif
			Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, TRUE);
			return;
		}
		else
		{
			Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, TRUE);//Vo always enable RTNR
			return;
		}
	}

	// force enable DI/NR when need enable HSD & VSD in the same time
	if(Get_PANEL_3D_DISPLAY_SUPPORT_ENABLE() && Get_PANEL_3D_LINE_ALTERNATIVE_SUPPORT_ENABLE()){
		if((Scaler_DispGetInputInfo(SLR_INPUT_DISP_WID) < Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID))
			&& (Scaler_Disp3dGetInfo(SLR_MAIN_DISPLAY, SLR_DISP_3D_3DTYPE) == SLR_3D_SIDE_BY_SIDE_HALF))
		{
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "[3D] Force Enable RTNR in SBS 3D, Width In/Out[%d/%d]\n", Scaler_DispGetInputInfo(SLR_INPUT_DISP_WID), Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID));
			Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, TRUE);
			return;
		}
	}

#ifdef ENABLE_DRIVER_I3DDMA
	if(Scaler_DispGetInputInfo(SLR_INPUT_THROUGH_I3DDMA) == TRUE){
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
		return;
	}
#endif

	// [SG] disable RTNR in 4k2k 3D mode
	if(Get_PANEL_3D_DISPLAY_SUPPORT_ENABLE() && (Get_PANEL_3D_LINE_ALTERNATIVE_SUPPORT_ENABLE() == FALSE)
		&& (Scaler_InputSrcGetMainChType() == _SRC_VO) && (Scaler_Get3DMode((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)) != SLR_3DMODE_2D)
		&& (Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) >= 3840))
	{
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "[RTNR] disable in 4k2k 3D mode\n");
		return;
	}

	//Elsie 20130314, force it to enter RTNR if source is CVBS.
	if(Scaler_InputSrcGetMainChType() == _SRC_CVBS)
	{
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR,TRUE);
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "[CVBS] RTNR ON\n");
		return;
	}
#ifdef CONFIG_RTNR_4K2K
	// [#0048022] 4k1k/4k2k video ratio mode 4:3 will cause RTNR fail
	if((Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID) > 2048)
			&& (Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN) >= 1080)){	// 4k1k/4k2k
		drv_memory_set_ip_DMA420_mode(SLR_DMA_422_mode);
		//frank@20130604 add below patch code for mantis#40619 solve DI readstart bits not enough problem
		if((Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID)-Scaler_DispGetInputInfo(SLR_INPUT_CAP_WID)) < 960)
			Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, TRUE);
		else
			Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
		return;
	}
#endif

	// disable DI/RTNR in VO source HD video 3D mode due to no enough memory space
	if((Scaler_InputSrcGetMainChType() == _SRC_VO) && (drvif_scaelr3d_decide_is_3D_display_mode() == TRUE)
		&& (Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) > 720))
	{
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
		return;
	} // Disable RTNR in MVC 3D
	else if((Scaler_InputSrcGetMainChType() == _SRC_VO) && (pVOInfo->mode_3d == VO_3D_FRAME_PACKING) && (!pVOInfo->force2d))
	{
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "[VO][3D] NR OFF\n");
		return;
	}


	// JPEG doesn't enter RTNR
	if ((Scaler_InputSrcGetMainChType()==_SRC_VO) && (Scaler_VOFromJPEG(Scaler_Get_CurVoInfo_plane()) == 1)) {
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_RTNR, FALSE);
		return;
	}

	#if 0	//20150817 roger mark, merlin do not have double DVS condition
	if (/*Scaler_PipGetInfo(SLR_PIP_ENABLE) && */modestate_decide_double_dvs_enable()) { //avoid memory allocate is not enough
		// Only main display can enter GIBI and RTNR should be closed
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
		return;
	}
	#endif
#ifdef CONFIG_DUAL_CHANNEL
	// Sub doesn't enter RTNR.
	if (Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_SUB_DISPLAY) {
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_RTNR, FALSE);
		return;
	}
#endif

	// [#0048022] 4k1k/4k2k video ratio mode 4:3 will cause RTNR fail

	if((Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN) > 2160)|| (Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID) > 4096)){//3   		//input frame paking case avoid scaler memory not enough
		//rika20151120 updated
		//let w=4096 goes rtnr, too
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, FALSE);
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "[4k2k] RTNR OFF in 4k2k\n");
		return;
	}

	if (Scaler_InputSrcGetMainChType() != _SRC_VGA) {
		if ( ((Scaler_InputSrcGetMainChFrom()==_SRC_FROM_TMDS) && (!drvif_IsHDMI())) ||
			((Scaler_DispGetStatus(SLR_MAIN_DISPLAY,SLR_DISP_INTERLACE) == 0) && (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422CAP) == FALSE) && (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)) ) // DVI don't enter RTNR
			Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_RTNR, FALSE);
		else
			Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_RTNR, TRUE);
	} else { // VGA don't enter RTNR
			Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_RTNR, FALSE);
	}
	//vflip rtnr check again
#ifdef CONFIG_DUAL_CHANNEL
	// if main needs RTNR but sub allocates DI, we have to release sub.
	if (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR)) {
			if (Scaler_DispGetStatus(SLR_SUB_DISPLAY, SLR_DISP_THRIP) || Scaler_DispGetStatus(SLR_SUB_DISPLAY, SLR_DISP_RTNR)) {
				/*Scaler_ForceBg(SLR_SUB_DISPLAY, SLR_FORCE_BG_SYSTEM, TRUE);*/
				fw_scalerip_disable_ip(SLR_SUB_DISPLAY);
				//frank@0528 Sove QCBUG10151 push below to set sub channel i,m,d domain to avoid sub set display but DI disable by main channel
				//flow_message_push(_MODE_MSG_SUB_SET_VGIP_AFTER_FOUND_MODE_SIGNAL);
				//flow_message_clearallType(_MODE_MSG_SUB_SETUP_BEFORE_SHOW_SIGNAL);
				//mark by frank@0528 flow_message_push(_MODE_MSG_SUB_SETUP_AFTER_FOUND_MODE_SIGNAL);
				Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_THRIP, FALSE);
				Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_RTNR, FALSE);
			}
	}
#endif
#endif
}

static void modestate_decide_DI(void)
{
	//unsigned char source = fwif_vip_source_check(3, 0);
	UINT32 picWidth = Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE);
	//unsigned char display_mode = Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR);
	UINT32 timingMode;
	// Elsie 20131106: playback always does not use RTNR 10-bit mode.
	// 20131210 sync from Mac2
	unsigned int modeByAP_table;
	if (Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_SUB_DISPLAY)
	{
		//Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT, FALSE);
		/*warning: sub could not set main di 10bit or 8bit flag*/
		//fw_scalerip_set_DI_chroma_10bits(FALSE);
#ifdef CONFIG_I2RND_ENABLE
	}else if((Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)){
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT, FALSE);
		fw_scalerip_set_DI_chroma_10bits(TRUE);
		printk(KERN_EMERG"[%s]I2rnd go 8bits!!!!!!\n", __FUNCTION__);
#endif
	}
#if 1
	else if ((Get_Live_zoom_mode() == LIVE_ZOOM_ON) && (Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)  == SLR_MAIN_DISPLAY)) {
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT, FALSE);
		fw_scalerip_set_DI_chroma_10bits(TRUE);
	}
#endif
	else if (vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY) && (Scaler_InputSrcGetMainChType() == _SRC_VO) ){
		//if <1080, di10bit , >1080 di 8bit
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT, TRUE);

		if(Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN_PRE) > 1080){
			fw_scalerip_set_DI_chroma_10bits(TRUE);
			rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "_rk adaptive >2k1k force 8bit\n");

		}
		else{
			fw_scalerip_set_DI_chroma_10bits(TRUE);
			rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "_rk adaptive 2k1k force 10bit\n");
		}
	} else if (Get_PANEL_3D_DISPLAY_SUPPORT_ENABLE() && Get_PANEL_3D_LINE_ALTERNATIVE_SUPPORT_ENABLE() && get_3D_overscan_enable() &&
		((Scaler_Disp3dGetInfo((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_3D_3DTYPE) == SLR_3D_SIDE_BY_SIDE_HALF) || (Scaler_Disp3dGetInfo((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_3D_3DTYPE) == SLR_3D_TOP_AND_BOTTOM) || (Scaler_Disp3dGetInfo((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_3D_3DTYPE) == SLR_3D_FRAME_PACKING))) {
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT, FALSE);
		fw_scalerip_set_DI_chroma_10bits(FALSE);
	}
	else if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC) && (Scaler_VOFromVDEC(Scaler_Get_CurVoInfo_plane()) == SOURCE_VIDEO)
		&& (Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) > 3000) && (Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) >= 480)
		&& (Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC) == FALSE) && (Get_DISPLAY_PANEL_OLED_TYPE() == TRUE))
	{ // [OLED panel] data FRC force in 8bit capture mode
		Scaler_DispSetStatus(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL) , SLR_DISP_10BIT, FALSE);
	} else if ((Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN_PRE) > 1080) && (Scaler_InputSrcGetMainChType() == _SRC_VO)) {
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT, TRUE);
		fw_scalerip_set_DI_chroma_10bits(TRUE);
	}
#ifdef ENABLE_DE_CONTOUR_I2R // TEST -- de-contour
    else if(rtd_inl(0xb8022288) & _BIT20){
        // IDMA source pixel width is 8 bit (0: 8bit, 1: 10bit)
        unsigned char bIdma10bitMode = VODMA_VODMA_V1_DCFG_get_seq_data_width(rtd_inl(VODMA_VODMA_V1_DCFG_reg));
        Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT, bIdma10bitMode);
	  fw_scalerip_set_DI_chroma_10bits(bIdma10bitMode);
    }
#endif

	else {
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT, TRUE);
		fw_scalerip_set_DI_chroma_10bits(TRUE);
	}

	//VP9 case use 8 bits setting @Crixus 20160407	2192
	if((Scaler_InputSrcGetMainChType() == _SRC_VO) && (get_vo_vp9_flag(Get_DisplayMode_Port(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY))))) {
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT, FALSE);
		fw_scalerip_set_DI_chroma_10bits(FALSE);
	}

	if(Get_Factory_SelfDiagnosis_Mode() == TRUE)
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT, FALSE);


	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "[VSC] src/vdec/wid/freq, fs/10/olde=%d/%d/%d/%d, %d/%d/%d\n",
		Get_DisplayMode_Src(SLR_MAIN_DISPLAY), Scaler_VOFromVDEC(Scaler_Get_CurVoInfo_plane()),
		Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE), Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ), Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC),
		Scaler_DispGetStatus(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT), Get_DISPLAY_PANEL_OLED_TYPE());


#if 1//def REDUCE_DIBW_ENABLE
//	UINT32 picWidth = Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE);

	// [XF112HAICNRTK1-88] linmc@20120712, reduce di bandwidth to resolve flicker picture screen happened
	//if (setManualReduceDIBW != NULL)
	//	setManualReduceDIBW();
	//else
	{
#ifdef CONFIG_ENABLE_VD_27MHZ_MODE
		//USER:LewisLee DATE:2012/12/20
		//fix VDC 27MHz mode, picture abnormal
		if(VD_27M_OFF != fw_video_get_27mhz_mode((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)))
		{
			picWidth = picWidth>>1;
		}
#endif //#ifdef CONFIG_ENABLE_VD_27MHZ_MODE

		// for playback source memory/bandwidth issue (24bit DI only for SD video--480i/576i)
		timingMode =  Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR);

		//Elsie 20131210: Enable BTR mode when source is 1080i. 20140211: Always disable BTR when source is playback.
		if((Scaler_InputSrcGetMainChType() != _SRC_VO) && (timingMode == _MODE_1080I25 || timingMode==_MODE_1080I30))
		{
			drv_memory_set_ip_Btr_mode(_ENABLE);
			drv_memory_set_ip_DMA420_mode(SLR_DMA_422_mode);
		}
		else if (picWidth > REDUCE_DI_BANDWIDTH_LIMIT_THRESHOLD)
		{
			drv_memory_set_ip_Btr_mode(_DISABLE);
			if(Scaler_InputSrcGetMainChType() == _SRC_VO){
				if((Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID) > 2048)&& (Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN) >= 1080)){		// 4k2k
					drv_memory_set_ip_DMA420_mode(SLR_DMA_400_mode);
				} else {
					drv_memory_set_ip_DMA420_mode(SLR_DMA_420_mode);
				}
			}
	                //frank@0904 add below code to avoid DI memory trash
			else if(Get_PANEL_VFLIP_ENABLE()){
				drv_memory_set_ip_DMA420_mode(SLR_DMA_420_mode);
			}
			else if((Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID) > 2048)
			&& (Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN) >= 1080)){
				drv_memory_set_ip_DMA420_mode(SLR_DMA_420_mode);				/*WOSQRTK-2096*/
			}
			else
			{
				drv_memory_set_ip_DMA420_mode(SLR_DMA_422_mode);
			}
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "[DI] DI BTR/420[%d/%d], width=%d!\n", drv_memory_get_ip_Btr_mode(), drv_memory_get_ip_DMA420_mode(), picWidth);
		}
		else{
		#if 0
			if(Scaler_InputSrcGetMainChType() == _SRC_VO) {
				drv_memory_set_ip_Btr_mode(_DISABLE);
				drv_memory_set_ip_DMA420_mode(SLR_DMA_420_mode);
			} else {
		#endif
				drv_memory_set_ip_Btr_mode(_ENABLE);
				drv_memory_set_ip_DMA420_mode(SLR_DMA_422_mode);
		//	}
		}
	}
#else

#ifdef CONFIG_ENABLE_VD_27MHZ_MODE
	//USER:LewisLee DATE:2012/12/20
	//fix VDC 27MHz mode, picture abnormal
	if(VD_27M_OFF != fw_video_get_27mhz_mode((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)))
	{
		picWidth = picWidth>>1;
	}
#endif //#ifdef CONFIG_ENABLE_VD_27MHZ_MODE


	if (picWidth > REDUCE_DI_BANDWIDTH_LIMIT_THRESHOLD){
		if((Scaler_InputSrcGetMainChType() == _SRC_HDMI)&&((_MODE_1080I25 == Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_CURR))||(_MODE_1080I30 == Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_CURR))) )
		{
			drv_memory_set_ip_Btr_mode(_ENABLE);//for 1080i video book Di 1 #chapter_10
			drv_memory_set_ip_DMA420_mode(SLR_DMA_422_mode);
		}
		else
		{
			drv_memory_set_ip_Btr_mode(_DISABLE);
			drv_memory_set_ip_DMA420_mode(SLR_DMA_422_mode);
  #if 0 // [IDMA] IDMA 3D reduce bandwidth issue (Sensio 3D mode)
			if((Scaler_InputSrcGetMainChType() == _SRC_VO) && modestate_I3DDMA_get_In3dMode() && (Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) >= REDUCE_DI_BW_VFREQ_THRESHOLD))
				drv_memory_set_ip_DMA420_mode(SLR_DMA_420_mode);
			else
				drv_memory_set_ip_DMA420_mode(SLR_DMA_422_mode);

			rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"[DBG] V_Freq=%d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ));
  #endif
		}
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "[DI] DI BTR/420[%d/%d], width=%d!!\n", drv_memory_get_ip_Btr_mode(), drv_memory_get_ip_DMA420_mode(), picWidth);
	}
	else{
		drv_memory_set_ip_Btr_mode(_ENABLE);
		drv_memory_set_ip_DMA420_mode(SLR_DMA_422_mode);
	}
#endif

#ifdef CONFIG_DUAL_CHANNEL
	if (Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_SUB_DISPLAY) {
#if 0//frank@1008 simple the PIP flow
		// main need DI, just return
		if (Scaler_DispGetStatus(SLR_MAIN_DISPLAY,SLR_DISP_THRIP) ||		// use DI's IP
			Scaler_DispGetStatus(SLR_MAIN_DISPLAY,SLR_DISP_INTERLACE) ||	// interlace source
			Scaler_DispGetStatus(SLR_MAIN_DISPLAY,SLR_DISP_RTNR))	{		// RTNR (because RTNR and DI uses the same IP)
				Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_THRIP,FALSE);
				return;
		}

		// main don't need DI, if sub need, sub get it!
		if (Scaler_DispGetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_INTERLACE))
			Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_THRIP, TRUE);
		return;
#else
		//add HDMI sub channel field control @Crixus 20151203
		if (Scaler_DispGetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_INTERLACE))
			DbgSclrFlgTkr.multiview_sub_interlace_flag = TRUE;
		else
			DbgSclrFlgTkr.multiview_sub_interlace_flag = FALSE;

		//sub always don't go DI
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_THRIP, FALSE);
		return;
#endif
	}
#endif

	// now handle main display
	//if(Scaler_DispGetStatus(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY),SLR_DISP_INTERLACE)) {
	if (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE)) {
#ifdef CONFIG_DUAL_CHANNEL
		if (Scaler_DispGetStatus(SLR_SUB_DISPLAY,SLR_DISP_THRIP) || Scaler_DispGetStatus(SLR_SUB_DISPLAY, SLR_DISP_RTNR)) {
			/*Scaler_ForceBg(SLR_SUB_DISPLAY, SLR_FORCE_BG_SYSTEM, TRUE);*/
			fw_scalerip_disable_ip(SLR_SUB_DISPLAY);
			//frank@0528 Sove QCBUG10151 push below to set sub channel i,m,d domain to avoid sub set display but DI disable by main channel
			/*flow_message_push(_MODE_MSG_SUB_SET_VGIP_AFTER_FOUND_MODE_SIGNAL);
			flow_message_clearallType(_MODE_MSG_SUB_SETUP_BEFORE_SHOW_SIGNAL);*/
			//mark by frank@0528 flow_message_push(_MODE_MSG_SUB_SETUP_AFTER_FOUND_MODE_SIGNAL);
			Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_THRIP, FALSE);
			Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_RTNR, FALSE);
		}
#endif
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_THRIP, TRUE);
	}
	else
	{
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_THRIP, FALSE);
	}

	/* in Main channel, DI is controlled by AP , AP controlled table priority is higher than others*/
	if (Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY) {
		modeByAP_table = get_current_driver_pattern(DRIVER_RTNR_PATTERN);
		if (modeByAP_table == DI_RTNR_422) {
			drv_memory_set_ip_DMA420_mode(SLR_DMA_422_mode);
		} else if (modeByAP_table == DI_RTNR_420) {
			drv_memory_set_ip_DMA420_mode(SLR_DMA_420_mode);
		} else if (modeByAP_table == DI_RTNR_400) {
			if (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE) == 0)
				drv_memory_set_ip_DMA420_mode(SLR_DMA_400_mode);
			else
				drv_memory_set_ip_DMA420_mode(SLR_DMA_422_mode);
		} else {
			//rtd_printk(KERN_INFO, TAG_NAME_VSC, "Decide DI by AP, NO RTNR, table value = %d\n", modeByAP_table);
		}
		rtd_printk(KERN_INFO, TAG_NAME_VSC, "Decide DI, AP Val=%d, isInterlace=%d,\n", modeByAP_table, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE));
	}

}

static void modestate_decide_nr_path(void)
{
	/* select bypass, NR or VUZD */
	if(Scaler_DispGetScaleStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_SCALE_V_DOWN)){  // go vuzd path
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_FSYNC_VUZD, VUZD_BUFFER_VUZD_MODE);
	}else{
		if (Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL))   //sub channal no NR path
			Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_FSYNC_VUZD, VUZD_BUFFER_BYPASS_MODE);
		else
		{
			if(Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC)) {//WOSQRTK-6131 Patch
				Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_FSYNC_VUZD, VUZD_BUFFER_FRAMESYNC_MODE);
			} else {
				Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_FSYNC_VUZD, VUZD_BUFFER_BYPASS_MODE);
			}
		}
	}
}
#if 0
static void modestate_setup_vgip_even_odd_toggle(void)
{
#ifdef CONFIG_DUAL_CHANNEL  // There are two channels
	unsigned short channel = Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL);
#endif

	//CSW+ 0970710 Sub Channel(480i or 576i or 1080i50 or 1080i60) interlace mode by video compensation
	if(Scaler_InputSrcGetMainChType() == _SRC_YPBPR || Scaler_InputSrcGetMainChType() == _SRC_VGA) {
#ifdef CONFIG_DUAL_CHANNEL  // There are two channels
		if(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_SUB_DISPLAY){				//ch2
			if(!Scaler_DispGetStatus(SLR_SUB_DISPLAY,SLR_DISP_THRIP))	//video comp
				IoReg_Mask32(channel ? SUB_VGIP_VGIP_CHN2_CTRL_reg : VGIP_VGIP_CHN1_CTRL_reg, ~_BIT18, 0x00);			//odd signal inverted disable
			else										//di or progressive
				IoReg_Mask32(channel ? SUB_VGIP_VGIP_CHN2_CTRL_reg : VGIP_VGIP_CHN1_CTRL_reg, ~_BIT18, _BIT18);			//odd signal inverted enable
		}
#endif
	}
	else if((Scaler_InputSrcGetMainChType() == _SRC_TV) || (Scaler_InputSrcGetMainChType() == _SRC_CVBS) || (Scaler_InputSrcGetMainChType() == _SRC_SV)){
#ifdef CONFIG_DUAL_CHANNEL  // There are two channels
		if(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_SUB_DISPLAY){				//ch2
			if(!Scaler_DispGetStatus(SLR_SUB_DISPLAY,SLR_DISP_THRIP))	//video comp
			{
				if ((Get_DisplayMode_Src(SLR_SUB_DISPLAY) == KADP_VSC_INPUTSRC_AVD) && (!get_sub_OutputVencMode()))
				{
					// AVD display in sub channel.
					IoReg_Mask32(channel ? SUB_VGIP_VGIP_CHN2_CTRL_reg : VGIP_VGIP_CHN1_CTRL_reg, ~_BIT18, 0x0);			//odd signal inverted disable
				}
				else
				{
					// APVR recording by sub channel
					IoReg_Mask32(channel ? SUB_VGIP_VGIP_CHN2_CTRL_reg : VGIP_VGIP_CHN1_CTRL_reg, ~_BIT18, _BIT18);			//odd signal inverted enable
				}
			}
			else
			{
				//di or progressive
				IoReg_Mask32(channel ? SUB_VGIP_VGIP_CHN2_CTRL_reg : VGIP_VGIP_CHN1_CTRL_reg, ~_BIT18, 0x00);			//odd signal inverted disable
			}
		}
#endif
	}
	else if(Scaler_InputSrcGetMainChType() == _SRC_HDMI){
		if(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY)
		{
			IoReg_Mask32(VGIP_VGIP_CHN1_CTRL_reg, ~(_BIT16|_BIT18), (_BIT16|_BIT18));
		}
#ifdef CONFIG_DUAL_CHANNEL  // There are two channels
		//add HDMI sub channel field control @Crixus 20151203
		if(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_SUB_DISPLAY){				//ch2
			if(!DbgSclrFlgTkr.multiview_sub_interlace_flag){//(!Scaler_DispGetStatus(SLR_SUB_DISPLAY, SLR_DISP_INTERLACE)){//!Scaler_DispGetStatus(SLR_SUB_DISPLAY,SLR_DISP_THRIP)){	//video comp
				IoReg_Mask32(channel ? SUB_VGIP_VGIP_CHN2_CTRL_reg : VGIP_VGIP_CHN1_CTRL_reg, ~_BIT18, 0x00);			//odd signal inverted disable
			}
			else{										//di or progressive
				IoReg_Mask32(channel ? SUB_VGIP_VGIP_CHN2_CTRL_reg : VGIP_VGIP_CHN1_CTRL_reg, ~_BIT18, _BIT18); 		//odd signal inverted enable
			}
		}
#endif
	}
}
#endif

static void modestate_EnableVGIPInt(unsigned char a_bEnable)
{
	// I-domain VGIP Int Ctl
	vgip_int_ctl_RBUS tVGIPIntCtl;

	tVGIPIntCtl.regValue = IoReg_Read32(VGIP_INT_CTL_reg);// Read value

	if (TRUE == a_bEnable){
		tVGIPIntCtl.vgip_int_ie = 1; // Enable VGIP Interrupt
	}else{
		tVGIPIntCtl.vgip_int_ie = 0; // Disable VGIP interrupt
	}

	IoReg_Write32(VGIP_INT_CTL_reg, tVGIPIntCtl.regValue); // Update value
}

#ifdef CONFIG_SCALER_BRING_UP
static void modestate_EnableDispInt(unsigned char a_bEnable)
{
	// Display I Domain Interrupt Enable Ctrl
	vgip_int_ctl_RBUS tVGIPIntCtl;

	tVGIPIntCtl.regValue = IoReg_Read32(VGIP_INT_CTL_reg); // Read value

	if (a_bEnable){
		tVGIPIntCtl.dispi_int_ie = 1; // Enable Disp Interrupt
	}else{
		tVGIPIntCtl.dispi_int_ie = 0; // Disable Disp interrupt
	}

	IoReg_Write32(VGIP_INT_CTL_reg, tVGIPIntCtl.regValue); // Update value
}
#endif

#ifdef CONFIG_SDNR_CROP
static void modestate_set_SDNR(unsigned char channel)
{
	VIDEO_RECT_T  outregion;
	outregion.x = Scaler_DispGetInputInfo(SLR_INPUT_SDNRH_ACT_STA);
	outregion.y = Scaler_DispGetInputInfo(SLR_INPUT_SDNRV_ACT_STA);
	outregion.w = Scaler_DispGetInputInfo(SLR_INPUT_SDNRH_ACT_WID);
	outregion.h = Scaler_DispGetInputInfo(SLR_INPUT_SDNRV_ACT_LEN);

	if (channel == SLR_MAIN_DISPLAY)
	{
		scaledown_ich1_sdnr_cutout_range_hor_RBUS ich1_sdnr_cutout_range_hor_reg;
		scaledown_ich1_sdnr_cutout_range_ver0_RBUS ich1_sdnr_cutout_range_ver0_reg;
		//scaledown_ich1_sdnr_cutout_range_ver1_RBUS ich1_sdnr_cutout_range_ver1_reg;
		scaledown_ich1_uzd_ctrl0_RBUS 	ich1_uzd_Ctrl0_REG;

		ich1_sdnr_cutout_range_hor_reg.regValue = IoReg_Read32(SCALEDOWN_ich1_sdnr_cutout_range_hor_reg);
		ich1_sdnr_cutout_range_hor_reg.hor_front= outregion.x;
		ich1_sdnr_cutout_range_hor_reg.hor_width= outregion.w; // chip setting need to +1
		IoReg_Write32(SCALEDOWN_ich1_sdnr_cutout_range_hor_reg, ich1_sdnr_cutout_range_hor_reg.regValue);

		ich1_sdnr_cutout_range_ver0_reg.regValue = IoReg_Read32(SCALEDOWN_ich1_sdnr_cutout_range_ver0_reg);
		ich1_sdnr_cutout_range_ver0_reg.ver_front= outregion.y;
		ich1_sdnr_cutout_range_ver0_reg.ver_height= outregion.h;	// chip setting need to +1
		IoReg_Write32(SCALEDOWN_ich1_sdnr_cutout_range_ver0_reg, ich1_sdnr_cutout_range_ver0_reg.regValue);

		//ich1_sdnr_cutout_range_ver1_reg.regValue = IoReg_Read32(SCALEDOWN_ich1_sdnr_cutout_range_ver1_reg);
		//ich1_sdnr_cutout_range_ver1_reg.ver_mid_top=0;	// inregion.y;
		//ich1_sdnr_cutout_range_ver1_reg.ver_mid_bot=0;	// inregion.y;
		//IoReg_Write32(SCALEDOWN_ich1_sdnr_cutout_range_ver1_reg, ich1_sdnr_cutout_range_ver1_reg.regValue);

#if 0
		rtd_printk(KERN_EMERG, TAG_NAME_VSC, "******************reg_hor_front = %d \n", outregion.x);
		rtd_printk(KERN_EMERG, TAG_NAME_VSC, "******************reg_ver_front = %d \n", outregion.y);
		rtd_printk(KERN_EMERG, TAG_NAME_VSC, "******************reg_ver_mid_top = %d \n", outregion.y);
		rtd_printk(KERN_EMERG, TAG_NAME_VSC, "******************reg_ver_mid_bot = %d \n", outregion.y);
		rtd_printk(KERN_EMERG, TAG_NAME_VSC, "******************reg_hor_back = %d \n", outregion.x+outregion.w);
		rtd_printk(KERN_EMERG, TAG_NAME_VSC, "******************reg_ver_back = %d \n", outregion.y+outregion.h);
#endif
		ich1_uzd_Ctrl0_REG.regValue = IoReg_Read32(SCALEDOWN_ICH1_UZD_Ctrl0_reg);
		ich1_uzd_Ctrl0_REG.cutout_en = 1;
		IoReg_Write32(SCALEDOWN_ICH1_UZD_Ctrl0_reg, ich1_uzd_Ctrl0_REG.regValue);
	}
	else
	{
		scaledown_ich2_sdnr_cutout_range_hor_RBUS ich1_sdnr_cutout_range_hor_reg;
		scaledown_ich2_sdnr_cutout_range_ver0_RBUS ich1_sdnr_cutout_range_ver0_reg;
		//scaledown_ich2_sdnr_cutout_range_ver1_RBUS ich1_sdnr_cutout_range_ver1_reg;
		scaledown_ich2_uzd_ctrl0_RBUS scaledown_ich2_uzd_ctrl0_reg;

		ich1_sdnr_cutout_range_hor_reg.regValue = IoReg_Read32(SCALEDOWN_ich2_sdnr_cutout_range_hor_reg);
		ich1_sdnr_cutout_range_hor_reg.hor_front= outregion.x;
		ich1_sdnr_cutout_range_hor_reg.hor_width= outregion.w; // chip setting need to +1
		IoReg_Write32(SCALEDOWN_ich2_sdnr_cutout_range_hor_reg, ich1_sdnr_cutout_range_hor_reg.regValue);

		ich1_sdnr_cutout_range_ver0_reg.regValue = IoReg_Read32(SCALEDOWN_ich2_sdnr_cutout_range_ver0_reg);
		ich1_sdnr_cutout_range_ver0_reg.ver_front= outregion.y;
		ich1_sdnr_cutout_range_ver0_reg.ver_height= outregion.h;	// chip setting need to +1
		IoReg_Write32(SCALEDOWN_ich2_sdnr_cutout_range_ver0_reg, ich1_sdnr_cutout_range_ver0_reg.regValue);

		//ich1_sdnr_cutout_range_ver1_reg.regValue = IoReg_Read32(SCALEDOWN_ich2_sdnr_cutout_range_ver1_reg);
		//ich1_sdnr_cutout_range_ver1_reg.ver_mid_top=0;	// inregion.y;
		//ich1_sdnr_cutout_range_ver1_reg.ver_mid_bot=0;	// inregion.y;
		//IoReg_Write32(SCALEDOWN_ich2_sdnr_cutout_range_ver1_reg, ich1_sdnr_cutout_range_ver1_reg.regValue);
#if 0
		rtd_printk(KERN_EMERG, TAG_NAME_VSC, "******************reg_hor_front = %d \n", outregion.x);
		rtd_printk(KERN_EMERG, TAG_NAME_VSC, "******************reg_ver_front = %d \n", outregion.y);
		rtd_printk(KERN_EMERG, TAG_NAME_VSC, "******************reg_ver_mid_top = %d \n", outregion.y);
		rtd_printk(KERN_EMERG, TAG_NAME_VSC, "******************reg_ver_mid_bot = %d \n", outregion.y);
		rtd_printk(KERN_EMERG, TAG_NAME_VSC, "******************reg_hor_back = %d \n", outregion.x+outregion.w);
		rtd_printk(KERN_EMERG, TAG_NAME_VSC, "******************reg_ver_back = %d \n", outregion.y+outregion.h);
#endif
		scaledown_ich2_uzd_ctrl0_reg.regValue = IoReg_Read32(SCALEDOWN_ICH2_UZD_Ctrl0_reg);
		scaledown_ich2_uzd_ctrl0_reg.cutout_en = 1;
		IoReg_Write32(SCALEDOWN_ICH2_UZD_Ctrl0_reg, scaledown_ich2_uzd_ctrl0_reg.regValue);
	}
}

#endif

static void modestate_setup_idomain(StructDisplayInfo* info)
{
	idomain_vfreq_pre = Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ);
	modestate_decide_pixel_mode();

	modestate_decide_dtg_m_mode();

	modestate_decide_fractional_framesync();

	//  decide which channel to use DI
	modestate_decide_DI();
	// Calculate main or sub display width and display height and set it to info
	// remember main's display width/height may change later if display ratio is
	// pointer to pointer
	fw_scalerdisplay_get_display_size(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));

	/* Decide RTNR flag */
	modestate_decide_rtnr();


#ifdef CONFIG_SDNR_CROP
	//for HSD enable

	//Scaler_AdjustPathAndInfo();/*Will add. decide Uzd path*/
	Scaler_AdjustPathAndInfo_HW_SNR();	// Include patch for SNR issue
	// Calculate Overscan
	fw_scaler_cal_sdnr_capture(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
	modestate_set_SDNR(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
#endif

	// Calculate the output size of scale down
	fw_scaler_cal_scale_down_size();

	/*Decide NR buffer mode,move from fw_scaler_cal_scale_down_size to support new NR path limit*/
	modestate_decide_nr_path();
	// Set in the scale up&down
	drvif_color_ultrazoom_config_scaling_down(Scaler_DispCheckRatio(SLR_RATIO_PANORAMA));


#if 0//remove in k4lp
	//DI game mode checking & setting in scaler flow @Crixus 20161217
	if(fw_scalerip_get_di_gamemode() == _ENABLE){
		fw_scalerip_set_di_gamemode_setting(_ENABLE);
		//printk(KERN_EMERG"[Game Mode]Enter DI game mode\n");
	}
	else{
		fw_scalerip_set_di_gamemode_setting(_DISABLE);
		//printk(KERN_EMERG"[Game Mode]Exit DI game mode\n");
	}
#endif

	if(DbgSclrFlgTkr.magnifier_mainscaler_run_livezoom == TRUE || (Get_LivezoomOffMainRunScaler() == TRUE && Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) <= 3000)
		||((get_rotate_mode()!=get_ori_rotate_mode()) && get_ori_rotate_mode()!=DIRECT_VO_FRAME_ORIENTATION_DEFAULT)) {
		pr_emerg("[rotate] no run vgip&di\n");
		/*no need run vgip to di for livezoom main*/
	} else  {
		// Disable VGIP Interrupt and let DI can be enabled.
		if(get_sub_OutputVencMode() == TRUE)
			IoReg_ClearBits(VGIP_VGIP_CHN1_CTRL_reg, _BIT24|_BIT25);
		else
			modestate_EnableVGIPInt(FALSE);

#if defined(CONFIG_RTK_AI_DRV)
		fw_scalerip_reset_NN();
#endif

		//DI control setting
		down(get_DI_semaphore());
		fw_scalerip_set_di();
		up(get_DI_semaphore());

		//De-XCXL
		fw_scalerip_set_deXC_XL();

		// set i-edge smooth
		fw_scalerip_set_IEGSM();

		// Enable VGIP Interrupt
		if(get_sub_OutputVencMode() == TRUE)
			IoReg_SetBits(VGIP_VGIP_CHN1_CTRL_reg, _BIT24|_BIT25);
		else
			modestate_EnableVGIPInt(TRUE);
	}

#ifdef CONFIG_VGA_AUTO_MA_ENABLE
	// enable AutoMA in VGA source

	if ( Scaler_InputSrcGetType(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)) == _SRC_VGA ) {
		drvif_scaler_vactive_end_irq(_ENABLE, info->display); // enable automa ISR
		drvif_scaler_vactive_sta_irq(_ENABLE, info->display); // enable automa ISR
	}
#endif
#if 0/*Framesync also need to enable VGIP ISR*/
    if((_FALSE == Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC)) /*&& (_ENABLE == drvif_memory_sw_buffer_swap_Enable((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)))*/)
#endif
	if (Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY){

		#ifdef CONFIG_SUPPORT_DOLBY_VSIF
		if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) {
			extern void reset_pre_dolby_hdmi_vsif_mode (void);

			reset_pre_dolby_hdmi_vsif_mode();
			vfe_hdmi_drv_set_infoframe_thread_stop(_TRUE);
		}
		#endif

		drvif_scaler_vactive_end_irq(_ENABLE, SLR_MAIN_DISPLAY);
		drvif_scaler_vactive_sta_irq(_ENABLE, SLR_MAIN_DISPLAY);
	} else {
#ifdef  CONFIG_I2RND_ENABLE
#else
		drvif_scaler_vactive_end_irq(_ENABLE, SLR_SUB_DISPLAY);
		drvif_scaler_vactive_sta_irq(_ENABLE, SLR_SUB_DISPLAY);
#endif
	}

#if 1
	if(get_3D_mode_enable() == TRUE && get_vo_3d_mode() == VO_3D_FRAME_PACKING && Scaler_InputSrcGetType(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)) == _SRC_VO)
	{
		drvif_scaler_vactive_end_irq(_DISABLE, SLR_MAIN_DISPLAY);
		drvif_scaler_vactive_sta_irq(_DISABLE, SLR_MAIN_DISPLAY);
	}
#endif

	if(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY)
	{
		if(get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1)
			twopixel_2_oneline_ctrl(1);//control two pixel mode
		else
			twopixel_2_oneline_ctrl(0);//control two pixel mode
	}

	#ifndef CONFIG_FORCE_RUN_I3DDMA	//not define
	//CSW+ 0970710 Sub Channel(480i or 576i or 1080i50 or 1080i60) interlace mode by video compensation
	//modestate_setup_vgip_even_odd_toggle();
	#endif
}

static void modestate_set_imd_domain(StructDisplayInfo* info)
{
	//rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\n Setup State: display:%d\n", Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));

	modestate_setup_idomain(info);

	force_enable_datapath_clock();//Force enable Xcdi_clock 0xb8022284 bit3
#ifdef CONFIG_DUAL_CHANNEL
	//when change PIP type to speed up sub channel setting
	/*modestate_set_sub_domain(msg);*/
#endif

}

static unsigned char modestate_set_framesync(StructDisplayInfo* info)
{
//	unsigned char result=0;
//	SLR_VOINFO *pVOInfo = Scaler_VOInfoPointer(Scaler_Get_CurVoInfo_plane());;
#ifdef CONFIG_DCLK_CHECK
	if(Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC))
	{
		if (Scaler_OpenVOGating())
		{
		//if((GET_HDMI_3DTYPE() == HDMI3D_FRAMESEQUENCE) &&  Get_PANEL_3D_LINE_ALTERNATIVE_SUPPORT_ENABLE()
		//&& (((Scaler_InputSrcGetMainChType() == _SRC_VO) && (scaler_2Dcvt3D_get_vgip2CurState() == VGIP2_2X_CLK_NON_ACTIVE)) || (scaler_2Dcvt3D_get_vgip2CurState() == VGIP2_2X_CLK_VO_GO)))

			check_dclk2_is_underflow();
		}
		else
		{
			check_dclk_is_underflow();
		}

	}
#endif
// move to vbe_disp_set_dtgM2uzu_lowdelay_mode(1)
//	if(info->display == SLR_MAIN_DISPLAY)
//		update_dtgm2uzu_delay();//update master to uzu dtg delay; //need to set before 0xb802850c bi30


	//frank@1011 FRC with frame sync timing so must do calculation IVS2DVS
	fw_scalerdisplay_handler(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));

	// Set in the scale up&down
	drvif_color_ultrazoom_config_scaling_up(Scaler_DispCheckRatio(SLR_RATIO_PANORAMA));

	if(info->display == SLR_MAIN_DISPLAY)
		vbe_disp_set_dtgM2uzu_lowdelay_mode(1);

	if(Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC)) {
	//	if(Scaler_InputSrcGetMainChType() != _SRC_VO){
		dvrif_memory_setting_for_data_fs();
		// Enter FrameSync Setup
		if(Scaler_InputSrcGetMainChType() == _SRC_VGA) {	// weihao 960308
			fw_scaler_update_mode_para(); //update mode parameters after adjust IVS2DVSDelay
		}


		// set display FIFO for Frame sync
		drvif_memory_set_fs_display_fifo();

		//data fs need to disable compression clock @Crixus 20171227
		dvrif_memory_comp_setting(FALSE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_CAP_WID), Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_CAP_LEN), dvrif_memory_get_compression_bits(SLR_MAIN_DISPLAY));
#if 0 //gamemode fix later
#ifdef CONFIG_FORCE_RUN_I3DDMA
				if(drv_memory_get_game_mode()){
					if(drvif_i3ddma_triplebuf_flag())
						drv_I3ddmaVodma_SingleBuffer_GameMode(_DISABLE);
					else
						drv_I3ddmaVodma_SingleBuffer_GameMode(_ENABLE);
					}
				else{

					drv_I3ddmaVodma_SingleBuffer_GameMode(_DISABLE);
				}

				/*qiangzhou:all i3ddma source go vodma timing sync i3ddma,all i3ddma source should setting iv2pv delay*/
				if(((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_ADC)
					|| (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)
					||((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD)	&& (get_AVD_Input_Source() != _SRC_TV)))
#ifdef CONFIG_ALL_SOURCE_DATA_FS
					//don't care 3 buffer case
					/*&&(!drvif_i3ddma_triplebuf_flag())*/){
#else
					&&(!drvif_i3ddma_triplebuf_flag())){
#endif
					drv_I3ddmaVodma_GameMode_iv2pv_delay(TRUE);
				} else {
					drv_I3ddmaVodma_GameMode_iv2pv_delay(FALSE);
				}
#endif
#endif

#if 0

		if(Scaler_OpenVOGating()){
/*
			if(Get_PANEL_TYPE_IS_MILLET3_4K2K_SERIES() ==1){
				//move framesync_gating to disp on
			}else if(Get_DISPLAY_PANEL_TYPE() == P_VBY1_4K2K){
				scaler_dtg_reconfig();
				drvif_framesync_gatting_do();
			}
			else
*/
			{
				scaler_dtg_reconfig();
				drvif_framesync_gatting_do();
				/*WaitFor_EN_STOP_MAIN_Done();*/
				//WaitFor_EN_STOP_MAIN_Done();//Will mark no need
				//WaitFor_EN_STOP_MAIN_Done();//Will mark no need
				drvif_framesync_gatting(_DISABLE);
				drvif_framesync_gatting(_ENABLE);
				/*WaitFor_EN_STOP_MAIN_Done();*/
				//WaitFor_EN_STOP_MAIN_Done();//Will mark no need
				//WaitFor_EN_STOP_MAIN_Done();//Will mark no need
			}
		}else{
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, KERN_INFO "\r\n[%s][line:%d] Error! Data FS without open gating!!\r\n", __FUNCTION__, __LINE__);
#if 0
				drvif_scaler_set_display_mode_frc2fsync_by_hw(_TRUE);
				result = drvif_framesync_do();

			if(Scaler_InputSrcGetMainChType()==_SRC_VO && (result != 0)){
				drvif_framesync_gatting(_DISABLE);
				drvif_framesync_gatting_do();
				msleep(50);
				drvif_framesync_gatting(_ENABLE);
				result = 0;
			}else if(Scaler_InputSrcGetMainChType()==_SRC_VO){//frank@0920 open VO gating function to solve mantis#5011
				drvif_framesync_gatting(_DISABLE);
				drvif_framesync_gatting(_ENABLE);
			}

			if (result != 0) {// frame sync fail
#if 0
				drvif_scaler_set_display_mode(DISPLAY_MODE_FRC);
				if(Scaler_DispGetInputInfo(SLR_INPUT_FAILURECOUNT) > 0) {
					//drvif_mode_resetmode();
					//Scaler_ForceBg((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_FORCE_BG_SYSTEM, TRUE);
					drvif_mode_disablechannelproc(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
					drvif_mode_disablevgip(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
					#if 0
					if(Scaler_InputSrcGetMainChType()==_SRC_VO) { // hsliao 20090311, VO source requests VO info again
						CVoRequestVoInfo(Scaler_Get_CurVoInfo_plane());
					}
					#endif
					Scaler_DispSetInputInfo(SLR_INPUT_STATE, _MODE_STATE_SEARCH); // hsliao 20090311, from active state or search state to search state

#ifdef CONFIG_ENABLE_YPBPR_AND_AV_USE_SAME_PATH
					if(_FALSE == modestate_send_ypbpr_and_av_same_path_init_msg())
						flow_message_push(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) ? _FL2FL_SUB_STATE_PERIODIC_EVENT : _FL2FL_MAIN_STATE_PERIODIC_EVENT);
#else //#ifdef CONFIG_ENABLE_YPBPR_AND_AV_USE_SAME_PATH
					flow_message_push(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) ? _FL2FL_SUB_STATE_PERIODIC_EVENT : _FL2FL_MAIN_STATE_PERIODIC_EVENT);
#endif //#ifdef CONFIG_ENABLE_YPBPR_AND_AV_USE_SAME_PATH

					Scaler_DispSetInputInfo(SLR_INPUT_FAILURECOUNT,0);
				} else {
					flow_message_push(_FL2FL_MAIN_SET_FRAMESYNC_SIGNAL);
					Scaler_DispSetInputInfo(SLR_INPUT_FAILURECOUNT,Scaler_DispGetInputInfo(SLR_INPUT_FAILURECOUNT)+1);
				}
#endif
				// while frame sync fail, must return fail
				// then try again, if frame sync still fail, goto search-state to re-detect signal.
				return FALSE;
			}else{
#ifdef CONFIG_FS_HS_BIAS
				if(drvif_framesync_hs_bias() == FALSE)
					return FALSE;
#endif
				// for gatting debug
				/*if(Scaler_InputSrcGetMainChType()==_SRC_VO){
					drvif_framesync_gatting(_ENABLE);
				}*/

			//	fw_dvi_framesync_setting();

			}
#endif
		}
#endif
#if 0
		if((GET_HDMI_3DTYPE() == HDMI3D_FRAMESEQUENCE) &&  Get_PANEL_3D_LINE_ALTERNATIVE_SUPPORT_ENABLE()
		&& (((Scaler_InputSrcGetMainChType() == _SRC_VO) && (scaler_2Dcvt3D_get_vgip2CurState() == VGIP2_2X_CLK_NON_ACTIVE)) || (scaler_2Dcvt3D_get_vgip2CurState() == VGIP2_2X_CLK_VO_GO)))
		{
			memory_3ddma_control();
			drvif_3ddma_DVTotal_Set(2);
		}
#endif

		//Scaler_DispSetInputInfo(SLR_INPUT_FAILURECOUNT,0);
		if(Get_DISPLAY_PANEL_TYPE() != P_VBY1_4K2K){
			if(!(Scaler_InputSrcGetMainChType() == _SRC_TV && Scaler_GetTvBlueScreen() == FALSE))	// weihao 960308
				fw_scaler_enable_fs_wdg(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), TRUE);
			else
				fw_scaler_enable_fs_wdg(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), FALSE);
		}
#if 0
		if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)
			&&(!drvif_i3ddma_triplebuf_flag())
			&&(get_HDMI_HDR_mode() != HDR_DOLBY_HDMI)
			//&&(pVOInfo->src_v_len>2000)
			){
			drv_I3ddmaVodma_GameMode_iv2pv_delay(TRUE);
		} else {
			drv_I3ddmaVodma_GameMode_iv2pv_delay(FALSE);
		}
#endif
		//drv_I3ddmaVodma_GameMode_iv2pv_delay(FALSE);
	} else {
#if 0 //frank@0903 mark redundent code
		if(Scaler_InputSrcGetMainChType() == _SRC_VGA) {	// weihao 960308
			fw_scaler_update_mode_para(); //update mode status after set capture window
		}
#endif

		//Set M-domain setting
		dvrif_memory_handler();
#if 0
		//USER:LewisLee DATE:2012/06/21
		//for SW buffer swap, need some IVS2DVS delay
		//to prevent DVS swap buffer too close IVS
		if(SLR_MAIN_DISPLAY == Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY))
		{
			if(TRUE == framesync_get_enterlastline_at_frc_mode_flg())
			{
				//it have set ivs2dvs Value
			}
			else// if(FALSE == framesync_get_enterlastline_at_frc_mode_flg())
			{
				//frank@0617 mark below code to speed up,below code will setting by memory_set_input_format
#if 0

				drvif_set_frc_ivs2dvsdelay_line(_FRC_MODE_IVS2DVS_LINE_1, _FRC_MODE_IVS2DVS_LINE_2, 0);
				drvif_set_frc_ivs2dvsdelay_pixel(_FRC_MODE_IVS2DVS_PIXEL_1, _FRC_MODE_IVS2DVS_PIXEL_2, 0);
#endif
			}
		}
//#else //#if 1
		if (Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) == SLR_MAIN_DISPLAY)
			drvif_clear_ivs2dvsdelay();

		modestate_set_FRC_fix_last_line();
#endif //#if 1
	}

//USER : LewusLee DATE:2012/11/30
//move position
#if 0
//USER : LewusLee DATE:2012/08/30
//for novatek Tcon IC, too easy to enter burn in mode
//sw we need to set FRC -> Framesync moer smooth
	framesync_adjust_dvtotal_at_framesync_mode((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
#endif

 	return TRUE;

}

void state_update_disp_info(void)	// updated by hsliao 20090515
{
	SCALER_DISPINFO_PKG info_pkg;
	unsigned char i;
	int ret;
	unsigned int ulIPKGItemCount = 0;
	unsigned int *pulTemp;
	for ( i=0 ; i<MAX_DISP_CHANNEL_NUM ; ++i )
	{
		info_pkg.disp_info[i].input_src = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_INPUT_SRC);
		info_pkg.disp_info[i].state = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_STATE);
		info_pkg.disp_info[i].disp_status = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_DISP_STATUS);
		info_pkg.disp_info[i].display = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_DISPLAY);
		info_pkg.disp_info[i].MEM_ACT_WID = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_MEM_ACT_WID);
		info_pkg.disp_info[i].MEM_ACT_LEN = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_MEM_ACT_LEN);
		info_pkg.disp_info[i].MEM_ACT_HSTA = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_MEM_ACT_HSTA);
		info_pkg.disp_info[i].MEM_ACT_VSTA = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_MEM_ACT_VSTA);
		info_pkg.disp_info[i].ucMode_Curr = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_MODE_CURR);
		info_pkg.disp_info[i].DispWid = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_DISP_WID);
		info_pkg.disp_info[i].DispLen = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_DISP_LEN);
		info_pkg.disp_info[i].IVFreq = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_V_FREQ);
		info_pkg.disp_info[i].CapWid = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_CAP_WID);
		info_pkg.disp_info[i].CapLen = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_CAP_LEN);
		info_pkg.disp_info[i].IphActWid_Pre = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_IPH_ACT_WID_PRE);
		info_pkg.disp_info[i].IpvActLen_Pre = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_IPV_ACT_LEN_PRE);


		info_pkg.disp_info[i].IpvActSTA_H = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_IPH_ACT_STA);
		info_pkg.disp_info[i].IpvActSTA_V = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_IPV_ACT_STA);
		info_pkg.disp_info[i].IphActWid_H = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_IPH_ACT_WID);
		info_pkg.disp_info[i].IpvActLen_V = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_IPV_ACT_LEN);
		info_pkg.disp_info[i].Iph_STA_Pre = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_IPH_ACT_STA_PRE);
		info_pkg.disp_info[i].Ipv_STA_Pre = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_IPV_ACT_STA_PRE);

		info_pkg.disp_info[i].src_h_total = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_H_LEN);
		info_pkg.disp_info[i].src_v_total = Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)i, SLR_INPUT_V_LEN);
		info_pkg.disp_info[i].scaler_source_type = Scaler_InputSrcGetType((SCALER_DISP_CHANNEL)i);
		if (i==0) {
			info_pkg.disp_info[i].input_2_pixel_mode = get_hdmi_4k_hfr_mode();
		} else {
			info_pkg.disp_info[i].input_2_pixel_mode = 0;
		}
		switch(Get_DisplayMode_Src(i))
		{//get adn set ui real src input
			case KADP_VSC_INPUTSRC_AVD:
				info_pkg.disp_info[i].ui_select_src = get_AVD_Input_Source();
			break;

			case KADP_VSC_INPUTSRC_ADC:
				info_pkg.disp_info[i].ui_select_src = get_ADC_Input_Source();
			break;

			case KADP_VSC_INPUTSRC_HDMI:
				info_pkg.disp_info[i].ui_select_src = _SRC_HDMI;
			break;

			case VSC_INPUTSRC_VDEC:
			case VSC_INPUTSRC_JPEG:
				info_pkg.disp_info[i].ui_select_src = _SRC_VO;
			break;

			default:
				info_pkg.disp_info[i].ui_select_src = _SRC_MAX;
			break;
		}
	}

	pulTemp = (unsigned int *)(&info_pkg);

	ulIPKGItemCount = sizeof(SCALER_DISPINFO_PKG) / sizeof(unsigned int);

	// change endian
	for (i = 0; i < ulIPKGItemCount; i++)
		pulTemp[i] = htonl(pulTemp[i]);

	//frank@0801 compare Disp_info is the same of video firmware,when the result is the same then return to speed up the code
	if (memcmp((unsigned char*)Scaler_GetShareMemVirAddr(SCALERIOC_SETDISPINFO), pulTemp, sizeof(SCALER_DISPINFO_PKG)) == 0) //compare equal or not
		return;
	// copy from RPC share memory
	memcpy((unsigned char*)Scaler_GetShareMemVirAddr(SCALERIOC_SETDISPINFO), pulTemp, sizeof(SCALER_DISPINFO_PKG));

	if ((ret = Scaler_SendRPC(SCALERIOC_SETDISPINFO,0,0)) < 0)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "ret = %d, set disp_info to driver fail !!!\n", ret );
		return;
	}

}

static struct vsc_film_mode_parameter_t vsc_film_mode_parameter = {0, 0, 60};

int vsc_get_film_mode_enable(void)
{
	return vsc_film_mode_parameter.enable;
}

int vsc_get_film_mode_type(void)
{
	return vsc_film_mode_parameter.type;
}

/*
int vsc_get_film_mode_type(void)
{
	return vsc_film_mode_parameter.type;
}
*/

struct vsc_film_mode_parameter_t vsc_set_film_mode_param(int film_mode_enable, int film_mode_type, int v_freq)
{
	struct vsc_film_mode_parameter_t cur_film_mode_parameter = {vsc_film_mode_parameter.enable, vsc_film_mode_parameter.type, vsc_film_mode_parameter.v_freq};

	if(!((film_mode_type == VO_FILM_TYPE_NONE) && (vsc_film_mode_parameter.type == 0))){
		pr_notice("[FILM] vsc_set_film_mode_param=%d/%d/%d\n", film_mode_enable, film_mode_type, v_freq);
		down(&set_vsc_film_mode_semaphore);
		//if new film type is NONE and current is 0, no need to run type change
		vsc_film_mode_parameter.enable = film_mode_enable;
		vsc_film_mode_parameter.type = film_mode_type;
		vsc_film_mode_parameter.v_freq = v_freq;
		up(&set_vsc_film_mode_semaphore);
	}

	return cur_film_mode_parameter;
}

extern void drivf_scaler_change_film_mode_type(int enable, int type, int v_freq);
// FixMe, 20190925
//extern void MEMC_Lib_set_memc_enable_to_bypass_flag(unsigned char u1_enable);
static int film_mode_change_task_flag = FALSE;
struct task_struct *p_film_mode_change_task = NULL;
unsigned int memc_me_clock_set_off = 0;
static int film_mode_change_task(void *data)
{
	struct vsc_film_mode_parameter_t cur_film_mode_parameter;
	unsigned int memc_me_clock = 0;
	while (1) {
		//Eric@20180913 check memc_me_clock_off status
		memc_me_clock = (IoReg_Read32(0xb800011c) & _BIT30) >> 30;
		if (Scaler_get_memc_me_clock_off() && memc_me_clock && !memc_me_clock_set_off &&
			(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) &&
			(Get_DISPLAY_REFRESH_RATE() != 120)
			/* && !modestate_get_fll_running_flag()*/	//Eric@20180926 do not check but break fll task.
			)
		{
			memc_me_clock_set_off = 1;
			printk("[FILM][%s] memc_me_clock_off = %d, memc_me_clock = %d, set ME clock off!!!\n", __func__,Scaler_get_memc_me_clock_off(),memc_me_clock);
			// FixMe, 20190925
			//MEMC_Lib_set_memc_enable_to_bypass_flag(1);
			Scaler_MEMC_MEMC_CLK_OnOff(0, 1, 0);
			memc_me_clock = (IoReg_Read32(0xb800011c) & _BIT30) >> 30;
			printk("[FILM][%s] memc_me_clock_off = %d, memc_me_clock = %d, set ME clock off done!!!\n", __func__,Scaler_get_memc_me_clock_off(),memc_me_clock);
		}
		if((memc_me_clock == 0) && (memc_me_clock_set_off == 1))
			memc_me_clock_set_off = 0;

		if (vsc_get_film_mode_enable() &&
			(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
			/* && !modestate_get_fll_running_flag()*/	//Eric@20180926 do not check but break fll task.
			)
		{
			printk("FILM_MODE %s, start\n", __func__);
			cur_film_mode_parameter = vsc_set_film_mode_param(0, 0, 0);
			film_mode_parameter = cur_film_mode_parameter;
			drivf_scaler_change_film_mode_type(1, cur_film_mode_parameter.type, cur_film_mode_parameter.v_freq);
			printk("FILM_MODE %s, end\n", __func__);
		}
		//Eric@20180926 do not check but break fll task.
		/* else if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) && modestate_get_fll_running_flag()){
			if(Scaler_get_film_mode_change_type() != 2){
			    printk("FILM_MODE FLL Running...\n");
			    Scaler_set_film_mode_change_type(2);
			}
		}*/
		else if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE) {
			if(Scaler_get_film_mode_change_type() != 3){
			    printk("FILM_MODE scaler state(%d) not in ACTIVE!!\n", Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE));
			    Scaler_set_film_mode_change_type(3);
			}
		}else if(Scaler_get_film_mode_change_type()){
			printk("FILM_MODE running state[%d] reset\n", Scaler_get_film_mode_change_type());
			Scaler_set_film_mode_change_type(0);
		}

		if (freezing(current)) {
			try_to_freeze();
		}
		if (kthread_should_stop()) {
			break;
		}

		msleep(10);
	}
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\n%s exit\n", __func__);
	do_exit(0);
	return 0;
}



struct vsc_film_mode_parameter_t get_film_mode_parameter(void){
	return film_mode_parameter;
}


static void create_film_mode_change_task(void)
{
	if (film_mode_change_task_flag == FALSE) {
		p_film_mode_change_task = kthread_run(film_mode_change_task, NULL, "init film_mode_change_task");

		if (IS_ERR(p_film_mode_change_task)) {
			pr_err("create film mode change task failed\n");
		} else {
			pr_notice("create film mode change task OK\n");
			film_mode_change_task_flag = TRUE;
		}
	}
}


static void delete_film_mode_change_task(void)
{
	int ret;
	if (film_mode_change_task_flag == TRUE) {
		ret = kthread_stop(p_film_mode_change_task);
		if (!ret) {
			p_film_mode_change_task = NULL;
			film_mode_change_task_flag = FALSE;
		}
	}
}

#if 1
static bool hdmi_4k120_se_task_flag = FALSE;
static struct task_struct *p_hdmi_4k120_se_tsk = NULL;
extern unsigned int i3ddma_cap_isr_cnt;
extern void scaler_hdmi_4k120_UV_interleave(void);
int i3ddma_dump_cap0cap2_to_file(unsigned int bufferindex);

void hdmi_4k120_se_wakeup(void)
{
	hdmi_4k120_se_trigger_flag = TRUE;
	wake_up(&HDMI_4K120_SE_WAIT_QUEUE);
}

static int hdmi_4k120_se_task(void *p)//This task run se proc
{
	static unsigned int vgip_isr_cnt_pre = 0;

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "hdmi_4k120_se_task()\n");

	current->flags &= ~PF_NOFREEZE;

	while (1)
	{
		wait_event_freezable(HDMI_4K120_SE_WAIT_QUEUE, hdmi_4k120_se_trigger_flag);
        down(&HDMI_4K120_MEMORY_PROTECTION_Semaphore);
		if(hdmi_4k120_se_trigger_flag)
		{
			hdmi_4k120_se_trigger_flag = FALSE;

			if((i3ddma_cap_isr_cnt != vgip_isr_cnt_pre))
			{
				vgip_isr_cnt_pre = i3ddma_cap_isr_cnt;

				if(get_i3ddma_4k120_flag() == TRUE)
				{
					//pr_emerg("se_task:i3ddma_cap_isr_cnt=%d\n",i3ddma_cap_isr_cnt);
					//scaler_hdmi_4k120_UV_interleave();
				}
			}
		}

		//dump 4k120 data
		if(get_i3ddma_4k120_flag() == TRUE)
		{
			if(IoReg_Read32(0xb802020c)& _BIT20)
			{
				IoReg_ClearBits(0xb802020c, _BIT20);
				i3ddma_dump_cap0cap2_to_file(0);
			}
		}
        up(&HDMI_4K120_MEMORY_PROTECTION_Semaphore);
		// to prevent STR/Snapshot fail
		if (freezing(current))
		{
			try_to_freeze();
		}

		if (kthread_should_stop()){
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "hdmi_4k120_se_task stop!!\n");
			break;
		}



	}

    rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####hdmi_4k120_se_task: exit...####\n");
    do_exit(0);
    return 0;
}

static void create_hdmi_4k120_se_task(void)
{
	int err;
	if (hdmi_4k120_se_task_flag == FALSE) {
		p_hdmi_4k120_se_tsk = kthread_create(hdmi_4k120_se_task, NULL, "hdmi_4k120_se_task");

		if (p_hdmi_4k120_se_tsk) {
			wake_up_process(p_hdmi_4k120_se_tsk);
			hdmi_4k120_se_task_flag = TRUE;
		} else {
			err = PTR_ERR(p_hdmi_4k120_se_tsk);
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Unable to start create_hdmi_4k120_se_task (err_id = %d)./n", err);
		}
	}
}


static void delete_hdmi_4k120_se_task(void)
{
	int ret;
	if (hdmi_4k120_se_task_flag) {
		ret = kthread_stop(p_hdmi_4k120_se_tsk);
		if (!ret) {
			p_hdmi_4k120_se_tsk = NULL;
			hdmi_4k120_se_task_flag = FALSE;
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "hdmi_4k120_se_task thread stopped\n");
		}
	}
}
#endif

unsigned char Scaler_get_vdec_2k120hz(void){
	if(!vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY) &&
		(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC) &&
		(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_WID_PRE) == 1920) &&
		(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_LEN_PRE) == 1080) &&
		(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_VO_SRC_FRAMERATE) >= 1195))
		return 1;
	else
		return 0;
}

unsigned int scaler_get_idomain_vfreq_pre(void)
{
	return idomain_vfreq_pre;
}

extern void i2rnd_debug(void);
extern void drv_memory_display_set_input_fast(void);
extern void drvif_color_rtnr_progressive_check(unsigned char interlace_flag, unsigned char channel);
extern void scalerVIP_Write_s1_RGB2YUV(unsigned long arg);
extern void i2rnd_s1_default_memory_tag(void);

extern int Scaler_MEMC_DTV_ME_CLK_OnOff(unsigned char enable, unsigned char bMute);
extern int vbe_dtg_memec_bypass_switch(void);
extern void vbe_dtg_memec_bypass_switch_set(int mode);
extern unsigned int vbe_get_HDMI_dynamic_film_mode_flag(void);
// FixMe, 20190925
//extern void MEMC_Lib_set_INPUT_COLOR_SPACE_Mode(unsigned char u1_mode);

static unsigned int record_Setup_IMD_timer_counter = 0;// record TIMER_SCPU_CLK90K_LO_reg after Setup_IMD
unsigned int MEMC_error_status_print_flag = 0;

void scaler_vsc_set_gamemode_force_framerate_lowdelay_mode(UINT8 bOnOff);
static DECLARE_WAIT_QUEUE_HEAD(dolby_apply_wq);
static bool dolby_apply_done = false;
int wait_ott_dolby_apply(void *data)
{
#ifdef CONFIG_RTK_KDRV_DV
    unsigned char cnt = 100;
#ifdef  CONFIG_DOLBY_IDK_1_6_1_1
    while (dolby_adapter_get_g_picModeUpdateFlag() && !DbgSclrFlgTkr.Main_Scaler_Stop_flag)
#else
    while (g_picModeUpdateFlag && !DbgSclrFlgTkr.Main_Scaler_Stop_flag)
#endif
    {

        if (cnt == 0) {
            /* force set Normal_TEST() */
            pr_info("[%s:%d][Dolby] force trigger Normal_TEST()", __func__, __LINE__);
            #ifdef  CONFIG_DOLBY_IDK_1_6_1_1
            dolby_adapter_set_g_picModeUpdateFlag(0xFFFFFFFF);
            #else
            g_picModeUpdateFlag = 0xFFFFFFFF;
            #endif
            break;
        }
        cnt--;
        usleep_range(1000, 1100);
    }

    if (cnt == 0) {
        cnt = 100;
#ifdef  CONFIG_DOLBY_IDK_1_6_1_1
        while (dolby_adapter_get_g_picModeUpdateFlag()
                && !DbgSclrFlgTkr.Main_Scaler_Stop_flag)
#else
        while (g_picModeUpdateFlag
                && !DbgSclrFlgTkr.Main_Scaler_Stop_flag)
#endif
        {
            usleep_range(1000, 1100);
            cnt--;
        }
        usleep_range(40000, 40000);
    }

    dolby_apply_done = true;
    wake_up(&dolby_apply_wq);
#endif
    return 0;
}
char DI_SW_Reset_INIT_CNT = 0;
extern unsigned int DI_SW_Detection_90k;
void Set_DI_SW_Detection_in_IMD(unsigned char display)
{
	extern unsigned char DI_SW_Reset_INIT_Flag;
	int timeout_cnt = 500;
	unsigned int t0, t1, t2;

	if(display == SLR_MAIN_DISPLAY) {
		t0 = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
		DI_SW_Reset_INIT_CNT = 0;
		if((DI_IM_DI_CONTROL_get_ip_enable(IoReg_Read32(DI_IM_DI_CONTROL_reg)) ==1 ) &&
			(DI_i2r_db_reg_ctl_get_reg_sm_size_change_sw_detect_en(IoReg_Read32(DI_i2r_db_reg_ctl_reg)) == 0) &&
			(VGIP_Data_Path_Select_get_xcdi_clk_en(IoReg_Read32(VGIP_Data_Path_Select_reg)) == 1)) {

			IoReg_SetBits(DI_i2r_db_reg_ctl_reg, DI_i2r_db_reg_ctl_reg_sm_size_change_sw_detect_en_mask);//set _BIT1
			rtd_printk(KERN_INFO, TAG_NAME_VSC, "DI_Enable, DI reset En, t0=%d, DI_SW_Reset_INIT_Flag=%d,\n", t0, DI_SW_Reset_INIT_Flag);

			if ((DI_SW_Reset_INIT_Flag == 1) && (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC) &&
				(Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE) ==1) && (get_platform() == PLATFORM_KXLP)) {
				timeout_cnt = 500;
				while ((DI_i2r_db_reg_ctl_get_reg_sm_size_change_sw_detect_en(IoReg_Read32(DI_i2r_db_reg_ctl_reg)) == 1) && (timeout_cnt>0)) {
					usleep_range(100, 200);
					timeout_cnt--;
				}

				t1 = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
				if (timeout_cnt<=0) {
					IoReg_ClearBits(DI_i2r_db_reg_ctl_reg, DI_i2r_db_reg_ctl_reg_sm_size_change_sw_detect_en_mask);//clear _BIT1
					rtd_printk(KERN_EMERG, TAG_NAME_VSC, "DI_Enable, DI reset En timeout, t0=%d,t1=%d, timeout_cnt=%d,\n", t0, t1, timeout_cnt);
				}
				//DI_SW_Reset_INIT_CNT = 2;
				DI_SW_Reset_INIT_CNT = 0;
				usleep_range(42000, 43000);

				t2 = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
				IoReg_SetBits(DI_i2r_db_reg_ctl_reg, DI_i2r_db_reg_ctl_reg_sm_size_change_sw_detect_en_mask);//set _BIT1

				rtd_printk(KERN_INFO, TAG_NAME_VSC, "DI_Enable, DI reset En 2, t0=%d,t1=%d, t2=%d, timeout_cnt=%d,\n", t0, t1,t2,  timeout_cnt);
			}

		}else{
			IoReg_ClearBits(DI_i2r_db_reg_ctl_reg, DI_i2r_db_reg_ctl_reg_sm_size_change_sw_detect_en_mask);//clear _BIT1
			if (Scaler_DispGetStatus((SCALER_DISP_CHANNEL)display,SLR_DISP_THRIP) || Scaler_DispGetStatus((SCALER_DISP_CHANNEL)display,SLR_DISP_RTNR)) {
				rtd_printk(KERN_EMERG, TAG_NAME_VSC, "DI_Enable, DI should be reset,ip_en=%d, sw_detect_en=%d,xcdi_clk=%d,DISP_THRIP=%d,DISP_RTNR=%d,t0=%d,\n",
					DI_IM_DI_CONTROL_get_ip_enable(IoReg_Read32(DI_IM_DI_CONTROL_reg)),
					DI_i2r_db_reg_ctl_get_reg_sm_size_change_sw_detect_en(IoReg_Read32(DI_i2r_db_reg_ctl_reg)),
					VGIP_Data_Path_Select_get_xcdi_clk_en(IoReg_Read32(VGIP_Data_Path_Select_reg)),
					Scaler_DispGetStatus((SCALER_DISP_CHANNEL)display,SLR_DISP_THRIP), Scaler_DispGetStatus((SCALER_DISP_CHANNEL)display,SLR_DISP_RTNR), t0);
			} else {
				rtd_printk(KERN_INFO, TAG_NAME_VSC, "DI_Enable, DI reset Disable, t0=%d,\n", t0);
			}
		}
		DI_SW_Reset_INIT_Flag = 0;
		DI_SW_Detection_90k = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
		rtd_printk(KERN_INFO, TAG_NAME_VSC, "DI_Enable, DI reset DI_SW_Detection_in_VPQ_TSK_Stable_CNT=%d,\n", DI_SW_Detection_90k);
	}
}

static DECLARE_WAIT_QUEUE_HEAD(hdr_type_apply_wq);
static bool hdr_type_setting_finish = false;
static int setup_imd_hdr_type_thread(void *data)
{
	unsigned int hdrtype = (uintptr_t)data;

	down(&HDR_Setting_Semaphore);
#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
	down(get_dolby_vision_dm_path_sem());
#endif

	Scaler_color_set_HDR_Type(hdrtype);
	scaler_vtop_dolby_mode_setting(hdrtype);
	if(Scaler_color_Get_HDR_AutoRun())
		Scaler_color_HDRIP_AutoRun(hdrtype);
	scaler_hdr_mode_setting(SLR_MAIN_DISPLAY, hdrtype);
	if(get_hdmi_4k_hfr_mode() == HDMI_4K120_2_0)
		scaler_hdr_mode_setting(SLR_SUB_DISPLAY, HDR_DM_MODE_NONE);//set sub hdr off for 4k120 hdmi2.0
#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
	up(get_dolby_vision_dm_path_sem());
#endif

	down(&SetMainOutPutRegion_Semaphore);
	if(!DbgSclrFlgTkr.Main_Scaler_Stop_flag)
		set_hdr_semaless_active(TRUE);
	up(&SetMainOutPutRegion_Semaphore);

	Scaler_SetDataFormatHandler();
	up(&HDR_Setting_Semaphore);

	hdr_type_setting_finish = true;
	wake_up(&hdr_type_apply_wq);

	return 0;
}

static void setup_imd_hdr(unsigned int hdrtype)
{
	unsigned int *hdrtype_t = (unsigned int *)hdrtype;


	hdr_type_setting_finish = false;

	if (hdrtype == HDR_DM_DOLBY) {
		setup_imd_hdr_type_thread(hdrtype_t);
	} else {
		kthread_run(setup_imd_hdr_type_thread, hdrtype_t, "set_hdr_type_thread");
	}
}

static void setup_imd_wait_hdr_type_finish(void)
{
	long time_left = wait_event_freezable_timeout(hdr_type_apply_wq, hdr_type_setting_finish, 2 * HZ);
	pr_info("[%s:%d] wait hdr type set finish result = %d (%ld)\n", __func__, __LINE__, hdr_type_setting_finish, time_left);
}

unsigned char Setup_IMD(StructDisplayInfo* info)
{
	extern void two_pixel_mode_edge_smooth_update(void);//two pixel mode edge smooth setting force update
#ifndef CONFIG_SDNR_CROP
	scaledown_ich1_uzd_RBUS 	ich1_uzd_Ctrl0_REG;
	ich1_uzd_Ctrl0_REG.regValue = IoReg_Read32(SCALEDOWN_ICH1_UZD_CTRL0_VADDR);
	ich1_uzd_Ctrl0_REG.cutout_en = 0;
	IoReg_Write32(SCALEDOWN_ICH1_UZD_CTRL0_VADDR, ich1_uzd_Ctrl0_REG.regValue);
#endif
	unsigned char srcType_2d;
	unsigned char phase_result = 0;
	unsigned char display;
#ifndef ADC_UP_DOWN_CLAMP
	int count;
#endif
//	mdomain_cap_cap_ddr_fifostatus_RBUS cap_ddr_fifostatus_reg;
//	unsigned char game_mode_wait_frame = 0;
//	unsigned int plane=0;
	VSC_INPUT_TYPE_T webos_src;
	seamless_change_sync_info *seamless_info = NULL;
	unsigned char hdrtype = HDR_DM_MODE_NONE;
	unsigned int src_type = 0;
    unsigned int *setup_di_done_flag = NULL;
#ifdef CONFIG_ENABLE_HDMI_NN
	unsigned char ver = get_ic_version();
#endif
#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
	ROTATE_MODE_LIST rotatemode;
	if (TRUE == Get_rotate_function())
	{
		rotatemode = (ROTATE_MODE_LIST)get_rotate_mode();
		pr_emerg("rotatemode=%d\n",rotatemode);
		Scaler_HDMI_Rotate(TRUE, rotatemode, 0);
	}
#endif
	display = info->display;

#ifdef _PRINT_AVD_COST_TIME
	rtd_printk(KERN_INFO, TAG_NAME_VSC,"_PRINT_AVD_COST_TIME: %s(%d) time = %d\n",__FUNCTION__,__LINE__,IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90);
#endif

	Scaler_DispSetInputInfo(SLR_INPUT_FAILURECOUNT, 0);
#if(VSC_PROFILE == 1)
	unsigned int before_time = 0;
	unsigned int after_time = 0;
	before_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
#endif
	set_display_forcebg_mask(display, SLR_FORCE_BG_TYPE_HDMI_AVMUTE_MASK, FALSE);//disable hdmi av mute mask
    update_vsc_task_status(1, VSC_I_DOMAIN);

	if(display == SLR_MAIN_DISPLAY)
	{
		set_mdomain_driver_status(false);//m domain driver not ready
		set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_DTV_CHANNEL_CHANGE_HDR_SEAMLESS, 0);//diable DTV switch seamless mask
        set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_DOLBY_MD_CRC, 0); /* disable dolby sink-led metadata crc error mask */
		if(!Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC))
			drv_memory_Main_Disp_Enable(FALSE);//move here early avoid noise
#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
        if(TRUE == Get_rotate_function())
        {
            scaler_set_I2D_tracking_in_slow_mode(1);//disable speedup locking flow
        }
        else
#endif
        {
            scaler_set_I2D_tracking_in_slow_mode(0);//keep speedup locking flow
        }
		if(get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1)
			two_pixel_mode_ctrl(1);
		else
			two_pixel_mode_ctrl(0);

    }

	set_di_wait_frame_num(0);//reset DI wait number
#ifdef ENABLE_AV1_AUTOSWITCH2SV1
		StructSourceInput *srcinput_pt = Scaler_InputSrc(Scaler_DispGetInputInfo(SLR_INPUT_INPUT_SRC));
		srcinput_pt->srcAutoSwitchAVSV_DB = 10;
#endif

		//Scaler_Set_Dynamic_Display_HV_total_Value((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));

#ifdef ENABLE_DRIVER_I3DDMA
		// [I3DDMA] VO source I3DDMA enable/disable control
		modestate_I3DDMA_update_VO_3D_enable();
		srcType_2d = modestate_I3DDMA_get_In3dMode() ? drvif_I3DDMA_Get_Input_Info_Vaule(I3DDMA_INFO_INPUT_SRC_TYPE):
#else
		srcType_2d = Scaler_InputSrcGetType(display);
#endif
		webos_src = Get_DisplayMode_Src(display);

		down(&HDR_Setting_Semaphore);
		reset_hdrtype_change_counter();
		up(&HDR_Setting_Semaphore);

		if(judge_scaler_break_case(display)) {
			rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "####channel:%d scaler need to break 1!!!####\r\n", display);
			return FALSE;
		}

		if(DbgSclrFlgTkr.magnifier_mainscaler_run_livezoom == TRUE || (Get_LivezoomOffMainRunScaler() == TRUE && Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) <= 3000)) {
			/*no need run vgip to di for livezoom main*/
		} else {
			if(display == SLR_MAIN_DISPLAY)
			{
					reset_hdr_mode(SLR_MAIN_DISPLAY);//disable dolby mode
					decide_qos_mode();//for kernel team to decide BW mode

#ifdef CONFIG_I2RND_ENABLE
					//get the sub hdr type from shared memory @Crixus 20180117
					if((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1))
						seamless_info = (seamless_change_sync_info *)Scaler_GetShareMemVirAddr(SCALERIOC_SUB_SEAMLESS_CHANGE_SHAREMEMORY_INFO_SYNC_FLAG);
					else
#endif
						seamless_info = (seamless_change_sync_info *)Scaler_GetShareMemVirAddr(SCALERIOC_SEAMLESS_CHANGE_SHAREMEMORY_INFO_SYNC_FLAG);
					down(&HDR_Setting_Semaphore);
#ifdef CONFIG_I2RND_ENABLE
					//get the sub src type for hdr info @Crixus 20180117
					if((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1))
						src_type = Get_DisplayMode_Src(SLR_SUB_DISPLAY);
					else
#endif
						src_type = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
					if(src_type == VSC_INPUTSRC_VDEC)
					{
						if(get_OTT_HDR_mode() == HDR_DOLBY_COMPOSER)
						/*20170908, pinyen add dolby hdr case*/
						{
							hdrtype = HDR_DM_DOLBY;
#ifdef CONFIG_RTK_KDRV_DV
#ifdef  CONFIG_DOLBY_IDK_1_6_1_1
                            dolby_adapter_set_g_picModeUpdateFlag(1);
#else
                            g_picModeUpdateFlag = 1;
#endif
#endif
						}
						else if(seamless_info)
						{
						    if(Scaler_ChangeUINT32Endian(seamless_info->vdec_cur_hdr_type) == HDR_DM_MODE_NONE)
							{//cp case and webos call dm connect and vo don't know har type. Currently this is youtube case
								if(vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY) && (get_OTT_HDR_mode() == HDR_HDR10_VDEC))
								{
									if(MAIN_VSC_HDRTYPE == KADP_VSC_HDR_HLG)
										hdrtype = HDR_DM_HLG;//according tha AP type
									else
										hdrtype = HDR_DM_HDR10;//according tha AP type
								}
								else if (get_support_vo_force_v_top(support_sdr_max_rgb))
								{
									hdrtype = HDR_DM_SDR_MAX_RGB;
								}
							}
							else if((Scaler_ChangeUINT32Endian(seamless_info->vdec_cur_hdr_type)) == HDR_DM_HDR10)
							{
								hdrtype = HDR_DM_HDR10;
							}
							else if((Scaler_ChangeUINT32Endian(seamless_info->vdec_cur_hdr_type)) == HDR_DM_HLG)
							{
								hdrtype = HDR_DM_HLG;
							}
							else if((Scaler_ChangeUINT32Endian(seamless_info->vdec_cur_hdr_type)) == HDR_DM_TECHNICOLOR)
							{
								hdrtype = HDR_DM_TECHNICOLOR;
							}
							else if((Scaler_ChangeUINT32Endian(seamless_info->vdec_cur_hdr_type)) == HDR_DM_ST2094)
							{
								//hdrtype = HDR_DM_ST2094;
								if (drvif_Get_ST2094_EFuse_Status() == 0)
									hdrtype = HDR_DM_ST2094;
								else
									hdrtype = HDR_DM_HDR10;
							}
							else if (get_support_vo_force_v_top(support_sdr_max_rgb))
							{
								hdrtype = HDR_DM_SDR_MAX_RGB;
							}
						}
					}
					else if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)
					{
#ifdef CONFIG_RTK_KDRV_DV
						if(get_HDMI_HDR_mode() == HDR_DOLBY_HDMI)
						/*20170908, pinyen add dolby hdr case*/
						{
#ifdef	CONFIG_DOLBY_IDK_1_6_1_1
							dolby_adapter_set_g_picModeUpdateFlag(3);
#else
                            g_picModeUpdateFlag = 3;//force update 3 times
#endif
							hdrtype = HDR_DM_DOLBY;
						}
						else
#endif
                        if(get_HDMI_HDR_mode() == HDR_HDR10_HDMI)
						{
							if (MAIN_VSC_HDRTYPE == KADP_VSC_HDR_HLG)	/*HLG case from LG*/
								hdrtype = HDR_DM_HLG;
							else if(MAIN_VSC_HDRTYPE == KADP_VSC_HDR_HDR10_PLUS) {
								//hdrtype = HDR_DM_ST2094;
								if (drvif_Get_ST2094_EFuse_Status() == 0)
									hdrtype = HDR_DM_ST2094;
								else
									hdrtype = HDR_DM_HDR10;

							} else
								hdrtype = HDR_DM_HDR10;
						}
						else if((get_hdmi_4k_hfr_mode() == HDMI_4K120_2_0))
						{
							hdrtype = HDR_DM_MODE_NONE;//hdmi2.0 4k2k120 mode can not do hdr
						}
						else if (get_support_vo_force_v_top(support_sdr_max_rgb))
						{
						#ifdef CONFIG_ENABLE_HDMI_NN
								if(ver < VERSION_C)
									hdrtype = HDR_DM_MODE_NONE;
								else
						#endif
									hdrtype = HDR_DM_SDR_MAX_RGB;
						}
						else if (get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1)
						{//if two pixel mode sdr also need to go vtop
							hdrtype = HDR_DM_SDR_MAX_RGB;
						}
					}
					else if(get_support_vo_force_v_top(support_sdr_max_rgb))
					{
						#ifdef CONFIG_ENABLE_HDMI_NN
								if(ver < VERSION_C)
									hdrtype = HDR_DM_MODE_NONE;
								else
						#endif
									hdrtype = HDR_DM_SDR_MAX_RGB;

					}

					up(&HDR_Setting_Semaphore);
					setup_imd_hdr(hdrtype);
					printk("[%s][%d] hdrtype=%d \n", __FUNCTION__, __LINE__,hdrtype);

                    if((src_type == VSC_INPUTSRC_VDEC)
						&& (get_OTT_HDR_mode() == HDR_DOLBY_COMPOSER)
						&& (hdrtype == HDR_DM_DOLBY)) {
#ifdef CONFIG_RTK_KDRV_DV
#ifdef	CONFIG_DOLBY_IDK_1_6_1_1
						dolby_adapter_set_g_picModeUpdateFlag(2);
#else
                        g_picModeUpdateFlag = 2;
#endif
#endif
						dolby_apply_done = false;
						kthread_run(wait_ott_dolby_apply, NULL, "wait_ott_dolby_apply");

					}

			} else {	/* for sub*/
				src_type = Get_DisplayMode_Src(SLR_SUB_DISPLAY);
				Scaler_SetDataFormatHandler();
				if(src_type == VSC_INPUTSRC_VDEC)
				{
					hdrtype = HDR_DM_MODE_NONE;
					scaler_hdr_mode_setting(SLR_SUB_DISPLAY, hdrtype);
				}
			}

			if((webos_src == VSC_INPUTSRC_ADC) && (get_ADC_Input_Source() == _SRC_YPBPR) && (auto_phase_flow_bypass() == FALSE)){// Start YPbPr auto phase
				//rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "%s(line: %d)####display=%d(0:main, 1:sub)####\r\n", __func__, __LINE__, display);
			#if 1 //enable auto phase flow, rzhen@2016-08-15
				rtd_printk(KERN_INFO, TAG_NAME_VSC, "start drvif_ypbpr_auto_phasedo_start\n");
				phase_result = drvif_ypbpr_auto_phasedo_start(SLR_MAIN_DISPLAY);
				//rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "drvif_ypbpr_auto_phasedo_start  result = %x\n", phase_result);
				if(phase_result != ERROR_SUCCEED){//Phase start setting fail
					rtd_printk(KERN_INFO, TAG_NAME_VSC, "###########drvif_ypbpr_auto_phasedo_start fail#############\r\n");
					return FALSE;
				}else{
					rtd_printk(KERN_INFO, TAG_NAME_VSC, "###########drvif_ypbpr_auto_phasedo_start success#############\r\n");
				}
			#else
				SyncProc_SetMinDiff(display);
			#endif
				drvif_scaler_check_vgip_data_dclk(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL));
			} else {
				if (((Get_Live_zoom_mode() == LIVE_ZOOM_ON) || Get_sub_from_DI_mux_path()) && (display == SLR_SUB_DISPLAY)) {
					//tmp code
				}
				else
				{
					fw_scaler_set_sample(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), _ENABLE);
					drvif_scaler_check_vgip_data_dclk(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL));
				}
				if((webos_src == VSC_INPUTSRC_ADC) && (get_ADC_Input_Source() == _SRC_YPBPR))
					rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "\r\n####YPP no need to run autophase again####\r\n");
			}

			if ( ( Scaler_InputSrcGetType((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)) == _SRC_TV ||
			      Scaler_InputSrcGetType((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)) == _SRC_CVBS ||
			      Scaler_InputSrcGetType((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)) == _SRC_SV ) &&
				( Scaler_DispGetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_422) == TRUE ) )
			{
#ifdef CONFIG_DUAL_CHANNEL  // There are two channels
				IoReg_Mask32(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) ? SUB_VGIP_VGIP_CHN2_MISC_reg : VGIP_VGIP_CHN1_MISC_reg, ~_BIT0, _BIT0);
#else
				IoReg_Mask32(/*Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)?SUB_VGIP_VGIP_CHN2_MISC_reg:*/VGIP_VGIP_CHN1_MISC_reg, ~_BIT0, _BIT0);
#endif
			}
			else
			{
#ifdef CONFIG_DUAL_CHANNEL  // There are two channels
				IoReg_Mask32(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) ? SUB_VGIP_VGIP_CHN2_MISC_reg : VGIP_VGIP_CHN1_MISC_reg, ~_BIT0, _ZERO);
#else
				IoReg_Mask32(/*Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)?SUB_VGIP_VGIP_CHN2_MISC_reg:*/VGIP_VGIP_CHN1_MISC_reg, ~_BIT0, _ZERO);
#endif
			}

			Scaler_SetDataFormatHandler();

			// we have to remember the original iv2dvs delay and other parameters
#ifdef CONFIG_DUAL_CHANNEL  // There are two channels
			Scaler_DispSetInputInfo(SLR_INPUT_IPV_DLY_PRE,Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) ? IoReg_ReadByte0(SUB_VGIP_VGIP_CHN2_DELAY_reg) : IoReg_ReadByte0(VGIP_VGIP_CHN1_DELAY_reg));
#else
			Scaler_DispSetInputInfo(SLR_INPUT_IPV_DLY_PRE,/*Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) ? IoReg_ReadByte0(SUB_VGIP_VGIP_CHN2_DELAY_reg) : */IoReg_ReadByte0(VGIP_VGIP_CHN1_DELAY_reg));
#endif
#if(VSC_PROFILE == 1)
			after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Setup_IMD initial time=%d ms", (after_time-before_time));
			before_time = after_time;
#endif
		}
		if(!modestate_set_vgip(info)){//set VGIP fail for vo source return detect state
			//flow_message_push(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY) ? _FL2FL_SUB_STATE_PERIODIC_EVENT: _FL2FL_MAIN_STATE_PERIODIC_EVENT);
			return FALSE;
		}
#ifdef CONFIG_ENABLE_HDMI_NN
	if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && get_i3ddma_NN_flag() && (ver < VERSION_C))
	{
		I3DDMA_ResetCap1();
	}
#endif


#if(VSC_PROFILE == 1)
		after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Setup_IMD set VGIP time=%d ms", (after_time-before_time));
		before_time = after_time;
#endif

#ifdef CONFIG_I2RND_ENABLE
		//check s0 still run idomain stage before refine vo1 clock, vgip hporch and DI h_blk size @Crixus 20180119
		if((display == SLR_MAIN_DISPLAY) && !((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1) || (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC))){
			if((get_i2rnd_vo1_refine_status_vir_addr() == I2RND_S1_REFINE_VO1) && (webos_src == VSC_INPUTSRC_VDEC)){
				Scaler_I2rnd_wait_timing_enable();
			}
			set_i2rnd_s0_idomain_done_status(I2RND_S0_IDOMAIN_STAGE_START);
			printk(KERN_EMERG"[I2RND]I2RND_S0_IDOMAIN_STAGE_START!!\n");
		}
#endif
		//IF HFR case, need bypass MEMC earlier, to avoid MEMC garbage
		if(((get_hdmi_4k_hfr_mode() != HDMI_NON_4K120) || force_enable_two_step_uzu())){
			//MEMC bypass
			Scaler_MEMC_MEMC_CLK_OnOff(0, 0, 1);
			//set MEMC mux disable
			Scaler_MEMC_Bypass_On(1);
	//		vbe_dtg_memec_bypass_switch_set(0);
			pr_notice("HFR bypass MEMC!!\n");
		}

		modestate_set_imd_domain(info);

		//memc timing stable log print
		MEMC_error_status_print_flag = 1;

#ifdef CONFIG_DATA_FRAMESYNC_FORCE_422_CAP
		if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC){
			//VDEC 2k1k use original flow, framesync with gatting
			if((_ENABLE == Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC)) && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE) > DATAFS_DISABLE_GATTING_WIDTH) && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) > DATAFS_DISABLE_GATTING_HEIGHT)){
				g_tDataFsAlgoResult.ulEnableVCrop = 1;
				g_tDataFsAlgoResult.ulUpdateReg = 1;
				rtd_printk(KERN_EMERG, TAG_NAME_VSC,"Send RPC to recalculate vo vstart htotal\n");
				UpdateDataFsAlgoRsult();
				//scaler_update_vo_vstat_htotal(TRUE,TRUE);
			}
		}
#endif
        if(judge_scaler_break_case(display))
        {
            rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "####channel:%d scaler need to break before dtg_pre_idomain!!!####\r\n", display);
            return FALSE;
        }

		scaler_disp_dtg_pre_i_domain_setting(display);
		if(idomain_vfreq_pre != Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)){
			rtd_printk(KERN_EMERG, TAG_NAME_VSC,"input vfreq has changed, force return to re-run scaler!!!\n");
			if(vbe_disp_decide_frc2fsync_using_I2D() == TRUE){
				drvif_scaler_set_display_mode_frc2fsync_I2D_disable();
			}
			return FALSE;
		}
		if(_ENABLE == Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC)){
			if(vbe_disp_decide_frc2fsync_using_I2D() == TRUE){
				printk(KERN_EMERG" data fs go vbe_disp_decide_frc2fsync_using_I2D!! SLR_INPUT_V_FREQ = %d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ));
				Scaler_Set_FreeRun_To_FrameSync_By_HW_SpeedUp_ByMcode_HW_CTRL4(FALSE);
				Scaler_Set_FreeRun_To_FrameSync_By_I2D_CTRL(TRUE);
			}else{
				printk(KERN_EMERG" data fs go Scaler_Set_FreeRun_To_FrameSync_By_HW_SpeedUp_ByMcode_HW_CTRL4!! SLR_INPUT_V_FREQ = %d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ));
				Scaler_Set_FreeRun_To_FrameSync_By_HW_SpeedUp_ByMcode_HW_CTRL4(TRUE);
				Scaler_Set_FreeRun_To_FrameSync_By_I2D_CTRL(FALSE);
			}
		}else{
			printk(KERN_EMERG" data frc go Scaler_Set_FreeRun_To_FrameSync_By_HW_SpeedUp_ByMcode_HW_CTRL4!! SLR_INPUT_V_FREQ = %d\n", Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ));
			Scaler_Set_FreeRun_To_FrameSync_By_HW_SpeedUp_ByMcode_HW_CTRL4(TRUE);
			Scaler_Set_FreeRun_To_FrameSync_By_I2D_CTRL(FALSE);
		}

#ifdef CONFIG_I2RND_ENABLE
		//check s0 still run idomain stage before refine vo1 clock, vgip hporch and DI h_blk size @Crixus 20180119
		if((display == SLR_MAIN_DISPLAY) && !((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1) || (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC))){
			set_i2rnd_s0_idomain_done_status(I2RND_S0_IDOMAIN_STAGE_DONE);
			printk(KERN_EMERG"[I2RND]I2RND_S0_IDOMAIN_STAGE_DONE!!\n");
		}
#endif

#if(VSC_PROFILE == 1)
		after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Setup_IMD set imd time=%d ms", (after_time-before_time));
		before_time = after_time;
#endif

		//modestate_arbitration_setup();

		//printk(KERN_EMERG"Get_display_forcebg_mask(SLR_MAIN_DISPLAY,SLR_FORCE_BG_TYPE_GameMode) = %d\n", Get_display_forcebg_mask(SLR_MAIN_DISPLAY,SLR_FORCE_BG_TYPE_GameMode));


#ifdef CONFIG_WSS_ENABLE
		check_wss(_TRUE,0); // move here by linmc, need to wait wss stable
#endif
		//IoReg_SetBits(/*Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL) ? SYNCPROCESSOR_SP_MS2STUS_VADDR : */ONMS_onms1_status_reg, (_BIT14|_BIT15|_BIT8|_BIT9));//clear online ms error flag
		if(judge_scaler_break_case(display)) {
			if(vbe_disp_decide_frc2fsync_using_I2D() == TRUE){
				drvif_scaler_set_display_mode_frc2fsync_I2D_disable();
			}
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####channel:%d scaler need to break 2!!!####\r\n", display);
			return FALSE;
		}

//move her to let semaless work early
		if(display == SLR_MAIN_DISPLAY)
		{
			if(webos_src == VSC_INPUTSRC_HDMI)
			{
#ifdef CONFIG_HDR_SDR_SEAMLESS
#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
				i3ddma_cap1_interrupt_ctrl(TRUE);//enable i3ddma cap1 interrupt
#endif
#endif
			}
		}

		if(display == SLR_MAIN_DISPLAY)
		{
			if(get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1)
			{
				two_pixel_mode_edge_smooth_update();//force update
			}
		}

        update_vsc_task_status(0, VSC_I_DOMAIN);//clear i domain statsu
        update_vsc_task_status(1, VSC_M_DOMAIN);//set M domain statsu
		if (((display == SLR_MAIN_DISPLAY) && get_main_OutputVencMode()) || ((display == SLR_SUB_DISPLAY) && get_sub_OutputVencMode())) {
#ifdef CONFIG_I2RND_ENABLE
 			if((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)){//capture progressive video data
 				printk(KERN_EMERG"[frank] apvr step3!\n");
				Scaler_i2rnd_send_apvr_info();
				mdomain_handler_i2rnd_mcap_apvr();

				vsc_i2rnd_sub_stage = I2RND_STAGE_MAIN_I2RND_DONE;
				drvif_scaler_vactive_end_irq(_ENABLE, SLR_SUB_DISPLAY);
				drvif_scaler_vactive_sta_irq(_ENABLE, SLR_SUB_DISPLAY);
				VencModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){VSC_INPUTSRC_MAXN, 0, 0};
				DbgSclrFlgTkr.OutputVencMode = FALSE;
				Scaler_I2rnd_set_display(I2RND_MAIN_S0_TABLE);
				i2rnd_send_table_idx(I2RND_MAIN_S0_TABLE);
				printk(KERN_EMERG"[frank] apvr step4!\n");
				//go to timing frame sync mode -s- Eric@0809
				rtd_printk(KERN_EMERG, TAG_NAME_VSC, "[OUTPUT_VENC_MODE] go to data frc & timing framesync!\n");
				VSC_OUTPUT_VENC_MODE_FLAG = FALSE;
                modestate_set_fll_running_flag(_DISABLE);
                fwif_color_safe_od_enable(0);
				drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
				fwif_color_safe_od_enable(1);
				//go to timing frame sync mode -e-
				Scaler_DispSetInputInfo(SLR_INPUT_STATE, _MODE_STATE_ACTIVE);
				//scaler_update_struct_info(SLR_SUB_DISPLAY);
				scaler_update_struct_info(SLR_MAIN_DISPLAY);
				return TRUE;
			}else if((display == SLR_SUB_DISPLAY) && (Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_DETECT_SOURCE)){//sub path capture
				printk(KERN_EMERG"[frank] apvr step1!\n");
				mdomain_handler_onlycap_i2run();
			}
			else
#endif
				mdomain_handler_onlycap();
		}
#ifdef CONFIG_I2RND_ENABLE
		else if((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1)){
			mdomain_handler_i2rnd_mcap_sdisp();
			i2rnd_group3_s1_to_s0_register_sync();
			Pipmp_SetPipCtrl();
			//Eric@0916 check s0 mdomain_in1cap_enable bit
			Scaler_I2rnd_set_display(I2RND_MAIN_S0_TABLE);
			IoReg_SetBits(MDOMAIN_CAP_Cap_In1_enable_reg, _BIT0);
			if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE){
				//Eric@0917 check s0 rtnr progressive i2r_fix_me
				drvif_color_rtnr_progressive_check(!i2rnd_main_voinfo.progressive,SLR_MAIN_DISPLAY);
				//Eric@0917 set s0 di size i2r_fix_me
				i2rnd_di_size_toggle();
			}
			Scaler_I2rnd_set_display(I2RND_SUB_S1_TABLE);
			//Eric@20171221 Trigger run s1 vip matrix table
			scalerVIP_Write_s1_RGB2YUV(1);
			//Eric@20171214 toggle di to make di change size setting
			i2rnd_di_size_toggle();
			#if 0
			//reset to free run first
			drivf_scaler_reset_freerun();
			modestate_set_fll_running_flag(_DISABLE);

			//Eric@20170919 set disp timing to framesync
			fwif_color_safe_od_enable(0);
			drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
			fwif_color_safe_od_enable(1);
			printk(KERN_EMERG"[I2RND] I2rnd default timing fs\n");
			#endif
			vsc_i2rnd_dualvo_sub_stage = I2RND_DUALVO_STAGE_RERUN_MAIN_DONE;
			printk(KERN_EMERG"[I2RND]@@@@@@@@@@@@ Stage go I2RND_DUALVO_STAGE_RERUN_MAIN_DONE @@@@@@@@@@\n");
			return TRUE;

		}
		else if((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)){
			mdomain_handler_i2rnd_mcap_sdisp();
			i2rnd_group3_s1_to_s0_register_sync();
			Pipmp_SetPipCtrl();
			//Eric@0916 check s0 mdomain_in1cap_enable bit
			Scaler_I2rnd_set_display(I2RND_MAIN_S0_TABLE);
			IoReg_SetBits(MDOMAIN_CAP_Cap_In1_enable_reg, _BIT0);
			if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE){
				//Eric@0917 check s0 rtnr progressive
				drvif_color_rtnr_progressive_check(!i2rnd_main_voinfo.progressive,SLR_MAIN_DISPLAY);
				//Eric@0917 set s0 di size
				i2rnd_di_size_toggle();
			}
			Scaler_I2rnd_set_display(I2RND_SUB_S1_TABLE);
			//Eric@20171221 Trigger run s1 vip matrix table
			scalerVIP_Write_s1_RGB2YUV(1);
			//Eric@20171214 toggle di to make di change size setting
			i2rnd_di_size_toggle();
			//reset to free run first
			drivf_scaler_reset_freerun();
			modestate_set_fll_running_flag(_DISABLE);

			//Eric@20170919 set disp timing to framesync
            fwif_color_safe_od_enable(0);
			drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
			fwif_color_safe_od_enable(1);
			printk(KERN_EMERG"[I2RND] I2rnd default timing fs\n");

			vsc_i2rnd_sub_stage = I2RND_STAGE_MAIN_I2RND_DONE;
			printk(KERN_EMERG"[I2RND]@@@@@@@@@@@@ I2RND_STAGE_MAIN_I2RND_DONE @@@@@@@@@@\n");
			return TRUE;
		}
#endif
		else {

			if (!modestate_set_framesync(info))  // if fs fail, keep in fs state
			{
				return FALSE;
			}
		}
#if 0//remove in k4lp
		//run scaler IM-domain flow to sync timing info after running smooth toggle@Crixus 20160919
		if((DbgSclrFlgTkr.game_mode_dynamic_flag == TRUE)&&(display == SLR_MAIN_DISPLAY))
		{
			rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"[GameMode][break for not setting d domain timing]Main re run scaler flow!!\n");
			//When enter or exit game mode, need to wait buffer write done @Crixus 20161005
			if(drv_memory_get_game_mode() == _ENABLE)
				game_mode_wait_frame = 1;//triple-buffer => single buffer, need to wait least 1 frame done.
			else
				game_mode_wait_frame = 3;//single-buffer => triple buffer, need to wait least 3 frame done.

			//Update the M-domain last done @Crixus 20161013
			drv_memory_wait_cap_last_write_done(SLR_MAIN_DISPLAY, game_mode_wait_frame, FALSE);
			state_update_disp_info();//send scaler info to smoothtoggle ,for issue KTASKWBS-6453
			return TRUE;
		}
#endif
#ifdef CONFIG_I2RND_ENABLE
		//update s1 memory tag info before send memory in fo video fw @Crixus 20171223
		if(display == SLR_MAIN_DISPLAY)
			i2rnd_s1_default_memory_tag();
#endif

#ifdef CONFIG_I2RND_B05_ENABLE
		//enable I2rnd_b05
         if (Scaler_I2rnd_b05_get_enable()) {
		 //	 Scaler_i2rnd_b05_buffer_copy();
             Scaler_I2rnd_b05_handler();
         }


#endif

#if(VSC_PROFILE == 1)
		after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Setup_IMD set Mdomain time=%d ms",(after_time-before_time));
		before_time = after_time;
#endif

		setup_imd_wait_hdr_type_finish();
#if(VSC_PROFILE == 1)
		after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Setup_IMD online measure enable time=%d ms", (after_time-before_time));
		before_time = after_time;
#endif
        update_vsc_task_status(0, VSC_M_DOMAIN);//clear M domain statsu
		update_vsc_task_status(1, VSC_D_DOMAIN);//clear M domain statsu

		if (((display == SLR_MAIN_DISPLAY) && get_main_OutputVencMode())
			|| ((display == SLR_SUB_DISPLAY) && get_sub_OutputVencMode())
			|| (DbgSclrFlgTkr.magnifier_mainscaler_run_livezoom == TRUE)) {
			/*not open disp*/
			//in VENC mode, apvr need to enable d-domain den start irq @Crixus 20161014
			drvif_scaler_ddomain_switch_irq(_ENABLE);
			if ((display == SLR_SUB_DISPLAY) && get_sub_OutputVencMode())
				drvif_scaler_sub_mdomain_switch_irq(_ENABLE);
		} else {
			Scaler_disp_setting(display);
		}

#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
	//rtd_setbits(TVSB2_TV_SB2_DCU1_ARB_CR1_reg,_BIT2|_BIT3);
	//if(DisplayModeInputInfo.type == VSC_INPUTSRC_VDEC || VencModeInputInfo.type ==VSC_INPUTSRC_VDEC || MemoryModeInputInfo.type ==VSC_INPUTSRC_VDEC)
			//if((rotatemode == ROTATE_MODE_90) || (rotatemode == ROTATE_MODE_180) || (rotatemode == ROTATE_MODE_270))
			if (TRUE == Get_rotate_function())
				scaler_Rotate_VI_init_send_rpc();
#endif

		if(judge_scaler_break_case(display)) {
			if(vbe_disp_decide_frc2fsync_using_I2D() == TRUE){
				drvif_scaler_set_display_mode_frc2fsync_I2D_disable();
			}
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####channel:%d scaler need to break 3!!!####\r\n", display);
			return FALSE;
		}

#if(VSC_PROFILE == 1)
		after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Setup_IMD set display time=%d ms",(after_time-before_time));
		before_time = after_time;
#endif
	//Scaler_DispSetInputInfo(SLR_INPUT_FAILURECOUNT, 0);

#ifndef CONFIG_MEMC_BYPASS
	if((Get_MEMC_Enable_Dynamic() == 1)
		&& (DbgSclrFlgTkr.magnifier_mainscaler_run_livezoom == FALSE)
		&& (!((Get_Live_zoom_mode() == LIVE_ZOOM_ON) && (display == SLR_SUB_DISPLAY)))){
		//run MEMC setting
		Scaler_MEMC_Handler();
	}

	// FixMe, 20190925
	//MEMC_Lib_set_INPUT_COLOR_SPACE_Mode(pc_mode_run_422());//I3DDMA_COLOR_SPACE_T

	if(0){//k-task8503 patch avoid set memc clk onoff(1) will mute main path
//	if(display == SLR_MAIN_DISPLAY){//k-task8503 patch avoid set memc clk onoff(1) will mute main path
		if(vbe_get_HDMI_dynamic_film_mode_flag()!= 1){
			if (vbe_dtg_memec_bypass_switch()) {
				pr_notice("[jerry_Scaler_MEMC_DTV_ME_CLK_OnOff_GGG][%d,%x]\n", ((rtd_inl(0xb8028100)>>13)&0x1), rtd_inl(0xb802e800));
				//Scaler_MEMC_Bypass_CLK(0);
				//Scaler_MEMC_Bypass_CLK_OnOff(0);
		#if 1
				Scaler_MEMC_DTV_ME_CLK_OnOff(0, 1);
		#endif
			} else {
				pr_notice("[jerry_Scaler_MEMC_DTV_ME_CLK_OnOff_HHH][%d,%x]\n", ((rtd_inl(0xb8028100)>>13)&0x1), rtd_inl(0xb802e800));
				//Scaler_MEMC_Bypass_CLK(1);
				//Scaler_MEMC_Bypass_CLK_OnOff(1);
		#if 1
				Scaler_MEMC_DTV_ME_CLK_OnOff(1, 1);
		#endif
			}
		}
	}
#else
pr_notice("[jerry_Scaler_MEMC_DTV_ME_CLK_OnOff_III]\n");
//	Scaler_MEMC_Bypass_CLK(0);
//	Scaler_MEMC_Bypass_CLK_OnOff(0);
	vbe_dtg_memec_bypass_switch_set(1);
	#if 1
		Scaler_MEMC_DTV_ME_CLK_OnOff(0, 1);
	#endif
#endif
	if(display == SLR_MAIN_DISPLAY)
	{
		check_di_buffer_mode();//Check DI buffer mode right or not. If wrong, recover it.
		Set_DI_SW_Detection_in_IMD(display);
	}

	setup_di_done_flag = (unsigned int *)Scaler_GetShareMemVirAddr(SCALERIOC_SETUP_DI_DONE);
	if(setup_di_done_flag)
    {
        *setup_di_done_flag = Scaler_ChangeUINT32Endian(1);
    }

    if(vbe_disp_oled_orbit_enable && SLR_MAIN_DISPLAY== display)
    {
        smooth_toggle_state_info_rpc(SLR_MAIN_DISPLAY);
        vo_smoothtoggle_memory_alloc(SLR_MAIN_DISPLAY);
    }

	if(Scaler_InputSrcGetType(display) == _SRC_VO)
	{
		MODE_CLEAR_ONMS_FLAG();
		if(!Get_vo_smoothtoggle_timingchange_flag(display))  //vo smooth toggle don't need onlinemeasure
		{
			if((Get_Live_zoom_mode() == LIVE_ZOOM_ON) && (display == SLR_SUB_DISPLAY)){
				/*qiangzhou added livezoom and magnifier case sub forbidden open wtd and interrupt and onlinemeasure*/
				drvif_mode_disableonlinemeasure(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
				drvif_mode_onlinemeasure_setting(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), Scaler_InputSrcGetMainChType(), FALSE, FALSE);
			} else {
				if((webos_src == VSC_INPUTSRC_VDEC) || (webos_src == VSC_INPUTSRC_JPEG)){
					//Real Vo case
					drvif_mode_enableonlinemeasure(display);//Enable online measure
					drvif_mode_onlinemeasure_setting(display, _SRC_VO, TRUE, FALSE);
				}
			}

		}

		if (get_scaler_stop_flag(display)) {
			if(vbe_disp_decide_frc2fsync_using_I2D() == TRUE){
				drvif_scaler_set_display_mode_frc2fsync_I2D_disable();
			}
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####channel:%d vsc already disconnet !!!####\r\n", display);
			return FALSE;
		} else if(get_vo_change_flag(Get_DisplayMode_Port(display))){
			if(vbe_disp_decide_frc2fsync_using_I2D() == TRUE){
				drvif_scaler_set_display_mode_frc2fsync_I2D_disable();
			}
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####channel:%d vo change!!!####\r\n", display);
			return FALSE;
		}
		down(get_vo_infosemaphore()); /* lock VO Semaphore */
#ifdef CONFIG_HDR_SDR_SEAMLESS
		if(display == SLR_MAIN_DISPLAY)
		{
			down(&HDR_Setting_Semaphore);
			if(!get_vo_change_flag(0)) {//main
				Scaler_DispSetInputInfo(SLR_INPUT_STATE, _MODE_STATE_ACTIVE);//For Video FW PQ
			}
			up(&HDR_Setting_Semaphore);
		}
		else
		{
			if(!get_vo_change_flag(1))//sub
				Scaler_DispSetInputInfo(SLR_INPUT_STATE, _MODE_STATE_ACTIVE);//For Video FW PQ
		}
#else
		if(display == SLR_MAIN_DISPLAY)
		{
			if(!get_vo_change_flag(0))//main
				Scaler_DispSetInputInfo(SLR_INPUT_STATE, _MODE_STATE_ACTIVE);//For Video FW PQ
		}
		else
		{
			if(!get_vo_change_flag(1))//sub
				Scaler_DispSetInputInfo(SLR_INPUT_STATE, _MODE_STATE_ACTIVE);//For Video FW PQ
		}
#endif
		up(get_vo_infosemaphore()); /* Release VO Semaphore */
		state_update_disp_info();//Update the active state
		if(((Get_vo_smoothtoggle_timingchange_flag(display)) && (get_vo_smoothtoggle_state(display) == SLR_SMOOTH_TOGGLE_INIT) && (Scaler_DispGetInputInfo(SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
			|| (Get_Live_zoom_mode() != LIVE_ZOOM_OFF))
		{
			smooth_toggle_preset_info(display);
			rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "enter SLR_SMOOTH_TOGGLE_ACTIVE state\n");
		}
	}
	else
	{
		if(judge_scaler_break_case(display) == FALSE)
		{
			if (get_scaler_stop_flag(display)) {
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####channel:%d vsc already disconnet !!!####\r\n", display);
				return FALSE;
			}

			if(Scaler_InputSrcGetType(display) == _SRC_TV) {
				if (display == SLR_MAIN_DISPLAY) {
#ifndef SPEEDUP_NEW_SCALER_FLOW
					down(&SetMainOutPutRegion_Semaphore);
					if(DbgSclrFlgTkr.Main_Output_Set_flag == TRUE) {
						up(&SetMainOutPutRegion_Semaphore);
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####Main Output change can not active!!!####\r\n");
						return FALSE;
					}
					up(&SetMainOutPutRegion_Semaphore);
#endif

				} else {
					down(&SetSubOutPutRegion_Semaphore);
					if(DbgSclrFlgTkr.Sub_Output_Set_flag == TRUE) {
						up(&SetSubOutPutRegion_Semaphore);
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####Sub Output change can not active!!!####\r\n");
						return FALSE;
					}
					up(&SetSubOutPutRegion_Semaphore);
				}
			}
			Scaler_DispSetInputInfo(SLR_INPUT_STATE, _MODE_STATE_ACTIVE);//For Video FW PQ
			state_update_disp_info();//Update the active state
		}
		else
		{
			if(vbe_disp_decide_frc2fsync_using_I2D() == TRUE){
				drvif_scaler_set_display_mode_frc2fsync_I2D_disable();
			}
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "####Online measure status error!!!####\r\n");
			return FALSE;
		}
	}
	MEMC_error_status_print_flag = 0;
	//rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "%s(line: %d)####display=%d(0:main, 1:sub)####\r\n", __func__, __LINE__, display);
	if((webos_src == VSC_INPUTSRC_ADC) && (get_ADC_Input_Source() == _SRC_YPBPR) && (auto_phase_flow_bypass() == FALSE)){

		//rtd_printk(KERN_INFO, TAG_NAME_VSC, "YPbPr auto phase---wait\n");
		drvif_ypbpr_auto_phasedo_WaitFinish(SLR_MAIN_DISPLAY);
		rtd_printk(KERN_INFO, TAG_NAME_VSC, "YPbPr auto phase---done\n");
		SyncProc_SetMinDiff(display);

		if(judge_scaler_break_case(display)) {
			if(vbe_disp_decide_frc2fsync_using_I2D() == TRUE){
				drvif_scaler_set_display_mode_frc2fsync_I2D_disable();
			}
			rtd_printk(KERN_INFO, TAG_NAME_VSC, "####after auto phase need to break!!!####\r\n");
			return FALSE;
		}
	}


#ifdef ADC_UP_DOWN_CLAMP
	if(webos_src == VSC_INPUTSRC_ADC){
		SyncProc_Check_UpDn_Stable(display);
	}
#else
	if(webos_src == VSC_INPUTSRC_ADC)
	{
		 abl_abl_status_RBUS abl_status_reg;
		 abl_abl_mgn_b_RBUS abl_mgn_b_reg;
		 abl_abl_mgn_rg_RBUS abl_mgn_rg_reg;
		 count = 50;
		 while(count > 0)	/* wait abl status ready */
		 {
			abl_status_reg.regValue = IoReg_Read32(ABL_ABL_STATUS_reg);
			if(abl_status_reg.abl_red_equal & abl_status_reg.abl_grn_equal & abl_status_reg.abl_blu_equal)
			{
				if(judge_scaler_break_case(display)){
					if(vbe_disp_decide_frc2fsync_using_I2D() == TRUE){
						drvif_scaler_set_display_mode_frc2fsync_I2D_disable();
					}
					return FALSE;
				}
				abl_mgn_rg_reg.regValue = IoReg_Read32(ABL_ABL_MGN_RG_reg);
				abl_mgn_rg_reg.abl_l_mgn_red = YPBPR_ABL_UV_LARGE_MARGIN;
				IoReg_Write32(ABL_ABL_MGN_RG_reg, abl_mgn_rg_reg.regValue);

				abl_mgn_b_reg.regValue = IoReg_Read32(ABL_ABL_MGN_B_reg);
				abl_mgn_b_reg.abl_l_mgn_blu = YPBPR_ABL_UV_LARGE_MARGIN;
				IoReg_Write32(ABL_ABL_MGN_B_reg, abl_mgn_b_reg.regValue);
				break;
			}
			else
			{
				count--;
				if((count%10) == 0) {
					if(judge_scaler_break_case(display)){
						if(vbe_disp_decide_frc2fsync_using_I2D() == TRUE){
							drvif_scaler_set_display_mode_frc2fsync_I2D_disable();
						}
						return FALSE;
					}
				}
				if(count == 0)
				{
					abl_mgn_rg_reg.regValue = IoReg_Read32(ABL_ABL_MGN_RG_reg);
					abl_mgn_rg_reg.abl_l_mgn_red = YPBPR_ABL_UV_LARGE_MARGIN;
					IoReg_Write32(ABL_ABL_MGN_RG_reg, abl_mgn_rg_reg.regValue);

					abl_mgn_b_reg.regValue = IoReg_Read32(ABL_ABL_MGN_B_reg);
					abl_mgn_b_reg.abl_l_mgn_blu = YPBPR_ABL_UV_LARGE_MARGIN;
					IoReg_Write32(ABL_ABL_MGN_B_reg, abl_mgn_b_reg.regValue);

					rtd_printk(KERN_INFO, TAG_NAME_VSC, "ABLStatus_Reg Count Time out!\n");
				}
				msleep(5);
			}
		 }
		//rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "%s(%d)-%s:  ABLStatus_Reg Count Time =%d !\n", __FILE__,__LINE__,__FUNCTION__, count);
	}
#endif

	if(webos_src == VSC_INPUTSRC_HDMI)
	{
		unsigned char check_framerate_result = TRUE;
		if(_FALSE == drvif_Hdmi_CheckStableBeforeDisplay())
			return FALSE;

		if(display == SLR_MAIN_DISPLAY)
		{
			if(get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1)
			{
				if(!check_online_result(SLR_MAIN_DISPLAY, _MAIN_VGIP_PATH))
					check_framerate_result = FALSE;
			}
			else
			{
				if(get_force_i3ddma_enable(SLR_MAIN_DISPLAY))
				{
					if(!check_online_result(SLR_MAIN_DISPLAY, _DAM_VGIP_PATH))
						check_framerate_result = FALSE;
				}
				else
				{
					if(!check_online_result(SLR_MAIN_DISPLAY, _MAIN_VGIP_PATH))
						check_framerate_result = FALSE;
				}
			}
		}
		else
		{
			if(!check_online_result(SLR_SUB_DISPLAY, _SUB_VGIP_PATH))
				check_framerate_result = FALSE;
		}
		if(check_framerate_result == FALSE)
		{
			reset_hdmi_timing_ready();
			vfe_hdmi_drv_handle_on_line_measure_error(0);
			return FALSE;
		}
	}

    if((display == SLR_MAIN_DISPLAY) && Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC))
	{
		//VDEC 2k1k use original flow, framesync with gatting
		if(((webos_src == VSC_INPUTSRC_VDEC)&& !((Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) > DATAFS_DISABLE_GATTING_WIDTH) && (Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN_PRE) > DATAFS_DISABLE_GATTING_HEIGHT)) && !drv_memory_get_game_mode_dynamic())
			||((webos_src == VSC_INPUTSRC_HDMI) && !drv_memory_get_game_mode_dynamic()) || (webos_src == VSC_INPUTSRC_JPEG))
		{
			//IoReg_SetBits(VODMA_VODMA_CLKGEN_reg,VODMA_VODMA_CLKGEN_en_fifo_full_gate_mask);

			if((display == SLR_MAIN_DISPLAY) && (webos_src == VSC_INPUTSRC_VDEC) && (Scaler_Get_Vo_Force_60_Framerate_State() == 1)) {
				rtd_printk(KERN_EMERG, "VSC", "Delay Gating!\n");
			}else{
				scaler_set_full_gatting_rpc(true);
				pr_notice("Enable gatting delay to input timing change\n");
			}

		}
	}


	if (display == SLR_MAIN_DISPLAY){
		//add main double buffer apply @Crixus 20160126
		imd_smooth_main_double_buffer_all_apply();
		if(Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC) == FALSE){
			//Update the M-domain last done @Crixus 20161013
			if ((TRUE == Get_rotate_function()) && (get_rotate_mode()!=DIRECT_VO_FRAME_ORIENTATION_DEFAULT))
				drv_memory_wait_mdom_vi_last_write_done(SLR_MAIN_DISPLAY, 3);//triple buf for rotate
			else
				drv_memory_wait_cap_last_write_done(SLR_MAIN_DISPLAY, 1, FALSE);

			//if input fast case, it need to wait capture done, then set FRC style.
			if(mdomain_input_fast_flag){
				drv_memory_display_set_input_fast();
				mdomain_input_fast_flag = 0;
			}
		}
		set_mdomain_driver_status(TRUE);//m domain driver ready
	} else {
		//add sub double buffer apply @Crixus 20160126
		imd_smooth_sub_double_buffer_all_apply();
#ifdef CONFIG_I2RND_ENABLE
		if(!(Scaler_I2rnd_get_timing_enable()) && (Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC) == FALSE)){
#else
		if(Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC) == FALSE){
#endif
			if (!get_sub_OutputVencMode()) {//sub m domain iterrupt open so don't need wait lastwrite @qing_liu --s4ap
				//Update the M-domain last done @Crixus 20161013
				drv_memory_wait_cap_last_write_done(SLR_SUB_DISPLAY, 1, FALSE);
			}
		}
	}

	if(judge_scaler_break_case(display)) {
		if(vbe_disp_decide_frc2fsync_using_I2D() == TRUE){
			drvif_scaler_set_display_mode_frc2fsync_I2D_disable();
		}
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####channel:%d scaler need to break 4!!!####\r\n", display);
		return FALSE;
	}
	//wait_DI_ready();//wait DI ready

	if(judge_scaler_break_case(display)) {
		if(vbe_disp_decide_frc2fsync_using_I2D() == TRUE){
			drvif_scaler_set_display_mode_frc2fsync_I2D_disable();
		}
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####channel:%d scaler need to break 5!!!####\r\n", display);
		return FALSE;
	}

	record_Setup_IMD_timer_counter = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);//record current 90k counter
#ifdef _PRINT_AVD_COST_TIME
	rtd_printk(KERN_INFO, TAG_NAME_VSC,"_PRINT_AVD_COST_TIME: %s(%d) time = %d\n",__FUNCTION__,__LINE__,IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90);
#endif

    update_vsc_task_status(0, VSC_D_DOMAIN);//clear M domain statsu

	return TRUE;
}

void drvif_vodma_di_freeze(unsigned char bFreeze)
{
	int ret;
	if (0 != (ret = Scaler_SendRPC(SCALERIOC_SET_VODMADI_FREEZE_ENABLE,bFreeze,1))){
		pr_emerg("[dc2h]ret=%d, SCALERIOC_SET_VODMADI_FREEZE_ENABLE RPC fail !!!\n", ret);
	}
}


void Scaler_SetFreeze(unsigned char channel, unsigned char mode)
{
#ifdef CONFIG_FORCE_RUN_I3DDMA
	VSC_INPUT_TYPE_T srctype;
	srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);

	if (SLR_MAIN_DISPLAY == channel) {
		if((srctype != VSC_INPUTSRC_VDEC)&&(srctype != VSC_INPUTSRC_JPEG)&&(Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE)==FALSE)){
			/*livezoom on k4lp,for smoothtgogle,could not m domain freeze, so progressive hdmi do freeze at i3ddma capture*/
			drvif_I3DDMA_freeze(mode);

		} else {
			if(mode == TRUE) {
				if (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE))
					drvif_vodma_di_freeze(0);/*di freeze on*/
				else
					drvif_vodma_di_freeze(1);/*vo freeze on*/
			} else {
				if (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE))
					drvif_vodma_di_freeze(2);/*di freeze off*/
				else
					drvif_vodma_di_freeze(3);/*vo freeze off*/
			}
		}
	}
#else
	if (Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)channel, SLR_INPUT_FRAMESYNC))
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "drvif_color_di_freeze\n");
		drvif_color_di_freeze(mode);
	}
	else
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "drvif_scalerdisplay_set_freeze\n");
		drvif_scalerdisplay_set_freeze(channel, mode);
	}
#endif
}

extern void magnifier_color_ultrazoom_config_scaling_up(unsigned char display);
//extern void imd_smooth_enable_sub_double_buffer(unsigned char bEnable);

unsigned char Scaler_DispWindowZoomin(SCALER_DISP_CHANNEL display, KADP_VIDEO_RECT_T inputwin, KADP_VIDEO_RECT_T outputwin, unsigned short W, unsigned short H, unsigned char changetomain)
{
	unsigned short usAfterDILen = 0;
	unsigned short usAfterDIWid = 0;
	unsigned short mDomainCapLen = 0;
	unsigned short mDomainCapWid = 0;

	mdomain_disp_ddr_mainsubctrl_RBUS mdomain_disp_ddr_mainsubctrl_Reg;
	ppoverlay_double_buffer_ctrl_RBUS ppoverlay_double_buffer_ctrl_Reg;
	scaleup_dm_uzu_db_ctrl_RBUS scaleup_dm_uzu_db_ctrl_Reg;
	scaleup_ds_uzu_db_ctrl_RBUS scaleup_ds_uzu_db_ctrl_Reg;
	ppoverlay_double_buffer_ctrl2_RBUS double_buffer_ctrl_reg;

	if (((outputwin.x + outputwin.w) > _DISP_WID) || ((outputwin.y + outputwin.h) > _DISP_LEN)) {
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Zoom in fail, for out size out of panel range\n");
		return FALSE;
	}

	if (display == SLR_SUB_DISPLAY)
	{
		sub_dispwin.srcx = outputwin.x;
		sub_dispwin.srcy = outputwin.y;
		sub_dispwin.src_height = outputwin.h;
		sub_dispwin.src_wid = outputwin.w;
		Scaler_SubDispWindowSet(sub_dispwin);
	} else {
		main_dispwin.srcx = outputwin.x;
		main_dispwin.srcy = outputwin.y;
		main_dispwin.src_height = outputwin.h;
		main_dispwin.src_wid = outputwin.w;

		Scaler_DispWindowSet(main_dispwin);
	}

	/*livezoom & magnifier DI Len Wid is the same*/
	if (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE)) {
		usAfterDILen =	(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN) << 1);
	} else {
		usAfterDILen = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN);
	}
	usAfterDIWid = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID);

	if ((display == SLR_SUB_DISPLAY) && (changetomain == TRUE))
	{
		mDomainCapLen = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_CAP_LEN);
		mDomainCapWid = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_CAP_WID);
	} else {
		mDomainCapLen = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_CAP_LEN);
		mDomainCapWid = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_CAP_WID);
	}

	/*if(Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE)) {
		Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_LEN, mDomainCapLen * inputwin.h / usAfterDILen);
		Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_VSTA, mDomainCapLen * (inputwin.y) / usAfterDILen);
	} else */{
		Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_LEN, mDomainCapLen * inputwin.h / usAfterDILen);
		Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_VSTA, mDomainCapLen * (inputwin.y) / usAfterDILen);
	}

	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID, mDomainCapWid * inputwin.w / usAfterDIWid);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA, mDomainCapWid * inputwin.x/ usAfterDIWid);


	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID, drvif_memory_get_data_littlealign(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID), 4));
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA, drvif_memory_get_data_littlealign(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA), 4));

	if ((Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA)  + Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID)) > mDomainCapWid) {
		Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID, (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) - 4));
	}


	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_DISP_WID, outputwin.w);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_DISP_LEN, outputwin.h);

	if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) < Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_DISP_WID)){
		Scaler_DispSetScaleStatus(display, SLR_SCALE_H_UP, TRUE);
	}else{
		Scaler_DispSetScaleStatus(display, SLR_SCALE_H_UP, FALSE);
	}

	if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_LEN) < Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_DISP_LEN))
		Scaler_DispSetScaleStatus(display, SLR_SCALE_V_UP, TRUE);
	else
		Scaler_DispSetScaleStatus(display, SLR_SCALE_V_UP, FALSE);

	if (display == SLR_SUB_DISPLAY) {
		//IoReg_SetBits(MDOMAIN_DISP_DDR_MainSubCtrl_reg, _BIT17);
		mdomain_disp_ddr_mainsubctrl_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
		mdomain_disp_ddr_mainsubctrl_Reg.disp2_double_enable = 1;
		mdomain_disp_ddr_mainsubctrl_Reg.disp2_db_rd_sel = 0;
		IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, mdomain_disp_ddr_mainsubctrl_Reg.regValue);

		//IoReg_SetBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT6);//Enable dtg double buffer register
		ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
		ppoverlay_double_buffer_ctrl_Reg.dsubreg_dbuf_en = 1;
		ppoverlay_double_buffer_ctrl_Reg.dsubreg_dbuf_read_sel = 1;
		IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);

		//WOSQRTK-8859:dtgm2uzu_delay set to non-zero, dbuf_vs_sel need to select the value after delay time.
		double_buffer_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL2_reg);
		double_buffer_ctrl_reg.uzudtgreg_dbuf_en = 1;
		double_buffer_ctrl_reg.uzudtg_dbuf_vsync_sel = 3;//using uzudtg vsync
		IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL2_reg, double_buffer_ctrl_reg.regValue);

		//IoReg_SetBits(SCALEUP_DS_UZU_DB_CTRL_reg, _BIT2);//Enable uzu double buffer register
		scaleup_ds_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DS_UZU_DB_CTRL_reg);
		scaleup_ds_uzu_db_ctrl_Reg.db_en = 1;
		scaleup_ds_uzu_db_ctrl_Reg.db_read_level = 1;
		IoReg_Write32(SCALEUP_DS_UZU_DB_CTRL_reg, scaleup_ds_uzu_db_ctrl_Reg.regValue);
	} else {
		//IoReg_SetBits(MDOMAIN_DISP_DDR_MainSubCtrl_reg, _BIT1);
		mdomain_disp_ddr_mainsubctrl_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
		mdomain_disp_ddr_mainsubctrl_Reg.disp1_double_enable = 1;
		mdomain_disp_ddr_mainsubctrl_Reg.disp1_db_rd_sel = 0;
		IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, mdomain_disp_ddr_mainsubctrl_Reg.regValue);

		//IoReg_SetBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT1);//Enable dtg double buffer register
		ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
		ppoverlay_double_buffer_ctrl_Reg.dreg_dbuf_read_sel = 1;
		ppoverlay_double_buffer_ctrl_Reg.dreg_dbuf_en = 1;
		IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);

		double_buffer_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL2_reg);
		double_buffer_ctrl_reg.uzudtgreg_dbuf_en = 1;
		double_buffer_ctrl_reg.uzudtg_dbuf_vsync_sel = 3;//using uzudtg vsync
		IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL2_reg, double_buffer_ctrl_reg.regValue);

		//IoReg_SetBits(SCALEUP_DM_UZU_DB_CTRL_reg, _BIT2);//Enable uzu double buffer register
		scaleup_dm_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DM_UZU_DB_CTRL_reg);
		scaleup_dm_uzu_db_ctrl_Reg.db_read_level = 1;
		scaleup_dm_uzu_db_ctrl_Reg.db_en = 1;
		IoReg_Write32(SCALEUP_DM_UZU_DB_CTRL_reg, scaleup_dm_uzu_db_ctrl_Reg.regValue);

	}
	//imd_smooth_enable_sub_double_buffer(TRUE);

	/*IoReg_SetBits(MDOMAIN_DISP_DDR_MainSubCtrl_reg, _BIT17);//Enable double buffer register*/
	/*WaitFor_DEN_START();*/
	/*WaitFor_DEN_STOP_Done_SUB();*/
	/*sub m domain display*/
	if (display == SLR_SUB_DISPLAY) {
		memory_set_sub_displaywindow_change(changetomain);
	} else {
		memory_set_main_displaywindow_change();
	}
	/*sub uzu*/
	magnifier_color_ultrazoom_config_scaling_up(display);

	if (display == SLR_SUB_DISPLAY) {
		PipmpSetSubDisplayWindow(
			outputwin.x, outputwin.x + Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_DISP_WID),
			outputwin.y, outputwin.y + Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_DISP_LEN),
			0);

		PipmpSetSubActiveWindow(
			0, Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_DISP_WID),
			0, Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_DISP_LEN));

	} else {
		ppoverlay_main_active_h_start_end_RBUS main_active_h_start_end_reg;
		ppoverlay_main_active_v_start_end_RBUS main_active_v_start_end_reg;

		// Main Active H pos
		main_active_h_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_H_Start_End_reg);
		main_active_h_start_end_reg.mh_act_sta = outputwin.x & 0x0fff;
		main_active_h_start_end_reg.mh_act_end = (outputwin.x + outputwin.w) & 0x0fff;
		IoReg_Write32(PPOVERLAY_MAIN_Active_H_Start_End_reg, main_active_h_start_end_reg.regValue);

		// Main Active V pos
		main_active_v_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_V_Start_End_reg);
		main_active_v_start_end_reg.mv_act_sta = outputwin.y & 0x0fff;
		main_active_v_start_end_reg.mv_act_end = (outputwin.y + outputwin.h) & 0x0fff;
		IoReg_Write32(PPOVERLAY_MAIN_Active_V_Start_End_reg, main_active_v_start_end_reg.regValue);

	}

	if (display == SLR_SUB_DISPLAY)
	{
		//if (subWin_LGowner)
			//set_vsc_SetCircle_OutputRegion(outputwin, W, H, sub_shape_type);
		//else
			//set_vsc_SetCircle_OutputRegion(outputwin, W, H, sub_window_type);
	}

	if (display == SLR_SUB_DISPLAY) {

		unsigned int uzulinecntA =0;
		unsigned int uzulinecntB =0;

		unsigned int timeoutcount = 0x3ffff;
		ppoverlay_dv_den_start_end_RBUS dv_den_start_end_reg;
		ppoverlay_new_meas2_linecnt_real_RBUS new_meas2_linecnt_real_reg;

		dv_den_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_DV_DEN_Start_End_reg);

		do {
			new_meas2_linecnt_real_reg.regValue = IoReg_Read32(PPOVERLAY_new_meas2_linecnt_real_reg);
			uzulinecntA = new_meas2_linecnt_real_reg.uzudtg_dly_line_cnt_rt;
			new_meas2_linecnt_real_reg.regValue = IoReg_Read32(PPOVERLAY_new_meas2_linecnt_real_reg);
			uzulinecntB = new_meas2_linecnt_real_reg.uzudtg_dly_line_cnt_rt;
			if((uzulinecntA == uzulinecntB)&&((uzulinecntA < (dv_den_start_end_reg.dv_den_end-100)) && (uzulinecntA > (dv_den_start_end_reg.dv_den_sta+100))))
			{
				ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\n *****   uzulinecntA =%d, dv_den_end =%d, dsubreg_dbuf_en =%d  ", uzulinecntA, dv_den_start_end_reg.dv_den_end, ppoverlay_double_buffer_ctrl_Reg.dsubreg_dbuf_en);

				mdomain_disp_ddr_mainsubctrl_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
				mdomain_disp_ddr_mainsubctrl_Reg.disp2_double_apply = 1;
				IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, mdomain_disp_ddr_mainsubctrl_Reg.regValue);

				ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
				ppoverlay_double_buffer_ctrl_Reg.dsubreg_dbuf_set = 1;
				IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);

				scaleup_ds_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DS_UZU_DB_CTRL_reg);
				scaleup_ds_uzu_db_ctrl_Reg.db_apply = 1;
				IoReg_Write32(SCALEUP_DS_UZU_DB_CTRL_reg, scaleup_ds_uzu_db_ctrl_Reg.regValue);

				new_meas2_linecnt_real_reg.regValue = IoReg_Read32(PPOVERLAY_new_meas2_linecnt_real_reg);
				uzulinecntB = new_meas2_linecnt_real_reg.uzudtg_dly_line_cnt_rt;

				ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\n *****   uzulinecntB =%d, dv_den_end =%d, dsubreg_dbuf_en =%d  ", uzulinecntA, dv_den_start_end_reg.dv_den_end, ppoverlay_double_buffer_ctrl_Reg.dsubreg_dbuf_en);

				break;
			}
			timeoutcount--;
		} while(timeoutcount);

		if(timeoutcount == 0)
		{
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\n *****   uzulinecntC =%d, dv_den_end =%d ", uzulinecntB, dv_den_start_end_reg.dv_den_end);

			mdomain_disp_ddr_mainsubctrl_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
			mdomain_disp_ddr_mainsubctrl_Reg.disp2_double_apply = 1;
			IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, mdomain_disp_ddr_mainsubctrl_Reg.regValue);

			ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
			ppoverlay_double_buffer_ctrl_Reg.dsubreg_dbuf_set = 1;
			IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);

			scaleup_ds_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DS_UZU_DB_CTRL_reg);
			scaleup_ds_uzu_db_ctrl_Reg.db_apply = 1;
			IoReg_Write32(SCALEUP_DS_UZU_DB_CTRL_reg, scaleup_ds_uzu_db_ctrl_Reg.regValue);
		}

#if 0
		tmp = 0;
		while((IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg)&_BIT4) || (IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg)&_BIT16) || (IoReg_Read32(SCALEUP_DS_UZU_DB_CTRL_reg)&_BIT0)){
			msleep(1);
			if(++tmp>30)
				break;
		}

		mdomain_disp_ddr_mainsubctrl_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
		mdomain_disp_ddr_mainsubctrl_Reg.disp2_double_enable = 0;
		IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, mdomain_disp_ddr_mainsubctrl_Reg.regValue);

		//IoReg_ClearBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT6);//Disable double buffer register
		ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
		ppoverlay_double_buffer_ctrl_Reg.dsubreg_dbuf_en = 0;
		IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);

		//IoReg_ClearBits(SCALEUP_DS_UZU_DB_CTRL_reg, _BIT2);//Disable uzu double buffer register
		scaleup_ds_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DS_UZU_DB_CTRL_reg);
		scaleup_ds_uzu_db_ctrl_Reg.db_en = 0;
		IoReg_Write32(SCALEUP_DS_UZU_DB_CTRL_reg, scaleup_ds_uzu_db_ctrl_Reg.regValue);
#endif
	} else {


		unsigned int uzulinecntA =0;
		unsigned int uzulinecntB =0;

		unsigned int timeoutcount = 0x3ffff;
		ppoverlay_dv_den_start_end_RBUS dv_den_start_end_reg;
		ppoverlay_new_meas2_linecnt_real_RBUS new_meas2_linecnt_real_reg;

		dv_den_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_DV_DEN_Start_End_reg);

		do {
			new_meas2_linecnt_real_reg.regValue = IoReg_Read32(PPOVERLAY_new_meas2_linecnt_real_reg);
			uzulinecntA = new_meas2_linecnt_real_reg.uzudtg_dly_line_cnt_rt;
			new_meas2_linecnt_real_reg.regValue = IoReg_Read32(PPOVERLAY_new_meas2_linecnt_real_reg);
			uzulinecntB = new_meas2_linecnt_real_reg.uzudtg_dly_line_cnt_rt;
			if((uzulinecntA == uzulinecntB)&&((uzulinecntA < (dv_den_start_end_reg.dv_den_end-100)) && (uzulinecntA > (dv_den_start_end_reg.dv_den_sta+100))))
			{
				//load M domain double buffer
				mdomain_disp_ddr_mainsubctrl_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
				mdomain_disp_ddr_mainsubctrl_Reg.disp1_double_apply = 1;
				IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, mdomain_disp_ddr_mainsubctrl_Reg.regValue);

				//load D domaindouble buffer register
				ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
				ppoverlay_double_buffer_ctrl_Reg.dreg_dbuf_set = 1;
				IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);

				//load uzu double buffer
				scaleup_dm_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DM_UZU_DB_CTRL_reg);
				scaleup_dm_uzu_db_ctrl_Reg.db_apply = 1;
				IoReg_Write32(SCALEUP_DM_UZU_DB_CTRL_reg, scaleup_dm_uzu_db_ctrl_Reg.regValue);
				break;
			}
			timeoutcount--;
		} while(timeoutcount);

		if(timeoutcount == 0)
		{
			//load M domain double buffer
			mdomain_disp_ddr_mainsubctrl_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
			mdomain_disp_ddr_mainsubctrl_Reg.disp1_double_apply = 1;
			IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, mdomain_disp_ddr_mainsubctrl_Reg.regValue);

			//load D domaindouble buffer register
			ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
			ppoverlay_double_buffer_ctrl_Reg.dreg_dbuf_set = 1;
			IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);

			//load uzu double buffer
			scaleup_dm_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DM_UZU_DB_CTRL_reg);
			scaleup_dm_uzu_db_ctrl_Reg.db_apply = 1;
			IoReg_Write32(SCALEUP_DM_UZU_DB_CTRL_reg, scaleup_dm_uzu_db_ctrl_Reg.regValue);
		}

#if 0
		tmp = 0;
		while((IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg)&_BIT0) || (IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg)&_BIT0) || (IoReg_Read32(SCALEUP_DM_UZU_DB_CTRL_reg)&_BIT0)){
			msleep(1);
			if(++tmp>30)
				break;
		}

		mdomain_disp_ddr_mainsubctrl_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
		mdomain_disp_ddr_mainsubctrl_Reg.disp1_double_enable = 0;
		IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, mdomain_disp_ddr_mainsubctrl_Reg.regValue);

		//IoReg_ClearBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT2);//Disable double buffer register
		ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
		ppoverlay_double_buffer_ctrl_Reg.dreg_dbuf_en = 0;
		IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);

		//IoReg_ClearBits(SCALEUP_DS_UZU_DB_CTRL_reg, _BIT2);//Disable uzu double buffer register
		scaleup_dm_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DM_UZU_DB_CTRL_reg);
		scaleup_dm_uzu_db_ctrl_Reg.db_en = 0;
		IoReg_Write32(SCALEUP_DM_UZU_DB_CTRL_reg, scaleup_dm_uzu_db_ctrl_Reg.regValue);
#endif
	}
	return TRUE;
}

unsigned short Scaler_CalAVD27MWidth(SCALER_DISP_CHANNEL display,unsigned short a_usInput)
{
	unsigned short usRet = a_usInput;

	//printk("file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);

	//rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"outregion.w=%d,display=%d,  outputRegion, orginal x=%d, y=%d, w=%d, h=%d\n", outregion->w,display,Main_InputRegion_x, Main_InputRegion_y, Main_InputRegion_w, Main_InputRegion_h);

	//if (outregion->w >= AVD_DI_5A_WIDTH )
	if(VD_27M_HSD960_DI5A == fw_video_get_27mhz_mode(display))
	{
		if (display == SLR_MAIN_DISPLAY)
		{
			usRet = a_usInput * AVD_DI_5A_WIDTH/AVD_27M_VGIP_WIDTH * 2;
		}
#ifdef CONFIG_DUAL_CHANNEL
		else
		{

		// Sub can use DI
		#ifdef CONFIG_I2RND_ENABLE
			usRet = a_usInput * AVD_DI_5A_WIDTH/AVD_27M_VGIP_WIDTH * 2;
		#else
			// By pass DI
			usRet = a_usInput * 2;
		#endif
		}
#endif
	}
	else if(VD_27M_HSD1440_DI3A== fw_video_get_27mhz_mode(display))
	{
		usRet = a_usInput * 2;
	}

	return usRet;

}


unsigned char Scaler_CalWindowZoominForAVD(SCALER_DISP_CHANNEL display,VIDEO_RECT_T *inregion, VIDEO_RECT_T *outregion)
{
	VIDEO_RECT_T tmpinregion;

#if 1
	if (display == SLR_MAIN_DISPLAY)
	{
		tmpinregion.x = Main_InputRegion_x;
		tmpinregion.y = Main_InputRegion_y;
		tmpinregion.w = Main_InputRegion_w;
		tmpinregion.h = Main_InputRegion_h;

		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"Main path inputRegion, orginal x=%d, y=%d, w=%d, h=%d\n", Main_InputRegion_x, Main_InputRegion_y, Main_InputRegion_w, Main_InputRegion_h);
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if (display == SLR_SUB_DISPLAY)
	{
		tmpinregion.x = Sub_InputRegion_x;
		tmpinregion.y = Sub_InputRegion_y / 2;  // ByPass DI
		tmpinregion.w = Sub_InputRegion_w;
		tmpinregion.h = Sub_InputRegion_h / 2;  // ByPass ID

		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"Sub path inputRegion, orginal x=%d, y=%d, w=%d, h=%d\n", Main_InputRegion_x, Main_InputRegion_y, Main_InputRegion_w, Main_InputRegion_h);
	}
#endif

#endif


	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"outregion.w=%d,display=%d,  outputRegion, orginal x=%d, y=%d, w=%d, h=%d\n", outregion->w,display,Main_InputRegion_x, Main_InputRegion_y, Main_InputRegion_w, Main_InputRegion_h);

	if (outregion->w >= AVD_DI_5A_WIDTH )
	{
		if (display == SLR_MAIN_DISPLAY)
		{
			inregion->x = tmpinregion.x*2*AVD_DI_5A_WIDTH/AVD_27M_VGIP_WIDTH ;
			inregion->y = tmpinregion.y;
			inregion->w = tmpinregion.w*2*AVD_DI_5A_WIDTH/AVD_27M_VGIP_WIDTH ;
			inregion->h = tmpinregion.h;

			#ifdef CONFIG_FIXED_VD_27MHZ_960_TO_UZU
				inregion->x = 0;
				inregion->w = 960;
			#endif
		}
#ifdef CONFIG_DUAL_CHANNEL
		else
		{
			inregion->x = tmpinregion.x*2;
			inregion->y = tmpinregion.y;
			inregion->w = tmpinregion.w*2;
			inregion->h = tmpinregion.h;
		}
#endif
	}
	else
	{
		if (outregion->w > tmpinregion.w)
		{
			inregion->x = tmpinregion.x;
			inregion->y = tmpinregion.y;
			inregion->w = tmpinregion.w;
			inregion->h = tmpinregion.h;
		}
		else
		{
			inregion->x = (tmpinregion.x *2*outregion->w)/AVD_27M_VGIP_WIDTH;
			inregion->y = tmpinregion.y;
			inregion->w = (tmpinregion.w *2*outregion->w)/AVD_27M_VGIP_WIDTH;
			inregion->h = tmpinregion.h;

			rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"inregion.w=%d, outregion.w=%d\n", inregion->w, outregion->w);
		}
	}

	#if 1
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"rtk_run_scaler 1 inregion x=%d, y=%d, w=%d, h=%d\n", inregion->x, inregion->y, inregion->w, inregion->h);
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"rtk_run_scaler 1 outregion x=%d, y=%d, w=%d, h=%d\n", outregion->x, outregion->y, outregion->w, outregion->h);
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"**** Scaler_DispWindowZoominForAVD()\n");
	#endif

	#if 0
	rtd_printk(KERN_EMERG, TAG_NAME_VSC, "display=%d\n", display);
	rtd_printk(KERN_EMERG, TAG_NAME_VSC, "file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	rtd_printk(KERN_EMERG, TAG_NAME_VSC, "rtk_run_scaler 1 inregion x=%d, y=%d, w=%d, h=%d\n", inregion->x, inregion->y, inregion->w, inregion->h);
	rtd_printk(KERN_EMERG, TAG_NAME_VSC, "rtk_run_scaler 1 outregion x=%d, y=%d, w=%d, h=%d\n", outregion->x, outregion->y, outregion->w, outregion->h);
	rtd_printk(KERN_EMERG, TAG_NAME_VSC, "**** Scaler_DispWindowZoominForAVD()\n");
	#endif

	return TRUE;
}

extern void avdmdsmooth_color_ultrazoom_config_scaling_up(unsigned char display);
unsigned char Scaler_DispWindowZoominForAVD(SCALER_DISP_CHANNEL display, VIDEO_RECT_T inputwin, VIDEO_RECT_T outputwin, unsigned char changetomain)
{
	unsigned short usAfterDILen = 0;
	unsigned short usAfterDIWid = 0;
	unsigned short mDomainCapLen = 0;
	unsigned short mDomainCapWid = 0;
	unsigned short x_offset = 0;
	unsigned short w_offset = 0;
	unsigned int ulMemActLen;
	unsigned int ulMemActSta;

	mdomain_disp_ddr_mainsubctrl_RBUS mdomain_disp_ddr_mainsubctrl_Reg;
	ppoverlay_double_buffer_ctrl_RBUS ppoverlay_double_buffer_ctrl_Reg;
	scaleup_dm_uzu_db_ctrl_RBUS scaleup_dm_uzu_db_ctrl_Reg;
	scaleup_ds_uzu_db_ctrl_RBUS scaleup_ds_uzu_db_ctrl_Reg;


	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);

	if (((outputwin.x + outputwin.w) > _DISP_WID) || ((outputwin.y + outputwin.h) > _DISP_LEN)) {
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"Zoom in fail, for out size out of panel range\n");
		return FALSE;
	}

	if (display == SLR_SUB_DISPLAY) {
		sub_dispwin.srcx = outputwin.x;
		sub_dispwin.srcy = outputwin.y;
		sub_dispwin.src_height = outputwin.h;
		sub_dispwin.src_wid = outputwin.w;
		Scaler_SubDispWindowSet(sub_dispwin);
	} else {
		main_dispwin.srcx = outputwin.x;
		main_dispwin.srcy = outputwin.y;
		main_dispwin.src_height = outputwin.h;
		main_dispwin.src_wid = outputwin.w;

		Scaler_DispWindowSet(main_dispwin);
	}

	if (display == SLR_MAIN_DISPLAY)
	{
		/*livezoom & magnifier DI Len Wid is the same*/
		if (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE)) {
			usAfterDILen =	(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN) << 1);
		} else {
			//usAfterDILen = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN);
			usAfterDILen = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_LEN);
		}

		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"main path usAfterDILen=%d\n", usAfterDILen);
	}
	else
	{
		usAfterDILen = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_LEN);

		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"sub path usAfterDILen=%d\n", usAfterDILen);
	}

	if ((display == SLR_SUB_DISPLAY) && (changetomain == TRUE))
	{
		mDomainCapLen = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_CAP_LEN);
		mDomainCapWid = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_CAP_WID);
	} else {
		mDomainCapLen = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_CAP_LEN);
		mDomainCapWid = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_CAP_WID);
	}

	usAfterDIWid = mDomainCapWid;

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"mDomainCapLen=%d, mDomainCapWid=%d\n", mDomainCapLen, mDomainCapWid);

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"inputwin.y=%d,  SLR_INPUT_IPV_ACT_STA=%d, SLR_INPUT_IPV_ACT_STA_PRE=%d, usAfterDILen=%d\n", inputwin.y, Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_STA), Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_STA_PRE), usAfterDILen);

#if 1
		if (inputwin.w > mDomainCapWid)
		{
			if (SLR_MAIN_DISPLAY == display)
			{
				inputwin.x = inputwin.x * mDomainCapWid / AVD_DI_5A_WIDTH ;
				inputwin.w = inputwin.w * mDomainCapWid / AVD_DI_5A_WIDTH ;
			}
			else
			{
				inputwin.x = inputwin.x * mDomainCapWid / AVD_27M_VGIP_WIDTH ;;
				inputwin.w = inputwin.w * mDomainCapWid / AVD_27M_VGIP_WIDTH ;

			}

		}
		else if (mDomainCapWid > AVD_NORMAL_WIDTH && mDomainCapWid < AVD_DI_5A_WIDTH)
		{
			inputwin.x = inputwin.x * mDomainCapWid / AVD_NORMAL_WIDTH;
			inputwin.w = inputwin.w * mDomainCapWid / AVD_NORMAL_WIDTH;
		}

		/*
		if (inputwin.h >= mDomainCapLen)
		{
			inputwin.h = mDomainCapLen;
			inputwin.y = 0;
		}
		*/
#endif

	ulMemActLen =  inputwin.h * mDomainCapLen / usAfterDILen;
	ulMemActSta = inputwin.y * mDomainCapLen / usAfterDILen;

	//printk("ulMemActLen = %d\n", ulMemActLen);

	if (ulMemActLen > mDomainCapLen)
	{
		ulMemActLen = mDomainCapLen;
		ulMemActSta = 0;
	}
	//printk("2 ulMemActLen = %d\n", ulMemActLen);


	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_LEN, ulMemActLen);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_VSTA, ulMemActSta);


#if 0
	if (display == SLR_MAIN_DISPLAY)
	{
		if(Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE)) {
			Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_LEN, mDomainCapLen * inputwin.h / usAfterDILen);
			//Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_VSTA, mDomainCapLen * (inputwin.y - 2*(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_STA) - Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_STA_PRE))) / usAfterDILen);
			Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_VSTA, inputwin.y * inputwin.h / usAfterDILen);
		} else {
			Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_LEN, mDomainCapLen * inputwin.h / usAfterDILen);
			Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_VSTA, mDomainCapLen * (inputwin.y - (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_STA) - Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_STA_PRE))) / usAfterDILen);
		}
	}
	else
	{
#if 0
		if (inputwin.w > mDomainCapWid)
		{
			if (SLR_MAIN_DISPLAY == display)
			{
				inputwin.x = 0;
				inputwin.w = inputwin.w * mDomainCapWid / AVD_DI_5A_WIDTH ;
			}
			else
			{
				inputwin.x = 0;
				inputwin.w = inputwin.w * mDomainCapWid / AVD_27M_VGIP_WIDTH ;

			}

		}

		if (inputwin.h >= mDomainCapLen)
		{
			inputwin.h = mDomainCapLen;
			inputwin.y = 0;
		}
#endif
		Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_LEN, mDomainCapLen * inputwin.h / usAfterDILen);
		Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_VSTA, inputwin.y * inputwin.h / usAfterDILen);
	}

#endif

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"SLR_INPUT_MEM_ACT_LEN=%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_LEN));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"SLR_INPUT_MEM_ACT_VSTA=%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_VSTA));

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"mDomainCapWid = %d,inputwin.w=%d,usAfterDIWid=%d\n",mDomainCapWid,inputwin.w,usAfterDIWid);

	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID, mDomainCapWid * inputwin.w / usAfterDIWid);
	//Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA, mDomainCapWid * (inputwin.x - (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_STA) - Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_STA_PRE))) / usAfterDIWid);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA, inputwin.x);

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"SLR_INPUT_MEM_ACT_WID=%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"SLR_INPUT_MEM_ACT_HSTA=%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA));

	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID, drvif_memory_get_data_align(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID), 2));
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA, drvif_memory_get_data_align(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA), 2));

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"align 2 SLR_INPUT_MEM_ACT_WID=%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"align 2 SLR_INPUT_MEM_ACT_HSTA=%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA));

	if ((Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA)  + Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID)) > mDomainCapWid) {
		Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID, (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) - 4));
	}

	DbgSclrFlgTkr.main_inputregion_x_ori_pre = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA);
	DbgSclrFlgTkr.main_inputregion_w_ori_pre = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID);

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"DbgSclrFlgTkr.main_inputregion_x_ori_pre=%d\n", DbgSclrFlgTkr.main_inputregion_x_ori_pre);
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"DbgSclrFlgTkr.main_inputregion_w_ori_pre=%d\n", DbgSclrFlgTkr.main_inputregion_w_ori_pre);
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"DbgSclrFlgTkr.main_inputregion_x_pre=%d\n", DbgSclrFlgTkr.main_inputregion_x_pre);
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"DbgSclrFlgTkr.main_inputregion_w_pre=%d\n", DbgSclrFlgTkr.main_inputregion_w_pre);

	if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) < DbgSclrFlgTkr.main_inputregion_w_pre)
		w_offset = DbgSclrFlgTkr.main_inputregion_w_pre - Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID);
	else
		w_offset = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) - DbgSclrFlgTkr.main_inputregion_w_pre;

	//add AVD offset modification flow for ISF @Crixus 20151220
	if(w_offset <= 4){//in the ISF control, there is only 2 pixels shift
		if(DbgSclrFlgTkr.main_inputregion_w_pre == 0){
			DbgSclrFlgTkr.main_inputregion_x_pre = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA);
			DbgSclrFlgTkr.main_inputregion_w_pre = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID);
		}
		else{
			if((Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA) > DbgSclrFlgTkr.main_inputregion_x_pre) && (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) < DbgSclrFlgTkr.main_inputregion_w_pre)){
				x_offset = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA) - DbgSclrFlgTkr.main_inputregion_x_pre;
				w_offset = DbgSclrFlgTkr.main_inputregion_w_pre - Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID);
				if(w_offset > x_offset){
					Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID, Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) + (w_offset - x_offset));
					DbgSclrFlgTkr.main_check_pre_flag = 1;
				}
				else if(w_offset < x_offset){
					Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID, Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) - (x_offset-w_offset));
					DbgSclrFlgTkr.main_check_pre_flag = 1;
				}
			}
			else if((Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA) < DbgSclrFlgTkr.main_inputregion_x_pre) && (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) > DbgSclrFlgTkr.main_inputregion_w_pre)){
				x_offset = DbgSclrFlgTkr.main_inputregion_x_pre - Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA);
				w_offset = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) - DbgSclrFlgTkr.main_inputregion_w_pre;
				if(w_offset > x_offset){
					Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID, Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) - (w_offset - x_offset));
					DbgSclrFlgTkr.main_check_pre_flag = 1;
				}
				else if(w_offset < x_offset){
					Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID, Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) + (x_offset-w_offset));
					DbgSclrFlgTkr.main_check_pre_flag = 1;
				}

			}
			else{
				if((DbgSclrFlgTkr.main_check_pre_flag == 1) && (DbgSclrFlgTkr.main_inputregion_x_ori_pre == Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA)) && (DbgSclrFlgTkr.main_inputregion_w_ori_pre == Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID))){
					//Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA, DbgSclrFlgTkr.main_inputregion_x_pre);
					Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID, DbgSclrFlgTkr.main_inputregion_w_pre);
					DbgSclrFlgTkr.main_check_pre_flag = 0;
				}
			}
				DbgSclrFlgTkr.main_inputregion_x_pre = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA);
				DbgSclrFlgTkr.main_inputregion_w_pre = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID);
		}
	}
	else{
		DbgSclrFlgTkr.main_check_pre_flag = 0;
		DbgSclrFlgTkr.main_inputregion_x_pre = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA);
		DbgSclrFlgTkr.main_inputregion_w_pre = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID);
	}

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"final SLR_INPUT_MEM_ACT_WID=%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"final SLR_INPUT_MEM_ACT_HSTA=%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_HSTA));


	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_DISP_WID, outputwin.w);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_DISP_LEN, outputwin.h);

	if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_WID) < Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_DISP_WID)){
		Scaler_DispSetScaleStatus(display, SLR_SCALE_H_UP, TRUE);
	}else{
		Scaler_DispSetScaleStatus(display, SLR_SCALE_H_UP, FALSE);
	}

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"SLR_SCALE_H_UP=%d\n", Scaler_DispGetScaleStatus(display, SLR_SCALE_H_UP));


	if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_MEM_ACT_LEN) < Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_DISP_LEN))
		Scaler_DispSetScaleStatus(display, SLR_SCALE_V_UP, TRUE);
	else
		Scaler_DispSetScaleStatus(display, SLR_SCALE_V_UP, FALSE);

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"SLR_SCALE_V_UP=%d\n", Scaler_DispGetScaleStatus(display, SLR_SCALE_V_UP));

	if (display == SLR_SUB_DISPLAY) {
		//IoReg_SetBits(MDOMAIN_DISP_DDR_MainSubCtrl_reg, _BIT17);
		mdomain_disp_ddr_mainsubctrl_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
		mdomain_disp_ddr_mainsubctrl_Reg.disp2_double_enable = 1;
		IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, mdomain_disp_ddr_mainsubctrl_Reg.regValue);

		//IoReg_SetBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT6);//Enable dtg double buffer register
		ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
		ppoverlay_double_buffer_ctrl_Reg.dsubreg_dbuf_en = 1;
		IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);

		//IoReg_SetBits(SCALEUP_DS_UZU_DB_CTRL_reg, _BIT2);//Enable uzu double buffer register
		scaleup_ds_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DS_UZU_DB_CTRL_reg);
		scaleup_ds_uzu_db_ctrl_Reg.db_en = 1;
		IoReg_Write32(SCALEUP_DS_UZU_DB_CTRL_reg, scaleup_ds_uzu_db_ctrl_Reg.regValue);
	} else {
		//IoReg_SetBits(MDOMAIN_DISP_DDR_MainSubCtrl_reg, _BIT1);
		mdomain_disp_ddr_mainsubctrl_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
		mdomain_disp_ddr_mainsubctrl_Reg.disp1_double_enable = 1;
		IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, mdomain_disp_ddr_mainsubctrl_Reg.regValue);

		//IoReg_SetBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT1);//Enable dtg double buffer register
		ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
		ppoverlay_double_buffer_ctrl_Reg.dreg_dbuf_en = 1;
		IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);

		//IoReg_SetBits(SCALEUP_DM_UZU_DB_CTRL_reg, _BIT2);//Enable uzu double buffer register
		scaleup_dm_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DM_UZU_DB_CTRL_reg);
		scaleup_dm_uzu_db_ctrl_Reg.db_en = 1;
		IoReg_Write32(SCALEUP_DM_UZU_DB_CTRL_reg, scaleup_dm_uzu_db_ctrl_Reg.regValue);

	}
	//imd_smooth_enable_sub_double_buffer(TRUE);

	/*IoReg_SetBits(MDOMAIN_DISP_DDR_MainSubCtrl_reg, _BIT17);//Enable double buffer register*/
	/*WaitFor_DEN_START();*/
	/*WaitFor_DEN_STOP_Done_SUB();*/
	/*sub m domain display*/
	if (display == SLR_SUB_DISPLAY) {
		memory_set_sub_displaywindow_change(changetomain);
	} else {
		memory_set_main_displaywindow_change();
	}
	/*sub uzu*/
	avdmdsmooth_color_ultrazoom_config_scaling_up(display);

	if (display == SLR_SUB_DISPLAY) {
		PipmpSetSubDisplayWindow(
			outputwin.x, outputwin.x + Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_DISP_WID) - 1,
			outputwin.y, outputwin.y + Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_DISP_LEN) - 1,
			0);

		PipmpSetSubActiveWindow(
			0, Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_DISP_WID)  - 1,
			0, Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_DISP_LEN) - 1);

	} else {
		ppoverlay_main_active_h_start_end_RBUS main_active_h_start_end_reg;
		ppoverlay_main_active_v_start_end_RBUS main_active_v_start_end_reg;

		// Main Active H pos
		main_active_h_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_H_Start_End_reg);
		main_active_h_start_end_reg.mh_act_sta = outputwin.x & 0x0fff;
		main_active_h_start_end_reg.mh_act_end = (outputwin.x + outputwin.w) & 0x0fff;
		IoReg_Write32(PPOVERLAY_MAIN_Active_H_Start_End_reg, main_active_h_start_end_reg.regValue);

		// Main Active V pos
		main_active_v_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_V_Start_End_reg);
		main_active_v_start_end_reg.mv_act_sta = outputwin.y & 0x0fff;
		main_active_v_start_end_reg.mv_act_end = (outputwin.y + outputwin.h) & 0x0fff;
		IoReg_Write32(PPOVERLAY_MAIN_Active_V_Start_End_reg, main_active_v_start_end_reg.regValue);

	}

	if (display == SLR_SUB_DISPLAY) {
		unsigned int uzulinecntA =0;
		unsigned int uzulinecntB =0;

		unsigned int timeoutcount = 0x3ffff;
		ppoverlay_dv_den_start_end_RBUS dv_den_start_end_reg;
		ppoverlay_new_meas2_linecnt_real_RBUS new_meas2_linecnt_real_reg;
		//IoReg_SetBits(MDOMAIN_DISP_DDR_MainSubCtrl_reg, _BIT0);//load M domain double buffer
		mdomain_disp_ddr_mainsubctrl_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
		mdomain_disp_ddr_mainsubctrl_Reg.disp2_double_apply = 1;
		IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, mdomain_disp_ddr_mainsubctrl_Reg.regValue);
#if 0
		IoReg_SetBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT4);//load D domaindouble buffer register
		ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
		ppoverlay_double_buffer_ctrl_Reg.dsubreg_dbuf_set = 1;
		IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);
#endif
		//IoReg_SetBits(SCALEUP_DS_UZU_DB_CTRL_reg, _BIT0);//load uzu double buffer
		scaleup_ds_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DS_UZU_DB_CTRL_reg);
		scaleup_ds_uzu_db_ctrl_Reg.db_apply = 1;
		IoReg_Write32(SCALEUP_DS_UZU_DB_CTRL_reg, scaleup_ds_uzu_db_ctrl_Reg.regValue);

		dv_den_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_DV_DEN_Start_End_reg);

		do {
			new_meas2_linecnt_real_reg.regValue = IoReg_Read32(PPOVERLAY_new_meas2_linecnt_real_reg);
			uzulinecntA = new_meas2_linecnt_real_reg.uzudtg_dly_line_cnt_rt;
			new_meas2_linecnt_real_reg.regValue = IoReg_Read32(PPOVERLAY_new_meas2_linecnt_real_reg);
			uzulinecntB = new_meas2_linecnt_real_reg.uzudtg_dly_line_cnt_rt;
			if((uzulinecntA == uzulinecntB)&&((uzulinecntA < (dv_den_start_end_reg.dv_den_sta)) || (uzulinecntA > (dv_den_start_end_reg.dv_den_end)))) {
				//IoReg_ClearBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT6);//Disable double buffer register
				ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
				ppoverlay_double_buffer_ctrl_Reg.dsubreg_dbuf_en = 0;
				IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);
				break;
			}
			timeoutcount--;
		} while(timeoutcount);

		if(timeoutcount == 0){
			//IoReg_ClearBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT6);//Disable double buffer register
			ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
			ppoverlay_double_buffer_ctrl_Reg.dsubreg_dbuf_en = 0;
			IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"[SUB DEN]timeout error!!!\n");
		}
#if 0
		tmp = 0;
		while((IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg)&_BIT4) || (IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg)&_BIT16) || (IoReg_Read32(SCALEUP_DS_UZU_DB_CTRL_reg)&_BIT0)){
			msleep(1);
			if(++tmp>30)
				break;
		}

		mdomain_disp_ddr_mainsubctrl_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
		mdomain_disp_ddr_mainsubctrl_Reg.disp2_double_enable = 0;
		IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, mdomain_disp_ddr_mainsubctrl_Reg.regValue);

		//IoReg_ClearBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT6);//Disable double buffer register
		ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
		ppoverlay_double_buffer_ctrl_Reg.dsubreg_dbuf_en = 0;
		IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);

		//IoReg_ClearBits(SCALEUP_DS_UZU_DB_CTRL_reg, _BIT2);//Disable uzu double buffer register
		scaleup_ds_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DS_UZU_DB_CTRL_reg);
		scaleup_ds_uzu_db_ctrl_Reg.db_en = 0;
		IoReg_Write32(SCALEUP_DS_UZU_DB_CTRL_reg, scaleup_ds_uzu_db_ctrl_Reg.regValue);
#endif
	} else {
		//IoReg_SetBits(MDOMAIN_DISP_DDR_MainSubCtrl_reg, _BIT0);//load M domain double buffer
		mdomain_disp_ddr_mainsubctrl_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
		mdomain_disp_ddr_mainsubctrl_Reg.disp1_double_apply = 1;
		IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, mdomain_disp_ddr_mainsubctrl_Reg.regValue);

		//IoReg_SetBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT4);//load D domaindouble buffer register
		ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
		ppoverlay_double_buffer_ctrl_Reg.dreg_dbuf_set = 1;
		IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);

		//IoReg_SetBits(SCALEUP_DM_UZU_DB_CTRL_reg, _BIT0);//load uzu double buffer
		scaleup_dm_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DM_UZU_DB_CTRL_reg);
		scaleup_dm_uzu_db_ctrl_Reg.db_apply = 1;
		IoReg_Write32(SCALEUP_DM_UZU_DB_CTRL_reg, scaleup_dm_uzu_db_ctrl_Reg.regValue);
#if 0
		tmp = 0;
		while((IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg)&_BIT0) || (IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg)&_BIT0) || (IoReg_Read32(SCALEUP_DM_UZU_DB_CTRL_reg)&_BIT0)){
			msleep(1);
			if(++tmp>30)
				break;
		}

		mdomain_disp_ddr_mainsubctrl_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
		mdomain_disp_ddr_mainsubctrl_Reg.disp1_double_enable = 0;
		IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, mdomain_disp_ddr_mainsubctrl_Reg.regValue);

		//IoReg_ClearBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT2);//Disable double buffer register
		ppoverlay_double_buffer_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
		ppoverlay_double_buffer_ctrl_Reg.dreg_dbuf_en = 0;
		IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, ppoverlay_double_buffer_ctrl_Reg.regValue);

		//IoReg_ClearBits(SCALEUP_DS_UZU_DB_CTRL_reg, _BIT2);//Disable uzu double buffer register
		scaleup_dm_uzu_db_ctrl_Reg.regValue = IoReg_Read32(SCALEUP_DS_UZU_DB_CTRL_reg);
		scaleup_dm_uzu_db_ctrl_Reg.db_en = 0;
		IoReg_Write32(SCALEUP_DS_UZU_DB_CTRL_reg, scaleup_dm_uzu_db_ctrl_Reg.regValue);
#endif
	}

	return TRUE;
}


void Scaler_SetDisplaySingleBufferMode(SCALER_DISP_CHANNEL channel, unsigned char mode)
{
	if (channel == SLR_MAIN_DISPLAY) {
		mdomain_disp_ddr_mainctrl_RBUS ddr_mainctrl_reg;
		ddr_mainctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainCtrl_reg);
		if (mode) {
			ddr_mainctrl_reg.main_v_flip_3buf_en = 0;
			ddr_mainctrl_reg.main_double_en = 0;
			ddr_mainctrl_reg.main_single_buffer_select = 2;
		} else {
			ddr_mainctrl_reg.main_v_flip_3buf_en = 1;
			ddr_mainctrl_reg.main_double_en = 1;
		}
		IoReg_Write32(MDOMAIN_DISP_DDR_MainCtrl_reg, ddr_mainctrl_reg.regValue);
	} else if (channel == SLR_SUB_DISPLAY) {
		mdomain_disp_ddr_subctrl_RBUS ddr_subctrl_reg;
		ddr_subctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_SubCtrl_reg);
		if (mode) {
			ddr_subctrl_reg.sub_v_flip_3buf_en = 0;
			ddr_subctrl_reg.sub_double_en = 0;
			ddr_subctrl_reg.sub_single_buffer_select = 2;
		} else {
			ddr_subctrl_reg.sub_v_flip_3buf_en = 1;
			ddr_subctrl_reg.sub_double_en = 1;
		}
		IoReg_Write32(MDOMAIN_DISP_DDR_SubCtrl_reg, ddr_subctrl_reg.regValue);
	}
	drvif_memory_set_dbuffer_write();
}

static unsigned char Hdmi_GameMode = FALSE;

unsigned char Get_HDMI_SingleBuffer_GameMode(void)
{
	//only support 50hz/60hz hdmi timing go data frc
	//if(((Scaler_InputSrcGetMainChType() == _SRC_HDMI) || (Scaler_InputSrcGetMainChType() == _SRC_DVI)) && (Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC) == FALSE))
	if(Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC) == FALSE)
	{
		/*magellan and sirius ic m cap and m disp not the same, but merlin the same*/
		if(((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) > 490) && (Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) < 510)) || ((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) > 590) && (Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) < 610)))
		{
			return Hdmi_GameMode;
		}
		else
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}
}

extern unsigned int Get_fine_tune_dclk_forGameMode(void);
#define IV2DVLINE_GAPSPACE 2
void FineTune_iv2dvline_GameMode(void)
{

	unsigned int htotal = Get_DISP_HORIZONTAL_TOTAL();
	unsigned int vtotal = Get_DISP_VERTICAL_TOTAL();
	unsigned int Dclock = Get_fine_tune_dclk_forGameMode();
	unsigned int dispDFRate =  (10*Dclock/(htotal*vtotal));
	unsigned int iputFRate = Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ);

	unsigned int dispLen = Scaler_DispGetInputInfo(SLR_INPUT_DISP_LEN);
	unsigned int inputSta = Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_STA);
	unsigned int inputLen = Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN);

	mdomain_disp_ddr_mainprevstart_RBUS ddr_mainprevstart_Reg;
	ppoverlay_dv_den_start_end_RBUS dv_den_start_end_reg;
	ppoverlay_main_active_v_start_end_RBUS main_active_v_start_end_reg;
	unsigned int preread = 0;
	unsigned int dv_sta = 0;
	unsigned int mv_sta = 0;
	int iv2dvlinesta = 0;
	unsigned int iv2dvlinefreq = 0;

	if(Scaler_DispGetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), SLR_DISP_INTERLACE))
		inputLen = inputLen*2;

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"[Game_mode]input frame rate = %d;output frame rate = %d\n",(unsigned int)iputFRate, (unsigned int)dispDFRate);
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"[Game_mode]inputSta = %d;inputLen = %d;dispLen = %d\n",(unsigned int)inputSta, (unsigned int)inputLen, (unsigned int)dispLen);

	if ((0 == iputFRate) || (0 == inputLen))
		return;

	ddr_mainprevstart_Reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainPreVStart_reg);
	preread = ddr_mainprevstart_Reg.main_pre_rd_v_start;
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"[Game_mode]preread = %d\n",preread);


	dv_den_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_DV_DEN_Start_End_reg);
	dv_sta = dv_den_start_end_reg.dv_den_sta;


	main_active_v_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_V_Start_End_reg);
	mv_sta = main_active_v_start_end_reg.mv_act_sta;

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"[Game_mode]dv_sta = %d;mv_sta = %d\n",dv_sta,mv_sta);

	iv2dvlinesta = (inputSta*(dispLen*dispDFRate)/(inputLen*iputFRate)) + IV2DVLINE_GAPSPACE + preread - (dv_sta+mv_sta);

	if(iv2dvlinesta < 0)
		iv2dvlinesta = 0;
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"[Game_mode]iv2dvline for reason sta diff = %d\n", iv2dvlinesta);

	if(iputFRate<dispDFRate)
		iv2dvlinefreq = (inputLen - inputLen*iputFRate/dispDFRate);

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"[Game_mode]iv2dvline for reason freq diff = %d\n", iv2dvlinefreq);
	drvif_set_frc_ivs2dvsdelay_line((iv2dvlinesta+iv2dvlinefreq),(iv2dvlinesta+iv2dvlinefreq), 0);
}


static unsigned char vscFilmMode = FALSE;

unsigned char Get_vscFilmMode(void)
{
	return vscFilmMode;
}

void filmmode_videofw_config(unsigned int filmmode, unsigned int buf4addr)//filmmode:0 disable filmmode;filmmode:0 enable filmmode
{
	FILM_MODE_IOCTL_PARAM param = {filmmode, buf4addr};
	unsigned int *pulTemp = NULL;
	unsigned int ulCount = 0, i = 0;
	int ret;

	pulTemp = (unsigned int*)Scaler_GetShareMemVirAddr(SCALERIOC_VIDEO_FILMMODE_ENABLE);
	ulCount = sizeof(FILM_MODE_IOCTL_PARAM) / sizeof(unsigned int);
	// copy to RPC share memory
	memcpy(pulTemp, &param, sizeof(FILM_MODE_IOCTL_PARAM));

	for (i = 0; i < ulCount; i++)
		pulTemp[i] = Scaler_ChangeUINT32Endian(pulTemp[i]);

	if (0 != (ret = Scaler_SendRPC(SCALERIOC_VIDEO_FILMMODE_ENABLE, 0, 0)))
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"ret=%d, Deinit SCALERIOC_VIDEO_FILMMODE_ENABLE fail !!!\n", ret);
	}
}

extern unsigned int FilmModeCachaddr;
extern unsigned int FilmModePhyadddr;

unsigned char rtk_vsc_setFilmMode(bool value)
{
//remove by ben, due to mag2 remove fs_5_4 hw
#ifdef CONFIG_5_4_FS
#if 0
	vscFilmMode = value;
	if(value == TRUE)
	{
		HAL_VBE_DISP_SetFrameRate(TRUE,48);
	}
	else
	{
		HAL_VBE_DISP_SetFrameRate(FALSE,60);
		dvr_free((void *)FilmModeCachaddr);
		FilmModeCachaddr = NULL;
		FilmModePhyadddr = NULL;
		filmmode_videofw_config(FALSE,NULL);
	}
//#else
	if(value==TRUE)
	{
		ppoverlay_dh_total_last_line_length_RBUS ppoverlay_dh_total_last_line_length_Reg;
		ppoverlay_dh_total_last_line_length_Reg.regValue=IoReg_Read32(PPOVERLAY_DH_TOTAL_LAST_LINE_LENGTH_VADDR);

		ppoverlay_dv_total_RBUS ppoverlay_dv_total_Reg;
		ppoverlay_dv_total_Reg.regValue = IoReg_Read32(PPOVERLAY_DV_TOTAL_VADDR);

		ppoverlay_fs54_dh_RBUS ppoverlay_fs54_dh_Reg;
		ppoverlay_fs54_dh_Reg.fs54_dh_total = ppoverlay_dh_total_last_line_length_Reg.dh_total;
		ppoverlay_fs54_dh_Reg.fs54_dh_last_line = ppoverlay_dh_total_last_line_length_Reg.dh_total_last_line;
		IoReg_Write32(PPOVERLAY_FS54_DH_VADDR, ppoverlay_fs54_dh_Reg.regValue);

		ppoverlay_fs54_dv_RBUS ppoverlay_fs54_dv_Reg;
		ppoverlay_fs54_dv_Reg.fs54_dv_total = ppoverlay_dv_total_Reg.dv_total*5/4;
		IoReg_Write32(PPOVERLAY_FS54_DV_VADDR,ppoverlay_fs54_dv_Reg.regValue);

		fs54_ctrl_RBUS ppoverlay_fs54_ctrl_Reg;
		ppoverlay_fs54_ctrl_Reg.regValue = IoReg_Read32(PPOVERLAY_FS54_CTRL_VADDR);
		ppoverlay_fs54_ctrl_Reg.fs54_dclk_en = 0;
		ppoverlay_fs54_ctrl_Reg.fs54_dclk_slow_modify_en = 0;
		ppoverlay_fs54_ctrl_Reg.fs54_pseudo_fsync_en = 0;
		ppoverlay_fs54_ctrl_Reg.fs54_timing_en = 1;
		ppoverlay_fs54_ctrl_Reg.fs54_vs_align = 3;
		ppoverlay_fs54_ctrl_Reg.fs54_force = 1;
		ppoverlay_fs54_ctrl_Reg.fs54_main_sub_sel = 0;
		ppoverlay_fs54_ctrl_Reg.fs54_frc_fastslow = 1;
		ppoverlay_fs54_ctrl_Reg.fs54_db_load = 1;
		ppoverlay_fs54_ctrl_Reg.fs54_en = 1;
		if((IoReg_Read32(PPOVERLAY_DOUBLE_BUFFER_CTRL_VADDR)&_BIT2)>>2)
		{
			IoReg_ClearBits(PPOVERLAY_DOUBLE_BUFFER_CTRL_VADDR, _BIT2);
			IoReg_Write32(PPOVERLAY_FS54_CTRL_VADDR,ppoverlay_fs54_ctrl_Reg.regValue);
			IoReg_SetBits(PPOVERLAY_DOUBLE_BUFFER_CTRL_VADDR, _BIT2);
		}
		else
		{
			IoReg_Write32(PPOVERLAY_FS54_CTRL_VADDR,ppoverlay_fs54_ctrl_Reg.regValue);
		}
	}
	else
	{
		fs54_ctrl_RBUS ppoverlay_fs54_ctrl_Reg;
		ppoverlay_fs54_ctrl_Reg.regValue = 0;
		IoReg_Write32(PPOVERLAY_FS54_CTRL_VADDR,ppoverlay_fs54_ctrl_Reg.regValue);
	}
#else
	if(value == TRUE)
		drvif_framesync_5_4();
	else
		drvif_framesync_5_4_release();
#endif
#endif
	return TRUE;

}

void scaler_sub_sync_main_timing_info(void)
{
	unsigned short IPH_ACT_STA = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_STA_PRE);
	unsigned short IPV_ACT_STA = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_STA_PRE);
	unsigned short IPH_ACT_WID = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_WID_PRE);
	unsigned short IPV_ACT_LEN = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_LEN_PRE);

	Scaler_SetCurrentDispInfo(SLR_SUB_DISPLAY);

	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_STA_PRE, IPH_ACT_STA);
	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_STA_PRE, IPV_ACT_STA);
	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE, IPH_ACT_WID);
	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE, IPV_ACT_LEN);
	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_STA, IPH_ACT_STA);
	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_STA, IPV_ACT_STA);
	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_WID, IPH_ACT_WID);
	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN, IPV_ACT_LEN);

}

void scaler_set_sub_vgip(unsigned char src, unsigned char mode)
{
	sub_vgip_vgip_chn2_ctrl_RBUS vgip_chn2_ctrl_reg;
	sub_vgip_vgip_chn2_act_hsta_width_RBUS vgip_chn2_act_hsta_width_reg;
	sub_vgip_vgip_chn2_act_vsta_length_RBUS vgip_chn2_act_vsta_length_reg;
	sub_vgip_vgip_chn2_delay_RBUS sub_vgip_vgip_chn2_delay_reg;

	// Disable SRC_Clock_Enbale bit
	vgip_chn2_ctrl_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_CTRL_reg);
	vgip_chn2_ctrl_reg.ch2_in_clk_en = 0;
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_CTRL_reg, vgip_chn2_ctrl_reg.regValue);

	// determine the input source
	vgip_chn2_ctrl_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_CTRL_reg);
	vgip_chn2_ctrl_reg.ch2_in_sel = src;
	vgip_chn2_ctrl_reg.ch2_digital_mode = mode;
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_CTRL_reg, vgip_chn2_ctrl_reg.regValue);

	//sub vgip size sync from main
	vgip_chn2_act_hsta_width_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_ACT_HSTA_Width_reg);
	vgip_chn2_act_hsta_width_reg.ch2_ih_act_sta = Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_STA_PRE);
	if(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE) < 720)
		vgip_chn2_act_hsta_width_reg.ch2_ih_act_wid = 720;
	else
		vgip_chn2_act_hsta_width_reg.ch2_ih_act_wid = Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE);
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_ACT_HSTA_Width_reg, vgip_chn2_act_hsta_width_reg.regValue);

	vgip_chn2_act_vsta_length_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_ACT_VSTA_Length_reg);
	vgip_chn2_act_vsta_length_reg.ch2_iv_act_sta = Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_STA_PRE);

	if((Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) < 288 ) && Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_THRIP))//SE do scaling up to 720x288 interlace
		vgip_chn2_act_vsta_length_reg.ch2_iv_act_len = 288;
	else if((Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) < 576 ) && !Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_THRIP))//SE do scaling up to 720x288 profrassive
		vgip_chn2_act_vsta_length_reg.ch2_iv_act_len = 576;
	else
		vgip_chn2_act_vsta_length_reg.ch2_iv_act_len = Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE);
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_ACT_VSTA_Length_reg, vgip_chn2_act_vsta_length_reg.regValue);

	sub_vgip_vgip_chn2_delay_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_DELAY_reg);
	sub_vgip_vgip_chn2_delay_reg.ch2_ihs_dly = 0;//reset 0
	sub_vgip_vgip_chn2_delay_reg.ch2_ivs_dly = 0;//reset 0
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_DELAY_reg, sub_vgip_vgip_chn2_delay_reg.regValue);

	vgip_chn2_ctrl_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_CTRL_reg);
	vgip_chn2_ctrl_reg.ch2_field_det_en = _DISABLE;		//bit16
	vgip_chn2_ctrl_reg.ch2_field_sync_edge = _ENABLE;	//bit17
	vgip_chn2_ctrl_reg.ch2_field_inv = _ENABLE;		//bit18
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_CTRL_reg, vgip_chn2_ctrl_reg.regValue);

	// enable SRC_Clock_Enbale bit
	vgip_chn2_ctrl_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_CTRL_reg);
	vgip_chn2_ctrl_reg.ch2_in_clk_en = 1;
	IoReg_Write32(SUB_VGIP_VGIP_CHN2_CTRL_reg, vgip_chn2_ctrl_reg.regValue);

}

void scaler_run_sub_capture_tve(SIZE outsize)
{
	unsigned char src;
	unsigned char mode;
	SIZE insize;
	unsigned char nMode = 0;
	src = VGIP_SRC_VODMA1;

	scaler_set_sub_vgip(src, VGIP_MODE_ANALOG);

	Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_10BIT, false);
	Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_FSYNC_VUZD, 0x2);
	Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_COMP, false);
	Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_422CAP, true);

	mode = Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR);
	if ((mode !=  _MODE_480I) && (mode !=  _MODE_480P) && (mode !=  _MODE_576I) && (mode !=  _MODE_576P))
		nMode = 1;
	drvif_color_set422to444(SLR_SUB_DISPLAY, false);
	fwif_color_colorspacergb2yuvtransfer(SLR_SUB_DISPLAY, _SRC_VO, nMode, 1, 0);

	insize.nWidth = Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE);
	insize.nLength = Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE);

	if(Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_THRIP))
	{

		outsize.nLength /=2;
		pr_debug("[scart out]enter DI, nLength = %d\n",outsize.nLength);
	}
	Scaler_DispSetScaleStatus(SLR_SUB_DISPLAY, SLR_SCALE_H_DOWN, (insize.nWidth > outsize.nWidth)?true:false);
	Scaler_DispSetScaleStatus(SLR_SUB_DISPLAY, SLR_SCALE_V_DOWN, (insize.nLength > outsize.nLength)?true:false);
	drvif_color_ultrazoom_set_scale_down(SLR_SUB_DISPLAY, &insize, &outsize, 0);

	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_CAP_WID,outsize.nWidth);
	Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_CAP_LEN,outsize.nLength);
	mdomain_handler_onlycap();
}

#if 0	//remove tve
void scaler_vodmatosub_prog(TVE_VIDEO_MODE_SEL tve_mode, UINT8 tve_vflip_en)
{

	SIZE tve_outsize;

	if (tve_mode == TVE_NTSC) {
		tve_outsize.nWidth = 720;
		tve_outsize.nLength = 480;
	}
	else if (tve_mode == TVE_PAL_I) {
		tve_outsize.nWidth = 720;
		tve_outsize.nLength = 576;
	} else {
			pr_debug("wrong params	tve_mode=%d\n",(int)tve_mode);
			return ;
	   }

	scaler_sub_sync_main_timing_info();

	scaler_run_sub_capture_tve(tve_outsize);
	//Not to do initial in based driver - LGE Project @ Crixus 20141110
	//drvif_module_tve_init();
	drvif_module_tve_set_mode(tve_mode);
	drvif_module_tve_video_memory_setting(tve_vflip_en);
	drvif_module_tve_change_memory_setting(Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE),tve_vflip_en);

	scaler_scart_out_isr_set_enable(TRUE);
	//pr_debug("[scart out]fScartOut_isr_Enable = %x\n",fScartOut_isr_Enable);

	//VODMA clock fine tune
	#if 0
	if((Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) <= 720) && (Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN_PRE) <= 576)){
		fScartOut_VO_clock_check = TRUE;
		//SE scaling up
		if((Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) < 720) || (Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN_PRE) < 576))
			fScartOut_VO_scaling_enable = TRUE;
		else
			fScartOut_VO_scaling_enable = FALSE;
	}else{
		fScartOut_VO_clock_check = FALSE;
	}
	#endif
	scaler_set_tve_vflip_enable(tve_vflip_en);

	 //bVodma2I3Dma = true;
#if 0//M-disp debug using
	//M-domain Disp verify
	IoReg_ClearBits(MDOMAIN_DISP_DDR_MainSubCtrl_reg,_BIT1); //clear double buffer
	IoReg_ClearBits(MDOMAIN_DISP_DDR_MainCtrl_reg,MDOMAIN_DISP_DDR_MainCtrl_main_double_en_mask); //use single buffer. [9:8] = 0 use buffer 0,
									   // [9:8] = 1 use buffer 1
	i3ddmaCapAddr = IoReg_Read32(I3DDMA_CAP_L1_START_VADDR); //capture Buf L1
	//UINT32 i3ddmaCapAddr = IoReg_Read32(I3DDMA_CAP_L2_START_VADDR); //capture Buf L2
	pr_debug("##### i3ddmaCapAddr : %x ##### \n", i3ddmaCapAddr);  //capture Buf L
	IoReg_Write32(MDOMAIN_DISP_DDR_MainAddr_reg, i3ddmaCapAddr); //M-Disp Buffer0 use capture Buf
#endif
}
#endif

static unsigned char VscInitdone_Flag = FALSE;
static unsigned char VscOpendone_Flag = FALSE;
#ifdef CONFIG_DUAL_CHANNEL
static unsigned char Sub_VscOpendone_Flag = FALSE;
#endif
static struct semaphore vsc_initial_ctrl_semaphore;//for call  rtk_hal_vsc_initialize use


unsigned char rtk_hal_vsc_initialize(void)
{
	if(VscInitdone_Flag == FALSE)
 	{
 		down(&vsc_initial_ctrl_semaphore);
		if(VscInitdone_Flag == FALSE)
 		{
			rtd_printk(KERN_INFO, TAG_NAME_VSC, "file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
			VscInitdone_Flag = TRUE;
#ifdef CONFIG_ORBIT_PIXEL_SHIFT_ALGO
			Scaler_Orbit_Timer_Init();
#endif
			panel_parameter_send_info(); //send panel info
			reset_support_vo_force_v_top();
#ifdef	CONFIG_SUPPORT_SDR_MAX_RGB
			set_support_vo_force_v_top(true, support_sdr_max_rgb);
#else
			set_support_vo_force_v_top(false, support_sdr_max_rgb);
#endif

			reset_all_top_dolby_mode();
#ifdef CONFIG_I2RND_ENABLE
				//Eric@20170904 I2rnd & pst init
				drvif_scaler_i2rnd_initial();
				drvif_scaler_pst_initial(_MAIN_MD);
				drvif_scaler_pst_initial(_SUB_MD);
				vsc_i2rnd_initial_done = _ENABLE;
#ifdef CONFIG_PST_ENABLE
				vsc_pst_initial_done = _ENABLE;
#endif
				//set_i2rnd_s0_pst_check_stage(MAIN_PST_TOP_CTRL_STAGE_DISABLE);
				//set_i2rnd_s1_pst_check_stage(SUB_PST_TOP_CTRL_STAGE_DISABLE);
#endif

#ifdef CONFIG_PST_ENABLE
#ifdef ENABLE_IMD_PST_SMOOTHTOGGLE
			drvif_scaler_pst_initial(_MAIN_VO_IMD);
			drvif_scaler_pst_initial(_SUB_VO_IMD);
#endif
#endif

#ifdef CONFIG_SCALER_BRING_UP
			modestate_EnableDispInt(TRUE);
#endif
			if(FALSE==Scaler_StructInit(PcbSource_GetTable(), PcbSource_GetTableSize(), PcbSource_GetTableSize()-3 /*OSD*/, 4 /*ypp*/))
			{
				rtd_printk(KERN_ERR, TAG_NAME_VSC, "function=%s Scaler_StructInit fail\n", __FUNCTION__);
			}
		}
		up(&vsc_initial_ctrl_semaphore);
	}
	return TRUE;
}

unsigned char rtk_hal_vsc_uninitialize(void)
{
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
#ifdef CONFIG_DUAL_CHANNEL
	if ((VscOpendone_Flag == TRUE) || (Sub_VscOpendone_Flag == TRUE)) {
#else
	if (VscOpendone_Flag == TRUE) {
#endif
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC main and sub not all closed,so can not uninitialize!\n");
		return TRUE;
	} else {
		return TRUE;


#ifdef CONFIG_I2RND_ENABLE
		//I2rnd & pst uninitial
		drvif_scaler_i2rnd_uninitial();
		drvif_scaler_pst_uninitial(_MAIN_MD);
		drvif_scaler_pst_uninitial(_SUB_MD);
		vsc_i2rnd_initial_done = _DISABLE;
#ifdef CONFIG_PST_ENABLE
		vsc_pst_initial_done = _DISABLE;
#endif
#endif

/*

		if (VscInitdone_Flag == TRUE) {
			Scaler_StructUninit();
			VscInitdone_Flag = FALSE;
			return TRUE;
		} else {
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC not init\n");
			return TRUE;
		}
*/
	}
}

unsigned char rtk_hal_vsc_open(VIDEO_WID_T wid)
{
#ifdef CONFIG_DUAL_CHANNEL
	if ((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX)) {
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not right\n");
		return FALSE;
	}
#else
	if (wid !=VIDEO_WID_0) {
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not right\n");
		return FALSE;
	}
#endif

	if (VscInitdone_Flag == FALSE) {
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC is not init, can not be opened\n");
	} else {
		if (wid ==VIDEO_WID_0) {
			if(VscOpendone_Flag == FALSE)	{
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
				VscOpendone_Flag = TRUE;
			} else {
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Main vsc open have done, not need open again\n");
			}
		}
#ifdef CONFIG_DUAL_CHANNEL
		if (wid ==VIDEO_WID_1) {
			if(Sub_VscOpendone_Flag == FALSE)	{
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
				Sub_VscOpendone_Flag = TRUE;
			} else {
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Sub vsc open have done,not need open again\n");
			}
		}
#endif
	}
	return TRUE;
}

unsigned char rtk_hal_vsc_close(VIDEO_WID_T wid)
{
#ifdef CONFIG_DUAL_CHANNEL
	if ((wid < VIDEO_WID_MIN) || (wid > VIDEO_WID_MAX)) {
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	}
#else
	if (wid != VIDEO_WID_0) {
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	}
#endif

	if (wid ==VIDEO_WID_0) {
		if (DbgSclrFlgTkr.OuputDisplayMode || DbgSclrFlgTkr.OutputVencMode || DbgSclrFlgTkr.OutputMemoryMode ||
		    DbgSclrFlgTkr.OutputAveMode) {
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Main vsc have source not disconnect, so can not close!\n");
		} else {
			if(VscOpendone_Flag == TRUE) {
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
				//drvif_mode_resetmode(SLR_MAIN_DISPLAY);
				down(&Main_ResetMode_Semaphore);
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####func:%s request reset mode####\r\n", __FUNCTION__);
				DbgSclrFlgTkr.Main_Reset_Mode_flag = TRUE;
				up(&Main_ResetMode_Semaphore);
				VscOpendone_Flag = FALSE;
		 	} else {
		 		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Main vsc not opened\n");
			}
		}
	}
#ifdef CONFIG_DUAL_CHANNEL
	if (wid ==VIDEO_WID_1) {
		if (DbgSclrFlgTkr.Sub_OuputDisplayMode || DbgSclrFlgTkr.Sub_OutputVencMode || DbgSclrFlgTkr.Sub_OutputMemoryMode ||
		    DbgSclrFlgTkr.Sub_OutputAveMode) {
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Sub vsc have source not disconnect, so can not close!\n");
		} else {
			if(Sub_VscOpendone_Flag == TRUE) {
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
				//drvif_mode_resetmode(SLR_SUB_DISPLAY);
				down(&Sub_ResetMode_Semaphore);
				DbgSclrFlgTkr.Sub_Reset_Mode_flag = TRUE;
				up(&Sub_ResetMode_Semaphore);
				Sub_VscOpendone_Flag = FALSE;
		 	} else {
		 		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Sub vsc not opened\n");
			}
		}
	}
#endif
	return TRUE;
}

long Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_TYPE_T type, unsigned char wid_port)
{
	long ret = 0;
#ifdef CONFIG_RTK_KDRV_RPC
	unsigned char type_local;
	unsigned char port_local;
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "[]###############%s\n", __FUNCTION__);

	if (type == KADP_VO_VSC_SRC_VDEC) {
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);
		type_local = 0;
	} else if(type == KADP_VO_VSC_SRC_JPEG){
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);
		type_local = 1;
	} else {
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);
		type_local = 2;
	}
	if (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC &&
		Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_VDEC &&
		Get_DisplayMode_Port(SLR_MAIN_DISPLAY) != Get_DisplayMode_Port(SLR_SUB_DISPLAY)) {
		type_local = 0x10 | type_local;
	}

	port_local = wid_port;
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\n\n[pool test][sendVo]wid:%d,port:%d,plane:%d\n",(wid_port&0xf0)>>4,wid_port&0xf,Scaler_DispGetInputInfoByDisp(((wid_port&0xf0)>>4), SLR_INPUT_VODMA_PLANE));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "[vo]%s type %d, port %d, m[%d/%d] s[%d/%d]\n", __FUNCTION__, type_local, port_local, Get_DisplayMode_Src(SLR_MAIN_DISPLAY), Get_DisplayMode_Port(SLR_MAIN_DISPLAY), Get_DisplayMode_Src(SLR_SUB_DISPLAY), Get_DisplayMode_Port(SLR_SUB_DISPLAY));
#ifdef CONFIG_RTK_KDRV_RPC
	//set_vo_nosignal_flag((port_local & 0xf), 1);
	if (send_rpc_command(RPC_VIDEO, VIDEO_RPC_VOUT_ToAgent_VSCDISCONNECT_TO_VODMA, type_local, port_local, &ret))
		rtd_printk(KERN_ERR, TAG_NAME_VSC, "RPC fail!!\n");
#endif
    // reset decomp info for main VDEC
    if((type == KADP_VO_VSC_SRC_VDEC) && ((wid_port & 0xf) < 2) && (((wid_port&0xf0)>>4) == 0))
        set_vo_veComp_flag(wid_port & 0xf,0);
#endif

	return ret;
}

long Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_TYPE_T type, unsigned char wid_port)
{
	long ret = 0;
#ifdef CONFIG_RTK_KDRV_RPC
	unsigned char type_local;
	unsigned char port_local;
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "[]###############%s\n", __FUNCTION__);

	if (type == KADP_VO_VSC_SRC_VDEC) {
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n###func:%s line:%d VO_VSC_SRC_VDEC####\r\n", __FUNCTION__, __LINE__);
		type_local = 0;
	} else if(type == KADP_VO_VSC_SRC_JPEG){
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n###func:%s line:%d VO_VSC_SRC_JPEG####\r\n", __FUNCTION__, __LINE__);
		type_local = 1;
	} else {
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n###func:%s line:%d VO_VSC_SRC_HDMI####\r\n", __FUNCTION__, __LINE__);
		type_local = 2;
	}
	if ((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC &&
		Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_VDEC &&
		Get_DisplayMode_Port(SLR_MAIN_DISPLAY) != Get_DisplayMode_Port(SLR_SUB_DISPLAY))
		&&(Get_Live_zoom_mode() == LIVE_ZOOM_OFF)){
		type_local = 0x10 | type_local;
	}

	port_local = wid_port;
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\n\n[pool test][sendVo]wid:%d,port:%d,plane:%d\n",(wid_port&0xf0)>>4,wid_port&0xf,Scaler_DispGetInputInfoByDisp(((wid_port&0xf0)>>4), SLR_INPUT_VODMA_PLANE));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "[vo]%s type %d, port %d, m[%d/%d] s[%d/%d]\n", __FUNCTION__, type_local, port_local, Get_DisplayMode_Src(SLR_MAIN_DISPLAY), Get_DisplayMode_Port(SLR_MAIN_DISPLAY), Get_DisplayMode_Src(SLR_SUB_DISPLAY), Get_DisplayMode_Port(SLR_SUB_DISPLAY));

	if((type == KADP_VO_VSC_SRC_VDEC) || (type == KADP_VO_VSC_SRC_JPEG)){
		set_vo_nosignal_flag((port_local & 0xf), 1);
		set_vo_EOS_flag((port_local & 0xf), 0);
		set_film_detect_done_flag((port_local & 0xf), 0);
       }
#if 0
	VIDEO_RPC_VOUT_VSCCONNECT_STRUCT *connect_parms;
	unsigned int vir_addr, vir_addr_noncache;
	unsigned int phy_addr;

	vir_addr = (unsigned int)dvr_malloc_uncached_specific(sizeof(VIDEO_RPC_VOUT_VSCCONNECT_STRUCT), GFP_DCU1, (void **)&vir_addr_noncache);
	phy_addr = (unsigned int)dvr_to_phys((void*)vir_addr);

	connect_parms = (VIDEO_RPC_VOUT_VSCCONNECT_STRUCT *)vir_addr_noncache;
	connect_parms->wid = port_local;
	connect_parms->vsc_source = type_local;
	connect_parms->vdo_port = connect_parms->wid;
	connect_parms->hdr_mode = port_local; //TODO

	connect_parms->wid = htonl(connect_parms->wid);
	connect_parms->vsc_source = htonl(connect_parms->vsc_source);
	connect_parms->vdo_port = htonl(connect_parms->vdo_port);
	connect_parms->hdr_mode = htonl(connect_parms->hdr_mode);

	if (send_rpc_command(RPC_VIDEO, VIDEO_RPC_VOUT_ToAgent_VSCINPUTTYPE_TO_VODMA,phy_addr, 0, &ret))
		rtd_printk(KERN_ERR, TAG_NAME_VSC, "RPC fail!!\n");

        dvr_free((void *)vir_addr);
#else
#ifdef CONFIG_RTK_KDRV_RPC
	if (send_rpc_command(RPC_VIDEO, VIDEO_RPC_VOUT_ToAgent_VSCINPUTTYPE_TO_VODMA, type_local, port_local, &ret))
		rtd_printk(KERN_ERR, TAG_NAME_VSC, "RPC fail!!\n");
#endif
#endif


#endif


	return ret;
}

unsigned char vsc_force_disconnect(VIDEO_WID_T wid, KADP_VSC_INPUT_SRC_INFO_T inputSrcInfo, KADP_VSC_OUTPUT_MODE_T outputMode)
{//This API is patch for CI test not work. force disconnect current outputMode.
	unsigned int *p_sourceID = NULL;
	StructSrcRect SrcRect = {0, 0, 0, 0};
	unsigned char plane=0;
#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	} else if (wid == VIDEO_WID_0) {
		p_sourceID = &DbgSclrFlgTkr.main_opensourceID;
	} else {
		p_sourceID = &DbgSclrFlgTkr.sub_opensourceID;
	}
#else
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	} else {
		p_sourceID = &DbgSclrFlgTkr.main_opensourceID;
	}
#endif


	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, KERN_WARNING "\r\n####function:%s wid:%d outputMode:%d####\r\n", __FUNCTION__, wid, outputMode);
	if (wid == VIDEO_WID_0) {
		set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_LIVEZOOM, FALSE);
		switch(outputMode)
		{
			case KADP_VSC_OUTPUT_DISPLAY_MODE:
			{
				set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);//Enable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
				if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE){//AP not mute on yet
					mute_control(SLR_MAIN_DISPLAY, TRUE);/*Auto BG. Add by Will*/
				}
				set_vsc_connect_ready(SLR_MAIN_DISPLAY, FALSE);//reset  vsc connect ready
				down(&SetMainOutPutRegion_Semaphore);
				DbgSclrFlgTkr.Main_Scaler_Stop_flag = TRUE;
				DbgSclrFlgTkr.Main_force_frc_flag = FALSE;
				DbgSclrFlgTkr.Main_force_frc_fs_flag = FALSE;
				DbgSclrFlgTkr.smoothtoggle_start_flag = FALSE;
				DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = FALSE;
				DbgSclrFlgTkr.Main_smooth_toggle_set_flag = FALSE;
				DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = FALSE;
				DbgSclrFlgTkr.rotate_run_scaler_flag = FALSE;
				DbgSclrFlgTkr.rotate_muteoff_request_flag = FALSE;
				is_DTV_flag_set(_DISABLE);
				zoom_clear_input_output_region_record(wid);
				Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_TIMING);
				up(&SetMainOutPutRegion_Semaphore);
				source_disconnect_reset_input(SLR_MAIN_DISPLAY);//reset input region to zero
				DbgSclrFlgTkr.main_winfreeze=0;
				DbgSclrFlgTkr.mainVscFreezeFlag=0;
				drvif_mode_disableonlinemeasure(_CHANNEL1);//Diable online measure
				drvif_mode_onlinemeasure_setting(_CHANNEL1, Scaler_InputSrcGetType(SLR_MAIN_DISPLAY), FALSE, FALSE);
				DbgSclrFlgTkr.Main_during_scalerflow_flag = FALSE;//WOSQRTK-7524 patch. Reset DbgSclrFlgTkr.Main_during_scalerflow_flag.
				drivf_scaler_reset_freerun();
				//set detect timng flag true:
				if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
				{
					/*//no need because AVD don't stop detect task
					down(get_vdc_detectsemaphore());
					if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
					up(get_vdc_detectsemaphore());
					*/
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
				{
					down(get_hdmi_detectsemaphore());
					if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
					up(get_hdmi_detectsemaphore());
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
				{
					down(get_adc_detectsemaphore());
					fw_scaler_adc_nolock_wdg_ctrl(SLR_MAIN_DISPLAY, FALSE);// Disable adc_nolock_wdg
					if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
						YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
						ADC_set_detect_flag(TRUE);
					}
					up(get_adc_detectsemaphore());
					set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
				} else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {

				//	vo_overscan_disable(inputSrcInfo.type);
					Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
					if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC)
						Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
					else
						Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);

					down(get_vo_infosemaphore());
					DbgSclrFlgTkr.OuputDisplayMode = FALSE; // Preset for vo
					plane=Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_VODMA_PLANE);
					DisplayModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};// Preset for vo
					set_vo_change_flag(inputSrcInfo.resourceIndex, FALSE);//Reset Vo change flag
					set_force_change_vo_flag(inputSrcInfo.resourceIndex, TRUE);
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####Set force_change_vo_flag TRUE and reset vo change flag####\r\n");
					up(get_vo_infosemaphore());
				}
				smooth_toggle_disconnect(SLR_MAIN_DISPLAY,plane);
				Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				state_update_disp_info();

				DbgSclrFlgTkr.OuputDisplayMode = FALSE;
				DisplayModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};
				*p_sourceID = _UNKNOWN_INPUT;
				//close display panel

				DbgSclrFlgTkr.Main_AutoRunScaler = FALSE;
				down(&SetMainOutPutRegion_Semaphore);
				reset_any_srcrect(&main_dispwin_pre);
				reset_any_srcrect(&main_dispwin_for_only_xy);
				up(&SetMainOutPutRegion_Semaphore);
				if (Get_LivezoomOffMainRunScaler() == TRUE) {
					Set_LivezoomOffMainRunScaler(FALSE);
				}
				DbgSclrFlgTkr.DataFramesynclivezoom = FALSE;
				break;
			}
			case KADP_VSC_OUTPUT_VENC_MODE:
			{
				drvif_mode_disableonlinemeasure(_CHANNEL1);//Diable online measure
				drvif_mode_onlinemeasure_setting(_CHANNEL1, Scaler_InputSrcGetType(SLR_MAIN_DISPLAY), FALSE, FALSE);
				//set detect timng flag true:
				if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
				{
					/*//no need because AVD don't stop detect task
					down(get_vdc_detectsemaphore());
					if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
					up(get_vdc_detectsemaphore());
					*/
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
				{
					down(get_hdmi_detectsemaphore());
					if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
					up(get_hdmi_detectsemaphore());
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
				{
					down(get_adc_detectsemaphore());
					fw_scaler_adc_nolock_wdg_ctrl(SLR_MAIN_DISPLAY, FALSE);// Disable adc_nolock_wdg
					if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
						YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
						ADC_set_detect_flag(TRUE);
					}
					up(get_adc_detectsemaphore());
					set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
					plane=Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_VODMA_PLANE);
					Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
					//smooth_toggle_disconnect(SLR_MAIN_DISPLAY,plane);
				}
				smooth_toggle_disconnect(SLR_MAIN_DISPLAY,plane);
				Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				state_update_disp_info();

				DbgSclrFlgTkr.OutputVencMode = FALSE;
				VencModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};
				*p_sourceID = _UNKNOWN_INPUT;

				break;
			}
			case KADP_VSC_OUTPUT_MEMORY_MODE://Current same with VSC_OUTPUT_DISPLAY_MODE
			{
				set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);//Enable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
				if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE){//AP not mute on yet
					mute_control(SLR_MAIN_DISPLAY, TRUE);/*Auto BG. Add by Will*/
				}
				set_vsc_connect_ready(SLR_MAIN_DISPLAY, FALSE);//reset  vsc connect ready
				down(&SetMainOutPutRegion_Semaphore);
				DbgSclrFlgTkr.Main_Scaler_Stop_flag = TRUE;
				DbgSclrFlgTkr.Main_force_frc_flag = FALSE;
				DbgSclrFlgTkr.Main_force_frc_fs_flag = FALSE;
				DbgSclrFlgTkr.smoothtoggle_start_flag = FALSE;
				DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = FALSE;
				DbgSclrFlgTkr.Main_smooth_toggle_set_flag = FALSE;
				DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = FALSE;
				DbgSclrFlgTkr.rotate_run_scaler_flag = FALSE;
				DbgSclrFlgTkr.rotate_muteoff_request_flag = FALSE;
				is_DTV_flag_set(_DISABLE);
				zoom_clear_input_output_region_record(wid);
				Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_TIMING);
				up(&SetMainOutPutRegion_Semaphore);
				source_disconnect_reset_input(SLR_MAIN_DISPLAY);//reset input region to zero
				DbgSclrFlgTkr.main_winfreeze=0;
				DbgSclrFlgTkr.mainVscFreezeFlag=0;
				drvif_mode_disableonlinemeasure(_CHANNEL1);//Diable online measure
				drvif_mode_onlinemeasure_setting(_CHANNEL1, Scaler_InputSrcGetType(SLR_MAIN_DISPLAY), FALSE, FALSE);
				DbgSclrFlgTkr.Main_during_scalerflow_flag = FALSE;//WOSQRTK-7524 patch. Reset DbgSclrFlgTkr.Main_during_scalerflow_flag.
				//set detect timng flag true:
				if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
				{
					/*//no need because AVD don't stop detect task
					down(get_vdc_detectsemaphore());
					if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
					up(get_vdc_detectsemaphore());
					*/
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
				{
					down(get_hdmi_detectsemaphore());
					if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
					up(get_hdmi_detectsemaphore());
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
				{
					down(get_adc_detectsemaphore());
					fw_scaler_adc_nolock_wdg_ctrl(SLR_MAIN_DISPLAY, FALSE);// Disable adc_nolock_wdg
					if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
						YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
						ADC_set_detect_flag(TRUE);
					}
					up(get_adc_detectsemaphore());
					set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
				} else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
				//	vo_overscan_disable(inputSrcInfo.type);
					Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
					if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC)
						Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
					else
						Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);

					down(get_vo_infosemaphore());
					DbgSclrFlgTkr.OutputMemoryMode = FALSE;
					plane=Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_VODMA_PLANE);
					MemoryModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};
					set_vo_change_flag(inputSrcInfo.resourceIndex, FALSE);//Reset Vo change flag
					set_force_change_vo_flag(inputSrcInfo.resourceIndex, TRUE);
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####Set force_change_vo_flag TRUE and reset vo change flag####\r\n");
					up(get_vo_infosemaphore());
				}
				smooth_toggle_disconnect(SLR_MAIN_DISPLAY,plane);
				Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				state_update_disp_info();

				DbgSclrFlgTkr.OutputMemoryMode = FALSE;
				MemoryModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};
				*p_sourceID = _UNKNOWN_INPUT;

				DbgSclrFlgTkr.Main_AutoRunScaler = FALSE;
				down(&SetMainOutPutRegion_Semaphore);
				reset_any_srcrect(&main_dispwin_pre);
				reset_any_srcrect(&main_dispwin_for_only_xy);
				up(&SetMainOutPutRegion_Semaphore);
				if (Get_LivezoomOffMainRunScaler() == TRUE) {
					Set_LivezoomOffMainRunScaler(FALSE);
				}
				DbgSclrFlgTkr.DataFramesynclivezoom = FALSE;
				break;
			}
			case KADP_VSC_OUTPUT_AVE_MODE:
			{
				HAL_VBE_AVE_Disconnect();
				DbgSclrFlgTkr.OutputAveMode = FALSE;
				AveModeInputInfo =  (KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};
				break;
			}
			default:
				break;
		}
	}
#ifdef CONFIG_DUAL_CHANNEL
	if (wid == VIDEO_WID_1) {
		set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_LIVEZOOM, FALSE);
		switch(outputMode)
		{
			case KADP_VSC_OUTPUT_DISPLAY_MODE:
			{
				set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);//Enable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
				down(get_forcebg_semaphore());
				scalerdisplay_force_bg_enable(SLR_SUB_DISPLAY, TRUE);//Auto mue before disconnect
				drvif_scalerdisplay_enable_display(SLR_SUB_DISPLAY, _DISABLE);
				up(get_forcebg_semaphore());
				down(&SetSubOutPutRegion_Semaphore);
				DbgSclrFlgTkr.Sub_Scaler_Stop_flag = TRUE;
				zoom_clear_input_output_region_record(wid);
				Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_TIMING);
				up(&SetSubOutPutRegion_Semaphore);
				source_disconnect_reset_input(SLR_SUB_DISPLAY);//reset input region to zero
				if ((/*(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD) ||*/(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI) ||(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC)) && (Get_Live_zoom_mode() == LIVE_ZOOM_ON )) {
					Set_Live_zoom_mode(LIVE_ZOOM_OFF);
#ifdef CONFIG_PST_ENABLE
					if(drvif_scaler_pst_get_mode_enable(_MAIN_VO_IMD))
						drvif_scaler_pst_uninitial(_MAIN_VO_IMD);
					if(drvif_scaler_pst_get_mode_enable(_SUB_VO_IMD))
						drvif_scaler_pst_uninitial(_SUB_VO_IMD);
#endif
					//DataFramesynclivezoom = FALSE;
					DbgSclrFlgTkr.LivezoomMainRerunFlag = FALSE;
					DbgSclrFlgTkr.LivezoomSubRerunFlag = FALSE;
					DbgSclrFlgTkr.LivezoomvoinfocheckFlag = FALSE;
					DbgSclrFlgTkr.LivezoomMainRerunEndneedOpenforcebgFlag = FALSE;
					sub_shape_type = VSC_MGF_TYPE_RECTANGLE;
					Set_LivezoomOffMainRunScaler(TRUE);
				} else {
					drvif_mode_disableonlinemeasure(_CHANNEL2);//Diable online measure
					drvif_mode_onlinemeasure_setting(_CHANNEL2, Scaler_InputSrcGetType(SLR_SUB_DISPLAY), FALSE, FALSE);
					//set detect timng flag true:
					if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
					{
						/*//no need because AVD don't stop detect task
						down(get_vdc_detectsemaphore());
						if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
						up(get_vdc_detectsemaphore());
						*/
					}
					else if(inputSrcInfo.type ==KADP_VSC_INPUTSRC_HDMI)
					{
						down(get_hdmi_detectsemaphore());
						if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
						up(get_hdmi_detectsemaphore());
					}
					else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
					{
						down(get_adc_detectsemaphore());
						fw_scaler_adc_nolock_wdg_ctrl(SLR_SUB_DISPLAY, FALSE);// Disable adc_nolock_wdg
						if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
							YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
							ADC_set_detect_flag(TRUE);
						}
						up(get_adc_detectsemaphore());
						set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
					} else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
					//	vo_overscan_disable(inputSrcInfo.type);
						Check_smooth_toggle_update_flag(SLR_SUB_DISPLAY);
						if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC)
							Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
						else
							Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);

						down(get_vo_infosemaphore());
						DbgSclrFlgTkr.Sub_OuputDisplayMode = FALSE; // Preset for vo
						plane=Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_VODMA_PLANE);
						Sub_DisplayModeInputInfo =(KADP_VSC_INPUT_SRC_INFO_T) {KADP_VSC_INPUTSRC_MAXN, 0, 0};// Preset for vo
						set_vo_change_flag(inputSrcInfo.resourceIndex, FALSE);//Reset Vo change flag
						set_force_change_vo_flag(inputSrcInfo.resourceIndex, TRUE);
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####Set force_change_vo_flag TRUE and reset vo change flag####\r\n");
						up(get_vo_infosemaphore());
					}
				}
				smooth_toggle_disconnect(SLR_SUB_DISPLAY,plane);
				Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				state_update_disp_info();

				DbgSclrFlgTkr.Sub_OuputDisplayMode = FALSE;
				DbgSclrFlgTkr.sub_wind0000 = FALSE;
				DbgSclrFlgTkr.subVscFreezeFlag=0;
				//add semaphore for sub disp @Crixus 20150901

				Scaler_SubDispWindowSet(SrcRect);
				Sub_DisplayModeInputInfo =(KADP_VSC_INPUT_SRC_INFO_T) {KADP_VSC_INPUTSRC_MAXN, 0, 0};
				*p_sourceID = _UNKNOWN_INPUT;

				//close_livezoom_doublebuffer();
				//close display panel

				DbgSclrFlgTkr.Sub_AutoRunScaler = FALSE;
				down(&SetSubOutPutRegion_Semaphore);
				reset_any_srcrect(&sub_dispwin_pre);
				up(&SetSubOutPutRegion_Semaphore);
				break;
			}
			case KADP_VSC_OUTPUT_VENC_MODE:
			{
				drvif_mode_disableonlinemeasure(_CHANNEL2);//Diable online measure
				drvif_mode_onlinemeasure_setting(_CHANNEL2, Scaler_InputSrcGetType(SLR_SUB_DISPLAY), FALSE, FALSE);
				//set detect timng flag true:
				if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
				{
					/*//no need because AVD don't stop detect task
					down(get_vdc_detectsemaphore());
					if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
					up(get_vdc_detectsemaphore());
					*/
#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
					printk(KERN_EMERG"[vsc_disconnect]display:%d,port:%d\n",wid,inputSrcInfo.resourceIndex);
					printk(KERN_EMERG"rtk_hal_vsc_Disconnect para,inputSrcInfo:%d;%d;%d,outputMode:%d\n",inputSrcInfo.type, inputSrcInfo.attr, inputSrcInfo.resourceIndex, outputMode);

					if(run_i2rnd_flag == 1){
						run_i2rnd_flag = 0;
						rtk_hal_vsc_i2rnd_enable(_DISABLE);
						//frank@I2run disable main VENC flag
						VencModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){VSC_INPUTSRC_MAXN, 0, 0};
						DbgSclrFlgTkr.OutputVencMode = FALSE;
						vsc_i2rnd_sub_stage = I2RND_STAGE_DISABLE;
						printk(KERN_EMERG"[%s][frank]I2RND close\n", __FUNCTION__);
					}
#endif
#endif
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
				{
					down(get_hdmi_detectsemaphore());
					if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
					up(get_hdmi_detectsemaphore());
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
				{
					down(get_adc_detectsemaphore());
					fw_scaler_adc_nolock_wdg_ctrl(SLR_SUB_DISPLAY, FALSE);// Disable adc_nolock_wdg
					if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
						YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
						ADC_set_detect_flag(TRUE);
					}
					up(get_adc_detectsemaphore());
					set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
				}
				else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
					plane=Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_VODMA_PLANE);
					Check_smooth_toggle_update_flag(SLR_SUB_DISPLAY);
					//smooth_toggle_disconnect(SLR_SUB_DISPLAY,plane);
				}
				smooth_toggle_disconnect(SLR_SUB_DISPLAY,plane);
				Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				state_update_disp_info();
				DbgSclrFlgTkr.Sub_OutputVencMode = FALSE;
				DbgSclrFlgTkr.subVscFreezeFlag=0;
				Sub_VencModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};
				*p_sourceID = _UNKNOWN_INPUT;

				break;
			}
			case KADP_VSC_OUTPUT_MEMORY_MODE:
			{
				down(&SetSubOutPutRegion_Semaphore);
				DbgSclrFlgTkr.Sub_Scaler_Stop_flag = TRUE;
				up(&SetSubOutPutRegion_Semaphore);
				source_disconnect_reset_input(SLR_SUB_DISPLAY);//reset input region to zero

				if ((/*(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD) ||*/(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI) ||(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC)) && (Get_Live_zoom_mode() == LIVE_ZOOM_ON )) {
					Set_Live_zoom_mode(LIVE_ZOOM_OFF);
#ifdef CONFIG_PST_ENABLE
					if(drvif_scaler_pst_get_mode_enable(_MAIN_VO_IMD))
						drvif_scaler_pst_uninitial(_MAIN_VO_IMD);
					if(drvif_scaler_pst_get_mode_enable(_SUB_VO_IMD))
						drvif_scaler_pst_uninitial(_SUB_VO_IMD);
#endif
					//DataFramesynclivezoom = FALSE;
					DbgSclrFlgTkr.LivezoomMainRerunFlag = FALSE;
					DbgSclrFlgTkr.LivezoomSubRerunFlag = FALSE;
					DbgSclrFlgTkr.LivezoomvoinfocheckFlag = FALSE;
					DbgSclrFlgTkr.LivezoomMainRerunEndneedOpenforcebgFlag = FALSE;
					sub_shape_type = KADP_VSC_MGF_TYPE_RECTANGLE;
					Set_LivezoomOffMainRunScaler(TRUE);
				} else {
					drvif_mode_disableonlinemeasure(_CHANNEL2);//Diable online measure
					drvif_mode_onlinemeasure_setting(_CHANNEL2,Scaler_InputSrcGetType(SLR_SUB_DISPLAY), FALSE, FALSE);
					//set detect timng flag true:
					if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
					{
						/*//no need because AVD don't stop detect task
						down(get_vdc_detectsemaphore());
						if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
						up(get_vdc_detectsemaphore());
						*/
					}
					else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
					{
						down(get_hdmi_detectsemaphore());
						if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
						up(get_hdmi_detectsemaphore());
					}
					else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
					{
						down(get_adc_detectsemaphore());
						fw_scaler_adc_nolock_wdg_ctrl(SLR_SUB_DISPLAY, FALSE);// Disable adc_nolock_wdg
						if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
							YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
							ADC_set_detect_flag(TRUE);
						}
						up(get_adc_detectsemaphore());
						set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
					} else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
					//	vo_overscan_disable(inputSrcInfo.type);
						Check_smooth_toggle_update_flag(SLR_SUB_DISPLAY);
						if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC)
							Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
						else
							Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);

						down(get_vo_infosemaphore());
						DbgSclrFlgTkr.Sub_OutputMemoryMode = FALSE; // Preset for vo
						plane=Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_VODMA_PLANE);
						Sub_MemoryModeInputInfo =(KADP_VSC_INPUT_SRC_INFO_T) {KADP_VSC_INPUTSRC_MAXN, 0, 0};// Preset for vo
						set_vo_change_flag(inputSrcInfo.resourceIndex, FALSE);//Reset Vo change flag
						set_force_change_vo_flag(inputSrcInfo.resourceIndex, TRUE);
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####Set force_change_vo_flag TRUE and reset vo change flag####\r\n");
						up(get_vo_infosemaphore());
					}
				}
				smooth_toggle_disconnect(SLR_SUB_DISPLAY,plane);
				Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				state_update_disp_info();

				DbgSclrFlgTkr.sub_wind0000 = FALSE;
				DbgSclrFlgTkr.Sub_OutputMemoryMode = FALSE;
				DbgSclrFlgTkr.subVscFreezeFlag=0;
				Scaler_SubDispWindowSet(SrcRect);
				Sub_MemoryModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};
				*p_sourceID = _UNKNOWN_INPUT;
				//close_livezoom_doublebuffer();
				DbgSclrFlgTkr.Sub_AutoRunScaler = FALSE;
				down(&SetSubOutPutRegion_Semaphore);
				reset_any_srcrect(&sub_dispwin_pre);
				up(&SetSubOutPutRegion_Semaphore);
				break;
			}
			case KADP_VSC_OUTPUT_AVE_MODE:
			{

				HAL_VBE_AVE_Disconnect();
				DbgSclrFlgTkr.Sub_OutputAveMode = FALSE;
				Sub_AveModeInputInfo =	(KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};

				break;
			}
			default:
				break;
		}
	}
#endif
	return TRUE;
}


unsigned char rtk_hal_vsc_Connect(VIDEO_WID_T wid, KADP_VSC_INPUT_SRC_INFO_T inputSrcInfo, KADP_VSC_OUTPUT_MODE_T outputMode)
{
#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	}
#endif
	rtd_printk(KERN_INFO, TAG_NAME_VSC, "vsc_connect wid:%d SrcInfo:%d;%d;%d,Mode:%d\n", wid, inputSrcInfo.type, inputSrcInfo.attr, inputSrcInfo.resourceIndex, outputMode);

	if (wid ==VIDEO_WID_0) {
		if (VscOpendone_Flag == FALSE) {
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Main vsc not open,so can not connect!\n");
			return TRUE;
		}
		increase_source_connect_verify_num(SLR_MAIN_DISPLAY);//increase the main source num
		if(KADP_VSC_INPUTSRC_AVD == inputSrcInfo.type)
		{
			if(SRC_CONNECT_DONE == get_AVD_Global_Status()){
				Scaler_AVD_SetHalVscConnect(SLR_MAIN_DISPLAY,TRUE);
				drvif_module_vpq_DmaAccessCtrl(ON);
				rtd_printk(KERN_INFO, TAG_NAME_VSC, "########[%s(%d)] ##drvif_module_vpq_DmaAccessCtrl(ON)######", __FUNCTION__, __LINE__);
			}
		}
		switch(outputMode)
		{
			case KADP_VSC_OUTPUT_DISPLAY_MODE:
			{
				scaler_Setdualdecoder_notchange(0);
				if(DbgSclrFlgTkr.OuputDisplayMode == TRUE)
				{
					 if(rtk_hal_vsc_Getdualdecoder_run() && (inputSrcInfo.type == (KADP_VSC_INPUT_TYPE_T)VSC_INPUTSRC_VDEC)) {
						Scaler_Send_VoType_VOMDA(VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
						rtd_printk(KERN_INFO, TAG_NAME_VSC, "dual decoder case,connect just change port return\n");
						inputSrcInfo.resourceIndex=0;
						DisplayModeInputInfo = inputSrcInfo;
						set_current_scaler_source_num(SLR_MAIN_DISPLAY);
						return TRUE;
					}
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "DbgSclrFlgTkr.OuputDisplayMode is on, please disconnect output display mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.OutputVencMode == TRUE)
				{
					if((VencModeInputInfo.type == inputSrcInfo.type) && (VencModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						DbgSclrFlgTkr.OuputDisplayMode = TRUE;
						DisplayModeInputInfo = inputSrcInfo;
						//open display panel
					}
					else
					{
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "because venc mode is on, and display mode input is not the same with venc mode\n");
						return TRUE;
					}

				}
				else if(DbgSclrFlgTkr.OutputMemoryMode == TRUE)
				{
					if((MemoryModeInputInfo.type == inputSrcInfo.type) && (MemoryModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						DbgSclrFlgTkr.OuputDisplayMode = TRUE;
						DisplayModeInputInfo = inputSrcInfo;
						//open display panel
					}
					else
					{
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "because memory mode is on, and display mode input is not the same with memory mode\n");
						return TRUE;
					}

				}
				else if(DbgSclrFlgTkr.OutputAveMode == TRUE)
				{
					if((AveModeInputInfo.type == inputSrcInfo.type) && (AveModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						DbgSclrFlgTkr.OuputDisplayMode = TRUE;
						DisplayModeInputInfo = inputSrcInfo;
						//open display panel
					}
					else
					{
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "because ave mode is on, and display mode input is not the same with ave mode\n");
						return TRUE;
					}

				}
				else
				{
					DisplayModeInputInfo = inputSrcInfo;
#ifdef CONFIG_I2RND_ENABLE
					down(&I2RND_Semaphore);
					//if timing disable or sub disconnect, need to set force cmd flag let update register @Crixus 20171124
					if(!(Scaler_I2rnd_get_timing_enable() && DbgSclrFlgTkr.Sub_OuputDisplayMode)){
						Scaler_I2rnd_set_force_cmd(_ENABLE);
						Scaler_I2rnd_set_display(I2RND_MAIN_S0_TABLE);
					}
					if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC){
						set_i2rnd_vo1_refine_status_vir_addr(I2RND_S0_CONNECTED);
						set_i2rnd_s0_idomain_done_status(I2RND_S0_IDOMAIN_STAGE_OFF);
						printk(KERN_EMERG"[I2RND]main connect, I2RND_S0_CONNECTED!!\n");
					}
					up(&I2RND_Semaphore);
#endif
#ifdef VDO_CONNECT_NEW_FLOW_ENABLE
#ifdef CONFIG_I2RND_ENABLE
					//fixed main use port 0;
					DisplayModeInputInfo.resourceIndex = 0;
#else
					if((inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC) || (inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG))
						DisplayModeInputInfo.resourceIndex = 0;//add by will for live zoom
#endif
#endif
					DbgSclrFlgTkr.OuputDisplayMode = TRUE;
					if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC) {
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);
						Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
					}
					else if (inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);
						Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);
					}

					if(KADP_VSC_INPUTSRC_HDMI != inputSrcInfo.type)
					{
						if(SRC_CONNECT_DONE == get_HDMI_Global_Status())
							drvif_Hdmi_WatchDogApply(_DISABLE, HDMI_WD_VSC_COND);

						//drvif_Hdmi_OutputDisable(1); //willychou remove it for fixing KTASKWBS-9866 on 2018/11/28
					}
					else
					{
						drvif_Hdmi_OutputDisable(0);
#ifdef CONFIG_SUPPORT_FREESYNC
						//vbe_disp_set_freesync_mode_flag(1);
						//rtd_printk(KERN_INFO, TAG_NAME_VSC, "\r\n########[FreeSync] set_freesync_mode_flag enable!!!######\r\n");
#endif
					}

				}
				set_vsc_connect_ready(SLR_MAIN_DISPLAY, TRUE);
				break;
			}
			case KADP_VSC_OUTPUT_VENC_MODE:
			{
				if(DbgSclrFlgTkr.OutputVencMode==TRUE)
				{
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "please disconnect output venc mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.OutputMemoryMode == TRUE)
				{
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "DbgSclrFlgTkr.OutputMemoryMode is on, please disconnect output memory mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.OutputAveMode == TRUE)
				{
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "DbgSclrFlgTkr.OutputAveMode is on, please disconnect output memory mode first\n");
					return TRUE;
				}
				else
				{
					if(DbgSclrFlgTkr.OuputDisplayMode == TRUE)
					{
						if((DisplayModeInputInfo.type == inputSrcInfo.type) && (DisplayModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
						{
							DbgSclrFlgTkr.OutputVencMode = TRUE;
							VencModeInputInfo = inputSrcInfo;
						}
						else
						{
							rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "because display mode is on, and venc mode input is not the same with display mode\n");
							return TRUE;
						}
					}
					else
					{
						VencModeInputInfo = inputSrcInfo;
						DbgSclrFlgTkr.OutputVencMode = TRUE;
					}
				}

				break;
			}
			case KADP_VSC_OUTPUT_MEMORY_MODE:
			{
				if(DbgSclrFlgTkr.OutputMemoryMode==TRUE)
				{
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "please disconnect output memory mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.OutputVencMode == TRUE)
				{
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "DbgSclrFlgTkr.OutputVencMode is on, please disconnect output Venc mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.OutputAveMode == TRUE)
				{
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "DbgSclrFlgTkr.OutputAveMode is on, please disconnect output memory mode first\n");
					return TRUE;
				}
				else
				{
					if(DbgSclrFlgTkr.OuputDisplayMode == TRUE)
					{
						if((DisplayModeInputInfo.type == inputSrcInfo.type) && (DisplayModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
						{
							DbgSclrFlgTkr.OutputMemoryMode = TRUE;
							MemoryModeInputInfo = inputSrcInfo;
						}
						else
						{
							rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "because display mode is on, and memory mode input is not the same with display mode\n");
							return TRUE;
						}
					}
					else
					{
						MemoryModeInputInfo = inputSrcInfo;
						DbgSclrFlgTkr.OutputMemoryMode = TRUE;
						if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC) {
							rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);
							Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
						} else if (inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
							rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);
							Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);
						}
					}
				}
				set_vsc_connect_ready(SLR_MAIN_DISPLAY, TRUE);
				break;
			}
			case KADP_VSC_OUTPUT_AVE_MODE:
			{
				if(DbgSclrFlgTkr.OutputAveMode == TRUE)
				{
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "DbgSclrFlgTkr.OutputAveMode is on, please disconnect output ave mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.OutputMemoryMode == TRUE)
				{
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "DbgSclrFlgTkr.OutputMemoryMode is on, please disconnect output memory mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.OutputVencMode == TRUE)
				{
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "DbgSclrFlgTkr.OutputVencMode is on, please disconnect output Venc mode first\n");
					return TRUE;
				}
				else
				{
					if(DbgSclrFlgTkr.OuputDisplayMode == TRUE)
					{
						if((DisplayModeInputInfo.type == inputSrcInfo.type) && (DisplayModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
						{
							DbgSclrFlgTkr.OutputAveMode = TRUE;
							AveModeInputInfo = inputSrcInfo;
						}
						else
						{
							rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "because display mode is on, and AVE mode input is not the same with display mode\n");
							return TRUE;
						}
					}
					else
					{
						DbgSclrFlgTkr.OutputAveMode = TRUE;
						AveModeInputInfo = inputSrcInfo;
					}
				}
				break;
			}
			default:
				break;
		}
	}
#ifdef CONFIG_DUAL_CHANNEL
	if (wid ==VIDEO_WID_1) {
		if (Sub_VscOpendone_Flag == FALSE) {
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Sub vsc not open,so can not connect!\n");
			return TRUE;
		}
#if defined(CONFIG_RTK_AI_DRV)
#ifdef CONFIG_ENABLE_HDMI_NN
		if(h3ddma_nn_get_sub_path_enable() == ALL_CAP_ENABLE)
		{
			int cap_mode_ret =0;
			if (0 != (cap_mode_ret = Scaler_SendRPC(SCALERIOC_NN_CAP_MODE_SWITCH_EABLE,H3DDMA_CAP_ENABLE_ONLY,1)))//
			{
				rtd_printk(KERN_ERR, TAG_NAME_VSC,"ret=%d, SCALERIOC_NN_CAP_MODE_SWITCH_EABLE RPC fail !!!\n", cap_mode_ret);
			}
			h3ddma_nn_disable_sub_path();
		}
#endif
#endif
		increase_source_connect_verify_num(SLR_SUB_DISPLAY);//increase the sub source num

		if(KADP_VSC_INPUTSRC_AVD == inputSrcInfo.type)
		{
			if(SRC_CONNECT_DONE == get_AVD_Global_Status()){
				Scaler_AVD_SetHalVscConnect(SLR_SUB_DISPLAY,TRUE);
				drvif_module_vpq_DmaAccessCtrl(ON);
				rtd_printk(KERN_INFO, TAG_NAME_VSC, "\r\n########func:%s line:%d ##drvif_module_vpq_DmaAccessCtrl(ON)######\r\n", __FUNCTION__, __LINE__);
			}
		}

		switch(outputMode)
		{
			case KADP_VSC_OUTPUT_DISPLAY_MODE:
			{
				if(DbgSclrFlgTkr.Sub_OuputDisplayMode == TRUE)
				{
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "DbgSclrFlgTkr.Sub_OuputDisplayMode is on, please disconnect output display mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.Sub_OutputVencMode == TRUE)
				{
					if((Sub_VencModeInputInfo.type == inputSrcInfo.type) && (Sub_VencModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						DbgSclrFlgTkr.Sub_OuputDisplayMode = TRUE;
						Sub_DisplayModeInputInfo = inputSrcInfo;
						//open display panel
					}
					else
					{
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "because venc mode is on, and display mode input is not the same with venc mode\n");
						return TRUE;
					}

				}
				else if(DbgSclrFlgTkr.Sub_OutputMemoryMode == TRUE)
				{
					if((Sub_MemoryModeInputInfo.type == inputSrcInfo.type) && (Sub_MemoryModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						DbgSclrFlgTkr.Sub_OuputDisplayMode = TRUE;
						Sub_DisplayModeInputInfo = inputSrcInfo;
						//open display panel
					}
					else
					{
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "because memory mode is on, and display mode input is not the same with memory mode\n");
						return TRUE;
					}

				}
				else if(DbgSclrFlgTkr.Sub_OutputAveMode == TRUE)
				{
					if((Sub_AveModeInputInfo.type == inputSrcInfo.type) && (Sub_AveModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						DbgSclrFlgTkr.Sub_OuputDisplayMode = TRUE;
						Sub_DisplayModeInputInfo = inputSrcInfo;
						//open display panel
					}
					else
					{
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "because ave mode is on, and display mode input is not the same with ave mode\n");
						return TRUE;
					}

				}
				else
				{
					Sub_DisplayModeInputInfo = inputSrcInfo;

#ifdef VDO_CONNECT_NEW_FLOW_ENABLE
#ifdef CONFIG_I2RND_ENABLE
					//fixed sub use port 1;
					Sub_DisplayModeInputInfo.resourceIndex = 1;
#else
					if((inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC) /*|| (inputSrcInfo.type == VSC_INPUTSRC_JPEG)*/)
					{
						Sub_DisplayModeInputInfo.resourceIndex = 1;
					}
#endif
#endif
					DbgSclrFlgTkr.Sub_OuputDisplayMode = TRUE;


					if ((/*(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD) ||*/(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI) || (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC))
						&& (Sub_DisplayModeInputInfo.type == DisplayModeInputInfo.type)
						&& (sub_livezoom_type == KADP_VSC_SUB_CONNECT_TYPE_MIRROR)
						&& (DbgSclrFlgTkr.Sub_OuputDisplayMode == DbgSclrFlgTkr.OuputDisplayMode)) {/*DTV and HDMI*/
						Set_Live_zoom_mode(LIVE_ZOOM_ON);

#if 1/*disable livezoom framsync flow*/
						DbgSclrFlgTkr.DataFramesynclivezoom = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC);
#else
						DataFramesynclivezoom = FALSE;
#endif
					} else {
#ifdef CONFIG_I2RND_ENABLE
						down(&I2RND_Semaphore);
						if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC){
							set_i2rnd_vo1_refine_status_vir_addr(I2RND_S1_REFINE_VO1);
							printk(KERN_EMERG"[I2RND]sub connect, I2RND_S1_REFINE_VO1!!\n");
						}
						up(&I2RND_Semaphore);
#endif
						Set_Live_zoom_mode(LIVE_ZOOM_OFF);
#ifdef CONFIG_PST_ENABLE
						if(drvif_scaler_pst_get_mode_enable(_MAIN_VO_IMD))
							drvif_scaler_pst_uninitial(_MAIN_VO_IMD);
						if(drvif_scaler_pst_get_mode_enable(_SUB_VO_IMD))
							drvif_scaler_pst_uninitial(_SUB_VO_IMD);
#endif
						DbgSclrFlgTkr.DataFramesynclivezoom = FALSE;
						DbgSclrFlgTkr.LivezoomMainRerunFlag = FALSE;
						DbgSclrFlgTkr.LivezoomSubRerunFlag = FALSE;
						DbgSclrFlgTkr.LivezoomvoinfocheckFlag = FALSE;
						DbgSclrFlgTkr.LivezoomMainRerunEndneedOpenforcebgFlag = FALSE;
						sub_shape_type = VSC_MGF_TYPE_RECTANGLE;
						Set_LivezoomOffMainRunScaler(FALSE);
						if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC) {
							rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);

							Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
						}
						else if (inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
							rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);
							Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);
						}
					}

				}

				break;
			}
			case KADP_VSC_OUTPUT_VENC_MODE:
			{
				if(DbgSclrFlgTkr.Sub_OutputVencMode == TRUE)
				{
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "please disconnect output venc mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.Sub_OutputMemoryMode == TRUE)
				{
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "DbgSclrFlgTkr.Sub_OutputMemoryMode is on, please disconnect output memory mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.Sub_OutputAveMode == TRUE)
				{
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "DbgSclrFlgTkr.Sub_OutputAveMode is on, please disconnect output memory mode first\n");
					return TRUE;
				}
				else
				{
					if(DbgSclrFlgTkr.Sub_OuputDisplayMode == TRUE)
					{
						if((Sub_DisplayModeInputInfo.type == inputSrcInfo.type) && (Sub_DisplayModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
						{
							DbgSclrFlgTkr.Sub_OutputVencMode = TRUE;
							Sub_VencModeInputInfo = inputSrcInfo;
#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
							printk(KERN_EMERG"[vsc_connect]display:%d,port:%d\n",wid,inputSrcInfo.resourceIndex);
							printk(KERN_EMERG"rtk_hal_vsc_Connect para,inputSrcInfo:%d;%d;%d,outputMode:%d\n",inputSrcInfo.type, inputSrcInfo.attr, inputSrcInfo.resourceIndex, outputMode);

							if((run_i2rnd_flag == 0) && (inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)){
								run_i2rnd_flag = 1;
								rtk_hal_vsc_i2rnd_enable(_ENABLE);
								Scaler_I2rnd_set_display(I2RND_MAIN_S0_TABLE);
								VSC_OUTPUT_VENC_MODE_FLAG = TRUE;
								//apvr trigger scaler flow in tsk @Crixus 20160824
								if((vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_DISABLE) || (vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_RERUN_MAIN_DONE))
									vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_TRIGGER_RUN_MAIN;
								printk(KERN_EMERG"[%s][crixus]I2RND initial done\n", __FUNCTION__);
							}
#endif
#endif
						}
						else
						{
							rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "because display mode is on, and venc mode input is not the same with display mode\n");
							return TRUE;
						}
					}
					else
					{
						Sub_VencModeInputInfo = inputSrcInfo;
						DbgSclrFlgTkr.Sub_OutputVencMode = TRUE;
#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
						printk(KERN_EMERG"[vsc_connect]display:%d,port:%d\n",wid,inputSrcInfo.resourceIndex);
						printk(KERN_EMERG"rtk_hal_vsc_Connect para,inputSrcInfo:%d;%d;%d,outputMode:%d\n",inputSrcInfo.type, inputSrcInfo.attr, inputSrcInfo.resourceIndex, outputMode);

						if((run_i2rnd_flag == 0) && (inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)){
							run_i2rnd_flag = 1;
							rtk_hal_vsc_i2rnd_enable(_ENABLE);
							Scaler_I2rnd_set_display(I2RND_MAIN_S0_TABLE);
							VSC_OUTPUT_VENC_MODE_FLAG = TRUE;

							//apvr trigger scaler flow in tsk @Crixus 20160824
							if((vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_DISABLE) || (vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_RERUN_MAIN_DONE))
								vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_TRIGGER_RUN_MAIN;
							printk(KERN_EMERG"[%s][crixus]I2RND initial done\n", __FUNCTION__);
						}
#endif
#endif
					}
				}
				break;
			}
			case KADP_VSC_OUTPUT_MEMORY_MODE:
			{
				if(DbgSclrFlgTkr.Sub_OutputMemoryMode == TRUE)
				{
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "please disconnect output memory mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.Sub_OutputVencMode == TRUE)
				{
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "DbgSclrFlgTkr.OutputVencMode is on, please disconnect output Venc mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.Sub_OutputAveMode == TRUE)
				{
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "DbgSclrFlgTkr.OutputAveMode is on, please disconnect output memory mode first\n");
					return TRUE;
				}
				else
				{
					if(DbgSclrFlgTkr.Sub_OuputDisplayMode == TRUE)
					{
						if((Sub_DisplayModeInputInfo.type == inputSrcInfo.type) && (Sub_DisplayModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
						{
							DbgSclrFlgTkr.Sub_OutputMemoryMode = TRUE;
							Sub_MemoryModeInputInfo = inputSrcInfo;
						}
						else
						{
							rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "because display mode is on, and memory mode input is not the same with display mode\n");
							return TRUE;
						}
					}
					else
					{

						Sub_MemoryModeInputInfo = inputSrcInfo;
						DbgSclrFlgTkr.Sub_OutputMemoryMode = TRUE;
						if ((/*(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD) ||*/(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI) || (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC))
							&& (Sub_DisplayModeInputInfo.type == DisplayModeInputInfo.type)
							&& (Sub_DisplayModeInputInfo.resourceIndex == DisplayModeInputInfo.resourceIndex)
							&& (DbgSclrFlgTkr.Sub_OuputDisplayMode == DbgSclrFlgTkr.OuputDisplayMode))
						{/*DTV and HDMI*/
							Set_Live_zoom_mode(LIVE_ZOOM_ON);

#if 1/*disable livezoom framsync flow*/
							DbgSclrFlgTkr.DataFramesynclivezoom = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC);
#else
							DataFramesynclivezoom = FALSE;
#endif
							} else {
								Set_Live_zoom_mode(LIVE_ZOOM_OFF);
#ifdef CONFIG_PST_ENABLE
								if(drvif_scaler_pst_get_mode_enable(_MAIN_VO_IMD))
									drvif_scaler_pst_uninitial(_MAIN_VO_IMD);
								if(drvif_scaler_pst_get_mode_enable(_SUB_VO_IMD))
									drvif_scaler_pst_uninitial(_SUB_VO_IMD);
#endif
								DbgSclrFlgTkr.DataFramesynclivezoom = FALSE;
								DbgSclrFlgTkr.LivezoomMainRerunFlag = FALSE;
								DbgSclrFlgTkr.LivezoomSubRerunFlag = FALSE;
								DbgSclrFlgTkr.LivezoomvoinfocheckFlag = FALSE;
								DbgSclrFlgTkr.LivezoomMainRerunEndneedOpenforcebgFlag = FALSE;
								sub_shape_type = VSC_MGF_TYPE_RECTANGLE;
								Set_LivezoomOffMainRunScaler(FALSE);
								if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC) {
									rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);

									Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
								}
								else if (inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
									rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n########func:%s line:%d ########\r\n", __FUNCTION__, __LINE__);
									Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);
								}
							}
					}
				}
				break;
			}
			case KADP_VSC_OUTPUT_AVE_MODE:
			{
				if(DbgSclrFlgTkr.Sub_OutputAveMode == TRUE)
				{
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "DbgSclrFlgTkr.Sub_OutputAveMode is on, please disconnect output ave mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.Sub_OutputMemoryMode == TRUE)
				{
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "DbgSclrFlgTkr.Sub_OutputMemoryMode is on, please disconnect output memory mode first\n");
					return TRUE;
				}
				else if(DbgSclrFlgTkr.Sub_OutputVencMode == TRUE)
				{
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "DbgSclrFlgTkr.Sub_OutputVencMode is on, please disconnect output Venc mode first\n");
					return TRUE;
				}
				else
				{
					if(DbgSclrFlgTkr.Sub_OuputDisplayMode == TRUE)
					{
						if((Sub_DisplayModeInputInfo.type == inputSrcInfo.type) && (Sub_DisplayModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
						{
							DbgSclrFlgTkr.Sub_OutputAveMode = TRUE;
							Sub_AveModeInputInfo = inputSrcInfo;
						}
						else
						{
							rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "because display mode is on, and AVE mode input is not the same with display mode\n");
							return TRUE;
						}
					}
					else
					{
						DbgSclrFlgTkr.Sub_OutputAveMode = TRUE;
						Sub_AveModeInputInfo = inputSrcInfo;
					}
				}
				break;
			}
			default:
				break;
		}
	}
#endif
	return TRUE;
}

void rtk_i3ddma_disable(void)
{
	extern void h3ddma_set_capture_enable(unsigned char chanel,unsigned char enable);

#ifdef CONFIG_FORCE_RUN_I3DDMA
down(&Force_Run_Idma_Semaphore);
	if(get_force_i3ddma_enable(SLR_MAIN_DISPLAY)) {
		Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_HDMI, 0xfa);
		set_force_i3ddma_enable(false);
		set_i3ddma_4k120_flag(0);
		#ifdef CONFIG_ENABLE_HDMI_NN
		if(h3ddma_nn_get_sub_path_enable() == ALL_CAP_ENABLE)
			h3ddma_nn_disable_sub_path();
		#endif
		h3ddma_set_capture_enable(0,0);
		h3ddma_set_capture_enable(1,0);
		h3ddma_set_capture_enable(2,0);
		h3ddma_set_capture_enable(3,0);
		I3DDMA_Setup3DDMA(&i3ddmaCtrl, I3DDMA_3D_OPMODE_DISABLE,SLR_MAIN_DISPLAY);
		/* WOSQRTK-11529 */
		if(H3DDMA_H3DDMA_PQ_CMP_DOUBLE_BUFFER_CTRL_get_db_en(IoReg_Read32(H3DDMA_H3DDMA_PQ_CMP_DOUBLE_BUFFER_CTRL_reg)) == 0) {
			mdelay(1);
		} else {
			msleep(40); /*wait DMA write done */
		}
		down(&HDMI_4K120_MEMORY_PROTECTION_Semaphore);
		up(&HDMI_4K120_MEMORY_PROTECTION_Semaphore);
		drvif_I3DDMA_Disable_Vgip();
		// [IDMA] allocate/release IDMA memory dynamic
		if(I3DDMA_Get3DAllocReleaseMemoryDynamic() == TRUE)
			I3DDMA_DolbyVision_HDMI_DeInit();

		#ifdef CONFIG_ENABLE_HDMI_NN
		if(get_i3ddma_NN_flag())
			h3ddma_free_nv12_mermory();
		#endif
	}

up(&Force_Run_Idma_Semaphore);

#endif
}


struct semaphore* get_double_buffer_semaphore(void)
{
	return &Double_buffer_Semaphore;
}
extern void vo_free_photo_buffer(unsigned int ch);

extern int flag_vdo_disconnect;
unsigned char vdo_connect(unsigned char display, unsigned char vdec_port)
{



#ifdef CONFIG_RTK_KDRV_RPC
	unsigned long ret = 0;
#endif
	if (display == VIDEO_WID_0)
	{
		if(vdo0_connect)
		{
			pr_notice("\r\n## main vdo_connect already connect ##\r\n");
			return TRUE;
		}
	}
	else
	{
		if(vdo1_connect)
		{
			pr_notice("\r\n## sub vdo_connect already connect ##\r\n");
			return TRUE;
		}
	}
	rtd_printk(KERN_INFO, TAG_NAME_VSC, "vdo_connect wid:%d vdec_port:%d\n", display, vdec_port);


	if(display == VIDEO_WID_0)//add by will for live zoom
		vdo0_connect = TRUE; //vo 0 connect
	else
		vdo1_connect = TRUE; //vo 1 connect

	increase_source_connect_verify_num(display);//increase the vsc source verify num. for checking vsc connect again

#ifdef CONFIG_RTK_KDRV_RPC
	if (send_rpc_command(RPC_VIDEO, VIDEO_RPC_VOUT_ToAgent_VDOCONNECT_TO_VODMA, (unsigned char)vdec_port, (unsigned char)display, &ret))
	{
		pr_err("\r\n#### VIDEO_RPC_VOUT_ToAgent_VDOCONNECT_TO_VODMA RPC fail ####\r\n");
		return FALSE;
	}
#endif


#ifdef CONFIG_DUMP_REGISTER_WHEN_ONLY_DISCONNECT
		flag_vdo_disconnect = 0;

#endif

	return TRUE;

}

unsigned char vdo_disconnect(unsigned char display, unsigned char vdec_port)
{
	unsigned char result = TRUE;
#ifdef CONFIG_RTK_KDRV_RPC
	unsigned long ret;
#endif

#ifdef CONFIG_DUMP_REGISTER_WHEN_ONLY_DISCONNECT
	flag_vdo_disconnect = 1;
#endif

	if (display == VIDEO_WID_0)
	{
		if(!vdo0_connect)
		{
			pr_notice("\r\n## main vdo_disconnect already disconnect ##\r\n");
			return TRUE;
		}
	}
	else
	{
		if(!vdo1_connect)
		{
			pr_notice("\r\n## sub vdo_disconnect already disconnect ##\r\n");
			return TRUE;
		}
	}
	if (rtk_hal_vsc_Getdualdecoder_run()) {
#ifdef CONFIG_RTK_KDRV_RPC
		if (send_rpc_command(RPC_VIDEO, VIDEO_RPC_VOUT_ToAgent_VDODISCONNECT_TO_VODMA, (unsigned char)vdec_port, (unsigned char)display, &ret))
		{
			pr_err("\r\n#### VIDEO_RPC_VOUT_ToAgent_VDODISCONNECT_TO_VODMA RPC fail ####\r\n");
			result =  FALSE;
		}
#endif
		if (display == VIDEO_WID_0) {
			vdo0_connect = FALSE;
		} else {
			vdo1_connect = FALSE;
		}
		rtd_printk(KERN_INFO, TAG_NAME_VSC, "dual decoder case,vdo_disconnect not change,return\n");
		return result;
	}
	set_display_forcebg_mask(display, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);//Enable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
	mute_control(display, TRUE);/*Auto BG. Add by Will*/
	rtd_printk(KERN_INFO, TAG_NAME_VSC, "vdo_disconnect wid:%d vdec_port:%d (0x%08x)\n", display, vdec_port, IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg));


	if (display == VIDEO_WID_0) {
		vdo0_connect = FALSE; //vo 0 disconnect
		down(&SetMainOutPutRegion_Semaphore);
		DbgSclrFlgTkr.Main_Scaler_Stop_flag = TRUE;
		DbgSclrFlgTkr.Main_force_frc_flag = FALSE;
		DbgSclrFlgTkr.Main_force_frc_fs_flag = FALSE;
		DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = FALSE;
		DbgSclrFlgTkr.Main_smooth_toggle_set_flag = FALSE;
		DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = FALSE;
		DbgSclrFlgTkr.rotate_run_scaler_flag = FALSE;
		DbgSclrFlgTkr.rotate_muteoff_request_flag = FALSE;
		rotate_mode = DIRECT_VO_FRAME_ORIENTATION_DEFAULT;
		rotate_mode_pre = DIRECT_VO_FRAME_ORIENTATION_DEFAULT;
		set_rotate_mode(DIRECT_VO_FRAME_ORIENTATION_DEFAULT);
		set_ori_rotate_mode(DIRECT_VO_FRAME_ORIENTATION_DEFAULT);
		is_DTV_flag_set(_DISABLE);
		DbgSclrFlgTkr.smoothtoggle_start_flag = FALSE;
		zoom_clear_input_output_region_record((unsigned char)display);
		Scaler_InputRegionType_Set(display,INPUT_BASE_ON_TIMING);
		up(&SetMainOutPutRegion_Semaphore);
		source_disconnect_reset_input(SLR_MAIN_DISPLAY);//reset input region to zero

		DbgSclrFlgTkr.main_winfreeze=0;
		drivf_scaler_reset_freerun();
#ifdef ENABLE_IMD_PST_SMOOTHTOGGLE
        scaler_vsc_set_keep_vo_framerate_control(0);
        scaler_vsc_set_adaptive_pst_lowdelay_mode(0);
#endif
	}
	else
	{
		vdo1_connect = FALSE; //vo 1 disconnect
		down(&SetSubOutPutRegion_Semaphore);
		DbgSclrFlgTkr.Sub_Scaler_Stop_flag = TRUE;
		zoom_clear_input_output_region_record((unsigned char)display);
		Scaler_InputRegionType_Set(display,INPUT_BASE_ON_TIMING);
		up(&SetSubOutPutRegion_Semaphore);
		source_disconnect_reset_input(SLR_SUB_DISPLAY);//reset input region to zero
	}

	drvif_mode_onlinemeasure_setting(display, Scaler_InputSrcGetType(display), FALSE, FALSE);
    drvif_mode_disableonlinemeasure(display);//Diable online measure

	down(get_vo_infosemaphore());
	set_vo_change_flag((unsigned char)display, FALSE);//Reset Vo change flag
	set_force_change_vo_flag((unsigned char)display, TRUE);
	up(get_vo_infosemaphore());

	Check_smooth_toggle_update_flag(display);
#ifdef CONFIG_RTK_KDRV_RPC
	if (send_rpc_command(RPC_VIDEO, VIDEO_RPC_VOUT_ToAgent_VDODISCONNECT_TO_VODMA, (unsigned char)vdec_port, (unsigned char)display, &ret))
	{
		pr_err("\r\n#### VIDEO_RPC_VOUT_ToAgent_VDODISCONNECT_TO_VODMA RPC fail ####\r\n");
		result =  FALSE;
	}
#endif
	smooth_toggle_disconnect(display,display);
	Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
	state_update_disp_info();

#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
	if (TRUE == Get_rotate_function())
	{
		down(&Main_ResetMode_Semaphore);
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####func:%s request reset mode####\r\n", __FUNCTION__);
		DbgSclrFlgTkr.Main_Reset_Mode_flag = TRUE;
		up(&Main_ResetMode_Semaphore);
	}
#endif


#ifdef Mer2_MEMORY_ALLOC
	if (display == VIDEO_WID_0)
	{
		Scaler_color_set_HDR_Type(0xff);	// reset hdr type
		drv_memory_I_De_XC_DMA_Memory_Get_From_VBM(0, 0, 0, 1);
		drv_memory_I_De_XC_DMA_Memory_Get_From_VBM(1, 0, 0, 1);
		drv_memory_MA_SNR_Disable(0);
		drv_memory_MA_SNR_Disable(1);
		/* for PQ IP Enable monitor*/
		Scaler_PQ_IP_Enable_Monitor_clear_Buff();
	}
#endif

	if (display == VIDEO_WID_0) {
		DbgSclrFlgTkr.Main_during_scalerflow_flag = FALSE;//WOSQRTK-7524 patch. Reset DbgSclrFlgTkr.Main_during_scalerflow_flag.
		DbgSclrFlgTkr.Main_AutoRunScaler = FALSE;
		down(&SetMainOutPutRegion_Semaphore);
		reset_any_srcrect(&main_dispwin_pre);
		reset_any_srcrect(&main_dispwin_for_only_xy);
		up(&SetMainOutPutRegion_Semaphore);
	} else {
		DbgSclrFlgTkr.Sub_AutoRunScaler = FALSE;
		down(&SetSubOutPutRegion_Semaphore);
		reset_any_srcrect(&sub_dispwin_pre);
		up(&SetSubOutPutRegion_Semaphore);
	}


	pr_notice("[VSC] vdo_disconnect done (0x%08x)\n", IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg));
	return result;
}


unsigned char rtk_hal_vsc_Disconnect(VIDEO_WID_T wid, KADP_VSC_INPUT_SRC_INFO_T inputSrcInfo, KADP_VSC_OUTPUT_MODE_T outputMode)
{
	unsigned int *p_sourceID = NULL;
	StructSrcRect SrcRect = {0, 0, 0, 0};
	unsigned char plane=0;
#ifdef CONFIG_I2RND_ENABLE
	unsigned char i2rnd_port_main = 0;
	unsigned char i2rnd_port_sub = 0;
#endif

#ifdef CONFIG_I2RND_B05_ENABLE
     if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC) {
           //  printk("!!!!!!!!!!!!!!!!!!!!!!!!!!!b05_vsc_Disconnect!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
             rtk_hal_vsc_i2rnd_b05_enable(_DISABLE);
     }
#endif

#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	} else if (wid == VIDEO_WID_0) {
		p_sourceID = &DbgSclrFlgTkr.main_opensourceID;
	} else {
		p_sourceID = &DbgSclrFlgTkr.sub_opensourceID;
	}
#else
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	} else {
		p_sourceID = &DbgSclrFlgTkr.main_opensourceID;
	}
#endif
//Eric@20171013 set cmd table index before setting register
#ifdef CONFIG_I2RND_ENABLE
	if(Scaler_I2rnd_get_timing_enable()){
		if(wid == VIDEO_WID_0)
			Scaler_I2rnd_set_display(I2RND_MAIN_S0_TABLE);
		else if (wid == VIDEO_WID_1)
			Scaler_I2rnd_set_display(I2RND_SUB_S1_TABLE);
	}
#endif
	rtd_printk(KERN_INFO, TAG_NAME_VSC, "vsc_disconnect wid:%d SrcInfo:%d;%d;%d,Mode:%d\n", wid, inputSrcInfo.type, inputSrcInfo.attr, inputSrcInfo.resourceIndex, outputMode);

	if (wid ==VIDEO_WID_0) {
		set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_LIVEZOOM, FALSE);

		if((KADP_VSC_INPUTSRC_AVD == inputSrcInfo.type))
		{
			Scaler_AVD_SetHalVscConnect(SLR_MAIN_DISPLAY,FALSE);
			if(Scaler_AVD_GetHalVscConnect(SLR_SUB_DISPLAY) == FALSE){
				drvif_module_vpq_DmaAccessCtrl(OFF);
				rtd_printk(KERN_INFO, TAG_NAME_VSC, "\r\n########func:%s line:%d ##drvif_module_vpq_DmaAccessCtrl(OFF)######\r\n", __FUNCTION__, __LINE__);
			}
		}

		switch(outputMode)
		{
			case KADP_VSC_OUTPUT_DISPLAY_MODE:
			{
				if(DbgSclrFlgTkr.OuputDisplayMode == TRUE)
				{
#ifdef VDO_CONNECT_NEW_FLOW_ENABLE
					if(DisplayModeInputInfo.type == inputSrcInfo.type)
#else
					if((DisplayModeInputInfo.type == inputSrcInfo.type) && (DisplayModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
#endif
					{
						if (rtk_hal_vsc_Getdualdecoder_run() && (inputSrcInfo.type == (KADP_VSC_INPUT_TYPE_T)VSC_INPUTSRC_VDEC)) {
							Scaler_Send_VoDisconnect_VOMDA(VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
							down(get_vo_infosemaphore());
							set_force_change_vo_flag(inputSrcInfo.resourceIndex, TRUE);
							up(get_vo_infosemaphore());
                            reset_any_srcrect(&main_input_size);
							reset_any_srcrect(&main_dispwin);
							scaler_Setdualdecoder_notchange(1);
							rtd_printk(KERN_INFO, TAG_NAME_VSC, "dual decoder case,disconnect not change,return, and clear pre input,output\n");
							return TRUE;
						}
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);//Enable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);/*Auto BG. Add by Will*/
						set_vsc_connect_ready(SLR_MAIN_DISPLAY, FALSE);
						down(&SetMainOutPutRegion_Semaphore);
						DbgSclrFlgTkr.Main_Scaler_Stop_flag = TRUE;
						DbgSclrFlgTkr.Main_force_frc_flag = FALSE;
						DbgSclrFlgTkr.Main_force_frc_fs_flag = FALSE;
						DbgSclrFlgTkr.smoothtoggle_start_flag = FALSE;
						DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = FALSE;
						DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = FALSE;
						DbgSclrFlgTkr.Main_smooth_toggle_set_flag = FALSE;
						DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = FALSE;
						DbgSclrFlgTkr.rotate_run_scaler_flag = FALSE;
						DbgSclrFlgTkr.rotate_muteoff_request_flag = FALSE;
						rotate_mode = DIRECT_VO_FRAME_ORIENTATION_DEFAULT;
						rotate_mode_pre = DIRECT_VO_FRAME_ORIENTATION_DEFAULT;
						set_rotate_mode(DIRECT_VO_FRAME_ORIENTATION_DEFAULT);
						set_ori_rotate_mode(DIRECT_VO_FRAME_ORIENTATION_DEFAULT);
						is_DTV_flag_set(_DISABLE);
						zoom_clear_input_output_region_record(wid);
						Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_TIMING);
						up(&SetMainOutPutRegion_Semaphore);
						DbgSclrFlgTkr.main_winfreeze=0;
						DbgSclrFlgTkr.mainVscFreezeFlag=0;
						source_disconnect_reset_input(SLR_MAIN_DISPLAY);//reset input region to zero
						memc_me_clock_set_off = 0;	//reset me_clock_set_off flag
						//reset film parameter
						film_mode_parameter.enable = 0;
						film_mode_parameter.type= 0;
						film_mode_parameter.v_freq = 0;
						ori_voclk_ratio_num = 0;
						Scaler_set_dynamic_framerate_change_flag(_DISABLE);
						drv_memory_set_vdec_direct_low_latency_mode(_DISABLE);
						scaler_set_VRR_pwm_frequency_update_in_isr(FALSE);
                        scaler_RGB444Mode_pre = FALSE;
						vsc_force_rerun_main_scaler = FALSE;
						//change source ap not close
						if(drv_memory_get_game_mode_flag())
						{
							drv_memory_set_game_mode_dynamic(_DISABLE);
							pr_notice("[%s][%d][Disable LowDelayMode]", __FUNCTION__, __LINE__);
							vpq_memc_set_lowDelayMode(_DISABLE);
							fw_scalerip_set_di_gamemode_setting(_DISABLE);
						}
#ifdef CONFIG_SUPPORT_FREESYNC
						//vbe_disp_set_freesync_mode_flag(0);
						//rtd_printk(KERN_INFO, TAG_NAME_VSC, "\r\n########[FreeSync] set_freesync_mode_flag disable!!!######\r\n");
#endif
						if (inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
							vo_free_photo_buffer(0);
						}
						drivf_scaler_reset_freerun();

						if((DbgSclrFlgTkr.OutputVencMode == FALSE) && (DbgSclrFlgTkr.OutputMemoryMode == FALSE) && (DbgSclrFlgTkr.OutputAveMode == FALSE))
						{
							drvif_mode_onlinemeasure_setting(_CHANNEL1, Scaler_InputSrcGetType(SLR_MAIN_DISPLAY), FALSE, FALSE);
                            drvif_mode_disableonlinemeasure(_CHANNEL1);//Diable online measure
                            //set detect timng flag true:
							if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
							{
								/*//no need because AVD don't stop detect task
								down(get_vdc_detectsemaphore());
								if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
								up(get_vdc_detectsemaphore());
								*/
								rtd_printk(KERN_INFO, TAG_NAME_VSC, "#####[%s(%d)] get_ADC_Global_Status=%d\n", __func__, __LINE__, get_ADC_Global_Status());
								if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
									drvif_adc_power_control(ADC_POWER_YPP_ONLY_DETECT_CONTROL,__func__,__LINE__);
								}
                                rtk_i3ddma_disable();
								set_force_change_vo_flag(0, TRUE);//[K5LG-14140] 0:main display, force set vo change flag as TURE to avoid switching with same timing case
							}
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
							{
								down(get_hdmi_detectsemaphore());
								if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
								up(get_hdmi_detectsemaphore());
                                rtk_i3ddma_disable();
								//drvif_Hdmi_OutputDisable(1); // not HDMI source, disable HDMI output,willychou remove it for fixing KTASKWBS-9866 on 2018/11/28
								drvif_Hdmi_WatchDogApply(_DISABLE, HDMI_WD_VSC_COND);
								set_force_change_vo_flag(0, TRUE);//[K5LG-14140] 0:main display, force set vo change flag as TURE to avoid switching with same timing case
							}
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
							{
								down(get_adc_detectsemaphore());
								fw_scaler_adc_nolock_wdg_ctrl(SLR_MAIN_DISPLAY, FALSE);// Disable adc_nolock_wdg
								if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
									YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
									ADC_set_detect_flag(TRUE);
								}
								up(get_adc_detectsemaphore());
								rtk_i3ddma_disable();
								set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
								set_force_change_vo_flag(0, TRUE);//[K5LG-14140] 0:main display, force set vo change flag as TURE to avoid switching with same timing case
							} else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
							//	vo_overscan_disable(inputSrcInfo.type);
								Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
								if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC)
								{
									Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
								}
								else
									Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);


								down(get_vo_infosemaphore());
								DbgSclrFlgTkr.OuputDisplayMode = FALSE;
								plane=Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_VODMA_PLANE);
								DisplayModeInputInfo =(KADP_VSC_INPUT_SRC_INFO_T) {KADP_VSC_INPUTSRC_MAXN, 0, 0};
#ifdef CONFIG_I2RND_ENABLE
								set_vo_change_flag(i2rnd_port_main, FALSE);//Reset Vo change flag
								set_force_change_vo_flag(i2rnd_port_main, TRUE);
#else
								set_vo_change_flag(inputSrcInfo.resourceIndex, FALSE);//Reset Vo change flag
								set_force_change_vo_flag(inputSrcInfo.resourceIndex, TRUE);
#endif
								rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####Set force_change_vo_flag TRUE and reset vo change flag####\r\n");
								up(get_vo_infosemaphore());
							}
							smooth_toggle_disconnect(SLR_MAIN_DISPLAY,plane);
							Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_STATE, _MODE_STATE_SEARCH);
							state_update_disp_info();

#ifdef Mer2_MEMORY_ALLOC
							Scaler_color_set_HDR_Type(0xff);	// reset hdr type
							drv_memory_I_De_XC_DMA_Memory_Get_From_VBM(0, 0, 0, 1);
							drv_memory_I_De_XC_DMA_Memory_Get_From_VBM(1, 0, 0, 1);
							drv_memory_MA_SNR_Disable(0);
							drv_memory_MA_SNR_Disable(1);
							/* for PQ IP Enable monitor*/
							Scaler_PQ_IP_Enable_Monitor_clear_Buff();
#endif

						}
						//USER:Lewislee DATE:2015/10/2
						//when PIP off, need reset setting
						Scaler_Disp3dSetInfo(SLR_MAIN_DISPLAY, SLR_DISP_3D_3DTYPE, SLR_3D_2D_ONLY);
						Scaler_Set3DMode_Attr(SLR_MAIN_DISPLAY, SLR_3DMODE_2D);
#ifdef CONFIG_I2RND_ENABLE
						//printk(KERN_EMERG"[crixus][vsc_disconnect]display:%d,port:%d\n",wid,inputSrcInfo.resourceIndex);
						//printk(KERN_EMERG"[crixus]rtk_hal_vsc_Disconnect para,inputSrcInfo:%d;%d;%d,outputMode:%d\n",inputSrcInfo.type, inputSrcInfo.attr, inputSrcInfo.resourceIndex, outputMode);
						down(&I2RND_Semaphore);
						//clear i2rnd main voinfo i2r_fix_me
						i2rnd_main_voinfo = i2rnd_empty_voinfo;

						//Eric@20170809 disable i2rnd when VDEC src disconnected
						if((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_SUB_DISABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_DISABLE)){
							//sub already disconnect
							Scaler_I2rnd_set_force_cmd(_DISABLE);
							Scaler_pst_buffer_initial(_MAIN_MD);
							printk(KERN_EMERG"[%s][I2RND][main disconnect]I2RND initial\n", __FUNCTION__);
						}
						else{
							//sub still connect, keep 1:1 mode
							printk(KERN_EMERG"[%s][I2RND][main disconnect]sub still connect, keep 1:1\n", __FUNCTION__);
						}
						if(get_i2rnd_vo1_refine_status_vir_addr() == I2RND_S0_CONNECTED){
							set_i2rnd_vo1_refine_status_vir_addr(I2RND_VO1_REFINE_OFF);
							printk(KERN_EMERG"[I2RND]main disconnect, I2RND_VO1_REFINE_OFF!!\n");
						}
						set_i2rnd_s0_idomain_done_status(I2RND_S0_IDOMAIN_STAGE_OFF);
						printk(KERN_EMERG"[I2RND]main disconnect, I2RND_S0_IDOMAIN_STAGE_OFF!!\n");
						up(&I2RND_Semaphore);
#endif

						DbgSclrFlgTkr.OuputDisplayMode = FALSE;
						DisplayModeInputInfo =(KADP_VSC_INPUT_SRC_INFO_T) {KADP_VSC_INPUTSRC_MAXN, 0, 0};
						*p_sourceID = _UNKNOWN_INPUT;
						//close display panel
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#ifdef CONFIG_SUPPORT_DOLBY_VSIF
						if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)//disconnect hdmi change the resource
						{
							vfe_hdmi_drv_set_infoframe_thread_stop(_FALSE);
#if FREEZE_MUTE_IMPLEMENT_STATE == H5X_MDOMAIN && defined(CONFIG_RTK_8KCODEC_INTERFACE)
							resetH5XFreezeMuteStatus();
#endif
						}
#endif //#ifdef CONFIG_SUPPORT_DOLBY_VSIF
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
					}
					else
					{
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "inputSrcInfo not match;display mode not open\n");
						return TRUE;
					}
				}
				else
				{
					if(DbgSclrFlgTkr.OutputVencMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_VENC_MODE);
					} else if(DbgSclrFlgTkr.OutputMemoryMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_MEMORY_MODE);
					} else if(DbgSclrFlgTkr.OutputAveMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_AVE_MODE);
					} else {
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, " error display mode not open\n");
						return TRUE;
					}
				}
				DbgSclrFlgTkr.Main_during_scalerflow_flag = FALSE;//WOSQRTK-7524 patch. Reset DbgSclrFlgTkr.Main_during_scalerflow_flag.
				DbgSclrFlgTkr.Main_AutoRunScaler = FALSE;
				down(&SetMainOutPutRegion_Semaphore);
				reset_any_srcrect(&main_dispwin_pre);
				reset_any_srcrect(&main_dispwin_for_only_xy);
				up(&SetMainOutPutRegion_Semaphore);
				if((Get_Live_zoom_mode()!=LIVE_ZOOM_OFF) &&(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_STATE) ==  _MODE_STATE_ACTIVE))
				{// when MAIN disconnected, mute the video for SUB of livezoom or magnifier. Q-3072
					down(get_forcebg_semaphore());
					scalerdisplay_force_bg_enable(SLR_SUB_DISPLAY, TRUE);//_DISABLE);//pool test
					drvif_scalerdisplay_enable_display(SLR_SUB_DISPLAY, _DISABLE);
					up(get_forcebg_semaphore());
				}
				if (Get_LivezoomOffMainRunScaler() == TRUE) {
					Set_LivezoomOffMainRunScaler(FALSE);
				}

				if(get_vdec_securestatus()==TRUE){
					set_vdec_securestatus(FALSE);
					set_dtv_securestatus(FALSE);
					#if defined(CONFIG_RTK_AI_DRV)// 0520 lsy
					set_vdec_securestatus_aipq(FALSE);
					set_dtv_securestatus_aipq(FALSE);
					#endif// end 0520 lsy
				}
				DbgSclrFlgTkr.DataFramesynclivezoom = FALSE;

				if(read_buffer_first_flag == 1){
					read_buffer_first_flag = 0;
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "[self-dianosis]27M reset !!\n");
				}
				break;
			}
			case KADP_VSC_OUTPUT_VENC_MODE:
			{
				if(DbgSclrFlgTkr.OutputVencMode == TRUE)
				{
					if((VencModeInputInfo.type == inputSrcInfo.type) && (VencModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						if(DbgSclrFlgTkr.OuputDisplayMode == FALSE)
						{
							drvif_mode_onlinemeasure_setting(_CHANNEL1, Scaler_InputSrcGetType(SLR_MAIN_DISPLAY), FALSE, FALSE);
                            drvif_mode_disableonlinemeasure(_CHANNEL1);//Diable online measure
                            //set detect timng flag true:
							if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
							{
								/*//no need because AVD don't stop detect task
								down(get_vdc_detectsemaphore());
								if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
								up(get_vdc_detectsemaphore());
								*/
							}
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
							{
								down(get_hdmi_detectsemaphore());
								if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
								up(get_hdmi_detectsemaphore());
							}
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
							{
								down(get_adc_detectsemaphore());
								fw_scaler_adc_nolock_wdg_ctrl(SLR_MAIN_DISPLAY, FALSE);// Disable adc_nolock_wdg
								if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
									YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
									ADC_set_detect_flag(TRUE);
								}
								up(get_adc_detectsemaphore());
								set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
							}
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
								plane=Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_VODMA_PLANE);
								Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
								//smooth_toggle_disconnect(SLR_MAIN_DISPLAY,plane);
							}
							smooth_toggle_disconnect(SLR_MAIN_DISPLAY,plane);
							Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_STATE, _MODE_STATE_SEARCH);
							state_update_disp_info();
						}
						DbgSclrFlgTkr.OutputVencMode = FALSE;
						VencModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};
						*p_sourceID = _UNKNOWN_INPUT;
					}
					else
					{
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "inputSrcInfo not match;venc mode close fail\n");
						return TRUE;
					}
				}
				else
				{
					if(DbgSclrFlgTkr.OuputDisplayMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
					} else if(DbgSclrFlgTkr.OutputMemoryMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_MEMORY_MODE);
					} else if(DbgSclrFlgTkr.OutputAveMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_AVE_MODE);
					} else {
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, " error venc mode not open\n");
						return TRUE;
					}
				}

				break;
			}
			case KADP_VSC_OUTPUT_MEMORY_MODE://Current same with VSC_OUTPUT_DISPLAY_MODE
			{
				if(DbgSclrFlgTkr.OutputMemoryMode == TRUE)
				{
					if((MemoryModeInputInfo.type == inputSrcInfo.type) && (MemoryModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);//Enable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);/*Auto BG. Add by Will*/
						down(&SetMainOutPutRegion_Semaphore);
						DbgSclrFlgTkr.Main_Scaler_Stop_flag = TRUE;
						DbgSclrFlgTkr.Main_force_frc_flag = FALSE;
						DbgSclrFlgTkr.Main_force_frc_fs_flag = FALSE;
						DbgSclrFlgTkr.smoothtoggle_start_flag = FALSE;
						DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = FALSE;
						DbgSclrFlgTkr.Main_smooth_toggle_set_flag = FALSE;
						DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = FALSE;
						DbgSclrFlgTkr.rotate_run_scaler_flag = FALSE;
						DbgSclrFlgTkr.rotate_muteoff_request_flag = FALSE;
						is_DTV_flag_set(_DISABLE);
						zoom_clear_input_output_region_record(wid);
						Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_TIMING);
						up(&SetMainOutPutRegion_Semaphore);
						source_disconnect_reset_input(SLR_MAIN_DISPLAY);//reset input region to zero
						DbgSclrFlgTkr.main_winfreeze=0;
						DbgSclrFlgTkr.mainVscFreezeFlag=0;
						if(DbgSclrFlgTkr.OuputDisplayMode==FALSE)
						{
							drvif_mode_onlinemeasure_setting(_CHANNEL1, Scaler_InputSrcGetType(SLR_MAIN_DISPLAY), FALSE, FALSE);
                            drvif_mode_disableonlinemeasure(_CHANNEL1);//Diable online measure
                            //set detect timng flag true:
							if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
							{
								/*//no need because AVD don't stop detect task
								down(get_vdc_detectsemaphore());
								if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
								up(get_vdc_detectsemaphore());
								*/
							}
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
							{
								down(get_hdmi_detectsemaphore());
								if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
								up(get_hdmi_detectsemaphore());
							}
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
							{
								down(get_adc_detectsemaphore());
								fw_scaler_adc_nolock_wdg_ctrl(SLR_MAIN_DISPLAY, FALSE);// Disable adc_nolock_wdg
								if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
									YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
									ADC_set_detect_flag(TRUE);
								}
								up(get_adc_detectsemaphore());
								set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
							} else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
							//	vo_overscan_disable(inputSrcInfo.type);
								Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
								if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC)
									Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
								else
									Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);

								down(get_vo_infosemaphore());
								DbgSclrFlgTkr.OutputMemoryMode = FALSE;
								plane=Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_VODMA_PLANE);
								MemoryModeInputInfo =(KADP_VSC_INPUT_SRC_INFO_T) {KADP_VSC_INPUTSRC_MAXN, 0, 0};
								set_vo_change_flag(inputSrcInfo.resourceIndex, FALSE);//Reset Vo change flag
								set_force_change_vo_flag(inputSrcInfo.resourceIndex, TRUE);
								rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####Set force_change_vo_flag TRUE and reset vo change flag####\r\n");
								up(get_vo_infosemaphore());
							}
							smooth_toggle_disconnect(SLR_MAIN_DISPLAY,plane);
							Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_STATE, _MODE_STATE_SEARCH);
							state_update_disp_info();
						}
						DbgSclrFlgTkr.OutputMemoryMode = FALSE;
						MemoryModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};
						*p_sourceID = _UNKNOWN_INPUT;
					}
					else
					{
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "inputSrcInfo not match;memory mode close fail\n");
						return TRUE;
					}
				}
				else
				{
					if(DbgSclrFlgTkr.OuputDisplayMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
					} else if(DbgSclrFlgTkr.OutputVencMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_VENC_MODE);
					} else if(DbgSclrFlgTkr.OutputAveMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_AVE_MODE);
					} else {
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, " error memory mode not open\n");
						return TRUE;
					}
				}
				DbgSclrFlgTkr.Main_during_scalerflow_flag = FALSE;//WOSQRTK-7524 patch. Reset DbgSclrFlgTkr.Main_during_scalerflow_flag.
				DbgSclrFlgTkr.Main_AutoRunScaler = FALSE;
				down(&SetMainOutPutRegion_Semaphore);
				reset_any_srcrect(&main_dispwin_pre);
				reset_any_srcrect(&main_dispwin_for_only_xy);
				up(&SetMainOutPutRegion_Semaphore);
				if((Get_Live_zoom_mode()!=LIVE_ZOOM_OFF) &&(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_STATE) ==  _MODE_STATE_ACTIVE))
				{// when MAIN disconnected, mute the video for SUB of livezoom or magnifier. Q-3072
					down(get_forcebg_semaphore());
					scalerdisplay_force_bg_enable(SLR_SUB_DISPLAY, TRUE);//_DISABLE);//pool test
					drvif_scalerdisplay_enable_display(SLR_SUB_DISPLAY, _DISABLE);
					up(get_forcebg_semaphore());
				}
				if (Get_LivezoomOffMainRunScaler() == TRUE) {
					Set_LivezoomOffMainRunScaler(FALSE);
				}
				DbgSclrFlgTkr.DataFramesynclivezoom = FALSE;
				break;
			}
			case KADP_VSC_OUTPUT_AVE_MODE:
			{
				if(DbgSclrFlgTkr.OutputAveMode == TRUE)
				{
					if((AveModeInputInfo.type == inputSrcInfo.type) && (AveModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						HAL_VBE_AVE_Disconnect();
						DbgSclrFlgTkr.OutputAveMode = FALSE;
						AveModeInputInfo =  (KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};
					}
					else
					{
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "inputSrcInfo not match;ave mode not open\n");
						return TRUE;
					}
				}
				else
				{
					if(DbgSclrFlgTkr.OuputDisplayMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
					} else if(DbgSclrFlgTkr.OutputVencMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_VENC_MODE);
					} else if(DbgSclrFlgTkr.OutputMemoryMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_MEMORY_MODE);
					} else {
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, " error ave mode not open\n");
						return TRUE;
					}
				}
				break;
			}
			default:
				break;
		}
	}
#ifdef CONFIG_DUAL_CHANNEL
	if (wid ==VIDEO_WID_1) {
		set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_LIVEZOOM, FALSE);

		if((KADP_VSC_INPUTSRC_AVD == inputSrcInfo.type))
		{
			Scaler_AVD_SetHalVscConnect(SLR_SUB_DISPLAY,FALSE);
			if(Scaler_AVD_GetHalVscConnect(SLR_MAIN_DISPLAY) == FALSE){
				drvif_module_vpq_DmaAccessCtrl(OFF);
				rtd_printk(KERN_INFO, TAG_NAME_VSC, "\r\n########func:%s line:%d ##drvif_module_vpq_DmaAccessCtrl(OFF)######\r\n", __FUNCTION__, __LINE__);
			}
		}

		switch(outputMode)
		{
			case KADP_VSC_OUTPUT_DISPLAY_MODE:
			{
				if(DbgSclrFlgTkr.Sub_OuputDisplayMode == TRUE)
				{
#ifdef VDO_CONNECT_NEW_FLOW_ENABLE
					if(Sub_DisplayModeInputInfo.type == inputSrcInfo.type)
#else
					if((Sub_DisplayModeInputInfo.type == inputSrcInfo.type) && (Sub_DisplayModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
#endif
					{
						set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);//Enable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
						down(get_forcebg_semaphore());
						scalerdisplay_force_bg_enable(SLR_SUB_DISPLAY, TRUE);//Auto mue before disconnect
						drvif_scalerdisplay_enable_display(SLR_SUB_DISPLAY, _DISABLE);
						up(get_forcebg_semaphore());
						if((DbgSclrFlgTkr.Sub_OutputVencMode == FALSE) && (DbgSclrFlgTkr.Sub_OutputMemoryMode == FALSE) && (DbgSclrFlgTkr.Sub_OutputAveMode == FALSE))
						{
							down(&SetSubOutPutRegion_Semaphore);
							DbgSclrFlgTkr.Sub_Scaler_Stop_flag = TRUE;
							DbgSclrFlgTkr.Sub_smooth_toggle_set_flag = FALSE;
							zoom_clear_input_output_region_record(wid);
							Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_TIMING);
							up(&SetSubOutPutRegion_Semaphore);
							source_disconnect_reset_input(SLR_SUB_DISPLAY);//reset input region to zero

#ifdef CONFIG_I2RND_ENABLE
							if(Get_Live_zoom_mode() == LIVE_ZOOM_OFF){
								down(&I2RND_Semaphore);
								//clear i2rnd sub voinfo //i2r_fix_me
								i2rnd_sub_voinfo = i2rnd_empty_voinfo;
								vsc_i2rnd_dualvo_sub_stage= I2RND_DUALVO_STAGE_SUB_DISABLE;
								vsc_i2rnd_sub_stage = I2RND_STAGE_DISABLE;
								//Eric@20171213 disable pst flag
								Scaler_main_md_pst_set_enable(_DISABLE);
								Scaler_sub_md_pst_set_enable(_DISABLE);

								if(DbgSclrFlgTkr.OuputDisplayMode == FALSE){
									printk(KERN_EMERG"[%s][I2RND]PIP disconnect sub src!\n", __FUNCTION__);
								}
								else{
									//main still connect
									Scaler_I2rnd_set_force_cmd(_ENABLE);
									Scaler_I2rnd_set_display(I2RND_MAIN_S0_TABLE);
									//drivf_scaler_reset_freerun();
									//modestate_set_fll_running_flag(_ENABLE);
									printk(KERN_EMERG"[%s][I2RND]PIP disconnect sub src, main still connect, set force cmd enable!\n", __FUNCTION__);
								}
								//disable dual vo mode flag
								if((inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI) || (inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD) || (inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC))
									Scaler_Send_VoDisconnect_VOMDA(VO_VSC_SRC_HDMI, 0xaa); //0xaa use for i2r sub window

								if(get_i2rnd_vo1_refine_status_vir_addr() == I2RND_S1_REFINE_VO1){
									set_i2rnd_vo1_refine_status_vir_addr(I2RND_VO1_REFINE_OFF);
									printk(KERN_EMERG"[I2RND]sub disconnect, I2RND_VO1_REFINE_OFF!!\n");
								}
								up(&I2RND_Semaphore);
							}
#endif

							if ((/*(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD) ||*/(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI) ||(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC)) && (Get_Live_zoom_mode() == LIVE_ZOOM_ON )) {
								Set_Live_zoom_mode(LIVE_ZOOM_OFF);
#ifdef CONFIG_PST_ENABLE
								if(drvif_scaler_pst_get_mode_enable(_MAIN_VO_IMD))
									drvif_scaler_pst_uninitial(_MAIN_VO_IMD);
								if(drvif_scaler_pst_get_mode_enable(_SUB_VO_IMD))
									drvif_scaler_pst_uninitial(_SUB_VO_IMD);
#endif
								//DataFramesynclivezoom = FALSE;
								DbgSclrFlgTkr.LivezoomMainRerunFlag = FALSE;
								DbgSclrFlgTkr.LivezoomSubRerunFlag = FALSE;
								DbgSclrFlgTkr.LivezoomvoinfocheckFlag = FALSE;
								DbgSclrFlgTkr.LivezoomMainRerunEndneedOpenforcebgFlag = FALSE;
								sub_shape_type = VSC_MGF_TYPE_RECTANGLE;
								Set_LivezoomOffMainRunScaler(TRUE);
								drvif_memory_compression_rpc(wid);
							} else {
								drvif_mode_onlinemeasure_setting(_CHANNEL2, Scaler_InputSrcGetType(SLR_SUB_DISPLAY), FALSE, FALSE);
                                drvif_mode_disableonlinemeasure(_CHANNEL2);//Diable online measure
                                //set detect timng flag true:
								if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
								{
									/*//no need because AVD don't stop detect task
									down(get_vdc_detectsemaphore());
									if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
									up(get_vdc_detectsemaphore());
									*/
								}
								else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
								{
									down(get_hdmi_detectsemaphore());
									if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
									up(get_hdmi_detectsemaphore());
								}
								else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
								{
									down(get_adc_detectsemaphore());
									fw_scaler_adc_nolock_wdg_ctrl(SLR_SUB_DISPLAY, FALSE);// Disable adc_nolock_wdg
									if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
										YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
										ADC_set_detect_flag(TRUE);
									}
									up(get_adc_detectsemaphore());
									set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
								} else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
									down(get_vo_infosemaphore());
									DbgSclrFlgTkr.Sub_OuputDisplayMode = FALSE;
									plane=Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_VODMA_PLANE);
									Sub_DisplayModeInputInfo =(KADP_VSC_INPUT_SRC_INFO_T) {KADP_VSC_INPUTSRC_MAXN, 0, 0};
#ifdef CONFIG_I2RND_ENABLE
									set_vo_change_flag(i2rnd_port_sub, FALSE);//Reset Vo change flag
#else
									set_vo_change_flag(inputSrcInfo.resourceIndex, FALSE);//Reset Vo change flag
#endif
									if(Get_Live_zoom_mode()==LIVE_ZOOM_OFF)
									{
#ifdef CONFIG_I2RND_ENABLE
										set_force_change_vo_flag(i2rnd_port_sub, TRUE);
#else
										set_force_change_vo_flag(inputSrcInfo.resourceIndex, TRUE);
#endif
									}
									else
									{
										//live zoom ON dont set force-chagne flag, cuz...
										// SUB disconnect -> set force change = 1 -> unpause -> Vo ready sent -> Vo Ready set info_change = 1
										// -> checksignal set MAIN state = search -> NG //WOSQRTK-2160
									}
									rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####Set force_change_vo_flag TRUE and reset vo change flag####\r\n");
									up(get_vo_infosemaphore());
								//	vo_overscan_disable(inputSrcInfo.type);
									Check_smooth_toggle_update_flag(SLR_SUB_DISPLAY);
									if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC)
										Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
									else
										Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);

									//smooth_toggle_disconnect(SLR_SUB_DISPLAY,plane);
								}
							}
							smooth_toggle_disconnect(SLR_SUB_DISPLAY,plane);
							Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
							state_update_disp_info();
						}
						DbgSclrFlgTkr.Sub_OuputDisplayMode = FALSE;
						DbgSclrFlgTkr.sub_wind0000 = FALSE;
						DbgSclrFlgTkr.subVscFreezeFlag=0;
						Scaler_SubDispWindowSet(SrcRect);

						Sub_DisplayModeInputInfo =(KADP_VSC_INPUT_SRC_INFO_T) {KADP_VSC_INPUTSRC_MAXN, 0, 0};
						*p_sourceID = _UNKNOWN_INPUT;
						//close_livezoom_doublebuffer();
						//close display panel

						//USER:Lewislee DATE:2015/10/2
						//when PIP off, need reset setting
						Scaler_Disp3dSetInfo(SLR_SUB_DISPLAY, SLR_DISP_3D_3DTYPE, SLR_3D_2D_ONLY);
						Scaler_Set3DMode_Attr(SLR_SUB_DISPLAY, SLR_3DMODE_2D);
					}
					else
					{
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "inputSrcInfo not match;display mode not open\n");
						return TRUE;
					}
				}
				else
				{
					if(DbgSclrFlgTkr.OutputVencMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_VENC_MODE);
					} else if(DbgSclrFlgTkr.OutputMemoryMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_MEMORY_MODE);
					} else if(DbgSclrFlgTkr.OutputAveMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_AVE_MODE);
					} else {
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, " error display mode not open\n");
						return TRUE;
					}
				}
				DbgSclrFlgTkr.Sub_AutoRunScaler = FALSE;
				/*qiangzhou:should clear setting for mutilvew(sub nosignal) and livezoom switch case */
				if (DbgSclrFlgTkr.Sub_Output_Set_flag == TRUE) {
					DbgSclrFlgTkr.Sub_Output_Set_flag = FALSE;
				}
				down(&SetSubOutPutRegion_Semaphore);
				reset_any_srcrect(&sub_dispwin_pre);
				up(&SetSubOutPutRegion_Semaphore);

				if(sub_read_buffer_first_flag == 1){
					Scaler_AVD_EnableVD27MMode(VD_27M_HSD960_DI5A);
					Scaler_AVD_SetDetectStage(0);//DETECT_STAGE_INIT
					sub_read_buffer_first_flag = 0;
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "[self-dianosis]27M reset !!\n");
				}
				break;
			}
			case KADP_VSC_OUTPUT_VENC_MODE:
			{
				if(DbgSclrFlgTkr.Sub_OutputVencMode == TRUE)
				{
					if((Sub_VencModeInputInfo.type == inputSrcInfo.type) && (Sub_VencModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						if(DbgSclrFlgTkr.Sub_OuputDisplayMode == FALSE)
						{
							drvif_mode_onlinemeasure_setting(_CHANNEL2, Scaler_InputSrcGetType(SLR_SUB_DISPLAY), FALSE, FALSE);
                            drvif_mode_disableonlinemeasure(_CHANNEL2);//Diable online measure
                            //set detect timng flag true:
							if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
							{
							/*//no need because AVD don't stop detect task
								down(get_vdc_detectsemaphore());
								if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
								up(get_vdc_detectsemaphore());
							*/
#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
							printk(KERN_EMERG"[vsc_disconnect]display:%d,port:%d\n",wid,inputSrcInfo.resourceIndex);
							printk(KERN_EMERG"rtk_hal_vsc_Disconnect para,inputSrcInfo:%d;%d;%d,outputMode:%d\n",inputSrcInfo.type, inputSrcInfo.attr, inputSrcInfo.resourceIndex, outputMode);

							if(run_i2rnd_flag == 1){
								run_i2rnd_flag = 0;
								//i2rnd_send_table_idx(I2RND_TABLE_OFF);
								rtk_hal_vsc_i2rnd_enable(_DISABLE);
								//frank@I2run disable main VENC flag
								VencModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};
								DbgSclrFlgTkr.OutputVencMode = FALSE;
								vsc_i2rnd_sub_stage = I2RND_STAGE_DISABLE;
								vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_DISABLE;
								//apvr_request_run_main_path();
								printk(KERN_EMERG"[%s][frank]I2RND close\n", __FUNCTION__);
							}
#endif
#endif

							}
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
							{
								down(get_hdmi_detectsemaphore());
								if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
								up(get_hdmi_detectsemaphore());
							}
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
							{
								down(get_adc_detectsemaphore());
								fw_scaler_adc_nolock_wdg_ctrl(SLR_SUB_DISPLAY, FALSE);// Disable adc_nolock_wdg
								if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
									YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
									ADC_set_detect_flag(TRUE);
								}
								up(get_adc_detectsemaphore());
								set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
							}
							else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {
								plane=Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_VODMA_PLANE);
								Check_smooth_toggle_update_flag(SLR_SUB_DISPLAY);
								//smooth_toggle_disconnect(SLR_SUB_DISPLAY,plane);
							}
							smooth_toggle_disconnect(SLR_SUB_DISPLAY,plane);
							Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
							state_update_disp_info();
						}

						DbgSclrFlgTkr.Sub_OutputVencMode = FALSE;
						DbgSclrFlgTkr.subVscFreezeFlag=0;
						Sub_VencModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};
						*p_sourceID = _UNKNOWN_INPUT;
					}
					else
					{
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "inputSrcInfo not match;venc mode close fail\n");
						return TRUE;
					}
				}
				else
				{
					if(DbgSclrFlgTkr.OuputDisplayMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
					} else if(DbgSclrFlgTkr.OutputMemoryMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_MEMORY_MODE);
					} else if(DbgSclrFlgTkr.OutputAveMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_AVE_MODE);
					} else {
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, " error venc mode not open\n");
						return TRUE;
					}
				}
				break;
			}
			case KADP_VSC_OUTPUT_MEMORY_MODE:
			{
				if(DbgSclrFlgTkr.Sub_OutputMemoryMode == TRUE)
				{
					if((Sub_MemoryModeInputInfo.type == inputSrcInfo.type) && (Sub_MemoryModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						if(DbgSclrFlgTkr.Sub_OuputDisplayMode == FALSE)
						{
							down(&SetSubOutPutRegion_Semaphore);
							DbgSclrFlgTkr.Sub_Scaler_Stop_flag = TRUE;
							zoom_clear_input_output_region_record(wid);
							Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_TIMING);
							up(&SetSubOutPutRegion_Semaphore);
							source_disconnect_reset_input(SLR_SUB_DISPLAY);//reset input region to zero

							if ((/*(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD) ||*/(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI) ||(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC)) && (Get_Live_zoom_mode() == LIVE_ZOOM_ON )) {
								Set_Live_zoom_mode(LIVE_ZOOM_OFF);
#ifdef CONFIG_PST_ENABLE
								if(drvif_scaler_pst_get_mode_enable(_MAIN_VO_IMD))
									drvif_scaler_pst_uninitial(_MAIN_VO_IMD);
								if(drvif_scaler_pst_get_mode_enable(_SUB_VO_IMD))
									drvif_scaler_pst_uninitial(_SUB_VO_IMD);
#endif
								//DataFramesynclivezoom = FALSE;
								DbgSclrFlgTkr.LivezoomMainRerunFlag = FALSE;
								DbgSclrFlgTkr.LivezoomSubRerunFlag = FALSE;
								DbgSclrFlgTkr.LivezoomvoinfocheckFlag = FALSE;
								DbgSclrFlgTkr.LivezoomMainRerunEndneedOpenforcebgFlag = FALSE;
								sub_shape_type = VSC_MGF_TYPE_RECTANGLE;
								Set_LivezoomOffMainRunScaler(TRUE);
								drvif_memory_compression_rpc(wid);
							} else {
								drvif_mode_onlinemeasure_setting(_CHANNEL2,Scaler_InputSrcGetType(SLR_SUB_DISPLAY), FALSE, FALSE);
                                drvif_mode_disableonlinemeasure(_CHANNEL2);//Diable online measure
                                //set detect timng flag true:
								if(inputSrcInfo.type == KADP_VSC_INPUTSRC_AVD)
								{
									/*//no need because AVD don't stop detect task
									down(get_vdc_detectsemaphore());
									if(get_AVD_Global_Status() == SRC_CONNECT_DONE) VDC_set_detect_flag(TRUE);
									up(get_vdc_detectsemaphore());
									*/
								}
								else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_HDMI)
								{
									down(get_hdmi_detectsemaphore());
									if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
									up(get_hdmi_detectsemaphore());
								}
								else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_ADC)
								{
									down(get_adc_detectsemaphore());
									fw_scaler_adc_nolock_wdg_ctrl(SLR_SUB_DISPLAY, FALSE);// Disable adc_nolock_wdg
									if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
										YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
										ADC_set_detect_flag(TRUE);
									}
									up(get_adc_detectsemaphore());
									set_auto_phase_flow_bypass_flag(FALSE);//Rest the auto phase bypass flag
								} else if(inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC || inputSrcInfo.type == KADP_VSC_INPUTSRC_JPEG) {

								//	vo_overscan_disable(inputSrcInfo.type);
									Check_smooth_toggle_update_flag(SLR_SUB_DISPLAY);
									if (inputSrcInfo.type == KADP_VSC_INPUTSRC_VDEC)
										Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_VDEC, (wid<<4) + inputSrcInfo.resourceIndex);
									else
										Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_JPEG, (wid<<4) + inputSrcInfo.resourceIndex);

									smooth_toggle_disconnect(SLR_SUB_DISPLAY,plane);
									down(get_vo_infosemaphore());
									DbgSclrFlgTkr.Sub_OutputMemoryMode = FALSE;
									plane=Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_VODMA_PLANE);
									Sub_MemoryModeInputInfo =(KADP_VSC_INPUT_SRC_INFO_T) {KADP_VSC_INPUTSRC_MAXN, 0, 0};
									set_vo_change_flag(inputSrcInfo.resourceIndex, FALSE);//Reset Vo change flag
									set_force_change_vo_flag(inputSrcInfo.resourceIndex, TRUE);
									rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####Set force_change_vo_flag TRUE and reset vo change flag####\r\n");
									up(get_vo_infosemaphore());
								}
							}
							Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_STATE, _MODE_STATE_SEARCH);
							state_update_disp_info();
						}

						DbgSclrFlgTkr.sub_wind0000 = FALSE;
						DbgSclrFlgTkr.subVscFreezeFlag=0;
						Scaler_SubDispWindowSet(SrcRect);

						DbgSclrFlgTkr.Sub_OutputMemoryMode = FALSE;
						Sub_MemoryModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};
						*p_sourceID = _UNKNOWN_INPUT;

						//close_livezoom_doublebuffer();
					}
					else
					{
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "inputSrcInfo not match;memory mode close fail\n");
						return TRUE;
					}
				}
				else
				{
					if(DbgSclrFlgTkr.OuputDisplayMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
					} else if(DbgSclrFlgTkr.OutputVencMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_VENC_MODE);
					} else if(DbgSclrFlgTkr.OutputAveMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_AVE_MODE);
					} else {
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "error memory mode not open\n");
						return TRUE;
					}
				}
				DbgSclrFlgTkr.Sub_AutoRunScaler = FALSE;
				down(&SetSubOutPutRegion_Semaphore);
				reset_any_srcrect(&sub_dispwin_pre);
				up(&SetSubOutPutRegion_Semaphore);
				break;
			}
			case KADP_VSC_OUTPUT_AVE_MODE:
			{
				if(DbgSclrFlgTkr.Sub_OutputAveMode == TRUE)
				{
					if((Sub_AveModeInputInfo.type == inputSrcInfo.type) && (Sub_AveModeInputInfo.resourceIndex == inputSrcInfo.resourceIndex))
					{
						HAL_VBE_AVE_Disconnect();
						DbgSclrFlgTkr.Sub_OutputAveMode = FALSE;
						Sub_AveModeInputInfo =	(KADP_VSC_INPUT_SRC_INFO_T){KADP_VSC_INPUTSRC_MAXN, 0, 0};
					}
					else
					{
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "inputSrcInfo not match;ave mode not open\n");
						return TRUE;
					}
				}
				else
				{
					if(DbgSclrFlgTkr.OuputDisplayMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
					} else if(DbgSclrFlgTkr.OutputVencMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_VENC_MODE);
					} else if(DbgSclrFlgTkr.OutputMemoryMode == TRUE) {
						vsc_force_disconnect(wid, inputSrcInfo, KADP_VSC_OUTPUT_MEMORY_MODE);
					} else {
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "error ave mode not open\n");
						return TRUE;
					}
				}
				break;
			}
			default:
				break;
		}
	}
#endif
	return TRUE;
}

unsigned char check_zoom_smooth_toggle_proc(void)
{//added by rika 20140904
	//int failflag=ZOOM_STATE_OK;
	//unsigned char resetflag=_DISABLE;
	return ZOOM_STATE_OK;//temp return by will.
#if 0
	if(zoom_smooth_toggle_get_finish() == ZOOM_STATE_NONE){
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "_rk %s none\n",__FUNCTION__);
		///Scaler_DispSetInputInfo(SLR_INPUT_STATE,_MODE_STATE_ACTIVE);//For check timing
	}
	else if(zoom_smooth_toggle_get_finish() == ZOOM_STATE_WAIT_APPLY_OK){
		//zoom_smooth_toggle_set_finish(ZOOM_STATE_DONOW);
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "_rk wait ok here\n-----\n");
		resetflag=_ENABLE;//reset size anyway  rika 20141112
		failflag=zoom_imd_smooth_toggle_proc(_ENABLE, _ENABLE, Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));//need review rika 20141224

		if(failflag==ZOOM_STATE_OK){
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "_rk %s wait ok done. send active2 \n", __FUNCTION__);
			///Scaler_DispSetInputInfo(SLR_INPUT_STATE,_MODE_STATE_ACTIVE);//For check timing

		}
		//else fail
		// do not set active
	}
	return failflag;
#endif
}


#define AVD_480i_MAX_LENGTH 504   // WebOS adjust v_size max size (2*v_start + v_length)
unsigned char CheckAVDandWebOSInfo(unsigned char display)
{
	unsigned char ucRet = TRUE;

	// The current signal color std is supported, check the M-domain size and InputRegion
	if( (Scaler_AVD_GetDetectStage() == VDC_DETECT_STAGE_FINAL)
		&& (0 == Scaler_AVD_IsSupportedColorSys()))  // 0: supported, -1: non-supported
	{
		unsigned short usAfterDILen = 0;
		unsigned short usInputRegion_h = 0, usInputRegion_y = 0;
		rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"#####[%s(%d)]DbgSclrFlgTkr.Main_Output_Set_flag=%x, DbgSclrFlgTkr.Main_Scaler_Stop_flag=%x, DbgSclrFlgTkr.Main_Run_Scaler_flag=%x\n", __FUNCTION__, __LINE__, DbgSclrFlgTkr.Main_Output_Set_flag, DbgSclrFlgTkr.Main_Scaler_Stop_flag, DbgSclrFlgTkr.Main_Run_Scaler_flag);


		if (display == SLR_MAIN_DISPLAY && Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE)) {
			usAfterDILen =	(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN) << 1);
		} else {
			usAfterDILen = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_LEN);
		}

		if(display == SLR_MAIN_DISPLAY)
		{
			usInputRegion_h = Main_InputRegion_h;
			usInputRegion_y = Main_InputRegion_y;
		}
		else
		{
			usInputRegion_h = Sub_InputRegion_h / 2;  // 480=>240, 576=>288 (InputRegion_h is full size)
			usInputRegion_y = Sub_InputRegion_y / 2;
		}

#ifdef NEW_INPUT_REGION_BASE_ON_HAL_ORIGINAL_INPUT
		if(Scaler_InputRegionType_Get(display) == INPUT_BASE_ON_HAL_ORIGINAL_INPUT){
			if(display == SLR_MAIN_DISPLAY)
			{
				usInputRegion_h = Scaler_intputRegion_base_scalerTiming[display].src_height;//Main_InputRegion_h;
				usInputRegion_y = Scaler_intputRegion_base_scalerTiming[display].srcy;//Main_InputRegion_y;
			}
			else
			{
				usInputRegion_h = Scaler_intputRegion_base_scalerTiming[display].src_height / 2;//Sub_InputRegion_h / 2;  // 480=>240, 576=>288 (InputRegion_h is full size)
				usInputRegion_y = Scaler_intputRegion_base_scalerTiming[display].srcy / 2;//Sub_InputRegion_y / 2;
			}
		}
#endif

		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"usInputRegion=%d,  usAfterDILen=%d\n", usInputRegion_h , usAfterDILen);

		if ((usInputRegion_h > usAfterDILen)
			|| ((usInputRegion_y*2 + usInputRegion_h) <= AVD_480i_MAX_LENGTH && usAfterDILen > 500)  //Throw DI (Current signal is 576i, but inputRegion is 480i)
			|| ((usInputRegion_y*2 + usInputRegion_h) <= (AVD_480i_MAX_LENGTH/2) && usAfterDILen > 250) ) // ByPass DI
		{
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC," m-domain size wrong, return false\n");

			ucRet = FALSE;
		}
	}

	return ucRet;
}

void wait_DI_auto_freeze(void)
{
	if(((rtd_inl(VODMA_VODMA_V1_DCFG_reg) &VODMA_VODMA_V1_DCFG_vodma_go_mask)==0)
			&&((rtd_inl(VODMA_VODMA_V1INT_reg) &VODMA_VODMA_V1INT_vgip_en_mask) == 0))
		{

			int timeout = 50;
			while(((rtd_inl(DI_IM_DI_DEBUG_MODE_reg)&_BIT8)>>8==0)&&timeout--){
				pr_emerg("wait DI freeze\n");
				mdelay(1);
			}
			if(timeout == 0)
				pr_emerg("wait_DI_auto_freeze timeout\n");

		}
}


void reset_rotate_status(unsigned char display)
{
#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
	if(display == SLR_MAIN_DISPLAY) {
	if (TRUE == Get_rotate_function())
	{
		extern unsigned int rotatedisconnecten;
		extern void scaler_mdom_stop(void);
		rotatedisconnecten = 1;
		scaler_Rotate_VI_init_send_rpc();
		rotatedisconnecten = 0;
		if(get_rotate_mode()!=get_ori_rotate_mode())
			wait_DI_auto_freeze();
		scaler_mdom_stop();
		Set_rotate_function(FALSE);
	} else {
		pr_emerg("reset_rotate_status sub do nothing\n");
	}

        if(!Get_PANEL_VFLIP_ENABLE())
        {
            scaler_send_rotate_vflip_rpc(FALSE);
        }
	}

#endif
}


void rotate_reset_mode(unsigned char display)
{//this api is for rotate reset mode replace drvif_mode_resetmode
#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
	if(display == SLR_MAIN_DISPLAY)
	{
		if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_FAILURECOUNT) == 0)
		{
			unsigned int wait_timeoutcnt = 30;
			//roatte case, becasue rotate not call reset mode for freeze issue.
			modestate_set_fll_running_flag(FALSE);
			drivf_scaler_reset_freerun();//free run
			drvif_mode_onlinemeasure_setting(SLR_MAIN_DISPLAY, Scaler_InputSrcGetFrom(SLR_MAIN_DISPLAY), FALSE, FALSE);//Disable online measure watchdog and interrupt
			drvif_mode_disableonlinemeasure(SLR_MAIN_DISPLAY);//Disable online measure
			IoReg_ClearBits(MDOMAIN_CAP_Cap_In1_enable_reg, _BIT0);//disable m domain capture
			IoReg_ClearBits(MDOMAIN_DISP_Disp_main_enable_reg, _BIT0);//disable m display capture
			IoReg_SetBits(MDOMAIN_CAP_cap_reg_doublbuffer_reg, _BIT2);//m cap db apply
			IoReg_SetBits(MDOMAIN_DISP_DDR_MainSubCtrl_reg, _BIT0);//m diaplay db apply

			//reset speedup_vtotal
			drvif_scaler_set_display_mode_frc2fsync_I2D_disable();
			drvif_scaler_enable_frc2fsync_HW_speedup_vtotal(FALSE);

			do{//wait gatting disable
				if(VODMA_VODMA_CLKGEN_get_en_fifo_full_gate(IoReg_Read32(VODMA_VODMA_CLKGEN_reg)) == 0)
					break;
				else
				{
					msleep(1); /* delay 10 ms*/
					wait_timeoutcnt--;
				}
			}while(wait_timeoutcnt);

			if((wait_timeoutcnt == 0) && VODMA_VODMA_CLKGEN_get_en_fifo_full_gate(IoReg_Read32(VODMA_VODMA_CLKGEN_reg)))
			{
				pr_err(" rotate_reset_mode disable gatting timeout fail\n\n");
				IoReg_ClearBits(VODMA_VODMA_CLKGEN_reg, VODMA_VODMA_CLKGEN_en_fifo_full_gate_mask);
			}

		}
	}
	reset_rotate_status(display);
#endif
}

unsigned char rtk_run_scaler(unsigned char display, KADP_VSC_INPUT_TYPE_T inputType, KADP_VSC_OUTPUT_MODE_T outputMode)
{
	StructDisplayInfo  *p_timing = NULL;
	StructSrcRect winSrcRect = {0, 0, 0, 0};
	unsigned char hdmi_unstable_reset_timing = TRUE;//if TRUE, do reset timing info. If false, this is hdr change case
#ifdef CONFIG_RTK_KDRV_PWM
	extern void HAL_VBE_DISP_GetOutputFrameRate(UINT8* pframeRates);
//	UINT8 frameRates;
#endif
	unsigned char wait_to_after_avsync_do = 0;
	unsigned char new_voinfo_flag = 0;// to check vo overscan or not
	unsigned char game_mode_wait_timeout = 40;	//400ms
	//unsigned char port = Get_DisplayMode_Port(SLR_MAIN_DISPLAY);
	switch(outputMode)
	{
		case KADP_VSC_OUTPUT_DISPLAY_MODE:
		case KADP_VSC_OUTPUT_MEMORY_MODE:
		{
#if(VSC_PROFILE == 1)
			unsigned int before_time = 0;
			unsigned int after_time = 0;
			before_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
#endif

#ifdef CONFIG_FORCE_RUN_I3DDMA
			if ((DbgSclrFlgTkr.magnifier_mainscaler_run_livezoom == FALSE)
				&&(get_force_i3ddma_enable(display) == false)
				&&(Get_Live_zoom_mode() == LIVE_ZOOM_OFF)
				&&(!(Get_LivezoomOffMainRunScaler() == TRUE && Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) <= 3000))
				&&((get_rotate_mode()==get_ori_rotate_mode() && rotate_mode == rotate_mode_pre)|| (get_ori_rotate_mode()==DIRECT_VO_FRAME_ORIENTATION_DEFAULT))
#ifdef CONFIG_I2RND_ENABLE
				//Eric@20170808 Dual vo i2rnd do not run reset mode when rerun main scaler path
				&&(!((Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1)))
				&&(!((Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)))
#endif
				)
#else
			if ((DbgSclrFlgTkr.magnifier_mainscaler_run_livezoom == FALSE)
				&&(Get_Live_zoom_mode() == LIVE_ZOOM_OFF)
				&&(!(Get_LivezoomOffMainRunScaler() == TRUE && Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID) <= 3000))
				&&((get_rotate_mode()==get_ori_rotate_mode())|| (get_ori_rotate_mode()==DIRECT_VO_FRAME_ORIENTATION_DEFAULT))
#ifdef CONFIG_I2RND_ENABLE
				//Eric@20170808 Dual vo i2rnd do not run reset mode when rerun main scaler path
				&&(!((Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1)))
				&&(!((Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)))
#endif
				)
#endif
			{
				drvif_mode_resetmode(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
			} else {
				if(DbgSclrFlgTkr.magnifier_mainscaler_run_livezoom == TRUE || (Get_LivezoomOffMainRunScaler() == TRUE && Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) <= 3000)) {
					/*livezoom no need do reset_rotate_mode*/
				} else if((get_rotate_mode()!=get_ori_rotate_mode()) && (get_ori_rotate_mode()!=DIRECT_VO_FRAME_ORIENTATION_DEFAULT)) {
					rotate_reset_mode(display);
				}
				if ((display == SLR_MAIN_DISPLAY)/*||((display == SLR_SUB_DISPLAY)&&(Get_Live_zoom_mode() != LIVE_ZOOM_OFF))*/
#ifdef CONFIG_I2RND_ENABLE
					//Eric@20171019 Dual vo i2rnd do not change snr clock setting when rerun main scaler path
					&&(!((Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1)))
					&&(!((Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)))
#endif
					&&(!((get_rotate_mode()!=get_ori_rotate_mode()) && (get_ori_rotate_mode()!=DIRECT_VO_FRAME_ORIENTATION_DEFAULT)))
				){
					//disable data path s1 clock for snr hw bug
					drvif_color_Set_DRV_SNR_Clock(display, _DISABLE);
				}
				if((Get_Live_zoom_mode() == LIVE_ZOOM_ON)&&(display == SLR_SUB_DISPLAY))
				{	//set_zoom_reset_double_state(_DISABLE, SLR_MAIN_DISPLAY);
					vgip_vgip_chn1_double_buffer_ctrl_RBUS vgip_chn1_double_buffer_reg;
					vgip_chn1_double_buffer_reg.regValue =rtd_inl(VGIP_VGIP_CHN1_DOUBLE_BUFFER_CTRL_reg);
					vgip_chn1_double_buffer_reg.ch1_db_en=0;
					vgip_chn1_double_buffer_reg.ch1_db_rdy=0;
					rtd_outl(VGIP_VGIP_CHN1_DOUBLE_BUFFER_CTRL_reg,vgip_chn1_double_buffer_reg.regValue);

				}
				set_zoom_reset_double_state(_DISABLE, display);//always disable double buffer
			}
#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
			down(&SetMainOutPutRegion_Semaphore);
			if((display == SLR_MAIN_DISPLAY)
				&&((get_rotate_mode() == DIRECT_VO_FRAME_ORIENTATION_ROTATE_90)
				||(get_rotate_mode() == DIRECT_VO_FRAME_ORIENTATION_ROTATE_270)))
			{
				Set_rotate_function(TRUE);
			}else if ((display == SLR_MAIN_DISPLAY) && (get_rotate_mode() == DIRECT_VO_FRAME_ORIENTATION_ROTATE_180)
			        && Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE))
            {
            	Set_rotate_function(TRUE);
            }else
            {
		        Set_rotate_function(FALSE);
	        }
			//set_ori_rotate_mode(get_rotate_mode());
			up(&SetMainOutPutRegion_Semaphore);

            if(!Get_PANEL_VFLIP_ENABLE()){
                if((get_rotate_mode() == DIRECT_VO_FRAME_ORIENTATION_ROTATE_180)
                    && (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE) == FALSE))
                {
                	pr_emerg("progressive rotate 180, send vo vflip to vcpu true \n");
                	scaler_send_rotate_vflip_rpc(TRUE);
                }
                else
                {
                    pr_emerg("interlace rotate 180, send vo vflip to vcpu  false \n");
                	scaler_send_rotate_vflip_rpc(FALSE);
                }
            }
			if((Get_rotate_function() == TRUE) || (get_rotate_mode()!=get_ori_rotate_mode()))
				set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ROTATE, TRUE);
#endif
            update_vsc_task_status(1, VSC_GET_INFO);
			if(get_displayinfo_proc(display, inputType) == FALSE)
			{
				rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "######get_displayinfo_proc fail fail fail!!!#######\n");
				if (display == SLR_MAIN_DISPLAY) {
					if((inputType == KADP_VSC_INPUTSRC_ADC) || (inputType == KADP_VSC_INPUTSRC_HDMI) || ((inputType == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() != _SRC_TV)))
					{//adc hdmi av case
						reset_ARC_cmd(SLR_MAIN_DISPLAY);
					}
					down(&SetMainOutPutRegion_Semaphore);
					reset_any_srcrect(&main_dispwin_pre);
					up(&SetMainOutPutRegion_Semaphore);
				} else {
					down(&SetSubOutPutRegion_Semaphore);
					reset_any_srcrect(&sub_dispwin_pre);
					up(&SetSubOutPutRegion_Semaphore);
				}
				if(inputType == KADP_VSC_INPUTSRC_ADC)
				{//Need to rerun scaler
					down(get_adc_detectsemaphore());
					reset_adc_timing_ready();
					p_timing = Get_ADC_Dispinfo();
					p_timing->IPH_ACT_WID_PRE = 0;
					p_timing->IPV_ACT_LEN_PRE = 0;
					p_timing->IVFreq = 0;
					p_timing->IHFreq = 0;
					p_timing->IHTotal = 0;
					p_timing->IVTotal = 0;
					p_timing->ucMode_Table_Index = Mode_Table_Init_Index;
					if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
						ADC_OnlineMeasureError_Handler(get_ADC_Input_Source());
						Set_Reply_Zero_Timing_Flag(VSC_INPUTSRC_ADC, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/
						//YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
						ADC_set_detect_flag(TRUE);
					}
					up(get_adc_detectsemaphore());

				}
				else if(inputType == KADP_VSC_INPUTSRC_HDMI)
				{//Need to rerun scaler
					reset_hdmi_timing_ready();
					vfe_hdmi_drv_handle_on_line_measure_error(0);
					down(get_hdmi_detectsemaphore());
					if (get_HDMI_Global_Status() == SRC_CONNECT_DONE) {
						Set_Reply_Zero_Timing_Flag(VSC_INPUTSRC_HDMI, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/
						HDMI_set_detect_flag(TRUE);
					}
					up(get_hdmi_detectsemaphore());
				}
				else if(inputType == KADP_VSC_INPUTSRC_AVD)
				{//Need to rerun scaler
					/*//no need because AVD don't stop detect task
					down(get_vdc_detectsemaphore());
					if (get_AVD_Global_Status() == SRC_CONNECT_DONE) {
						VDC_set_detect_flag(TRUE);
					}
					up(get_vdc_detectsemaphore());
					*/
					reset_avd_timing_ready();
					Set_Reply_Zero_Timing_Flag(KADP_VSC_INPUTSRC_AVD, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/
				}
				if (display == SLR_MAIN_DISPLAY) {
					drivf_scaler_reset_freerun();
					if(DbgSclrFlgTkr.Main_AutoRunScaler) {
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "######Need to run scale again#######\n");
						DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;
					}
				} else {
					if(DbgSclrFlgTkr.Sub_AutoRunScaler) {
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "######Need to run scale again#######\n");
						DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;
					}
				}
                update_vsc_task_status(0, VSC_GET_INFO);
				return FALSE;
			}
			else
			{
				rtd_printk(KERN_INFO, TAG_NAME_VSC, "######get_displayinfo_proc success!!!#######\n");
			}
            update_vsc_task_status(0, VSC_GET_INFO);
			if(Setup_IMD(Scaler_DispGetInfoPtr()) == FALSE)
			{
				//reset smoothtoggle state
				if(Get_vo_smoothtoggle_timingchange_flag(display)) {
					unsigned int plane = Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_VODMA_PLANE);
					Check_smooth_toggle_update_flag(display);
					set_vo_smoothtoggle_state(SLR_SMOOTH_TOGGLE_INIT, display,plane);
	                           	smooth_toggle_state_info_rpc(display);
				}
				Scaler_DispSetInputInfo(SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				state_update_disp_info();//Update the search state
				if (display == SLR_MAIN_DISPLAY) {
					if((inputType == KADP_VSC_INPUTSRC_ADC) || (inputType == KADP_VSC_INPUTSRC_HDMI) || ((inputType == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() != _SRC_TV)))
					{//adc hdmi av case
						reset_ARC_cmd(SLR_MAIN_DISPLAY);
					}
					down(&SetMainOutPutRegion_Semaphore);
					reset_any_srcrect(&main_dispwin_pre);
					up(&SetMainOutPutRegion_Semaphore);
				} else {
					down(&SetSubOutPutRegion_Semaphore);
					reset_any_srcrect(&sub_dispwin_pre);
					up(&SetSubOutPutRegion_Semaphore);
				}
				if(inputType == KADP_VSC_INPUTSRC_ADC)
				{
					if (display == SLR_MAIN_DISPLAY) {
						Reset_YPP_Auto_Phase_SmartFit_Setting();//Reset auto phase related setting
					}
					down(get_adc_detectsemaphore());
					reset_adc_timing_ready();
					p_timing = Get_ADC_Dispinfo();
					p_timing->IPH_ACT_WID_PRE = 0;
					p_timing->IPV_ACT_LEN_PRE = 0;
					p_timing->IVFreq = 0;
					p_timing->IHFreq = 0;
					p_timing->IHTotal = 0;
					p_timing->IVTotal = 0;
					p_timing->ucMode_Table_Index = Mode_Table_Init_Index;
					if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
						ADC_OnlineMeasureError_Handler(get_ADC_Input_Source());
						Set_Reply_Zero_Timing_Flag(VSC_INPUTSRC_ADC, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/
						//YPbPr_Power_ADCRGB(FALSE);//Turn off RGB for saving power on detecting.  brandon add
						ADC_set_detect_flag(TRUE);
					}
					up(get_adc_detectsemaphore());
				}
				else if(inputType == KADP_VSC_INPUTSRC_HDMI)
				{
					if((display == SLR_MAIN_DISPLAY) && (vsc_force_rerun_main_scaler == TRUE)){
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "######run scaler again due to condition changed#######\n");
						DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;
					}
					else{
						if (display == SLR_MAIN_DISPLAY)
						{
							set_hdr_semaless_active(FALSE);
							if(Scaler_InputSrcGetType(display) == _SRC_VO)
							{
								if(drvif_mode_check_dma_onlinemeasure_status())
									hdmi_unstable_reset_timing = FALSE;
							}
							else
							{
								if(drvif_mode_check_onlinemeasure_status(SLR_MAIN_DISPLAY))
									hdmi_unstable_reset_timing = FALSE;
							}
						}
						if(hdmi_unstable_reset_timing)
						{
							reset_hdmi_timing_ready();
							vfe_hdmi_drv_handle_on_line_measure_error(0);
						}
						vfe_hdmi_drv_set_infoframe_thread_stop_nonseamphore(FALSE);

						down(get_hdmi_detectsemaphore());
						if (get_HDMI_Global_Status() == SRC_CONNECT_DONE) {
							Set_Reply_Zero_Timing_Flag(VSC_INPUTSRC_HDMI, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/
							HDMI_set_detect_flag(TRUE);
						}
						up(get_hdmi_detectsemaphore());
					}
				}
				else if(inputType == KADP_VSC_INPUTSRC_AVD)
				{
					/*//no need because AVD don't stop detect task
					down(get_vdc_detectsemaphore());
					if (get_AVD_Global_Status() == SRC_CONNECT_DONE) {

						VDC_set_detect_flag(TRUE);
					}
					up(get_vdc_detectsemaphore());
					*/
					reset_avd_timing_ready();
					Set_Reply_Zero_Timing_Flag(KADP_VSC_INPUTSRC_AVD, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/
				} else if(inputType == KADP_VSC_INPUTSRC_JPEG || inputType == KADP_VSC_INPUTSRC_VDEC){
					 //[WOSQRTK-7490]update to add Dolby OTT condition @Crixus 20160414
					if((get_vo_open_smooth_toggle_enable(display) || vsc_get_adaptivestream_flag(display) || (get_OTT_HDR_mode() == HDR_DOLBY_COMPOSER)) && (display == SLR_MAIN_DISPLAY)) {//direct vo and VO change
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "######run scale again vo change for direct vo#######\n");
						DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;
					}
					if (display == SLR_MAIN_DISPLAY)
						DbgSclrFlgTkr.Main_during_scalerflow_flag = FALSE;//WOSQRTK-7524 patch. Reset DbgSclrFlgTkr.Main_during_scalerflow_flag
				}
				rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "######Channel:%d src:%d Setup_IMD fail!!!#######\n", display, inputType);
				if (display == SLR_MAIN_DISPLAY) {
					drivf_scaler_reset_freerun();
					if(DbgSclrFlgTkr.Main_AutoRunScaler) {
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "######Need to run scale again#######\n");
						DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;
					}
				} else {
					if(DbgSclrFlgTkr.Sub_AutoRunScaler) {
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "######Need to run scale again#######\n");
						DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;
					}
				}
				return FALSE;
			}
			else
			{
				if(display == SLR_MAIN_DISPLAY)
				{
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, FALSE);//disable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ROTATE, FALSE);//disable roate mask
#ifdef CONFIG_I2RND_ENABLE
					if((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && ((vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_I2RND_DONE) || (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_DONE))){
#ifdef CONFIG_MDOMAIN_RESERVED_MEMORY
						//Eric@20171206 send rpc to set i2rnd memory addr
						send_memory_mapping_for_adaptive_streaming();
#endif
						printk(KERN_EMERG"[crixus]I2RND_STAGE_MAIN_I2RND_DONE return 2!!\n");
						return 1;
					}
#endif

				}
				else
				{
                    if(vbe_disp_oled_orbit_enable)
					{
						ScalerForceUpdateOrbit(1);

						rtd_printk(KERN_INFO, TAG_NAME_VSC, "####[%s(%d)] enable orbit mask\n",__func__, __LINE__);
						set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ORBIT_READY, TRUE);//Set orbit mask
					}

					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, FALSE);//disable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
				}

				if(display == SLR_MAIN_DISPLAY){
					Share_Memory_Set_Scaler_Run_Flag(0);
					if(inputType == KADP_VSC_INPUTSRC_AVD){
						//printk(KERN_EMERG"[%s][%d]\n", __FUNCTION__, __LINE__);
						zoom_clear_input_output_region_record(display);
					}
				}

				//imd_smooth_toggle_check_pre_double_buffer(display);

				rtd_printk(KERN_INFO, TAG_NAME_VSC, "######Channel:%d src:%d Setup_IMD success!!!#######\n", display, inputType);
				//Need to check MEMC output BG again for first booting
				if(Scaler_MEMC_Get_First_Run_FBG_enable() || Scaler_MEMC_Get_instanboot_resume_Done() || Scaler_MEMC_Get_snashop_resume_Done()){
					Scaler_MEMC_Set_CheckMEMC_Outbg(TRUE);
				}
				//state_update_disp_info();//Update the active state
				if (display == SLR_MAIN_DISPLAY) {
					down(&SetMainOutPutRegion_Semaphore);
					reset_any_srcrect(&main_dispwin_pre);
					up(&SetMainOutPutRegion_Semaphore);
				} else {
					down(&SetSubOutPutRegion_Semaphore);
					reset_any_srcrect(&sub_dispwin_pre);
					up(&SetSubOutPutRegion_Semaphore);
				}
				if (Scaler_InputSrcGetType(display) != _SRC_VO)
				{
					if((Get_Live_zoom_mode() == LIVE_ZOOM_ON) && (display == SLR_SUB_DISPLAY)){
						/*qiangzhou added livezoom and magnifier case sub forbidden open wtd and interrupt and onlinemeasure*/
						drvif_mode_onlinemeasure_setting(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), Scaler_InputSrcGetMainChType(), FALSE, FALSE);
					} else {
						if (Scaler_InputSrcGetType(display) == _SRC_TV)//ATV no need online interrupt
							drvif_mode_onlinemeasure_setting(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), Scaler_InputSrcGetMainChType(), TRUE, FALSE);
						else
						{
							if(inputType == KADP_VSC_INPUTSRC_ADC)
							{
								if(check_verify_mode_enable())//adc verify mode
									drvif_mode_onlinemeasure_setting(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), Scaler_InputSrcGetMainChType(), FALSE, FALSE);
								else
									drvif_mode_onlinemeasure_setting(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), Scaler_InputSrcGetMainChType(), TRUE, TRUE);
							}
							else
								drvif_mode_onlinemeasure_setting(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), Scaler_InputSrcGetMainChType(), TRUE, TRUE);
						}
					}

					if (Scaler_InputSrcGetType(display) == _SRC_YPBPR || Scaler_InputSrcGetType(display) == _SRC_VGA) {
						if(YPbPr_Small_Signal_precheck() == FALSE)
							fw_scaler_adc_nolock_wdg_ctrl(display, TRUE);
					}
				}
				else
				{
#ifdef CONFIG_FORCE_RUN_I3DDMA
					if(display == SLR_MAIN_DISPLAY)
					{
						if(inputType == KADP_VSC_INPUTSRC_ADC)
						{
							if(check_verify_mode_enable())
								drvif_mode_dma_onlinemeasure_setting( FALSE, FALSE);//ADC verify mode
							else
								drvif_mode_dma_onlinemeasure_setting( TRUE, TRUE);//ADC CASE
						}
						else if((inputType == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() != _SRC_TV))
							drvif_mode_dma_onlinemeasure_setting( TRUE, TRUE);//AV CASE
						else if(inputType == KADP_VSC_INPUTSRC_HDMI)
							drvif_mode_dma_onlinemeasure_setting( TRUE, TRUE);//HDMI CASE
					}
#endif
                    if(inputType != KADP_VSC_INPUTSRC_JPEG)
					    enable_vodma_empty_gate(Scaler_Get_CurVoInfo_VoVideoPlane(display));//Enable vo gating
					//Scaler_SendDisplayReadyIrc(Scaler_Get_CurVoInfo_VoVideoPlane(display));/*Send display ready to video FW*/
				}

				if(inputType == KADP_VSC_INPUTSRC_AVD) //Let AVD detect enable
				{
					/*//no need because AVD don't stop detect task
					//down(get_vdc_detectsemaphore());
					if(get_AVD_Global_Status() == SRC_CONNECT_DONE)
						VDC_set_detect_flag(TRUE);
					//up(get_vdc_detectsemaphore());
					*/
					rtd_printk(KERN_INFO, TAG_NAME_VSC, "#####[%s(%d) Scaler_AVD_SetRunSearchState(false)\n",__func__,__LINE__);
					Scaler_AVD_SetRunSearchState(display, false);
				}
#ifdef CONFIG_RTK_KDRV_PWM
				if (display == SLR_MAIN_DISPLAY) {
					/*
					frameRates = Scaler_DispGetInputInfo(SLR_INPUT_DTG_MASTER_V_FREQ);
					//rtk_pwm_set_freq(0, frameRates, 2);
					rtk_pwm_set_scaler_source(frameRates, 2);
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "########Set PWM framerate:%d##########\r\n", frameRates);
					*/
					//vbe_disp_pwm_frequency_update(TRUE);
				}
#endif
				if((display == SLR_MAIN_DISPLAY) && (inputType == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV)){
					Scaler_MEMC_SetInOutFrameRate();
                }

				if((display == SLR_MAIN_DISPLAY) && (inputType == KADP_VSC_INPUTSRC_VDEC) && (Scaler_Get_Vo_Force_60_Framerate_State() == 1)) {
					pr_emerg("[24force60][state %d->2]when 60hz set_imd finished, trigger vo run real 24hz\n", Scaler_Get_Vo_Force_60_Framerate_State());
					Scaler_Set_Vo_Force_60_Framerate_State(2);
				}else {
					pr_emerg("[24force60][state %d->0]no trigger vo run 24hz",Scaler_Get_Vo_Force_60_Framerate_State());
					Scaler_Set_Vo_Force_60_Framerate_State(0);
				}

				if(Scaler_Get_Vo_Force_60_Framerate_State()==2){
					unsigned char count=20;
					while((Scaler_Get_Vo_Force_60_Framerate_State()!=4)&& --count){
						msleep(0);
					}
					pr_emerg("[24force60][state %d] count=%d",Scaler_Get_Vo_Force_60_Framerate_State(),count);
				}

				if((display == SLR_MAIN_DISPLAY) && (inputType == KADP_VSC_INPUTSRC_VDEC) && (Scaler_Get_Vo_Force_60_Framerate_State() == 4)) {
					if((Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) > DATAFS_DISABLE_GATTING_WIDTH) && (Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN_PRE) > DATAFS_DISABLE_GATTING_HEIGHT)){
						rtd_printk(KERN_EMERG, "VSC", "UHD VDEC do not enable gatting on state 4!\n");
					}
					else{
						scaler_set_full_gatting_rpc(true);
						rtd_printk(KERN_EMERG, "VSC", "Enable Gating on state 4!\n");
					}
				}

				if(display == SLR_MAIN_DISPLAY) {
					if((DbgSclrFlgTkr.Main_Output_Set_flag || DbgSclrFlgTkr.Main_smooth_toggle_set_flag || DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag) && (DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE) && (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
					{
						if (/*Scaler_InputSrcGetType(display) == _SRC_VO && */DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting)	{
							//This is for smooth togggle presetting
							//state_update_disp_info();//Update the active state
							DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = FALSE;
						#ifdef CONFIG_I2RND_ENABLE
							if (!((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_I2RND_DONE)))
						#endif
								smooth_toggle_preset_info(display);
						}
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
						if((inputType == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
							return FALSE;
#endif
						down(&SetMainOutPutRegion_Semaphore);
						if(!compare_rerify_vsc_source_num_result(display))
						{
							up(&SetMainOutPutRegion_Semaphore);
							rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "### rtk_run_scaler main source already change line:%d###\r\n", __LINE__);
							return FALSE;
						}

						Scaler_DispWindowSet(main_dispwin);

						if(inputType == KADP_VSC_INPUTSRC_AVD)
						{
							if(get_AVD_Input_Source() != _SRC_TV)
							{//AV case
								new_voinfo_flag = 1;
								//whether timing need to change or not
								if (get_current_driver_pattern(DRIVER_FREERUN_PATTERN) == 1) {//curr source timing go data fs,need vo overscan
									Convert_Timing_To_fs_Depend_datafs(display);
								}
								//zoom_imd_smooth_toggle_config(VIDEO_WID_0, main_dispwin.srcx, main_dispwin.srcy, main_dispwin.src_wid, main_dispwin.src_height, ZOOM_DISP);
								zoom_imd_smooth_toggle_config(display, getInputRegionType(display), main_input_size, main_input_timing, main_dispwin);
								Check_smooth_toggle_update_flag(display);//wait smooth toggle ready to avoid to see ARC change

#ifdef SPEEDUP_NEW_SCALER_FLOW
									set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, FALSE);
									avd_start_compensation();//compensation h v start
#endif
								}
						} else {
							if (inputType != KADP_VSC_INPUTSRC_VDEC) {
								new_voinfo_flag = 1;
								Check_smooth_toggle_update_flag(display);
								//whether timing need to change or not
								if (get_current_driver_pattern(DRIVER_FREERUN_PATTERN) == 1) {//curr source timing go data fs,need vo overscan
									Convert_Timing_To_fs_Depend_datafs(display);
								}
								zoom_imd_smooth_toggle_config(display, getInputRegionType(display), main_input_size, main_input_timing, main_dispwin);
								Check_smooth_toggle_update_flag(display);//wait smooth toggle ready to avoid to see ARC change
							} else {
								wait_to_after_avsync_do = 1;
							}
#ifdef SPEEDUP_NEW_SCALER_FLOW
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, FALSE);
#endif
						}
						DbgSclrFlgTkr.Main_Run_Scaler_flag = FALSE;
						DbgSclrFlgTkr.Main_Output_Set_flag = FALSE;
						DbgSclrFlgTkr.Main_smooth_toggle_set_flag = FALSE;
						DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = FALSE;
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "\r\n#### scaler to run smooth toggle 1 (%d %d %d %d)####\r\n", main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
						up(&SetMainOutPutRegion_Semaphore);
					}else if (DbgSclrFlgTkr.rotate_muteoff_request_flag && (DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE) && (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)){
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "request mute off run rotate-scaler\n");
						return FALSE;
					}
					if((DbgSclrFlgTkr.Main_Run_Scaler_flag || DbgSclrFlgTkr.Main_smooth_toggle_set_flag || DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag) && (DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE) && (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)) {
						if(Scaler_InputSrcGetType(display) == _SRC_VO ){
							if(get_vo_change_flag(Get_DisplayMode_Port(SLR_MAIN_DISPLAY)) == FALSE) {
								if (DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting) {
									//This is for smooth togggle presetting
									//state_update_disp_info();//Update the active state
									DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = FALSE;
								#ifdef CONFIG_I2RND_ENABLE
									if (!((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_I2RND_DONE)))
								#endif
										smooth_toggle_preset_info(display);
								}
							} else {
								Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
								state_update_disp_info();
								DbgSclrFlgTkr.Main_during_scalerflow_flag = FALSE;//WOSQRTK-7524 patch. Reset DbgSclrFlgTkr.Main_during_scalerflow_flag
								return FALSE;
							}

						}
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
						if((inputType == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
							return FALSE;
#endif
						down(&SetMainOutPutRegion_Semaphore);
						if(!compare_rerify_vsc_source_num_result(display))
						{
							up(&SetMainOutPutRegion_Semaphore);
							rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "### rtk_run_scaler main source already change line:%d###\r\n", __LINE__);
							return FALSE;
						}
						Scaler_DispWindowSet(main_dispwin);
						if(((get_rotate_mode()>=DIRECT_VO_FRAME_ORIENTATION_ROTATE_90)&& (get_rotate_mode()<=DIRECT_VO_FRAME_ORIENTATION_FLIP_ROTATE_270))||((rotate_mode>=DIRECT_VO_FRAME_ORIENTATION_ROTATE_90)&& (rotate_mode<=DIRECT_VO_FRAME_ORIENTATION_FLIP_ROTATE_270))){
							up(&SetMainOutPutRegion_Semaphore);
							return FALSE;
						}else{
							DbgSclrFlgTkr.Main_Run_Scaler_flag = FALSE;
							DbgSclrFlgTkr.Main_Output_Set_flag = FALSE;
							DbgSclrFlgTkr.Main_smooth_toggle_set_flag = FALSE;
							DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = FALSE;
						}

						if(inputType == KADP_VSC_INPUTSRC_AVD)
						{
							if(get_AVD_Input_Source() != _SRC_TV)
							{//AV case
								new_voinfo_flag = 1;
								//whether timing need to change or not
								if (get_current_driver_pattern(DRIVER_FREERUN_PATTERN) == 1) {//curr source timing go data fs,need vo overscan
									Convert_Timing_To_fs_Depend_datafs(display);
								}
								zoom_imd_smooth_toggle_config(display, getInputRegionType(display), main_input_size, main_input_timing, main_dispwin);
								Check_smooth_toggle_update_flag(display);//wait smooth toggle ready to avoid to see ARC change

#ifdef SPEEDUP_NEW_SCALER_FLOW
								set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, FALSE);
								avd_start_compensation();//compensation h v start
#endif
							}
						} else {
							if (inputType != KADP_VSC_INPUTSRC_VDEC) {
								new_voinfo_flag = 1;
								Check_smooth_toggle_update_flag(display);
								winSrcRect = Scaler_DispWindowGet();
								//whether timing need to change or not
								if (get_current_driver_pattern(DRIVER_FREERUN_PATTERN) == 1) {//curr source timing go data fs,need vo overscan
									Convert_Timing_To_fs_Depend_datafs(display);
								}
								zoom_imd_smooth_toggle_config(display, getInputRegionType(display), main_input_size, main_input_timing, winSrcRect);
								Check_smooth_toggle_update_flag(display);//wait smooth toggle ready to avoid to see ARC change
							} else {
								wait_to_after_avsync_do = 1;
							}
#ifdef SPEEDUP_NEW_SCALER_FLOW
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, FALSE);
#endif
						}
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "\r\n#### scaler to run smooth toggle 2 (%d %d %d %d)####\r\n", main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
						up(&SetMainOutPutRegion_Semaphore);
					} else if (DbgSclrFlgTkr.rotate_run_scaler_flag && (DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE) && (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)){
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "request just run rotate-scaler\n");
						return FALSE;
					}
					if(!vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY) && (inputType == KADP_VSC_INPUTSRC_VDEC) && (is_DTV_flag_get())
						&& (display == SLR_MAIN_DISPLAY)
						&& (!(Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)display,SLR_INPUT_IPV_ACT_LEN_PRE) > 2000) || (Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)display,SLR_INPUT_IPV_ACT_LEN_PRE) == 720))// 4k2k or 720p don't have ip change
						&& ((IoReg_Read32(VODMA_VODMA_V1_DCFG_reg) &VODMA_VODMA_V1_DCFG_vodma_go_mask) &&(IoReg_Read32(VODMA_VODMA_V1INT_reg) &VODMA_VODMA_V1INT_vgip_en_mask))// when vo FREEZE ,don't go this flow
						&& (!(IoReg_Read32(DI_IM_DI_DEBUG_MODE_reg) & DI_IM_DI_DEBUG_MODE_auto_freeze_mask))
#ifdef CONFIG_I2RND_ENABLE
						&& (Scaler_I2rnd_get_timing_enable() == _DISABLE)//i2run case need to	use pst flow. @Crixus 20170418
#endif
					){// if di freeze ,can't run this flow ,cause this flow need apply di double buffer
							/* K5lp No need the dummy smooth toggle. reduce time
							pr_emerg("run smooth toggle for DTV I/P exchange after scaler\n");
							run_smoothtoggle_for_ip_change(display);
							*/
					}
				}
#if 0//for sub smooth toggle test
#ifdef CONFIG_DUAL_CHANNEL
				else
				{
					down(&SetSubOutPutRegion_Semaphore);
					//if(DbgSclrFlgTkr.Sub_Output_Set_flag == TRUE)
					{
						//Scaler_DispWindowSet(main_dispwin);
						Scaler_SubDispWindowSet(sub_dispwin);
						pr_notice("\r\n####send sub smooth toggle info!!!####\r\n");
						//sub always sends memory info to video after scaler
						smooth_toggle_preset_info(display);

						//DbgSclrFlgTkr.Sub_Output_Set_flag = FALSE;
					}
					if(!compare_rerify_vsc_source_num_result(display))
					{
						up(&SetSubOutPutRegion_Semaphore);
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "### rtk_run_scaler sub source already change line:%d###\r\n", __LINE__);
						return FALSE;
					}
					if((inputType != KADP_VSC_INPUTSRC_AVD) || (_SRC_TV != get_AVD_Input_Source()))
					{
						if(((DbgSclrFlgTkr.Sub_Output_Set_flag == TRUE) || (DbgSclrFlgTkr.Sub_Run_Scaler_flag == TRUE)) && (DbgSclrFlgTkr.Sub_Scaler_Stop_flag == FALSE) && (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
						{
							if(decide_run_sub_smoothtoggle_case())
							{
								set_input_for_vgip(SLR_SUB_DISPLAY, sub_input_size.srcx, sub_input_size.srcy, sub_input_size.src_wid, sub_input_size.src_height);
								zoom_imd_smooth_toggle_config(SLR_SUB_DISPLAY, hal_sub_InputRegionType, sub_input_size, sub_input_timing, sub_dispwin);
								DbgSclrFlgTkr.Sub_Output_Set_flag = FALSE;
								DbgSclrFlgTkr.Sub_Run_Scaler_flag = FALSE;
							}
							else
							{
								Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
								state_update_disp_info();
								reset_any_srcrect(&sub_dispwin_pre);
								up(&SetSubOutPutRegion_Semaphore);
								rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "####(%d) got new output. need to run scaler again ####\n", __LINE__);
								return FALSE;
							}
						}
					}
					up(&SetSubOutPutRegion_Semaphore);
				}
#endif
#endif
			}

#if(VSC_PROFILE == 1)
			after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\nVSC VSC_CONNECT time=%d ms\n",(after_time-before_time));
#endif


#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
			if((inputType == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV) && (display == SLR_MAIN_DISPLAY))
			{//current smooth toggle is at video fw, so need alwasy to call smooth_toggle_preset_info
				if (/*Scaler_InputSrcGetType(display) == _SRC_VO && */DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting && (display == SLR_MAIN_DISPLAY)){
				//This is for smooth togggle presetting
					DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = FALSE;
					smooth_toggle_preset_info(display);
				}
				return FALSE;//no need to do forcebg. we always to mute off at smooth toggle
			}
#endif



			if (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) {
				//Avoid online interrupt occur
//				if(Scaler_InputSrcGetType(display) == _SRC_TV) {
				//if((Scaler_InputSrcGetType(display) == _SRC_TV)||(Scaler_InputSrcGetType(display) == _SRC_CVBS)) {

#ifdef SPEEDUP_NEW_SCALER_FLOW
				if((inputType == KADP_VSC_INPUTSRC_AVD) && (_SRC_TV == get_AVD_Input_Source()))
#else
				if(inputType == KADP_VSC_INPUTSRC_AVD)//need to check
#endif
				{

#ifdef CONFIG_ENABLE_VD_27MHZ_MODE


#ifdef CONFIG_SDNR_CROP

#else
					//if(VD_27M_HSD960_DI5A == fw_video_get_27mhz_mode((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)))
					if(VD_27M_HSD960_DI5A == fw_video_get_27mhz_mode(display))
					{
						VIDEO_RECT_T inregion_avd;
						VIDEO_RECT_T outregion_avd;
						rtk_hal_vsc_GetOutputRegion(display, &outregion_avd);
						Scaler_CalWindowZoominForAVD(display, &inregion_avd, &outregion_avd);

						rtd_printk(KERN_INFO, TAG_NAME_VSC, "file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
						Scaler_DispWindowZoominForAVD(display, inregion_avd, outregion_avd,FALSE);
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "&&&& Scaler_DispWindowZoominForAVD()\n");
						//rtd_printk(KERN_EMERG, TAG_NAME_VSC, "&&&& Scaler_DispWindowZoominForAVD()\n");
					}
#endif

#endif


					if (FALSE == CheckAVDandWebOSInfo(display))
					{
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "CheckAVDandWebOSInfo() fail\n");

						if (0xff == DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount)
						{
							rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Set DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount = 0\n");
							DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount = 0;
						}

						DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount++;

						if(display == SLR_MAIN_DISPLAY)	{
							if(DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE && DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount < CHECK_AVD_WEBOS_INFO_TIMEOUT){
								DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;// Set output again, switch channel
								return FALSE;
							}
							else
							{
								rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount timeout\n");
								DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount = 0xff;
							}
						} else {
							if(DbgSclrFlgTkr.Sub_Scaler_Stop_flag == FALSE && DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount < CHECK_AVD_WEBOS_INFO_TIMEOUT){
									DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;// Set output again, switch channel
									return FALSE;
							}
							else
							{
								rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount timeout\n");
								DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount = 0xff;
							}
						}
					}
					else
					{
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "CheckAVDandWebOSInfo ok, DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount=%d\n", DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount);
						DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount = 0xff;
					}


					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Cur VD stage=%x, SetWinBlank VD stage=%x\n", Scaler_AVD_GetDetectStage(), DbgSclrFlgTkr.g_ucVDCDetectStage);
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount=%d\n", DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount);

					//rtd_printk(KERN_EMERG, TAG_NAME_VSC, "Cur VD stage=%x, SetWinBlank VD stage=%x\n", Scaler_AVD_GetDetectStage(), DbgSclrFlgTkr.g_ucVDCDetectStage);
					//rtd_printk(KERN_EMERG, TAG_NAME_VSC, "DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount=%d\n", DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount);

					// The timing info is changed from SetOutputRegion to SetWinBlank, therefore avoid to clear ForceBg
					if ((Scaler_AVD_GetDetectStage() == VDC_DETECT_STAGE_FINAL)
						&& (DbgSclrFlgTkr.g_ucVDCDetectStage != VDC_DETECT_STAGE_FINAL)
						&& (get_AVD_Input_Source() == _SRC_TV)
						&& DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount  == 1)
					{
						rtd_printk(KERN_INFO, TAG_NAME_VSC, "In ATV, The timing info is changed between SetWinBlank and Scaler unmute video, therefore avoid to clear ForceBg\n");

						if(display == SLR_MAIN_DISPLAY){
							if(DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE)
								DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;// Set output again, switch channel
							return FALSE;
						} else {
							if(DbgSclrFlgTkr.Sub_Scaler_Stop_flag == FALSE)
								DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;// Set output again, switch channel
							return FALSE;
						}
					}

					if(wait_atv_stable_for_bg(display,__func__,__LINE__) == FALSE)
					{
						if((get_AVD_Input_Source() != _SRC_TV) || (display == SLR_SUB_DISPLAY)) {//For KTASKWBS-5200
							Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
							state_update_disp_info();
						}
						if(display == SLR_MAIN_DISPLAY)	{
							if((DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE) && DbgSclrFlgTkr.Main_Output_Set_flag) {
								DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;
								return FALSE;
							}
							if((DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE)
								&&(get_AVD_Input_Source() == _SRC_TV)
								&&((vdc_LockStatus == 0)||(drvif_module_vdc_OutputStable()==FALSE)||(Scaler_AVD_GetDetectStage() != VDC_DETECT_STAGE_FINAL))
								&&(0 == drvif_video_status_reg(VDC_no_signal))){
								rtd_printk(KERN_INFO, TAG_NAME_VSC,"######[%s(line:%d)]fast zapping, flicker garbage.#####\n",__FUNCTION__, __LINE__);
								DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;
								return FALSE;
							}
						} else {
							if((DbgSclrFlgTkr.Sub_Scaler_Stop_flag == FALSE) && (DbgSclrFlgTkr.Sub_Output_Set_flag  || DbgSclrFlgTkr.Sub_Run_Scaler_flag)) {
								DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;
								return FALSE;
							}
						}
					}

					if ((get_AVD_Input_Source() == _SRC_TV)
						&&(Scaler_AVD_GetVDPreMode() == _MODE_UNKNOWN)
						&&(1 == vdc_LockStatus)
						&&(DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE) && (display == SLR_MAIN_DISPLAY)){
						rtd_printk(KERN_INFO, TAG_NAME_VSC,"######[%s(line:%d)]fast zapping, flicker garbage.#####\n",__FUNCTION__, __LINE__);
						DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE; // Set output again, switch channel
						return FALSE;
					}
				}
#ifdef SPEEDUP_NEW_SCALER_FLOW
				else if((inputType == KADP_VSC_INPUTSRC_AVD) && (_SRC_TV != get_AVD_Input_Source()))
				{//av condition
					if(wait_atv_stable_for_bg(display,__func__,__LINE__) == FALSE)
					{
							Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
							state_update_disp_info();
							reset_avd_timing_ready();
							Set_Reply_Zero_Timing_Flag(KADP_VSC_INPUTSRC_AVD, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/

					}

				}
#endif
				else if(inputType == KADP_VSC_INPUTSRC_VDEC)
				{
					int port = Get_DisplayMode_Port(display);
					int vo_timeout = 30;
                                	int filmDetect_timeout = FILM_DETECT_TO;
					unsigned int input_len_tmp = 0;
					unsigned int vo_len_tmp = 0;
					if(display == SLR_MAIN_DISPLAY) {
						// [K5LG-828] wait for film mode detect done
						unsigned int stc = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
						while(((get_vo_avsync_flag(port) == FALSE) && vo_timeout)|| ((get_film_detect_done_flag(port) == FALSE) && filmDetect_timeout))
						{
							vo_timeout -- ;
							filmDetect_timeout--;
							if(DbgSclrFlgTkr.Main_Scaler_Stop_flag || DbgSclrFlgTkr.Main_Run_Scaler_flag)
								break;
							if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
								break;
							msleep(1);

						}
						if(filmDetect_timeout != FILM_DETECT_TO)
						    rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "[FILM] Disp[%d] P[%d] Wait Detect Done[%d]=%d ms\n", display, port, filmDetect_timeout, (IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg) - stc)/90);

						rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "\r\n### main vo wait sync & film detect done timeout:%d, %d####\r\n", vo_timeout, filmDetect_timeout);
						if (wait_to_after_avsync_do) {
							wait_to_after_avsync_do = 0;
							down(&SetMainOutPutRegion_Semaphore);
							Scaler_DispWindowSet(main_dispwin);
							if(DbgSclrFlgTkr.Main_smooth_toggle_set_flag)
							{
									DbgSclrFlgTkr.Main_smooth_toggle_set_flag=FALSE;
									rtd_printk(KERN_INFO, TAG_NAME_VSC, "clear Main_smooth_toggle_set_flag\n");
							}
							if(DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off) {
								DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off=FALSE;
									rtd_printk(KERN_INFO, TAG_NAME_VSC, "clear Main_run_smooth_toggle_from_mute_off\n");
							}
							up(&SetMainOutPutRegion_Semaphore);
							Check_smooth_toggle_update_flag(display);
							winSrcRect = Scaler_DispWindowGet();

							if (get_current_driver_pattern(DRIVER_FREERUN_PATTERN) == 1) {//curr source timing go data fs,need vo overscan
								Convert_Timing_To_fs_Depend_datafs(display);
								down(&SetMainOutPutRegion_Semaphore);
								input_len_tmp = main_input_size.src_height;
								up(&SetMainOutPutRegion_Semaphore);

								down(get_vo_infosemaphore());
								vo_len_tmp =  Scaler_VOInfoPointer(port)->v_length;
								up(get_vo_infosemaphore());
								if (Scaler_DispGetStatus(display,SLR_DISP_INTERLACE)) {
									vo_len_tmp = vo_len_tmp * 2;
								}
								if(Scaler_InputRegionType_Get(display) == INPUT_BASE_ON_DISP_WIN){
									/*apative input case ，need convert  input_len_tmp*/
									input_len_tmp = ((Scaler_VOInfoPointer(port)->progressive ? Scaler_VOInfoPointer(port)->src_v_len : 2*Scaler_VOInfoPointer(port)->src_v_len) *main_input_size.src_height * 100/_DISP_LEN + 50)/100;
								}
								if (input_len_tmp !=vo_len_tmp)
									zoom_clear_input_output_region_record(display); //clear size to run vo smooth toggle
							}

							zoom_imd_smooth_toggle_config(display, getInputRegionType(display), main_input_size, main_input_timing, winSrcRect);
							Check_smooth_toggle_update_flag(display);//wait smooth toggle ready to avoid to see ARC change
							new_voinfo_flag = 1;
						}
						if((DbgSclrFlgTkr.Main_smooth_toggle_set_flag) || (DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off))
						{
							unsigned int input_len_tmp = 0;
							unsigned int vo_len_tmp = 0;
							new_voinfo_flag = 1;
							down(&SetMainOutPutRegion_Semaphore);
							Scaler_DispWindowSet(main_dispwin);
							DbgSclrFlgTkr.Main_smooth_toggle_set_flag=FALSE;
							DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = FALSE;
							up(&SetMainOutPutRegion_Semaphore);
							winSrcRect = Scaler_DispWindowGet();

							if (get_current_driver_pattern(DRIVER_FREERUN_PATTERN) == 1) {//curr source timing go data fs,need vo overscan
								Convert_Timing_To_fs_Depend_datafs(display);
								down(&SetMainOutPutRegion_Semaphore);
								input_len_tmp = main_input_size.src_height;
								up(&SetMainOutPutRegion_Semaphore);

								down(get_vo_infosemaphore());
								vo_len_tmp =  Scaler_VOInfoPointer(port)->v_length;
								up(get_vo_infosemaphore());
								if (Scaler_DispGetStatus(display,SLR_DISP_INTERLACE)) {
									vo_len_tmp = vo_len_tmp * 2;
								}
								if(Scaler_InputRegionType_Get(display) == INPUT_BASE_ON_DISP_WIN){
									/*apative input case ，need convert  input_len_tmp*/
									input_len_tmp = ((Scaler_VOInfoPointer(port)->progressive ? Scaler_VOInfoPointer(port)->src_v_len : 2*Scaler_VOInfoPointer(port)->src_v_len) *main_input_size.src_height * 100/_DISP_LEN + 50)/100;
								}
								if (input_len_tmp !=vo_len_tmp)
									zoom_clear_input_output_region_record(display);//clear size to run vo smooth toggle
							}
#ifdef SPEEDUP_NEW_SCALER_FLOW
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, FALSE);//disable arc ready mask. because we will run smooth toggle below
#endif
							smooth_toggle_preset_info(display);
							Check_smooth_toggle_update_flag(display);
							zoom_imd_smooth_toggle_config(display, getInputRegionType(display), main_input_size, main_input_timing, winSrcRect);
							rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "\r\n####scaler to run smooth toggle 3!!!####\r\n");
							Check_smooth_toggle_update_flag(display);
						}
					}
#ifdef CONFIG_DUAL_CHANNEL
					else
					{
						// [K5LG-828] wait for VO film mode detect done
						unsigned int stc = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
						while(((get_vo_avsync_flag(port) == FALSE) && vo_timeout) || ((get_film_detect_done_flag(port) == FALSE) && filmDetect_timeout))
						{
							vo_timeout -- ;
							filmDetect_timeout--;
							if(DbgSclrFlgTkr.Sub_Scaler_Stop_flag || DbgSclrFlgTkr.Sub_Run_Scaler_flag)
								break;
							if(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
								break;
							msleep(1);

						}
						if(filmDetect_timeout != FILM_DETECT_TO)
						    rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "[FILM] Disp[%d] P[%d] Wait Detect Done[%d]=%d ms\n", display, port, filmDetect_timeout, (IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg) - stc)/90);

						rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "\r\n### sub vo wait sync & film detect done timeout:%d, %d####\r\n", vo_timeout, filmDetect_timeout);
					}
#endif
				}
				else if(inputType == KADP_VSC_INPUTSRC_HDMI)
				{
					drvif_Hdmi_WatchDogApply(_ENABLE, HDMI_WD_VSC_COND);
				}

				if((get_current_driver_pattern(DRIVER_FREERUN_PATTERN) == 1) && (new_voinfo_flag == 0) && (display == SLR_MAIN_DISPLAY) && Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_FRAMESYNC) && (!DbgSclrFlgTkr.Main_smooth_toggle_set_flag) && (!DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag)) {
					unsigned int input_wid_tmp = 0;
					unsigned int input_len_tmp = 0;
					unsigned int input_x_tmp = 0;
					unsigned int vo_len_tmp = 0;
					down(&SetMainOutPutRegion_Semaphore);

					if (Scaler_InputRegionType_Get(display) == INPUT_BASE_ON_DISP_WIN) {
						StructSrcRect newInput = cal_new_input_base_on_display_win(display);

						input_wid_tmp = newInput.src_wid;
						input_len_tmp = newInput.src_height;
						input_x_tmp = newInput.srcx;
					} else {
						input_wid_tmp = main_input_size.src_wid;
						input_len_tmp = main_input_size.src_height;
						input_x_tmp = main_input_size.srcx;
					}
					Scaler_DispWindowSet(main_dispwin);
					up(&SetMainOutPutRegion_Semaphore);

					down(get_vo_infosemaphore());
					vo_len_tmp =  Scaler_VOInfoPointer(Get_DisplayMode_Port(SLR_MAIN_DISPLAY))->v_length;
					up(get_vo_infosemaphore());

					if (Scaler_DispGetStatus(display,SLR_DISP_INTERLACE)) {
						vo_len_tmp = vo_len_tmp * 2;
					}
					if (inputType== KADP_VSC_INPUTSRC_AVD) {
						input_wid_tmp = Scaler_CalAVD27MWidth(display,input_wid_tmp);
						input_x_tmp = Scaler_CalAVD27MWidth(display,input_x_tmp);
					}
					if (input_len_tmp !=vo_len_tmp) {
						rtd_printk(KERN_EMERG, TAG_NAME_VSC, "\r\n### before open bg, smoothtoggle will let vo do overscan####\r\n");
						Check_smooth_toggle_update_flag(display);
					 	smooth_toggle_preset_info(display);
						winSrcRect = Scaler_DispWindowGet();
						zoom_clear_input_output_region_record(display);
						zoom_imd_smooth_toggle_config(display, getInputRegionType(display), main_input_size, main_input_timing, winSrcRect);
						Check_smooth_toggle_update_flag(display);
					}
				}

				if(display == SLR_SUB_DISPLAY){
				       if((DbgSclrFlgTkr.Sub_Output_Set_flag || DbgSclrFlgTkr.Sub_Run_Scaler_flag) && (DbgSclrFlgTkr.Sub_Scaler_Stop_flag == FALSE)){
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "####(%d) got new output. need to run scaler again ####\n", __LINE__);
						Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
						state_update_disp_info();
						down(&SetSubOutPutRegion_Semaphore);
						DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;
				        reset_any_srcrect(&sub_dispwin_pre);
				        up(&SetSubOutPutRegion_Semaphore);
						return FALSE;
					}
				}

				if((KADP_VSC_INPUTSRC_AVD == inputType) && (_SRC_TV == get_AVD_Input_Source()))
				{
					if(fwif_color_GetAutoMAFlag() == 0){
						fwif_color_SetAutoMAFlag(1);
					}

					// Ready to clear forceBG, finish channel change
					DbgSclrFlgTkr.g_ucVSCATVChanelChangeStart = FALSE;
					DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount = 0;
					//rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Ready to Clear forceBG, set DbgSclrFlgTkr.g_ucVSCATVChanelChangeStart=0\n");
				}


#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
				// FixMe, 20170602
				//rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "[HDR10] src/st/ret=%d/%d/%d\n", Scaler_InputSrcGetType(display), Scaler_HDR10_Hdmi_Get_Detect_Status(), hdmi_is_drm_info_ready());
#endif
#if 0//def CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "[DolbyVision] src/st/ret=%d/%d/%d\n", Scaler_InputSrcGetType(display), Scaler_HDR_DolbyVision_Hdmi_Get_Detect_Status(), Scaler_HDR_DolbyVision_Hdmi_Get_Detect_Result());
				if((Scaler_InputSrcGetType(display) == _SRC_HDMI)
					&& (Scaler_HDR_DolbyVision_Hdmi_Get_Detect_Status() != SLR_DV_HDMI_DETECT_OFF)
					&& Scaler_HDR_DolbyVision_Hdmi_Get_Detect_Result())
				{
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "[DolbyVision] Skip disable BG...\n");
				}else if((Scaler_InputSrcGetType(display) == _SRC_VO)
					&& (Scaler_HDR_DolbyVision_Hdmi_Get_Detect_Status() == SLR_DV_HDMI_DETECT_FOUND_CRC))
				{
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "[DolbyVision] disable BG later...\n");
				}else
#endif
#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
				if((Scaler_InputSrcGetType(display) == _SRC_HDMI)
					&& (Scaler_Hdmi_DM_Get_Status() != SLR_HDMI_DM_CLOSE))
					// FixMe, 20170602
					// && hdmi_is_drm_info_ready())
				{
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "[HDR10] Skip disable BG...\n");
				}else if((Scaler_InputSrcGetType(display) == _SRC_VO)
					&& (Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT))
				{
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "[DolbyVision] disable BG later...\n");
				}else
#endif
				if ((get_HDMI_HDR_mode() == HDR_DOLBY_HDMI && (inputType == KADP_VSC_INPUTSRC_HDMI))
					&& (display == SLR_MAIN_DISPLAY)) {
#ifdef CONFIG_RTK_KDRV_DV
					unsigned char cnt = 50;
#ifdef	CONFIG_DOLBY_IDK_1_6_1_1
					while (dolby_adapter_get_g_picModeUpdateFlag() && !DbgSclrFlgTkr.Main_Scaler_Stop_flag) {
#else
					while (g_picModeUpdateFlag && !DbgSclrFlgTkr.Main_Scaler_Stop_flag) {
#endif
						if (cnt == 0)
                        {
                            if (get_OTT_HDR_mode() == HDR_DOLBY_COMPOSER && inputType == KADP_VSC_INPUTSRC_VDEC) {
								/* force set Normal_TEST() */
#ifdef	CONFIG_DOLBY_IDK_1_6_1_1
								dolby_adapter_set_g_picModeUpdateFlag(0xFFFFFFFF);
#else
                                g_picModeUpdateFlag = 0xFFFFFFFF;
#endif
							}
                            break;
                        }

						cnt--;
						msleep(1);
					}
#endif
				}
                else if (((get_OTT_HDR_mode() == HDR_DOLBY_COMPOSER && inputType == KADP_VSC_INPUTSRC_VDEC))
						&& (display == SLR_MAIN_DISPLAY))
				{
					    wait_event_freezable_timeout(dolby_apply_wq, dolby_apply_done, 2 * HZ);
				}

				//Race condition isse for HDR HDMI aspect ratio faster changing @Crixus 20160412
				if((get_HDMI_HDR_mode() == HDR_HDR10_HDMI) && (inputType == KADP_VSC_INPUTSRC_HDMI)
					&& (DbgSclrFlgTkr.Main_Run_Scaler_flag == TRUE) && (DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE)){
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "WebOS will run scaler again, do not disable FBG[%s]:%d\n", __FUNCTION__, __LINE__);
				}
				else{
					wait_DI_ready();//wait DI ready
					if(display == SLR_MAIN_DISPLAY) {
						DbgSclrFlgTkr.Main_during_scalerflow_flag = FALSE;//WOSQRTK-7524 patch. Reset DbgSclrFlgTkr.Main_during_scalerflow_flag. Means webos can mute off directly
					}
#ifdef CONFIG_I2RND_ENABLE
					//if i2rnd and multivie case, do not disable fbg in sub scaler. @Crixus 20160728
					if((display == SLR_SUB_DISPLAY) && (vsc_i2rnd_sub_stage == I2RND_STAGE_DETECT_SOURCE)){
						down(get_forcebg_semaphore());
						scalerdisplay_force_bg_enable(SLR_SUB_DISPLAY, TRUE);
						up(get_forcebg_semaphore());
						printk(KERN_EMERG"[I2RND]Do not disable fbg in sub scaler.\n");
					}
					else if((display == SLR_SUB_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_SUB_CONNECT)){
						//Eric@0802 if i2rnd dualvo case, do not disable fbg in sub scaler
						down(get_forcebg_semaphore());
						scalerdisplay_force_bg_enable(SLR_SUB_DISPLAY, TRUE);
						up(get_forcebg_semaphore());
						printk(KERN_EMERG"[I2RND] DualVO sub scaler path, do not disable fbg!!\n");
					}
					else
#endif
					{
#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG
						if(display == SLR_MAIN_DISPLAY)
						{
							if(!Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY))
							{//means not run arc yet
								//down(&SetMainOutPutRegion_Semaphore);
								if(!DbgSclrFlgTkr.Main_Scaler_Stop_flag && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
								{
									down(&new_input_output_main_sem);
									reset_pst_sharemem_buffer(SLR_MAIN_DISPLAY);//reset pst buffer data
									set_pst_active_state(SLR_MAIN_DISPLAY, TRUE);//update to enable PST
									up(&new_input_output_main_sem);
								}
								//up(&SetMainOutPutRegion_Semaphore);
							}
						}
#endif
						//HDMI game mode scaler flow, disable forcebg after game mode task done.
						if(((inputType == KADP_VSC_INPUTSRC_HDMI) || (inputType == KADP_VSC_INPUTSRC_VDEC)) && drv_memory_get_game_mode_dynamic() && game_mode_ignore_cmd_check ){
							//rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "[GAME MODE] HDMI/VDEC wait game mode ready  %d\n",game_mode_wait_timeout);
							while(game_mode_wait_timeout--){
								if(!game_mode_ignore_cmd_check){
									break;
								}
								//wait 10ms
								msleep(0);
							}
							//rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "[GAME MODE] HDMI/VDEC wait game mode done  %d\n",game_mode_wait_timeout);
							if(game_mode_wait_timeout == 0)
								rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "[GAME MODE] HDMI/VDEC game mode wait timeout = %d\n",game_mode_wait_timeout);
						}
                        if(display == SLR_MAIN_DISPLAY)
						{
							if(!Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY) && vbe_disp_oled_orbit_enable)
							{
								ScalerForceUpdateOrbit(1);

								rtd_printk(KERN_INFO, TAG_NAME_VSC, "####[%s(%d)] enable orbit mask\n",__func__, __LINE__);
								set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ORBIT_READY, TRUE);//Set orbit mask
							}
						}
						trigger_mute_off(display, 1);
						if((drv_memory_get_game_mode_dynamic() == drv_memory_get_game_mode_flag()) && (game_mode_ignore_cmd_check == _ENABLE))
							game_mode_ignore_cmd_check = _DISABLE;
					}
					Scaler_MEMC_fbg_control();


#ifdef CONFIG_SUPPORT_SRC_VGA //for first-timing adjust
					if((inputType == KADP_VSC_INPUTSRC_ADC) && (get_ADC_Input_Source() == _SRC_VGA) && (display == SLR_MAIN_DISPLAY)){

						rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "#####[%s(%d)]check_vga_auto_calib_status=%d #####\n", __func__, __LINE__, check_vga_auto_calib_status());
						if(!check_vga_auto_calib_status())
						{
							down(get_adc_adjustsemaphore());
							Scaler_AdjustPCAuto(display);
							up(get_adc_adjustsemaphore());
						}
					}
#endif



				}

				if(!drv_memory_get_game_mode_dynamic_flag() && display ==SLR_MAIN_DISPLAY)	//WOSQRTK-10203 already done in Scaler_disp_setting if game mode (patch for QA stage)
				{
					Scaler_MEMC_SetInOutFrameRateByDisp(display);
				}


#ifdef _PRINT_VSC_COST_TIME_AFTER_MUTE_OFF
				cost_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90 - cost_time;
				rtd_printk(KERN_EMERG, TAG_NAME_VSC, "\r\n####vsc cost time:%d ms after mute off####\r\n", cost_time);
#endif
				//state_update_disp_info();//Update the active state
				if(Scaler_InputSrcGetType(display) == _SRC_VO) {
					Scaler_SendDisplayReadyIrc(Scaler_Get_CurVoInfo_VoVideoPlane(display));/*Send display ready to video FW*/
				}
			}

			if (/*Scaler_InputSrcGetType(display) == _SRC_VO && */DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting && (display == SLR_MAIN_DISPLAY)){
			//This is for smooth togggle presetting
				DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = FALSE;
			#ifdef CONFIG_I2RND_ENABLE
					if (!((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_I2RND_DONE)))
			#endif
				smooth_toggle_preset_info(display);
			}
			else if(Scaler_InputSrcGetType(display) == _SRC_VO && (display == SLR_SUB_DISPLAY))
			{
				smooth_toggle_preset_info(display);
				down(&SetSubOutPutRegion_Semaphore);
				if(!DbgSclrFlgTkr.Sub_Scaler_Stop_flag && (Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
				{
					down(&new_input_output_sub_sem);
					reset_pst_sharemem_buffer(SLR_SUB_DISPLAY);//reset pst buffer data
					set_pst_active_state(SLR_SUB_DISPLAY, FALSE);//update to enable PST
					up(&new_input_output_sub_sem);
				}
				up(&SetSubOutPutRegion_Semaphore);
			}

/////////////////////////////////////////
			break;
		}
		case KADP_VSC_OUTPUT_VENC_MODE:
		{

			if(Scaler_DispGetInputInfo(SLR_INPUT_FAILURECOUNT) == 0)
			{
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####Go VencMode Src:%d!!!#####\r\n", VencModeInputInfo.type);
				Scaler_DispSetInputInfo(SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				state_update_disp_info();
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n######set search state#####\r\n");
			}
			else
			{
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "######get_displayinfo_proc success!!!#######\n");
			}

#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
 			if((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)){//capture progressive video data

			}
			else{
				drvif_mode_resetmode(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
			}

			drvif_mode_resetmode(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
#endif
#else
			drvif_mode_resetmode(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
#endif



			if(get_displayinfo_proc(display, inputType)== FALSE)
			{
				//rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "######get_displayinfo_proc fail fail fail!!!#######\n");
				return FALSE;
			}

			if(Setup_IMD(Scaler_DispGetInfoPtr())==FALSE)
			{
				if(inputType == KADP_VSC_INPUTSRC_ADC)
				{
					down(get_adc_detectsemaphore());
					reset_adc_timing_ready();
					p_timing = Get_ADC_Dispinfo();
					p_timing->IPH_ACT_WID_PRE = 0;
					p_timing->IPV_ACT_LEN_PRE = 0;
					p_timing->IVFreq = 0;
					p_timing->IHFreq = 0;
					p_timing->IHTotal = 0;
					p_timing->IVTotal = 0;
					p_timing->ucMode_Table_Index = Mode_Table_Init_Index;
					if(get_ADC_Global_Status() == SRC_CONNECT_DONE) ADC_set_detect_flag(TRUE);
					up(get_adc_detectsemaphore());
				}
				else if(inputType == KADP_VSC_INPUTSRC_HDMI)
				{
					down(get_hdmi_detectsemaphore());
					if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
					up(get_hdmi_detectsemaphore());
				}
				else if(inputType == KADP_VSC_INPUTSRC_AVD)
				{
					/*//no need because AVD don't stop detect task
					//down(get_vdc_detectsemaphore());
					if(get_AVD_Global_Status() == SRC_CONNECT_DONE)
						VDC_set_detect_flag(TRUE);
					//up(get_vdc_detectsemaphore());
					*/
				}
				printk(KERN_EMERG "######VSC_OUTPUT_VENC_MODE Setup_IMD fail fail!!!#######\n");
				return FALSE;
			}
			else
			{
#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
				if((Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_I2RND_DONE)){
					printk(KERN_EMERG"apvr flow finish, so didnot re-run sub path\n");
					break;
				}
#endif
#endif
				printk(KERN_EMERG"######VSC_OUTPUT_VENC_MODE Channel:%d src:%d Setup_IMD success!!!#######\n", display, inputType);
				//imd_smooth_toggle_check_pre_double_buffer(display);
				//state_update_disp_info();//Update the active state

				if(inputType == KADP_VSC_INPUTSRC_AVD) //Let AVD detect enable
				{
					/*//no need because AVD don't stop detect task
					//down(get_vdc_detectsemaphore());
					if(get_AVD_Global_Status() == SRC_CONNECT_DONE)
						VDC_set_detect_flag(TRUE);
					//up(get_vdc_detectsemaphore());
					*/
					rtd_printk(KERN_INFO, TAG_NAME_VSC, "#####[%s(%d)] Scaler_AVD_SetRunSearchState(false)\n",__func__,__LINE__);
					Scaler_AVD_SetRunSearchState(display, false);
#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
					//I2rnd sub=>vo RPC
					if((Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_DETECT_SOURCE)){
						vsc_i2rnd_sub_stage = I2RND_STAGE_SUB_VO_RPC;
						printk(KERN_EMERG"[frank]APVR step 2@@@@@@@@I2RND_STAGE_SUB_VO_RPC\n");
						Scaler_I2rnd_set_display(I2RND_SUB_S1_TABLE);
						i2rnd_send_table_idx(I2RND_SUB_S1_TABLE);
						drvif_scaler_i2rnd_vodma_setting(SLR_SUB_DISPLAY, inputType);
						drivf_Sub_I2rnd_SetupVODMA();
						//i2rnd_debug();
						printk(KERN_EMERG"[frank]@@@@@@@@@@@@I2RND_STAGE_SUB_VO_RPC OK!!!!!\n");
					}
#endif
#endif
				}

				if (Scaler_InputSrcGetType(display) != _SRC_VO)
				{
					if((Get_Live_zoom_mode() == LIVE_ZOOM_ON) && (display == SLR_SUB_DISPLAY)){
						/*qiangzhou added livezoom and magnifier case sub forbidden open wtd and interrupt and onlinemeasure*/
						drvif_mode_onlinemeasure_setting(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), Scaler_InputSrcGetMainChType(), FALSE, FALSE);
					} else {
						if (Scaler_InputSrcGetType(display) == _SRC_TV)//ATV no need online interrupt
							drvif_mode_onlinemeasure_setting(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), Scaler_InputSrcGetMainChType(), TRUE, FALSE);
						else
							drvif_mode_onlinemeasure_setting(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), Scaler_InputSrcGetMainChType(), TRUE, TRUE);
					}
				}
			}
			break;
		}

		default:

			break;
	}

	return TRUE;
}

#ifdef CONFIG_I2RND_ENABLE
unsigned char check_Sub_I2rnd_done(void)
{
	if ((vsc_i2rnd_sub_stage == I2RND_STAGE_DISABLE) || (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_I2RND_FINISH) || (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_SUB_DISABLE) || (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FINISH))
		return TRUE;
	else
		return FALSE;
}
#endif

void set_frc_style_input_fast_than_display(bool enable)
{
	unsigned char frc_style = (enable) ? 1 : 0;

	mdomain_disp_ddr_mainsubctrl_RBUS disp_mainsubctrl;
	mdomain_disp_ddr_mainctrl_RBUS ddr_mainctrl;

	ddr_mainctrl.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainCtrl_reg);
	if(ddr_mainctrl.main_frc_style == frc_style)
		return;//no need to do

	disp_mainsubctrl.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
	disp_mainsubctrl.disp1_double_enable = 1;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, disp_mainsubctrl.regValue);

	ddr_mainctrl.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainCtrl_reg);
	ddr_mainctrl.main_frc_style = frc_style;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainCtrl_reg, ddr_mainctrl.regValue);

	disp_mainsubctrl.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
	disp_mainsubctrl.disp1_double_apply = 1;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, disp_mainsubctrl.regValue);
}

unsigned char get_frc_style_input_fast_than_display(void)
{
	mdomain_disp_ddr_mainctrl_RBUS ddr_mainctrl;

	ddr_mainctrl.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainCtrl_reg);
	return ddr_mainctrl.main_frc_style;
}
unsigned char scaler_get_current_framesync_mode(unsigned char display)
{
	mdomain_disp_ddr_mainctrl_RBUS mdomain_disp_ddr_mainctrl_reg;
	mdomain_disp_ddr_subctrl_RBUS mdomain_disp_ddr_subctrl_reg;

	if(display==SLR_MAIN_DISPLAY){
		mdomain_disp_ddr_mainctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainCtrl_reg);
		if(mdomain_disp_ddr_mainctrl_reg.main_source_sel == 0x3)
			return TRUE; //data fs
	}
	else if (display==SLR_SUB_DISPLAY){
		mdomain_disp_ddr_subctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_SubCtrl_reg);
		if(mdomain_disp_ddr_subctrl_reg.sub_source_sel == 0x3)
			return TRUE; //data fs
	}

	return FALSE; ////data frc
}
unsigned char rtk_check_signal(unsigned char display)
{/*This is for source check signal stable or not. Must be _MODE_STATE_ACTIVE*/
	unsigned char result;
	KADP_VSC_OUTPUT_MODE_T outputMode;
	KADP_VSC_INPUT_TYPE_T inputType = KADP_VSC_INPUTSRC_MAXN;
	unsigned char inputPort = 0;
	unsigned int inputVfreq = 0;
	unsigned int input_isInterlace = 0;
/*
	unsigned char frame_idicator=0;
	unsigned char b_run_frame_check=0;
	ppoverlay_dtg_frame_cnt1_RBUS dtg_frame_cnt1_reg;
	ppoverlay_new_meas1_linecnt_real_RBUS new_meas1_linecnt_real_reg;
	vgip_vgip_chn1_lc_RBUS vgip_chn1_lc_reg;
	unsigned int count2 = 0x3fffff;
	unsigned int ch1_line_cnt_lower = 0;
	unsigned int ch1_line_cnt_upper = 0;

	//check fix last line lock status @Crixus 20151219
	ppoverlay_fix_last_line_mode_lock_status_RBUS fix_last_line_mode_lock_status_reg;
//	display_timing_ctrl1_RBUS display_timing_ctrl1_reg;
	extern unsigned char modestate_decide_display_timing(void);
	static UINT8 checkStableCnt=0;
*/
	unsigned char plane = 0;//get_vo_plane_flag(display);

#ifdef _VBY1_TO_HDMI_DIRTY_FIX
	static unsigned char bfirst_boot = 1;
#endif


	if (display == SLR_MAIN_DISPLAY) {
		if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_DISPLAY_MODE;
			inputType = DisplayModeInputInfo.type;
			inputPort = DisplayModeInputInfo.resourceIndex;
		}
		else if(VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_VENC_MODE;
			inputType = VencModeInputInfo.type;
			inputPort = VencModeInputInfo.resourceIndex;
		}
		else if(MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_MEMORY_MODE;
			inputType = MemoryModeInputInfo.type;
			inputPort = MemoryModeInputInfo.resourceIndex;
		}
		else
		{
			return false;
		}

#ifdef _VBY1_TO_HDMI_DIRTY_FIX
		if(bfirst_boot == 1){
			scaler_dtg_reconfig(); //vtotal set 0x8ca during boot up, recover to 0x8c9
			bfirst_boot	= 0;
		}
#endif
		//Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);//Remove by Will
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if (display == SLR_SUB_DISPLAY){
		if(Sub_DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_DISPLAY_MODE;
			inputType = Sub_DisplayModeInputInfo.type;
			inputPort = Sub_DisplayModeInputInfo.resourceIndex;
		}
		else if(Sub_VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_VENC_MODE;
			inputType = Sub_VencModeInputInfo.type;
			inputPort = Sub_VencModeInputInfo.resourceIndex;
		}
		else if(Sub_MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_MEMORY_MODE;
			inputType = Sub_MemoryModeInputInfo.type;
			inputPort = Sub_MemoryModeInputInfo.resourceIndex;
		}
		else
		{
			return false;
		}
		//Scaler_SetCurrentDispInfo(SLR_SUB_DISPLAY);//Remove by Will
	}
#endif

#ifdef CONFIG_I2RND_ENABLE
if((VSC_OUTPUT_VENC_MODE_FLAG == TRUE) && (Scaler_I2rnd_get_enable())){
	//Eric@0809
	rtd_printk(KERN_EMERG, TAG_NAME_VSC, "[OUTPUT_VENC_MODE] timing framesync!\n");
	modestate_set_fll_running_flag(_DISABLE);
	if(modestate_decide_display_timing() != DISPLAY_MODE_FRAME_SYNC){
		if(drvif_scaler_get_display_mode() != DISPLAY_MODE_FRAME_SYNC){
            fwif_color_safe_od_enable(0);
			drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
			fwif_color_safe_od_enable(1);
		}
	}
	VSC_OUTPUT_VENC_MODE_FLAG = FALSE;
}
#endif

#if 0
	down(get_scaler_fll_running_semaphore());
	if((display == SLR_MAIN_DISPLAY) &&
		(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)){
		if(modestate_get_fll_running_flag()){
			if(checkStableCnt> 2){
				if((modestate_decide_display_timing() == DISPLAY_MODE_NEW_FLL_MODE) &&
					(drvif_scaler_get_display_mode() != DISPLAY_MODE_NEW_FLL_MODE)){
					down(&VSC_Semaphore);
					Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
					//add check frame cnt and add 1 frame delay @Crixus 20151221
					if((inputType == KADP_VSC_INPUTSRC_HDMI) && (DbgSclrFlgTkr.line_cnt_no_run_hdmi_check == 0)){
						//if HDMI source, not to run check mode until sync OK @Crixus 20151229
						DbgSclrFlgTkr.line_cnt_no_run_hdmi_check = 1;
					}
					if(Scaler_DispGetInputInfo(SLR_INPUT_FRAC_FS_MULTIPLE_RATIO) > 1){
						b_run_frame_check = 1;
						frame_idicator = Scaler_DispGetInputInfo(SLR_INPUT_FRAC_FS_MULTIPLE_RATIO)-1;
						switch (Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR)) {
							case _MODE_480I:
								ch1_line_cnt_lower = MODE_480I_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_480I_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_480P:
								ch1_line_cnt_lower = MODE_480P_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_480P_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_576I:
								ch1_line_cnt_lower = MODE_576I_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_576I_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_576P:
								ch1_line_cnt_lower = MODE_576P_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_576P_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_720P50:
								ch1_line_cnt_lower = MODE_720P50_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_720P50_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_720P60:
								ch1_line_cnt_lower = MODE_720P60_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_720P60_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_1080I25:// Mode 100: YPbPr 1920x1080ix50HZ (802R)
								ch1_line_cnt_lower = MODE_1080I50_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_1080I50_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_1080I30:// Mode 101: YPbPr 1920x1080ix60HZ (802R)
								ch1_line_cnt_lower = MODE_1080I60_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_1080I60_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_1080P50:
								ch1_line_cnt_lower = MODE_1080P50_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_1080P50_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_1080P60:
								ch1_line_cnt_lower = MODE_1080P60_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_1080P60_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_1080P23:
							case _MODE_1080P24:
							case _MODE_1080P25:
								ch1_line_cnt_lower = MODE_1080P24_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_1080P24_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_1080P29:
							case _MODE_1080P30:
								//[KTASK-3997]Modify 1080p30Hz line count setting for 60Hz panel @Crixus 20160527
								if((Get_DISPLAY_REFRESH_RATE() == 60) && (Get_DISPLAY_PANEL_CUSTOM_INDEX() == VBY_ONE_PANEL_LG_4K2K_600M_1S_8L)){
									ch1_line_cnt_lower = MODE_1080P30_FRAME_DELAY_LOWER_BOUNDARY_60HZ_PANEL;
									ch1_line_cnt_upper = MODE_1080P30_FRAME_DELAY_UPPER_BOUNDARY_60HZ_PANEL;
								}
								else{
									ch1_line_cnt_lower = MODE_1080P30_FRAME_DELAY_LOWER_BOUNDARY;
									ch1_line_cnt_upper = MODE_1080P30_FRAME_DELAY_UPPER_BOUNDARY;
								}
								break;
							case _MODE_4k2kP24:
								ch1_line_cnt_lower = MODE_4K2K24_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_4K2K24_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_4k2kP25:
								ch1_line_cnt_lower = MODE_4K2K24_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_4K2K24_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_4k2kP30:
								ch1_line_cnt_lower = MODE_4K2K30_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_4K2K30_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_4k2kP50:
								ch1_line_cnt_lower = MODE_4K2K50_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_4K2K50_FRAME_DELAY_UPPER_BOUNDARY;
								break;
							case _MODE_4k2kP60:
								ch1_line_cnt_lower = MODE_4K2K60_FRAME_DELAY_LOWER_BOUNDARY;
								ch1_line_cnt_upper = MODE_4K2K60_FRAME_DELAY_UPPER_BOUNDARY;
								break;

							default:
								ch1_line_cnt_lower = 0;
								ch1_line_cnt_upper = (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_LEN) * 1 / 4);
							break;
						}
						//rtd_printk(KERN_EMERG, TAG_NAME_VSC,"\n SLR_INPUT_MODE_CURR = %d\n", Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR));
						//rtd_printk(KERN_EMERG, TAG_NAME_VSC,"\n ch1_line_cnt_lower = %d, ch1_line_cnt_upper = %d\n", ch1_line_cnt_lower, ch1_line_cnt_upper);
					}
					if(b_run_frame_check == 1){
						dtg_frame_cnt1_reg.regValue = IoReg_Read32(PPOVERLAY_DTG_FRAME_CNT1_reg);
						if(dtg_frame_cnt1_reg.uzudtg_input_frame_cnt == (frame_idicator-1)){
							dtg_frame_cnt1_reg.regValue = IoReg_Read32(PPOVERLAY_DTG_FRAME_CNT1_reg);
							//make sure that we can have a full porch apply timing change settings
							while((dtg_frame_cnt1_reg.uzudtg_input_frame_cnt != frame_idicator)&& --count2){
								dtg_frame_cnt1_reg.regValue = IoReg_Read32(PPOVERLAY_DTG_FRAME_CNT1_reg);
							}
							vgip_chn1_lc_reg.regValue = IoReg_Read32(VGIP_VGIP_CHN1_LC_reg);
							if((vgip_chn1_lc_reg.ch1_line_cnt >= ch1_line_cnt_lower) && (vgip_chn1_lc_reg.ch1_line_cnt <= ch1_line_cnt_upper)){
								//change to FLL
								rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "### set fll new mode 1.###\n");
								framesync_lastlinefinetune_at_new_mode();
								modestate_set_display_timing(0);
								modestate_set_fll_running_flag(FALSE);
								checkStableCnt=0;
								if(inputType == KADP_VSC_INPUTSRC_HDMI){
									DbgSclrFlgTkr.line_cnt_no_run_hdmi_check = 0;
								}
								//rtd_printk(KERN_EMERG, TAG_NAME_VSC,"\n vgip_chn1_lc_reg.ch1_line_cnt = %d\n", vgip_chn1_lc_reg.ch1_line_cnt);
							}
							if(count2 == 0)
								rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "count timeout !!!\n");
						}
					}
					else{
						new_meas1_linecnt_real_reg.regValue = IoReg_Read32(PPOVERLAY_new_meas1_linecnt_real_reg);
						if(new_meas1_linecnt_real_reg.memcdtg_line_cnt_rt < 200){
							//change to FLL
							rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "### set fll new mode 2.###\n");
							framesync_lastlinefinetune_at_new_mode();
							modestate_set_display_timing(0);
							modestate_set_fll_running_flag(FALSE);
							checkStableCnt=0;
						}
					}
					up(&VSC_Semaphore);
				}
			}else{
				checkStableCnt++;
			}
		}else{

			if(vbe_disp_get_adaptivestream_fs_mode() == 1){
                drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
			}
			if(Get_DISPLAY_PANEL_OLED_TYPE()==TRUE){
				if((drv_memory_get_game_mode_dynamic() == _ENABLE)&&(drv_memory_get_game_mode() == TRUE)){
                    drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
				}
			}
			checkStableCnt = 0;
			//if source is table, change to false
			if(DbgSclrFlgTkr.line_cnt_no_run_hdmi_check == 1){
				DbgSclrFlgTkr.line_cnt_no_run_hdmi_check = 0;
			}
		}


		fix_last_line_mode_lock_status_reg.regValue = IoReg_Read32(PPOVERLAY_fix_last_line_mode_lock_status_reg);
		fix_last_line_mode_lock_status_reg.lock_th = 0x800;
		IoReg_Write32(PPOVERLAY_fix_last_line_mode_lock_status_reg, fix_last_line_mode_lock_status_reg.regValue);
#if 0//mark redundaent code
		display_timing_ctrl1_reg.regValue = IoReg_Read32(PPOVERLAY_Display_Timing_CTRL1_reg);
		if((display_timing_ctrl1_reg.disp_fix_last_line == 2) && (fix_last_line_mode_lock_status_reg.t_s != 0)){
			//double buffer D0
			ppoverlay_double_buffer_ctrl_RBUS double_buffer_ctrl_reg;
			double_buffer_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
			double_buffer_ctrl_reg.dreg_dbuf_en = 0;
			IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, double_buffer_ctrl_reg.regValue);

			display_timing_ctrl1_reg.disp_fix_last_line = 0;
			IoReg_Write32(PPOVERLAY_Display_Timing_CTRL1_reg, display_timing_ctrl1_reg.regValue);

			//double_buffer_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
			//double_buffer_ctrl_reg.dreg_dbuf_set = 1;
			//IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, double_buffer_ctrl_reg.regValue);

			//display_timing_ctrl1_reg.disp_fix_last_line = 2;
			//IoReg_Write32(PPOVERLAY_Display_Timing_CTRL1_reg, display_timing_ctrl1_reg.regValue);
			rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "FLL re-sync!!\n");
			modestate_set_fll_running_flag(TRUE);

			//double_buffer_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
			//double_buffer_ctrl_reg.dreg_dbuf_set = 1;
			//IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, double_buffer_ctrl_reg.regValue);
		}
#endif
	}else{
		checkStableCnt = 0;
	}
	up(get_scaler_fll_running_semaphore());
#endif

	//check abnormal dvs flag
	drvif_scaler_check_abnormal_dvs_flag();

	// check IVS over threshold error
	// RL6557-448 add ivs over threshold test function
	//drvif_scaler_check_ivs_over_threshold(TRUE);

	//check onlinemeasure flag
	if(Scaler_InputSrcGetMainChType() == _SRC_VO){
		drvif_scaler_check_main_onlinemeasure_flag();
	}

	if (inputType == KADP_VSC_INPUTSRC_JPEG || inputType == KADP_VSC_INPUTSRC_VDEC) {
		if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)//If get_vo_change_flag() == TRUE, VO info change
		{
#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)
		//	static unsigned int hdrCrcErrCnt = 0;
#endif
			plane = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_VODMA_PLANE);//Avoid to print port error
			down(get_vo_infosemaphore());
			if(get_vo_change_flag(inputPort) == TRUE)
			{
				up(get_vo_infosemaphore());
				if (Get_vo_smoothtoggle_timingchange_flag(display)) {
	               if(get_vo_run_smooth_toggle_enable(display)) {
#if 0
	                   if (get_vo_imd_disable(display)) {
	                       set_vo_change_flag(inputPort, FALSE);
	                       set_vo_imd_disable(_DISABLE,display);
						   inputVfreq = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_V_FREQ);
   	                       rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\n +++ adaptive stream before vfreq:%d\n", inputVfreq);
						   Scaler_SET_VSCDispinfo_WithVFEDispinfo(display, Get_VO_Dispinfo(inputPort));
   	                       rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\n +++ adaptive stream after vfreq:%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_V_FREQ));
						   if(inputVfreq!=Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_V_FREQ)){
							   scaler_disp_smooth_variable_setting();
						   }
	                       rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\n smooth toggle timing change don't need to go scaler\n");
	                       return TRUE;
	                   }
#endif
	               } else {
                       if (get_vo_smoothtoggle_state(display) == SLR_SMOOTH_TOGGLE_ACTIVE) {
                           //vo_force_data_mode_set_enable(vo_force_data_mode_get_enable(display), display);
                           set_vo_smoothtoggle_state(SLR_SMOOTH_TOGGLE_INIT, display,plane);
                           smooth_toggle_state_info_rpc(display);
                           rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "set_vo_smoothtoggle_state=SLR_SMOOTH_TOGGLE_INIT\n");
                       }
	               }
				}
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####check_signal vo change active to search####\r\n");

				if(display == SLR_MAIN_DISPLAY) {
					down(&SetMainOutPutRegion_Semaphore);
					reset_any_srcrect(&main_dispwin_pre); //Need to Reste previous output value. For run scaler flow
					up(&SetMainOutPutRegion_Semaphore);
				} else {
					down(&SetSubOutPutRegion_Semaphore);
					reset_any_srcrect(&sub_dispwin_pre); //Need to Reste previous output value. For run scaler flow
					up(&SetSubOutPutRegion_Semaphore);
				}
				Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);    //WOSQRTK-3464
				state_update_disp_info();

				return TRUE;
			} else {
				up(get_vo_infosemaphore());
			}

			/*livezoom openning and closing stop framsync check, or will have noise for scaler run another times*/
			if((Get_LivezoomOffMainRunScaler() == TRUE) || (Get_Live_zoom_mode()!=LIVE_ZOOM_OFF) || (Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_FRAMESYNC) == FALSE) || (drvif_framesync_detect()))//If Framesync case, we just check drvif_framesync_detect
			{
				down(get_vo_infosemaphore());
				if (get_vo_run_smooth_toggle_enable(display) && get_vo_imd_disable(display)) {
					set_vo_imd_disable(_DISABLE,display);
					inputVfreq = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_V_FREQ);
					input_isInterlace = Scaler_DispGetStatus(display,SLR_DISP_INTERLACE);
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\n +++ adaptive stream before vfreq:%d\n", inputVfreq);
					Scaler_SET_VSCDispinfo_WithVFEDispinfo(display, Get_VO_Dispinfo(inputPort));
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\n +++ adaptive stream after vfreq:%d\n", Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_V_FREQ));
					up(get_vo_infosemaphore());
					//add frame rate changing smooth toggle flow @Crixus 20151215
					if((get_vo_frameratechange_enable(display)==1) && (!vsc_get_adaptivestream_flag(display)) && (scaler_get_current_framesync_mode(display) ==0)){
						//before set DTG frame rate, it has to wait for smooth toggle done. @Crixus 20151215
						down(&SetMainOutPutRegion_Semaphore);
						Check_smooth_toggle_update_flag(display);
						scaler_disp_smooth_variable_settingByDisp(0);
						up(&SetMainOutPutRegion_Semaphore);
						set_frc_style_input_fast_than_display(FALSE);
					}
					drvif_scaler_wclr_abnormal_dvs_long_short();
					rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "\n timing:go smooth toggle\n");
				}
				else{
					up(get_vo_infosemaphore());
				}

				if(Get_vo_smoothtoggle_timingchange_flag(display))  //direct vo smooth toggle
				{
					if(get_vo_run_smooth_toggle_enable(display))  //direct_vo :curr display size changed  go smooth toggle
					{
					}
					else
					{
						if (get_reset_smooth_toggle_state(display)) {
							//vo_force_data_mode_set_enable(vo_force_data_mode_get_enable(display), display);
							smooth_toggle_state_info_rpc(display);
							set_reset_smooth_toggle_state(_DISABLE,display);
							rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "set_vo_smoothtoggle_state=SLR_SMOOTH_TOGGLE_ACTIVE\n");
						}
					}
				}
#ifdef ENABLE_IMD_PST_SMOOTHTOGGLE
				if((vsc_get_adaptivestream_flag(display)||scaler_vsc_get_force_pst_lowdelay_mode())&&(scaler_vsc_get_adaptive_pst_lowdelay_mode()==TRUE)&&(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC)){
					ppoverlay_memc_mux_ctrl_RBUS memc_mux_ctrl_reg;
					ppoverlay_uzudtg_fractional_fsync_RBUS uzudtg_fractional_fsync_reg;
                    pst_i2rnd_top_ctrl_RBUS   top_ctrl;
					top_ctrl.regValue = IoReg_Read32(PST_I2RND_TOP_CTRL_reg);
                    memc_mux_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_MEMC_MUX_CTRL_reg);
					if(memc_mux_ctrl_reg.memc_outmux_sel == 1){
						uzudtg_fractional_fsync_reg.regValue = IoReg_Read32(PPOVERLAY_uzudtg_fractional_fsync_reg);
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "[%s][line:%d] uzudtg_fractional_fsync_reg.regValue:%x\r\n", __FUNCTION__, __LINE__, uzudtg_fractional_fsync_reg.regValue);
						if((uzudtg_fractional_fsync_reg.uzudtg_multiple_vsync == 0) && (uzudtg_fractional_fsync_reg.uzudtg_remove_half_ivs_mode == 0)){
							rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "[%s][line:%d] Scaler_MEMC_Bypass_On\r\n", __FUNCTION__, __LINE__);
                            Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
                            Scaler_MEMC_Bypass_On(1);
						}
					}
				}
#endif
				return TRUE;
			}
			else
			{
				rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "####VO frame sync error!!!######\r\n");
				mute_control(display, TRUE);/*Auto BG. Add by Will*/

				down(get_vo_infosemaphore());
				if(get_vo_change_flag(inputPort) == TRUE)
				{
					up(get_vo_infosemaphore());
					if(display == SLR_MAIN_DISPLAY) {
						down(&SetMainOutPutRegion_Semaphore);
						reset_any_srcrect(&main_dispwin_pre); //Need to Reste previous output value. For run scaler flow
						up(&SetMainOutPutRegion_Semaphore);
					} else {
						down(&SetSubOutPutRegion_Semaphore);
						reset_any_srcrect(&sub_dispwin_pre); //Need to Reste previous output value. For run scaler flow
						up(&SetSubOutPutRegion_Semaphore);
					}
					Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
					state_update_disp_info();
					return TRUE;
				}
				Scaler_SET_VSCDispinfo_WithVFEDispinfo(display, Get_VO_Dispinfo(inputPort));
				if (get_vo_run_smooth_toggle_enable(display) && get_vo_imd_disable(display)) {
					set_vo_imd_disable(_DISABLE,display);
				}
				up(get_vo_infosemaphore());
				Check_smooth_toggle_update_flag(display);
				if(Get_vo_smoothtoggle_timingchange_flag(display))  //framesync fail need vo smooth toggle reset to init
				{
					set_vo_smoothtoggle_state(SLR_SMOOTH_TOGGLE_INIT, display,plane);
					smooth_toggle_state_info_rpc(display);
				}
			}
		}
		else//if(Scaler_DispGetInputInfo(SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
		{
					return TRUE;
		}
	} else {
		if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
			return TRUE;/* State is not _MODE_STATE_ACTIVE. No need to check signal*/

		//if HDMI source, not to run check mode until sync OK @Crixus 20151229
		//USER:LewisLee DATE:2016/02/21
		//for zhaodong_yin suggest
		//to fix HDR mode, Scaler_InputSrcGetType() will change to _SRC_VO
		//it need change to Get_DisplayMode_Src()
//		if((Scaler_InputSrcGetType(display) == _SRC_HDMI) && (DbgSclrFlgTkr.line_cnt_no_run_hdmi_check == 0)) {
		if((Get_DisplayMode_Src(display) == VSC_INPUTSRC_HDMI) && (DbgSclrFlgTkr.line_cnt_no_run_hdmi_check == 0)) {

			unsigned char hdmi_check_mode_err = 0;
			unsigned char cur_vrr_status = 0;
			unsigned char cur_freesync_status = 0;

			if(drvif_Hdmi_CheckMode() == FALSE)
				hdmi_check_mode_err = 1;
			else
			{
				cur_vrr_status = drvif_Hdmi_GetVRREnable();
				if(vbe_disp_get_VRR_timingMode_flag() != cur_vrr_status)
					hdmi_check_mode_err = 2;
				else
				{
					cur_freesync_status = drvif_Hdmi_GetAMDFreeSyncEnable();
					if(vbe_disp_get_freesync_mode_flag() != cur_freesync_status)
						hdmi_check_mode_err = 3;
				}
			}

			if(hdmi_check_mode_err)
			{
				set_display_forcebg_mask(display, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);//Enable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
				mute_control(display, TRUE);/*Auto BG*/
				if (Get_Live_zoom_mode() == LIVE_ZOOM_ON ) {
					mute_control(SLR_SUB_DISPLAY, TRUE);/*Auto BG*/
				}
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\n drvif_Hdmi_CheckMode ERROR\n");


				drvif_mode_onlinemeasure_setting(display, _SRC_HDMI, FALSE, FALSE);//Disable online measure watchdog and interrupt
                drvif_mode_disableonlinemeasure(display);//Disable online measure
                if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_STATE) == _MODE_STATE_SEARCH) {
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\n HDMI Interrupt already happen\n");
					return TRUE;
				}
				Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				if (display == SLR_MAIN_DISPLAY) {
					drivf_scaler_reset_freerun();
				}
				reset_hdmi_timing_ready();
 				vfe_hdmi_drv_handle_on_line_measure_error(0);
				down(get_hdmi_detectsemaphore());
				if (get_HDMI_Global_Status() == SRC_CONNECT_DONE) {
					Set_Reply_Zero_Timing_Flag(VSC_INPUTSRC_HDMI, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/
					HDMI_set_detect_flag(TRUE);
				}
				up(get_hdmi_detectsemaphore());

                if(hdmi_check_mode_err == 1)
				{
					rtd_printk(KERN_INFO, TAG_NAME_VSC, "\n Hdmi_CheckMode ERROR by drvif_Hdmi_CheckMode error\n");
				}
				else if(hdmi_check_mode_err == 2)
				{
					rtd_printk(KERN_INFO, TAG_NAME_VSC, "\n Hdmi_CheckMode ERROR by VRR (%d %d) change\n", vbe_disp_get_VRR_timingMode_flag(), cur_vrr_status);
				}
				else if(hdmi_check_mode_err == 3)
				{
					rtd_printk(KERN_INFO, TAG_NAME_VSC, "\n Hdmi_CheckMode ERROR by freesync (%d %d) change\n",vbe_disp_get_freesync_mode_flag(), cur_freesync_status);
				}
				return false;
			}
		}
		return TRUE; /* Not VO source no need to auto run scaler*/
	}
	down(&VSC_Semaphore);
	Scaler_SetCurrentDispInfo(display);
	result = rtk_run_scaler(display, inputType, outputMode); /*This is for VO frame sync error*/
	Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
	up(&VSC_Semaphore);
	return result;

}

static int GamemodeSaveI3ddmaGetcurMode;

int Get_GamemodeSaveI3ddmaGetcurMode(void)
{
	return GamemodeSaveI3ddmaGetcurMode;
}

void Set_GamemodeSaveI3ddmaGetcurMode(int value)
{
	GamemodeSaveI3ddmaGetcurMode = value;
}

unsigned char rtk_output_connect(unsigned char display)
{
	KADP_VSC_OUTPUT_MODE_T outputMode = KADP_VSC_OUTPUT_MAXN;
	KADP_VSC_INPUT_TYPE_T inputType = KADP_VSC_INPUTSRC_MAXN;
	unsigned char inputPort = 0;
	unsigned char result;
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
	unsigned short mode_id;
#endif
	if(get_scaler_stop_flag(display) == TRUE)
		  return FALSE;


	//printk(KERN_EMERG"[crixus]@@@@@[%s][%d]\n", __FUNCTION__, __LINE__);
#ifdef CONFIG_I2RND_ENABLE
	if((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC) &&(vsc_i2rnd_sub_output_mode ==KADP_VSC_OUTPUT_VENC_MODE)){
		//save sub info
		VencModeInputInfo.type = vsc_i2rnd_sub_input_type;
		VencModeInputInfo.resourceIndex = vsc_i2rnd_sub_input_port;
	}

#endif
	if (display == SLR_MAIN_DISPLAY) {
#ifdef CONFIG_I2RND_ENABLE
		if(!(Scaler_I2rnd_get_timing_enable() && ((vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC) || (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1))))
#endif
		{
			if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			{
				outputMode = KADP_VSC_OUTPUT_DISPLAY_MODE;
				inputType = DisplayModeInputInfo.type;
				inputPort = DisplayModeInputInfo.resourceIndex;
			}
			else if(VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			{
				outputMode = KADP_VSC_OUTPUT_VENC_MODE;
				inputType = VencModeInputInfo.type;
				inputPort = VencModeInputInfo.resourceIndex;
			}
			else if(MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
			{
				outputMode = KADP_VSC_OUTPUT_MEMORY_MODE;
				inputType = MemoryModeInputInfo.type;
				inputPort = MemoryModeInputInfo.resourceIndex;
			}
			else
			{
				return false;
			}
		}
		Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);

#ifdef CONFIG_I2RND_ENABLE
	if((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC) &&(vsc_i2rnd_sub_output_mode ==KADP_VSC_OUTPUT_VENC_MODE)){
			outputMode = KADP_VSC_OUTPUT_VENC_MODE;
			inputType = VencModeInputInfo.type;
			inputPort = VencModeInputInfo.resourceIndex;
			DbgSclrFlgTkr.OutputVencMode = TRUE;
	}
	else if((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE)
		&& ((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1) || (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC))){
		outputMode = KADP_VSC_OUTPUT_DISPLAY_MODE;
		inputType = Sub_DisplayModeInputInfo.type;
		inputPort = Sub_DisplayModeInputInfo.resourceIndex;

		printk(KERN_EMERG"[crixus][PIP]Sub_DisplayModeInputInfo.resourceIndex = %d\n", Sub_DisplayModeInputInfo.resourceIndex);
	}
	else{
#endif
		if (DbgSclrFlgTkr.main_opensourceID == _UNKNOWN_INPUT) {
			if (init_source_proc(SLR_MAIN_DISPLAY, inputType, inputPort) == FALSE) {
				rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "\r\n######init_source_proc fail fail#####\r\n");
				DbgSclrFlgTkr.main_opensourceID = _UNKNOWN_INPUT;
				return false;
			}
		}
#ifdef CONFIG_I2RND_ENABLE
		}
#endif
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if (display == SLR_SUB_DISPLAY){
		if(Sub_DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_DISPLAY_MODE;
			inputType = Sub_DisplayModeInputInfo.type;
			inputPort = Sub_DisplayModeInputInfo.resourceIndex;
		}
		else if(Sub_VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_VENC_MODE;
			inputType = Sub_VencModeInputInfo.type;
			inputPort = Sub_VencModeInputInfo.resourceIndex;
		}
		else if(Sub_MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
		{
			outputMode = KADP_VSC_OUTPUT_MEMORY_MODE;
			inputType = Sub_MemoryModeInputInfo.type;
			inputPort = Sub_MemoryModeInputInfo.resourceIndex;
		}
		else
		{
			return false;
		}

		Scaler_SetCurrentDispInfo(SLR_SUB_DISPLAY);
		if (DbgSclrFlgTkr.sub_opensourceID == _UNKNOWN_INPUT) {
			if (init_source_proc(SLR_SUB_DISPLAY, inputType, inputPort) == FALSE) {
				rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "\r\n######init_source_proc fail fail#####\r\n");
				DbgSclrFlgTkr.sub_opensourceID = _UNKNOWN_INPUT;
				return false;
			}
		}
	}
#endif
#ifdef CONFIG_FORCE_RUN_I3DDMA
	if((inputType == KADP_VSC_INPUTSRC_JPEG || inputType == KADP_VSC_INPUTSRC_VDEC || get_line_alternative_3d_mode_enable() == TRUE
		#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
		|| Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT
		#endif
		|| (get_force_i3ddma_enable(display) == true)
#ifdef CONFIG_I2RND_ENABLE
		|| ((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC))//VO source
#endif
		) && !((display == SLR_MAIN_DISPLAY) && (get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1)))
#else
	if(inputType == KADP_VSC_INPUTSRC_JPEG || inputType == KADP_VSC_INPUTSRC_VDEC || get_line_alternative_3d_mode_enable() == TRUE
		#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
		|| Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT
		#endif
		)//VO source
#endif
	{
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
		if((inputType == KADP_VSC_INPUTSRC_AVD) && (display == SLR_MAIN_DISPLAY))
		{
			mode_id = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_CURR);

		}
#endif
		down(get_vo_infosemaphore());
#ifdef CONFIG_FORCE_RUN_I3DDMA
		if(get_line_alternative_3d_mode_enable() == TRUE
			#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
			|| Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT
			#endif
			|| get_force_i3ddma_enable(display) == true
#ifdef CONFIG_I2RND_ENABLE
			|| ((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC) && (vsc_i2rnd_sub_output_mode == KADP_VSC_OUTPUT_DISPLAY_MODE))
#endif
			)
#else
		if(get_line_alternative_3d_mode_enable() == TRUE
			#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
			|| Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT
			#endif
			)
#endif
		{
#ifdef CONFIG_HDR_SDR_SEAMLESS
			if((display == SLR_MAIN_DISPLAY) && (inputType != KADP_VSC_INPUTSRC_VDEC) && (inputType != KADP_VSC_INPUTSRC_JPEG))
#endif

			inputPort = 0; //hdmi hdr always set vo port0:
		}
#ifdef CONFIG_I2RND_ENABLE
		if((display == SLR_MAIN_DISPLAY) && (Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_output_mode == KADP_VSC_OUTPUT_DISPLAY_MODE)
			&& ((vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC) ||(vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1))
		){
			inputPort = Sub_DisplayModeInputInfo.resourceIndex;; //pip sub use planeV2
			printk(KERN_EMERG"[crixus]sub re-run main scaler, need to use sub inputPort = %d\n", inputPort);
		}
#endif

		set_vo_change_flag(inputPort, FALSE);
	#if 0
		if(get_vo_3d_mode() == VO_3D_SIDE_BY_SIDE_HALF || get_vo_3d_mode() == VO_3D_TOP_AND_BOTTOM || get_vo_3d_mode() == VO_3D_FRAME_PACKING)
		{
			drvif_scalerdisplay_force_bg((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY), 1);//enable force BG for vo 3d auto detect
		}
	#endif
		if (((Get_Live_zoom_mode() == LIVE_ZOOM_ON)||Get_sub_from_DI_mux_path()) && (display == SLR_SUB_DISPLAY)) {
			//tmp code
			Scaler_SET_VSCSubDispinfo_Withmain();
		} else {
			Scaler_SET_VSCDispinfo_WithVFEDispinfo(display, Get_VO_Dispinfo(inputPort));
		}
		up(get_vo_infosemaphore());

		if((get_hdmi_4k_hfr_mode() == HDMI_4K120_2_0) && (display == SLR_MAIN_DISPLAY))
		{
			//Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_LEN_PRE, Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_LEN_PRE) >> 1);
		}
		if (vsc_timinginfo_check() == FALSE) {
			rtd_printk(KERN_ERR, TAG_NAME_VSC, "\n####VO info is zero####\n");
			if (display == SLR_MAIN_DISPLAY) {
				down(&SetMainOutPutRegion_Semaphore);
				reset_any_srcrect(&main_dispwin_pre);
				up(&SetMainOutPutRegion_Semaphore);
				DbgSclrFlgTkr.Main_during_scalerflow_flag = FALSE;//WOSQRTK-7524 patch. Reset Main_during_scalerflag
			} else {
				down(&SetSubOutPutRegion_Semaphore);
				reset_any_srcrect(&sub_dispwin_pre);
				up(&SetSubOutPutRegion_Semaphore);
			}
			return FALSE;
		}
		if(inputType == KADP_VSC_INPUTSRC_VDEC)
		{
			Check_smooth_toggle_update_flag(display);
		}

#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
		if((inputType == KADP_VSC_INPUTSRC_AVD) && (display == SLR_MAIN_DISPLAY))
			Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_MODE_CURR, mode_id);

#endif
	}
	else
	{

	}
	vbe_disp_set_pre_VRR_ALLM_flag(0);	//reset pre vrr allm flag
#ifdef CONFIG_I2RND_ENABLE
	//Update sub source i2r condition @Crixus 20170928
	if(Get_Live_zoom_mode() == LIVE_ZOOM_OFF){
		if(inputType == KADP_VSC_INPUTSRC_VDEC){
			//first time or sub scaler re-run, need to check condition
			//Eric@20170315 only sub display mode go i2rnd flow
			if((display == SLR_SUB_DISPLAY) && ((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_SUB_DISABLE) || (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FINISH))){
				vsc_i2rnd_dualvo_sub_stage = I2RND_DUALVO_STAGE_SUB_CONNECT;
				//save sub info
				vsc_i2rnd_sub_output_mode= outputMode;
				vsc_i2rnd_sub_input_type = inputType;
				vsc_i2rnd_sub_input_port = Sub_MemoryModeInputInfo.resourceIndex;
				rtd_printk(KERN_EMERG, TAG_NAME_VSC, "[I2RND]@@@@@@@@@@@@I2RND_DUALVO_STAGE_SUB_CONNECT@@@@@@@@@@\n");
			}
		}
		else{
			//i2rnd sub=>vodma checking @Crixus 2160721
			//Eric@20180315 if sub venc mode , do not go i2rnd flow
			if((display == SLR_SUB_DISPLAY) && (DbgSclrFlgTkr.Sub_OutputVencMode == FALSE) && ((vsc_i2rnd_sub_stage == I2RND_STAGE_DISABLE) || (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_I2RND_FINISH))){
				vsc_i2rnd_sub_stage = I2RND_STAGE_DETECT_SOURCE;
				//save sub info
				vsc_i2rnd_sub_output_mode= outputMode;
				vsc_i2rnd_sub_input_type = inputType;
				vsc_i2rnd_sub_input_port = Sub_MemoryModeInputInfo.resourceIndex;
				printk(KERN_EMERG"[I2RND]@@@@@@@@@@@@I2RND_STAGE_DETECT_SOURCE\n");
			}
		}
	}

	//I2run case, check sub over 2k1k do not run i2run @Crixus 20170906
	if(display == SLR_SUB_DISPLAY)
		Scaler_I2rnd_condition_check(DbgSclrFlgTkr.OuputDisplayMode, Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE) , Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE));
	printk(KERN_EMERG"[frank]rtk_output_connect %d,%d,%d\n",display,inputType,outputMode);
#endif

#ifdef CONFIG_I2RND_B05_ENABLE
	if((Scaler_I2rnd_b05_get_enable() == _ENABLE) && (inputType == KADP_VSC_INPUTSRC_VDEC)){
		if(display == SLR_MAIN_DISPLAY)
			drvif_scaler_i2rnd_b05_vodma_setting(SLR_MAIN_DISPLAY);
	}
#endif

	//reset film parameter
	film_mode_parameter.enable = 0;
	film_mode_parameter.type= 0;
	film_mode_parameter.v_freq = 0;
	ori_voclk_ratio_num = 0;

	result = rtk_run_scaler(display, inputType, outputMode);
	if (result == TRUE)/*checking vsc freeze flag*/
	{
		if (display == SLR_MAIN_DISPLAY) {
			if (DbgSclrFlgTkr.mainVscFreezeFlag) {

				rtd_printk(KERN_EMERG, TAG_NAME_VSC, "\r\n####func:%s line:%d####\r\n", __FUNCTION__, __LINE__);
				Scaler_SetFreeze(SLR_MAIN_DISPLAY, DbgSclrFlgTkr.mainVscFreezeFlag);
			}
		}
		if (display == SLR_SUB_DISPLAY) {
			if (DbgSclrFlgTkr.subVscFreezeFlag) {
				Scaler_SetFreeze(SLR_SUB_DISPLAY, DbgSclrFlgTkr.subVscFreezeFlag);
			}
		}
	}

	return result;

}

void scaler_i2rnd_run_main(void){
	//printk(KERN_EMERG"[crixus]@@@@@[%s][%d]\n", __FUNCTION__, __LINE__);
	rtk_output_connect(SLR_MAIN_DISPLAY); // different format to go normal scaler
}

extern unsigned char g_ucCurColorStd;
extern unsigned char Scaler_AVD_GetDetectStage(void);
extern unsigned char g_ucColorOK;

void wait_buffer_ready_after_SetupIMD(unsigned char num)
{//this api is for wait buffer ready after Setup_IMD
//num:How many frames to wait for
	unsigned int cur_counter;
	unsigned int need_time, vfreq;
	unsigned char timeout = 10;

	if(num != 0)
	{
		vfreq = Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ);

		if(vfreq)
			need_time = 900000 * num / vfreq;
		else
		{
			rtd_printk(KERN_INFO, TAG_NAME_VSC,"#####[%s(%d)] err frame rate zero####\r\n", __FUNCTION__,__LINE__);
			return;
		}
		while(timeout)
		{
			cur_counter = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
			if(cur_counter < record_Setup_IMD_timer_counter)
			{
				if((cur_counter + (0xFFFFFFFF - record_Setup_IMD_timer_counter)) >= need_time)
					break;

			}
			else if ((cur_counter - record_Setup_IMD_timer_counter) >= need_time)
				break;
			msleep(10);
			timeout --;
		}

		rtd_printk(KERN_INFO, TAG_NAME_VSC,"###[%s(%d)] ori:%d needwait num:%d time:%d cur_counter=%d timeout=%d#####\r\n", __FUNCTION__, __LINE__,record_Setup_IMD_timer_counter, num, need_time,cur_counter,timeout);
		if(!timeout)
			rtd_printk(KERN_INFO, TAG_NAME_VSC,"###[%s(%d)] err wait timeout#####\r\n", __FUNCTION__, __LINE__);
	}
}

unsigned char wait_atv_stable_for_bg(unsigned char display,char const* pfunc,unsigned int line)
{
	UINT8 ucVdReady = 0;
	unsigned short Timeout = 0;
	unsigned short Channel_Ch_Timeout = 0;
	unsigned char *p_stop_flag = &DbgSclrFlgTkr.Main_Scaler_Stop_flag;
	unsigned char *p_output_set_flag = &DbgSclrFlgTkr.Main_Output_Set_flag;
	unsigned char *p_run_scaler_flag = &DbgSclrFlgTkr.Main_Run_Scaler_flag;
	if(display == SLR_MAIN_DISPLAY) {
		p_stop_flag = &DbgSclrFlgTkr.Main_Scaler_Stop_flag;
		p_output_set_flag = &DbgSclrFlgTkr.Main_Output_Set_flag;
		p_run_scaler_flag = &DbgSclrFlgTkr.Main_Run_Scaler_flag;
	}
#ifdef CONFIG_DUAL_CHANNEL
	else
	{
		p_stop_flag = &DbgSclrFlgTkr.Sub_Scaler_Stop_flag;
		p_output_set_flag = &DbgSclrFlgTkr.Sub_Output_Set_flag;
		p_run_scaler_flag = &DbgSclrFlgTkr.Sub_Run_Scaler_flag;
	}
#endif
	rtd_printk(KERN_INFO, TAG_NAME_VSC, "[%s(%d)] call %s start!!! \n",pfunc,line,__FUNCTION__);
	down(get_avd_power_semaphore());
	if(get_AVD_Global_Status() == SRC_CONNECT_DONE)
	{
		ucVdReady = drvif_module_vdc_OutputStable();
	}
	up(get_avd_power_semaphore());

	rtd_printk(KERN_INFO, TAG_NAME_VSC, "[%s(%d)]vdc_LockStatus=%d,ucVdReady=%d, vstate=%d\n",__FUNCTION__, __LINE__,vdc_LockStatus,ucVdReady,drvif_module_vdc_Read_Vstate());

	if (vdc_LockStatus)
	{
		//extern UINT8 dma_3d_ON_count;
		//dma_3d_ON_count = 0;	//init
#if 0
		if(get_AVD_Input_Source() == _SRC_TV){
			while(Scaler_AVD_GetIsChannelChange()){
				msleep(10);
				Channel_Ch_Timeout++;
				if ((Channel_Ch_Timeout >= 30)||
					(Scaler_AVD_GetIsChannelChange()== FALSE)) {
					rtd_printk(KERN_INFO, TAG_NAME_VSC, "vdc_LockStatus=%d, Channel_Ch_Timeout=%d, IsChannelChange=%d [%s(line:%d)]\n",vdc_LockStatus, Channel_Ch_Timeout, Scaler_AVD_GetIsChannelChange(), __FUNCTION__, __LINE__);
					break;
				}
			}
		}
#endif
		while (ucVdReady == FALSE)
		{
			//VDC_DEBUG_MSG(VDC_MSG_TVCHCH, "[1]V_state timeout = %d\n",Timeout);
			msleep(10);
			if(*p_stop_flag || *p_output_set_flag || *p_run_scaler_flag){
				rtd_printk(KERN_INFO, TAG_NAME_VSC, "#####[%s(%d)] p_stop_flag=%d, p_output_set_flag=%d, p_run_scaler_flag=%d\n",__FUNCTION__,__LINE__,*p_stop_flag,*p_output_set_flag,*p_run_scaler_flag);
				return FALSE;
			}
			//Timeout++;
			if (Timeout++ >= 100) {
				rtd_printk(KERN_INFO, TAG_NAME_VSC, "[VSC]V_state timeout\n");
				drvif_module_vdc_set_vstate_new2to3_en(_ENABLE);		/* vstate != 3, set */
				VDC_DEBUG_MSG(VDC_MSG_TVCHCH, "[VSC]V_state timeout\n");
				//return FALSE;
				break;  //modify for [KTASKWBS-7166],if vdpq_dma_ctrl4_reg.dma_3d_on_off is always 0, no need keep mute
			}

			down(get_avd_power_semaphore());
			if(get_AVD_Global_Status() == SRC_CONNECT_DONE){
				ucVdReady = drvif_module_vdc_OutputStable();
				rtd_printk(KERN_INFO, TAG_NAME_VSC, "[%s(%d)](Timeout=%d)ucVdReady=%d,vstate=%d,0xb80192d8=0x%08x\n",__FUNCTION__, __LINE__,Timeout,ucVdReady,drvif_module_vdc_Read_Vstate(),IoReg_Read32(VDTOP_VSTATELOCK_TIME_POLLING_reg));
			}
			up(get_avd_power_semaphore());
		}
	}else{
		if(0 == drvif_video_status_reg(VDC_no_signal))
			return FALSE;
	}

	rtd_printk(KERN_INFO, TAG_NAME_VSC, "vdc_LockStatus=%x, ucVdReady=%x, Timeout=%d, Channel_Ch_Timeout=%d [%s(line:%d)]\n",vdc_LockStatus, ucVdReady, Timeout, Channel_Ch_Timeout, __FUNCTION__, __LINE__);
//	VDC_DEBUG_MSG(VDC_MSG_TVCHCH, "vdc_LockStatus=%x, ucVdReady=%x, count=%d wait_atv_stable_for_bg\n",vdc_LockStatus, ucVdReady, Timeout);
#ifdef _PRINT_AVD_COST_TIME
	rtd_printk(KERN_INFO, TAG_NAME_VSC,"_PRINT_AVD_COST_TIME: %s(%d) time = %d\n",__FUNCTION__,__LINE__,IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90);
#endif

	drvif_module_vdc_new_vdetect_Enable(New_vedetect);
	drvif_module_vdc_set_vstate_speedup(vstate_count_default);
	//Check if there are three frames after Setup_IMD to here
	wait_buffer_ready_after_SetupIMD(3);//For KTASKWBS-9770 AV DC off/on judder
	if(*p_stop_flag || *p_output_set_flag || *p_run_scaler_flag){
		rtd_printk(KERN_INFO, TAG_NAME_VSC, "#####[%s(%d)] p_stop_flag=%d, p_output_set_flag=%d, p_run_scaler_flag=%d\n",__FUNCTION__,__LINE__,*p_stop_flag,*p_output_set_flag,*p_run_scaler_flag);
		return FALSE;
	}else{
		rtd_printk(KERN_INFO, TAG_NAME_VSC, "#####[%s(%d)] p_stop_flag=%d, p_output_set_flag=%d, p_run_scaler_flag=%d\n",__FUNCTION__,__LINE__,*p_stop_flag,*p_output_set_flag,*p_run_scaler_flag);
		return TRUE;
	}
}

unsigned char check_atv_stable_for_bg(unsigned char display)
{
	UINT8 ucVdReady = 0;
	unsigned short Timeout = check_atv_stable_count;

	down(get_avd_power_semaphore());
	if(get_AVD_Global_Status() == SRC_CONNECT_DONE)
	{
		ucVdReady = drvif_module_vdc_OutputStable();
	}
	up(get_avd_power_semaphore());
	rtd_printk(KERN_INFO, TAG_NAME_VSC, "vdc_LockStatus=%x, ucVdReady=%x, count=%d [%s(line:%d)]\n",vdc_LockStatus, ucVdReady, Timeout, __FUNCTION__, __LINE__);

	if (vdc_LockStatus)
	{
		extern UINT8 dma_3d_ON_count;
		dma_3d_ON_count = 0;	//init
		if (ucVdReady == FALSE)
		{

			Timeout++;
			if (Timeout >= 20) {
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "[VSC]V_state timeout\n");
				drvif_module_vdc_set_vstate_new2to3_en(_ENABLE);		/* vstate != 3, set */
				VDC_DEBUG_MSG(VDC_MSG_TVCHCH_DETAIL, "[VSC]V_state timeout\n");
				return FALSE;
			}
			check_atv_stable_count = Timeout;
			drvif_module_vdc_new_vdetect_Enable(New_vedetect);
			drvif_module_vdc_set_vstate_speedup(vstate_count_default);
			return FALSE;

		}else{

			return TRUE;
		}
	}else{
		if(0 == drvif_video_status_reg(VDC_no_signal))
			return FALSE;
	}
	return FALSE;

}

//Calc the count of SetWinBlank=0 durning ATV Channel change
void	CalcWinBlankCountForATVChanlChg(unsigned char channel, bool bonoff)
{
	//rtd_printk(KERN_INFO, TAG_NAME_VSC, "file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);

	// VSC is connectd to AVD
	if (!bonoff && (VSC_INPUTSRC_AVD == Get_DisplayMode_Src(channel))
		&& (get_AVD_Input_Source() == _SRC_TV))
	{
		if (TRUE == DbgSclrFlgTkr.g_ucVSCCheckATVChanelChange)
		{
			DbgSclrFlgTkr.g_ucVDCDetectStage = Scaler_AVD_GetDetectStage();

			DbgSclrFlgTkr.g_ucVSCCheckATVChanelChange = FALSE;
			DbgSclrFlgTkr.g_ucVSCATVChanelChangeStart = TRUE;

			rtd_printk(KERN_INFO, TAG_NAME_VSC, "reset DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount=0\n");
		}


		if (TRUE == DbgSclrFlgTkr.g_ucVSCATVChanelChangeStart)
		{
			DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount++;
			rtd_printk(KERN_INFO, TAG_NAME_VSC, "DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount=%d\n", DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount);
		}
	}
}


unsigned char rtk_hal_vsc_SetWinBlank(VIDEO_WID_T wid, bool bonoff, KADP_VIDEO_DDI_WIN_COLOR_T color)
{
	SCALER_DISP_CHANNEL channel;

	rtd_printk(KERN_INFO, TAG_NAME_VSC, "#####[%s(%d)] wid:%d, enable=%d\n",__func__,__LINE__, wid, bonoff);

#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN) || (wid > VIDEO_WID_MAX))
	{
		rtd_printk(KERN_INFO, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid != VIDEO_WID_0)
	{
		rtd_printk(KERN_INFO, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	}
#endif

	if((color > KADP_VIDEO_DDI_WIN_COLOR_COLOR_RGB_API) || (color < KADP_VIDEO_DDI_WIN_COLOR_BLACK))
		return FALSE;

	if (wid == VIDEO_WID_0) {
		channel = SLR_MAIN_DISPLAY;
	} else if (wid == VIDEO_WID_1) {
		channel = SLR_SUB_DISPLAY;
	}

	if(OutpuLocalDimmingPatMode == TRUE){
        if(bonoff)
            set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, TRUE);
        else
            set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
		return TRUE;
	}

	if(bonoff)
		set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, TRUE);
	//Calc the count of SetWinBlank=0 durning ATV Channel change
	CalcWinBlankCountForATVChanlChg(channel, bonoff);
#if 0
	if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD)&&(get_AVD_Input_Source() == _SRC_TV)){//For KTASKWBS-5200
		check_atv_stable_count =0;
		if (!bonoff && Scaler_AVD_GetIsChannelChange()&& (Scaler_AVD_GetDemodType()==KADP_AVD_EXTERNAL_DEMOD)
			&&(DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount ==1)
			&& 0 == drvif_video_status_reg(VDC_no_signal)){
			set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
			rtd_printk(KERN_INFO, TAG_NAME_VSC,"######[%s(line:%d)]external_ch_change_flag =1 don't run rtk_hal_vsc_SetWinBlank\n",__FUNCTION__, __LINE__);
			return TRUE;
		}

		if (!bonoff
#ifndef SPEEDUP_NEW_SCALER_FLOW//need to check
			&& (DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE)
#endif
			&&(Scaler_AVD_GetVDPreMode() == _MODE_UNKNOWN)
			&&(0 == drvif_video_status_reg(VDC_no_signal))
			&&(0 == drvif_video_status_reg(VDC_noisy))
			&&(DbgSclrFlgTkr.g_ucVSCATVSetWinBlankCount ==1)){
			set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
			rtd_printk(KERN_INFO, TAG_NAME_VSC,"######[%s(line:%d)]fast zapping, flicker garbage.#####\n",__FUNCTION__, __LINE__);
			return TRUE;

		}
	}
#endif
	if (bonoff) {
		if(channel == SLR_MAIN_DISPLAY) {
			DbgSclrFlgTkr.Main_ATV_Go_Smooth_Toggle_flag = FALSE;//ATV can not run smooth toggle
#ifdef CONFIG_DUAL_CHANNEL
		} else {
			DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag = FALSE;//ATV can not run smooth toggle
		}
#endif
		//frank@03102016 DOLBYCERT-144 store mode change playback file osd flash issue ++
		if ((channel == SLR_MAIN_DISPLAY) && Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_FRAMESYNC) &&(get_HDMI_HDR_mode() !=HDR_DOLBY_HDMI) && (get_HDMI_HDR_mode() !=HDR_HDR10_HDMI) &&(!vbe_disp_get_adaptivestream_fs_mode())){
			#ifndef CONFIG_FORCE_RUN_I3DDMA //not define
			drivf_scaler_reset_freerun();
			#endif
		}
		//if((Get_DISPLAY_PANEL_OLED_TYPE()==1)&& vsc_get_adaptivestream_flag() && (channel == SLR_MAIN_DISPLAY)){
		if(vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY) && (channel == SLR_MAIN_DISPLAY)&&(Check_AP_Set_Enable_ForceBG(channel) == FALSE)){
			Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
			rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "######### [%s]line:%d, enable wdg\n", __FUNCTION__, __LINE__);

			drvif_mode_onlinemeasure_setting(channel, _SRC_VO, TRUE, FALSE);
            drvif_mode_enableonlinemeasure(channel);//Enable online measure
		}
		//frank@03102016 DOLBYCERT-144 store mode change playback file osd flash issue --


		if(color == KADP_VIDEO_DDI_WIN_COLOR_BLACK)
		{
			drvif_scalerdisplay_set_bg_color(channel, _DISPLAY_BG, 0x0000, 0x0000, 0x0000);
		}
		else if(color == KADP_VIDEO_DDI_WIN_COLOR_BLUE)
		{
			drvif_scalerdisplay_set_bg_color(channel, _DISPLAY_BG, 0x0000, 0x0000, 0x3FFF);
		}
		else if(color == KADP_VIDEO_DDI_WIN_COLOR_GRAY)
		{
			drvif_scalerdisplay_set_bg_color(channel, _DISPLAY_BG, 0x2fff, 0x2fff, 0x2fff);
		}
		else if(color == KADP_VIDEO_DDI_WIN_COLOR_COLOR_RGB_API)
		{
			rtd_printk(KERN_INFO, TAG_NAME_VSC, "\r\n rtk_hal_vsc_SetWinBlank display:%d follow RGB color API\n", channel);
		}


		//set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, TRUE);

		if((channel == SLR_MAIN_DISPLAY) && TV006_WB_Pattern_En)	//WOSQRTK-7731
		{
			return TRUE;
		}

	} else {
		if(channel == SLR_MAIN_DISPLAY) {
			down(&SetMainOutPutRegion_Semaphore);
			if(DbgSclrFlgTkr.Main_Output_Set_flag) {
				DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;
				DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;
#ifdef _PRINT_VSC_COST_TIME_AFTER_MUTE_OFF
				cost_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
#endif

				set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
				up(&SetMainOutPutRegion_Semaphore);
				rtd_printk(KERN_INFO, TAG_NAME_VSC, "########func:%s request main scaler##########\r\n", __FUNCTION__);
				return TRUE;
			} else  if(DbgSclrFlgTkr.rotate_muteoff_request_flag) {

				set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
				DbgSclrFlgTkr.rotate_run_scaler_flag = TRUE;
				up(&SetMainOutPutRegion_Semaphore);
				rtd_printk(KERN_INFO, TAG_NAME_VSC, "########func:%s request main rotate##########\r\n", __FUNCTION__);
				return TRUE;
			} else if(DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag) {

				set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
				DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = TRUE;
				up(&SetMainOutPutRegion_Semaphore);
				rtd_printk(KERN_INFO, TAG_NAME_VSC, "########func:%s request main smooth toggle##########\r\n", __FUNCTION__);
				return TRUE;
			} else if(DbgSclrFlgTkr.Main_smooth_toggle_set_flag || DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off){//Rika
				set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
				up(&SetMainOutPutRegion_Semaphore);
				rtd_printk(KERN_INFO, TAG_NAME_VSC, "########func:%s smoothtoggle now##########\r\n", __FUNCTION__);
				return TRUE;
			}
			up(&SetMainOutPutRegion_Semaphore);
			if ((Get_Live_zoom_mode() == LIVE_ZOOM_ON) || (Get_LivezoomOffMainRunScaler() == TRUE)) {
				set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
			} else {
				if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
				{
					set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
					if(DbgSclrFlgTkr.Main_ATV_PassThrought_output_flag == TRUE){
						if((Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
							&& (drvif_module_vdc_OutputStable() || drvif_video_status_reg(VDC_no_signal) || drvif_module_vdc_read_scan_flag())){

							if(drvif_module_vdc_read_scan_flag() && Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY)){
								rtd_printk(KERN_INFO, TAG_NAME_VSC, "####[%s(%d)] disable arc mask\r\n",__func__, __LINE__);
								set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, FALSE);
							}

							rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"#####[%s(%d)]ATV signal stable to trigger_mute_off!\n", __func__, __LINE__);
							trigger_mute_off(SLR_MAIN_DISPLAY, 0);//trigger mute off. switch ratio case
						}
						rtd_printk(KERN_INFO, TAG_NAME_VSC, "########func:%s(%d) atv case##########\r\n", __FUNCTION__,__LINE__);
						return TRUE;
					}
				}
				if(Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE) {
					set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);

					rtd_printk(KERN_INFO, TAG_NAME_VSC, "########func:%s Main currently is not active can not disable BG##########\r\n", __FUNCTION__);
					return TRUE;
				}
				else if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) ==  VSC_INPUTSRC_VDEC) && DbgSclrFlgTkr.Main_during_scalerflow_flag)
				{
					set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
					rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "####func:%s Main during scaler flow so can not disable BG####\r\n", __FUNCTION__);
					return TRUE;
				}
			}
		} else {
			down(&SetSubOutPutRegion_Semaphore);
			if(DbgSclrFlgTkr.Sub_Output_Set_flag) {
				DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;
				DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;
				set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
				up(&SetSubOutPutRegion_Semaphore);
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n########func:%s request sub scaler##########\r\n", __FUNCTION__);
				return TRUE;
			}
			up(&SetSubOutPutRegion_Semaphore);
			if ((Get_Live_zoom_mode() == LIVE_ZOOM_ON) || (Get_LivezoomOffMainRunScaler() == TRUE)) {
				set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
			} else {
				if((Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
				{
					set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);

					rtd_printk(KERN_INFO, TAG_NAME_VSC, "########func:%s(%d) atv case##########\r\n", __FUNCTION__,__LINE__);
					return TRUE;
				}
				if(Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE) {
					set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);

					rtd_printk(KERN_INFO, TAG_NAME_VSC, "########func:%s Sub currently is not active can not disable BG##########\r\n", __FUNCTION__);
				}
			}
		}
		set_display_forcebg_mask(channel, SLR_FORCE_BG_TYPE_VSC, FALSE);
	}

	if ((Get_Live_zoom_mode() == LIVE_ZOOM_ON) || (Get_LivezoomOffMainRunScaler() == TRUE)) {
		/*livezoom and magnifier open forcebg no need check status*/
	} else {
		if((Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE) && !bonoff) {
			rtd_printk(KERN_INFO, TAG_NAME_VSC, "########func:%s line:%d signal not stable can not disable BG##########\r\n", __FUNCTION__, __LINE__);
			return TRUE;
		}
	}

	if(channel == SLR_MAIN_DISPLAY)
	{
		if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY))
		{
			mute_control(SLR_MAIN_DISPLAY, TRUE);
				//These are for mute on to wait memc already blck video
			if(sync_memc_ready && bonoff)//if TRUE. when mute on to wait memc buffer
			{
				wait_memc_ready();//wait memc buffer
			}

		}
		else
		{
			if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV)){
				if(drvif_module_vdc_OutputStable()){
					rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"#####[%s(%d)]ATV signal stable to trigger_mute_off!\n", __func__, __LINE__);
					trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off
				}else{
					rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"#####[%s(%d)]ATV signal not stable, can not mute off!\n", __func__, __LINE__);
				}
			}else{
				//int port = Get_DisplayMode_Port(channel);
				rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"#####[%s(%d)]trigger_mute_off\n", __func__, __LINE__);
				trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off

			}
		}
	}
#ifdef CONFIG_DUAL_CHANNEL
	else
	{
		if(bonoff)
		{
/*			down(&SetSubOutPutRegion_Semaphore);
			set_sub_mutewin(sub_dispwin);//notice mute on driver the sub window area
			up(&SetSubOutPutRegion_Semaphore);*/
		}

		if(Check_AP_Set_Enable_ForceBG(SLR_SUB_DISPLAY))
		{
			mute_control(SLR_SUB_DISPLAY, TRUE);
		}
		else
		{
			trigger_mute_off(SLR_SUB_DISPLAY, 1);//trigger mute off
		}
	}
#endif

#if 1
//	if (bonoff)
	if (bonoff && (Get_DisplayMode_Src(channel) == VSC_INPUTSRC_AVD) && (!get_sub_OutputVencMode()))
	{
		if (get_AVD_Input_Source() == _SRC_TV)
		{
#if 1  //ch_change_flag, 20151221
			vdc_resetTV_Count = 0x0;
#else
			if (drvif_module_vdc_read_Clamping_path() == 0)
			{
				vdc_exTV_chch = TRUE;
				vdc_resetTV_Count = 0x0;
				drvif_module_vdc_set_ch_change_flag(1);
			}/* mark internal ch change
			else {
				vdc_inTV_chch = TRUE;
				vdc_resetTV_Count = 0x0;
			}*/
#endif
		} else if (get_AVD_Input_Source() == _SRC_CVBS)
			vdc_AV_modech = TRUE;
	}
	else
	{
#if 0  //ch_change_flag, 20151221
		vdc_inTV_chch = FALSE;
		vdc_exTV_chch = FALSE;
#endif
		vdc_resetTV_Count = 0x0;
	}
#endif
	return TRUE;
}


unsigned char rtk_hal_vsc_GetInputRegion(KADP_VIDEO_WID_T wid, KADP_VIDEO_RECT_T * pinregion)
{
#ifdef CONFIG_DUAL_CHANNEL
	if((wid < KADP_VIDEO_WID_MIN)||(wid > KADP_VIDEO_WID_MAX))
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=KADP_VIDEO_WID_0)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	}
#endif

		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);

	if(wid ==KADP_VIDEO_WID_0) {
		if ((DbgSclrFlgTkr.OutputVencMode || DbgSclrFlgTkr.OutputMemoryMode || DbgSclrFlgTkr.OutputAveMode || DbgSclrFlgTkr.OuputDisplayMode)) {
			pinregion->x = main_input_size.srcx;
			pinregion->w = main_input_size.src_wid;
			pinregion->y = main_input_size.srcy;
			pinregion->h = main_input_size.src_height;
#ifdef CONFIG_SDNR_CROP
#ifdef CONFIG_I2RND_ENABLE
			if((Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)){
				pinregion->x = sub_input_size.srcx;
				pinregion->w = sub_input_size.src_wid;
				pinregion->y = sub_input_size.srcy;
				pinregion->h = sub_input_size.src_height;
			}
#endif
#endif
		} else {
			pinregion->x = 0;
			pinregion->y = 0;
			pinregion->w = 0;
			pinregion->h = 0;
		}
	} else if (wid ==KADP_VIDEO_WID_1) {
		if ((DbgSclrFlgTkr.Sub_OutputVencMode || DbgSclrFlgTkr.Sub_OutputMemoryMode || DbgSclrFlgTkr.Sub_OutputAveMode || DbgSclrFlgTkr.Sub_OuputDisplayMode)) {
			pinregion->x = sub_input_size.srcx;
			pinregion->w = sub_input_size.src_wid;
			pinregion->y = sub_input_size.srcy;
			pinregion->h = sub_input_size.src_height;
		} else {
			pinregion->x = 0;
			pinregion->y = 0;
			pinregion->w = 0;
			pinregion->h = 0;
		}

	}
	return TRUE;
}

#if(LiveZoom_PROFILE == 1)
unsigned int magnifierbefore_time = 0;
unsigned int magnifierafter_time = 0;
#endif

unsigned char check_only_xy_shift_case(unsigned char display, StructSrcRect *input, StructSrcRect *inputTiming, StructSrcRect *output);
void apply_only_xy_shift(unsigned char display, StructSrcRect input, StructSrcRect inputTiming, StructSrcRect output);
#ifdef CONFIG_FORCE_RUN_I3DDMA
unsigned char scaler_force_run_idma(unsigned char display, VSC_INPUT_TYPE_T inputSrctype);
#endif

unsigned char rtk_hal_vsc_SetInputRegion_ForAdaptive(VIDEO_WID_T wid, KADP_VIDEO_RECT_T  inregion)
{
	VSC_INPUT_TYPE_T srctype;


	if(wid == VIDEO_WID_0)
		srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
	else
		srctype = Get_DisplayMode_Src(SLR_SUB_DISPLAY);

	if((srctype == VSC_INPUTSRC_HDMI) && (wid == VIDEO_WID_0))
	{
		unsigned int input_w;

		input_w = Scaler_ModeGet_Hdmi_ModeInfo(SLR_MODE_IHWID);
		//input_w = Scaler_HDR10_Hdmi_Get_Input_ACT_WID_info();
		if(input_w > HDMI_WIDTH_THRESHOLD){
			rtd_printk(KERN_INFO, TAG_NAME_VSC, "\n input_w=%d \n",input_w);
			inregion.x = HDMI_WIDTH_THRESHOLD*inregion.x/input_w;
			inregion.w = HDMI_WIDTH_THRESHOLD*inregion.w/input_w;
		}
	}


	if(inregion.w%2)
		inregion.w -=1;

#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	}
#endif
	down(&Magnifier_Semaphore);

	rtd_printk(KERN_EMERG, TAG_NAME_VSC, "rtk_hal_vsc_SetInputRegion_ForAdaptive x=%d, y=%d, w=%d, h=%d\n", inregion.x, inregion.y, inregion.w, inregion.h);
	if ((inregion.w < 1) || (inregion.h < 1)) {
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####func:%s wid:%d input paramter is 0#####\r\n",__FUNCTION__, wid);
		//if ((wid == VIDEO_WID_0) && (Get_LivezoomOffMainRunScaler() == TRUE)) {
			//DbgSclrFlgTkr.LivezoomOffKeepMainForceBG = TRUE;
		//}
		if (wid == VIDEO_WID_0)
			main_InputRegion_0000 = 1;
		up(&Magnifier_Semaphore);
		return TRUE;
	}
	else
	{
		if (wid == VIDEO_WID_0)
			main_InputRegion_0000 = 0;
	}

	if(_DISP_WID && _DISP_LEN){
		if(inregion.w + inregion.x > _DISP_WID){
			inregion.x = 0;
			inregion.w = _DISP_WID;
			rtd_printk(KERN_EMERG, TAG_NAME_VSC, "rtk_hal_vsc_SetInputRegion_ForAdaptive wrong wid\n");
		}
		if(inregion.h + inregion.y > _DISP_LEN){
			inregion.y = 0;
			inregion.h = _DISP_LEN;
			rtd_printk(KERN_EMERG, TAG_NAME_VSC, "rtk_hal_vsc_SetInputRegion_ForAdaptive wrong len\n");
		}
	}

	if(wid == VIDEO_WID_0) {
		down(&SetMainOutPutRegion_Semaphore);
		srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);

		main_input_size.srcx = inregion.x;
		main_input_size.srcy = inregion.y;
		main_input_size.src_wid = inregion.w;
		main_input_size.src_height = inregion.h;

		Scaler_AdaptiveStream_InputWindowSet(main_input_size, wid);//for the first time, adpative stream timing change smooth toggle overscan size
		//Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_DISP_WIN);//add this to identify different input region
		setInputRegionType(wid, INPUT_BASE_ON_DISP_WIN);
		if ((srctype == VSC_INPUTSRC_AVD))
		{
			set_input_for_vgip(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
			set_input_for_crop(SLR_MAIN_DISPLAY, main_input_size);
			Scaler_InputRegionType_Set(SLR_MAIN_DISPLAY,getInputRegionType(SLR_MAIN_DISPLAY));
		}
		else
		{
			//zoom_imd_smooth_toggle_config(wid, inregion.x, inregion.y, inregion.w, inregion.h, ZOOM_CROP);
			if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) && (srctype == VSC_INPUTSRC_JPEG))
			{
				Scaler_InputRegionType_Set(wid,getInputRegionType(wid));
				if(check_only_xy_shift_case(SLR_MAIN_DISPLAY, &main_input_size_pre, &main_input_timing_pre, &main_dispwin_for_only_xy))
				{
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "apply_only_xy_shift...\n");
					apply_only_xy_shift(SLR_MAIN_DISPLAY, main_input_size, main_input_timing, main_dispwin_for_only_xy);
				}
				else {
					if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE){

						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####func:%s line:%d request run smooth toggle flow####\r\n", __FUNCTION__, __LINE__);
						DbgSclrFlgTkr.Main_smooth_toggle_set_flag = TRUE;
					} else {

						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####func:%s line:%d request mute off to run smooth toggle####\r\n", __FUNCTION__, __LINE__);
						DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = TRUE;
					}
				}
			}
		}
		up(&SetMainOutPutRegion_Semaphore);
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if(wid == VIDEO_WID_1) {
		down(&SetSubOutPutRegion_Semaphore);

		sub_input_size.srcx = inregion.x;
		sub_input_size.srcy = inregion.y;
		sub_input_size.src_wid = inregion.w;
		sub_input_size.src_height = inregion.h;

		setInputRegionType(wid, INPUT_BASE_ON_DISP_WIN);
		#if 0// for sub smooth toggle test
		zoom_imd_smooth_toggle_config(wid, inregion.x, inregion.y, inregion.w, inregion.h, ZOOM_CROP);
		#endif
		Scaler_AdaptiveStream_InputWindowSet(sub_input_size, wid);
		up(&SetSubOutPutRegion_Semaphore);
	}
#endif

	up(&Magnifier_Semaphore);

	return TRUE;
}

unsigned char rtk_hal_vsc_GetInputRegion_ForAdaptive(VIDEO_WID_T wid, VIDEO_RECT_T * poutregion)
{
#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN) || (wid > VIDEO_WID_MAX))
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	}
#endif

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);

	if(wid ==VIDEO_WID_0) {
		if ((DbgSclrFlgTkr.OutputVencMode || DbgSclrFlgTkr.OutputMemoryMode || DbgSclrFlgTkr.OutputAveMode || DbgSclrFlgTkr.OuputDisplayMode)) {
			poutregion->x = main_dispwin.srcx;
			poutregion->y = main_dispwin.srcy;
			poutregion->w = main_dispwin.src_wid;
			poutregion->h = main_dispwin.src_height;
		} else {
			poutregion->x = 0;
			poutregion->y = 0;
			poutregion->w = 0;
			poutregion->h = 0;
		}
	} else if (wid ==VIDEO_WID_1) {
		if ((DbgSclrFlgTkr.Sub_OutputVencMode || DbgSclrFlgTkr.Sub_OutputMemoryMode || DbgSclrFlgTkr.Sub_OutputAveMode || DbgSclrFlgTkr.Sub_OuputDisplayMode)) {
			poutregion->x = sub_dispwin.srcx;
			poutregion->y = sub_dispwin.srcy;
			poutregion->w = sub_dispwin.src_wid;
			poutregion->h = sub_dispwin.src_height;
		} else {
			poutregion->x = 0;
			poutregion->y = 0;
			poutregion->w = 0;
			poutregion->h = 0;
		}

	}

	return TRUE;

}
unsigned char rtk_hal_vsc_SetInputRegion(KADP_VIDEO_WID_T wid, KADP_VIDEO_RECT_T  inregion)
{
	VSC_INPUT_TYPE_T srctype;

#if(LiveZoom_PROFILE == 1)
	magnifierafter_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
	rtd_printk(KERN_EMERG, TAG_NAME_VSC, "\nVSC SetOutputRegion  end to next SetInputRegion star time=%d ms\n",(magnifierafter_time -magnifierbefore_time));
	magnifierbefore_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
#endif

	if(wid == KADP_VIDEO_WID_0)
    {
    	if(1)//Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
    	{
    		rtd_printk(KERN_INFO, TAG_NAME_VSC, "SetInputRegion main input(%d %d %d %d) \n", inregion.x, inregion.y, inregion.w, inregion.h);
    	}
    }
	else
	{
		if(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
    	{
    		rtd_printk(KERN_INFO, TAG_NAME_VSC, "SetInputRegion sub input(%d %d %d %d) \n", inregion.x, inregion.y, inregion.w, inregion.h);
    	}
	}

    if(wid == KADP_VIDEO_WID_0)
		srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
	else
		srctype = Get_DisplayMode_Src(SLR_SUB_DISPLAY);

	if((srctype == VSC_INPUTSRC_HDMI)&&(wid == KADP_VIDEO_WID_0))
	{
		unsigned int input_w;

		input_w = Scaler_ModeGet_Hdmi_ModeInfo(SLR_MODE_IHWID);
		//input_w = Scaler_HDR10_Hdmi_Get_Input_ACT_WID_info();
		if(input_w > HDMI_WIDTH_THRESHOLD){
			rtd_printk(KERN_INFO, TAG_NAME_VSC, "\n input_w=%d \n",input_w);
			inregion.x = HDMI_WIDTH_THRESHOLD*inregion.x/input_w;
			inregion.w = HDMI_WIDTH_THRESHOLD*inregion.w/input_w;
		}
	}

#ifdef FORCE_BYPASS_DI_RTNR
//Debug use. Interlace timing don't go rtnr and DI
	if(wid == KADP_VIDEO_WID_0)
	{
		inregion.h = inregion.h/2;
		inregion.y = inregion.y/2;
	}
#endif

	if(inregion.w%2)
		inregion.w -=1;

#ifdef CONFIG_DUAL_CHANNEL
	if((wid < KADP_VIDEO_WID_MIN)||(wid > KADP_VIDEO_WID_MAX))
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=KADP_VIDEO_WID_0)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	}
#endif
	down(&Magnifier_Semaphore);
#if 0
	if (srctype == VSC_INPUTSRC_AVD)
	{
#if 0 //ch_change_flag, 20151221
		vdc_inTV_chch = FALSE;
		vdc_exTV_chch = FALSE;
#endif
		if((get_AVD_Input_Source() == _SRC_TV) && (Scaler_AVD_GetIsChannelChange())&& (Scaler_AVD_GetDemodType()==KADP_AVD_EXTERNAL_DEMOD)){//For KTASKWBS-5200
			rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"external_ch_change_flag =1 don't clear exTV flag and count\n");
			up(&Magnifier_Semaphore);
			return TRUE;
		}else{
			//vdc_resetTV_Count = 0x0;
			//rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"clear exTV flag and count\n");
		}
	}
#endif
	if(inregion.x >4096) {
		 inregion.x=0;
	}
	if(inregion.w >4096) {
		 inregion.w=0;
	}
	if(inregion.h >4096) {
		 inregion.h=0;
	}
	if(inregion.y >4096) {
		 inregion.y=0;
	}
	//rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "rtk_hal_vsc_SetInputRegion x=%d, y=%d, w=%d, h=%d\n", inregion.x, inregion.y, inregion.w, inregion.h);
	if ((inregion.w < 1) || (inregion.h < 1)) {
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####func:%s wid:%d input paramter is 0#####\r\n",__FUNCTION__, wid);
		//if ((wid == VIDEO_WID_0) && (Get_LivezoomOffMainRunScaler() == TRUE)) {
			//DbgSclrFlgTkr.LivezoomOffKeepMainForceBG = TRUE;
		//}
		if (wid == KADP_VIDEO_WID_0)
			main_InputRegion_0000 = 1;
		up(&Magnifier_Semaphore);
		return TRUE;
	}
	else
	{
		if (wid == KADP_VIDEO_WID_0)
			main_InputRegion_0000 = 0;
	}

	if(wid == KADP_VIDEO_WID_0) {
		down(&SetMainOutPutRegion_Semaphore);
		srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);

		main_input_size.srcx = inregion.x;
		main_input_size.srcy = inregion.y;
		main_input_size.src_wid = inregion.w;
		main_input_size.src_height = inregion.h;
		//rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "rtk_hal_vsc_SetInputRegion x=%d, y=%d, w=%d, h=%d\n", inregion.x, inregion.y, inregion.w, inregion.h);

		Scaler_AdaptiveStream_InputWindowSet(main_input_size,wid);
		setInputRegionType(wid, INPUT_BASE_ON_TIMING);
		if ((srctype == VSC_INPUTSRC_AVD))
		{
			set_input_for_vgip(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
			set_input_for_crop(SLR_MAIN_DISPLAY, main_input_size);
			Scaler_InputRegionType_Set(SLR_MAIN_DISPLAY,getInputRegionType(SLR_MAIN_DISPLAY));

			inregion.x = Scaler_CalAVD27MWidth(SLR_MAIN_DISPLAY,inregion.x);
			inregion.w = Scaler_CalAVD27MWidth(SLR_MAIN_DISPLAY,inregion.w);

			//zoom_imd_smooth_toggle_config(wid, inregion.x, inregion.y, inregion.w, inregion.h, ZOOM_CROP);

		}
		else
		{
			//zoom_imd_smooth_toggle_config(wid, inregion.x, inregion.y, inregion.w, inregion.h, ZOOM_CROP);
			if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) && (srctype == VSC_INPUTSRC_JPEG))
			{
				Scaler_InputRegionType_Set(SLR_MAIN_DISPLAY,getInputRegionType(SLR_MAIN_DISPLAY));
				if(check_only_xy_shift_case(SLR_MAIN_DISPLAY, &main_input_size_pre, &main_input_timing_pre,&main_dispwin_for_only_xy))
				{
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "apply_only_xy_shift...\n");
					apply_only_xy_shift(SLR_MAIN_DISPLAY, main_input_size, main_input_timing, main_dispwin_for_only_xy);
				}
				else {
					if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE){

						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####func:%s line:%d request run smooth toggle flow####\r\n", __FUNCTION__, __LINE__);
						DbgSclrFlgTkr.Main_smooth_toggle_set_flag = TRUE;
					} else {

						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####func:%s line:%d request mute off to run smooth toggle####\r\n", __FUNCTION__, __LINE__);
						DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = TRUE;
					}
				}
			}
		}
		up(&SetMainOutPutRegion_Semaphore);
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if(wid == KADP_VIDEO_WID_1) {
		down(&SetSubOutPutRegion_Semaphore);

		sub_input_size.srcx = inregion.x;
		sub_input_size.srcy = inregion.y;
		sub_input_size.src_wid = inregion.w;
		sub_input_size.src_height = inregion.h;

		setInputRegionType(wid, INPUT_BASE_ON_TIMING);
		#if 0// for sub smooth toggle test
		zoom_imd_smooth_toggle_config(wid, inregion.x, inregion.y, inregion.w, inregion.h, ZOOM_CROP);
		#endif
		Scaler_AdaptiveStream_InputWindowSet(sub_input_size,wid);
		up(&SetSubOutPutRegion_Semaphore);
	}
#endif

	up(&Magnifier_Semaphore);

#if(LiveZoom_PROFILE == 1)
	magnifierafter_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
	rtd_printk(KERN_EMERG, TAG_NAME_VSC, "\nVSC rtk_hal_vsc_SetInputRegion time=%d ms\n",(magnifierafter_time -magnifierbefore_time));
#endif

	return TRUE;
}

unsigned char rtk_hal_vsc_GetOutputRegion(KADP_VIDEO_WID_T wid, KADP_VIDEO_RECT_T * poutregion)
{
#ifdef CONFIG_DUAL_CHANNEL
	if((wid < KADP_VIDEO_WID_MIN) || (wid > KADP_VIDEO_WID_MAX))
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=KADP_VIDEO_WID_0)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	}
#endif

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);

	if(wid ==KADP_VIDEO_WID_0) {
		if ((DbgSclrFlgTkr.OutputVencMode || DbgSclrFlgTkr.OutputMemoryMode || DbgSclrFlgTkr.OutputAveMode || DbgSclrFlgTkr.OuputDisplayMode)) {
			poutregion->x = main_dispwin.srcx;
			poutregion->y = main_dispwin.srcy;
			poutregion->w = main_dispwin.src_wid;
			poutregion->h = main_dispwin.src_height;
#ifdef CONFIG_SDNR_CROP
#ifdef CONFIG_I2RND_ENABLE
			if((Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_GET_RPC)){
				poutregion->x = sub_dispwin.srcx;
				poutregion->y = sub_dispwin.srcy;
				poutregion->w = sub_dispwin.src_wid;
				poutregion->h = sub_dispwin.src_height;
			}
#endif
#endif
		} else {
			poutregion->x = 0;
			poutregion->y = 0;
			poutregion->w = 0;
			poutregion->h = 0;
		}
	} else if (wid ==KADP_VIDEO_WID_1) {
		if ((DbgSclrFlgTkr.Sub_OutputVencMode || DbgSclrFlgTkr.Sub_OutputMemoryMode || DbgSclrFlgTkr.Sub_OutputAveMode || DbgSclrFlgTkr.Sub_OuputDisplayMode)) {
			poutregion->x = sub_dispwin.srcx;
			poutregion->y = sub_dispwin.srcy;
			poutregion->w = sub_dispwin.src_wid;
			poutregion->h = sub_dispwin.src_height;
		} else {
			poutregion->x = 0;
			poutregion->y = 0;
			poutregion->w = 0;
			poutregion->h = 0;
		}

	}

	return TRUE;

}
void vbe_disp_orbit_set_vo_overscan(unsigned char bEnable);
extern StructSrcRect vbe_orbit_input_size;
extern StructSrcRect vbe_orbit_output_size;
extern unsigned char vbe_disp_oled_orbit_enable;
extern unsigned char vbe_disp_oled_orbit_mode;
extern int ori_input_width;
extern int ori_input_height;

//New set input region for K4LP @Crixus 20170608
unsigned char rtk_hal_vsc_SetInputRegionEx(VIDEO_WID_T wid, VIDEO_RECT_T  inregion, VIDEO_RECT_T originalInput)
{
	VSC_INPUT_TYPE_T srctype;

#ifdef CONFIG_RTK_KDRV_DV_IDK_DUMP
	inregion.x =0 ;
	inregion.y =0 ;
	inregion.w = originalInput.w;
	inregion.h = originalInput.h;
#endif
#if(LiveZoom_PROFILE == 1)
	magnifierafter_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
	rtd_printk(KERN_EMERG, TAG_NAME_VSC, "\nVSC SetOutputRegion  end to next SetInputRegion star time=%d ms\n",(magnifierafter_time -magnifierbefore_time));
	magnifierbefore_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
#endif

    if(wid == VIDEO_WID_0)
    {
    	if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
    	{
    		rtd_printk(KERN_INFO, TAG_NAME_VSC, "SetInputRegionEx main input(%d %d %d %d) ori(%d %d)\n", inregion.x, inregion.y, inregion.w, inregion.h, originalInput.w, originalInput.h);
    	}
    }
	else
	{
		if(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
    	{
    		rtd_printk(KERN_INFO, TAG_NAME_VSC, "SetInputRegionEx sub input(%d %d %d %d) ori(%d %d)\n", inregion.x, inregion.y, inregion.w, inregion.h, originalInput.w, originalInput.h);
    	}
	}

    if(wid == VIDEO_WID_0)
		srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
	else
		srctype = Get_DisplayMode_Src(SLR_SUB_DISPLAY);

	if(inregion.w%2)
		inregion.w -=1;

#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	}
#endif
	down(&Magnifier_Semaphore);

	if (srctype == VSC_INPUTSRC_AVD)
	{
#if 0 //ch_change_flag, 20151221
		vdc_inTV_chch = FALSE;
		vdc_exTV_chch = FALSE;
#endif
#if 0
		if((get_AVD_Input_Source() == _SRC_TV) && (Scaler_AVD_GetIsChannelChange())&& (Scaler_AVD_GetDemodType()==KADP_AVD_EXTERNAL_DEMOD)){//For KTASKWBS-5200
			rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"external_ch_change_flag =1 don't clear exTV flag and count\n");
			up(&Magnifier_Semaphore);
			return TRUE;
		}else{
			//vdc_resetTV_Count = 0x0;
			//rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"clear exTV flag and count\n");
		}
#endif
	}

	//rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "rtk_hal_vsc_SetInputRegion x=%d, y=%d, w=%d, h=%d\n", inregion.x, inregion.y, inregion.w, inregion.h);
	if ((inregion.w < 1) || (inregion.h < 1) || (originalInput.w < 1) || (originalInput.h < 1)) {
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####func:%s wid:%d input paramter is 0#####\r\n",__FUNCTION__, wid);
		//if ((wid == VIDEO_WID_0) && (Get_LivezoomOffMainRunScaler() == TRUE)) {
			//DbgSclrFlgTkr.LivezoomOffKeepMainForceBG = TRUE;
		//}
		if (wid == VIDEO_WID_0)
			main_InputRegion_0000 = 1;
		up(&Magnifier_Semaphore);
		return TRUE;
	}
	else
	{
		if (wid == VIDEO_WID_0)
			main_InputRegion_0000 = 0;
	}

	if(wid == VIDEO_WID_0) {
		down(&SetMainOutPutRegion_Semaphore);
		srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);

		main_input_size.srcx = inregion.x;
		main_input_size.srcy = inregion.y;
		main_input_size.src_wid = inregion.w;
		main_input_size.src_height = inregion.h;
		//rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "rtk_hal_vsc_SetInputRegion x=%d, y=%d, w=%d, h=%d\n", inregion.x, inregion.y, inregion.w, inregion.h);

		main_input_timing.srcx = originalInput.x;
		main_input_timing.srcy = originalInput.y;
		main_input_timing.src_wid = originalInput.w;
		main_input_timing.src_height = originalInput.h;
        /*
        if((vbe_disp_oled_orbit_mode ==_VBE_PANEL_ORBIT_AUTO_MODE|| vbe_disp_oled_orbit_mode ==_VBE_PANEL_ORBIT_STORE_MODE) && vbe_disp_oled_orbit_enable)
        {
        	vbe_disp_orbit_set_vo_overscan_state(_ENABLE);
		vbe_orbit_input_size = main_input_size;
        }*/
		if ((srctype == VSC_INPUTSRC_AVD))
		{
			main_input_timing.src_wid = 720; // ATV
			if(VD_27M_HSD960_DI5A == fw_video_get_27mhz_mode(wid)){//AV
				main_input_timing.src_wid = 720;
			}else if(VD_27M_HSD1440_DI3A== fw_video_get_27mhz_mode(wid)){
				main_input_timing.src_wid = 1440;
			}
		}

		Scaler_AdaptiveStream_InputWindowSet(main_input_size,wid);
		//Scaler_InputRegionType_Set(wid,INPUT_BASE_ON_HAL_ORIGINAL_INPUT);
		setInputRegionType(wid, INPUT_BASE_ON_HAL_ORIGINAL_INPUT);
		if ((srctype == VSC_INPUTSRC_AVD))
		{
			set_input_for_vgip(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
			set_input_for_crop(SLR_MAIN_DISPLAY, main_input_size);
			set_input_timing_for_crop(SLR_MAIN_DISPLAY, main_input_timing);
			Scaler_InputRegionType_Set(wid,getInputRegionType(wid));

			//inregion.x = Scaler_CalAVD27MWidth(SLR_MAIN_DISPLAY,inregion.x);
			//inregion.w = Scaler_CalAVD27MWidth(SLR_MAIN_DISPLAY,inregion.w);

			//zoom_imd_smooth_toggle_config(wid, inregion.x, inregion.y, inregion.w, inregion.h, ZOOM_CROP);
			//zoom_imd_smooth_toggle_config(wid, main_input_timing.srcx, main_input_timing.srcy, main_input_timing.src_wid, main_input_timing.src_height, ZOOM_CROP_TIMING);
		}
		else
		{
			//zoom_imd_smooth_toggle_config(wid, inregion.x, inregion.y, inregion.w, inregion.h, ZOOM_CROP);
			if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) && (srctype == VSC_INPUTSRC_JPEG))
			{
				Scaler_InputRegionType_Set(wid,getInputRegionType(wid));
				if(check_only_xy_shift_case(SLR_MAIN_DISPLAY, &main_input_size_pre, &main_input_timing_pre,&main_dispwin_for_only_xy))
				{
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "apply_only_xy_shift...\n");
					apply_only_xy_shift(SLR_MAIN_DISPLAY, main_input_size, main_input_timing, main_dispwin_for_only_xy);
				}
				else {
					if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE){

						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####func:%s line:%d request run smooth toggle flow####\r\n", __FUNCTION__, __LINE__);
						DbgSclrFlgTkr.Main_smooth_toggle_set_flag = TRUE;
					} else {

						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####func:%s line:%d request mute off to run smooth toggle####\r\n", __FUNCTION__, __LINE__);
						DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = TRUE;
					}
				}
			}
		}
		up(&SetMainOutPutRegion_Semaphore);
	}
#ifdef CONFIG_DUAL_CHANNEL

	else if(wid == VIDEO_WID_1) {
		down(&SetSubOutPutRegion_Semaphore);

		if(DbgSclrFlgTkr.Sub_OutputVencMode && (originalInput.w == 704) && (srctype == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV)){
			rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "#####[%s(%d)] reset original input width to 720 #####", __FUNCTION__, __LINE__);
			originalInput.w=720;
		}

		sub_input_size.srcx = inregion.x;
		sub_input_size.srcy = inregion.y;
		sub_input_size.src_wid = inregion.w;
		sub_input_size.src_height = inregion.h;

		sub_input_timing.srcx = originalInput.x;
		sub_input_timing.srcy = originalInput.y;
		sub_input_timing.src_wid = originalInput.w;
		sub_input_timing.src_height = originalInput.h;

		setInputRegionType(wid, INPUT_BASE_ON_HAL_ORIGINAL_INPUT);
		#if 0// for sub smooth toggle test
		zoom_imd_smooth_toggle_config(wid, inregion.x, inregion.y, inregion.w, inregion.h, ZOOM_CROP);
		zoom_imd_smooth_toggle_config(wid, main_input_timing.srcx, main_input_timing.srcy, main_input_timing.src_wid, main_input_timing.src_height, ZOOM_CROP_TIMING);
		#endif
		Scaler_AdaptiveStream_InputWindowSet(sub_input_timing,wid);
		up(&SetSubOutPutRegion_Semaphore);
	}
#endif

	up(&Magnifier_Semaphore);

#if(LiveZoom_PROFILE == 1)
	magnifierafter_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
	rtd_printk(KERN_EMERG, TAG_NAME_VSC, "\nVSC rtk_hal_vsc_SetInputRegion time=%d ms\n",(magnifierafter_time -magnifierbefore_time));
#endif

	return TRUE;
}

#if 0
unsigned char vo_overscan_disable(VSC_INPUT_TYPE_T srctype)
{
	VIDEO_RPC_VO_OVERSCAN_INFO overscan_info;
	unsigned int *pulDataTemp = NULL;
	unsigned int ulCount = 0, i = 0;
	int ret = 0;
	if (srctype!=VSC_INPUTSRC_VDEC) {
		return 0;
	}
	if ((get_zoom_smoothtoggle_vo_hwid(SLR_MAIN_DISPLAY)!=Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE)) &&
		(get_zoom_smoothtoggle_vo_vlen(SLR_MAIN_DISPLAY)!=Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE))) {
			overscan_info.input_y=Main_InputRegion_y;
			overscan_info.input_h=Main_InputRegion_h;
			overscan_info.input_w=Main_InputRegion_w;
			overscan_info.input_x=Main_InputRegion_x;
			overscan_info.plane=Scaler_Get_CurVoInfo_VoVideoPlane(SLR_MAIN_DISPLAY);
			overscan_info.vo_source=Scaler_DispGetInputInfoByDisp(Get_DisplayMode_Port(SLR_MAIN_DISPLAY), SLR_INPUT_VO_SOURCE_TYPE);
			overscan_info.vo_overscan_enable=0;
			pulDataTemp = (unsigned int*)Scaler_GetShareMemVirAddr(SCALERIOC_SEND_VO_OVERSCAN_INFO);
			ulCount = sizeof(VIDEO_RPC_VO_OVERSCAN_INFO) / sizeof(unsigned int);

			// copy to RPC share memory
			memcpy(pulDataTemp, &overscan_info, sizeof(VIDEO_RPC_VO_OVERSCAN_INFO));

			for (i = 0; i < ulCount; i++)
				pulDataTemp[i] = Scaler_ChangeUINT32Endian(pulDataTemp[i]);

			if (0 != (ret = Scaler_SendRPC(SCALERIOC_SEND_VO_OVERSCAN_INFO,0,0)))//add 0,0 to fix compile error
			{
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "ret=%d, send VO's overscan info to driver fail !!!\n", ret);
			}
			return 1;
	}
	return 0;
}
unsigned char vo_overscan_adjust(VSC_INPUT_TYPE_T srctype)
{
	unsigned int v_len,interlace;
	VIDEO_RPC_VO_OVERSCAN_INFO overscan_info;
	unsigned int *pulDataTemp = NULL;
	unsigned int ulCount = 0, i = 0;
	unsigned char ch = Scaler_Get_CurVoInfo_plane();
	int ret = 0;
	if (srctype!=VSC_INPUTSRC_VDEC) {
		return 0;
	}
	if ((Scaler_DispWindowGet().src_height == _DISP_LEN)&&(Get_VO_Dispinfo(ch)->IPH_ACT_WID_PRE >= 3000)&&(Get_VO_Dispinfo(ch)->IVFreq>310)) {
		if ((Get_VO_Dispinfo(ch)->disp_status&_BIT8)>>8) { // interlace
			v_len=(Get_VO_Dispinfo(ch)->IPV_ACT_LEN_PRE<<1);
			interlace=1;
		} else {
			v_len=Get_VO_Dispinfo(ch)->IPV_ACT_LEN_PRE;
			interlace=0;
		}
		if ((Main_InputRegion_h<v_len)||(Main_InputRegion_y>0)) {
			set_vo_change_flag(ch, FALSE);
			if (interlace) {
				overscan_info.input_y=Main_InputRegion_y/2;
			} else {
				overscan_info.input_y=Main_InputRegion_y;
			}
			if (Main_InputRegion_h>v_len) {
				overscan_info.input_h=v_len;
			} else {
				overscan_info.input_h=Main_InputRegion_h;
			}
			if (Main_InputRegion_w>Get_VO_Dispinfo(ch)->IPH_ACT_WID_PRE) {
				overscan_info.input_w=Get_VO_Dispinfo(ch)->IPH_ACT_WID_PRE;
			} else {
				overscan_info.input_w=Main_InputRegion_w;
			}
			overscan_info.input_x=Main_InputRegion_x;
			overscan_info.plane=Scaler_Get_CurVoInfo_VoVideoPlane(SLR_MAIN_DISPLAY);
			overscan_info.vo_source=Scaler_DispGetInputInfoByDisp(Get_DisplayMode_Port(SLR_MAIN_DISPLAY), SLR_INPUT_VO_SOURCE_TYPE);
			overscan_info.vo_overscan_enable=1;
			pulDataTemp = (unsigned int*)Scaler_GetShareMemVirAddr(SCALERIOC_SEND_VO_OVERSCAN_INFO);
			ulCount = sizeof(VIDEO_RPC_VO_OVERSCAN_INFO) / sizeof(unsigned int);

			// copy to RPC share memory
			memcpy(pulDataTemp, &overscan_info, sizeof(VIDEO_RPC_VO_OVERSCAN_INFO));

			for (i = 0; i < ulCount; i++)
				pulDataTemp[i] = Scaler_ChangeUINT32Endian(pulDataTemp[i]);

			if (0 != (ret = Scaler_SendRPC(SCALERIOC_SEND_VO_OVERSCAN_INFO,0,0)))//add 0,0 to fix compile error
			{
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "ret=%d, send VO's overscan info to driver fail !!!\n", ret);
			}
			return 1;
		}
	}
	return 0;
}
#endif
static KADP_VSC_SUB_PURPOSE_T VSC_SUB_PURPOSE = KADP_VSC_SUB_PURPOSE_NONE;

void Set_Magnifier_LiveZoom_Mode(KADP_VSC_SUB_PURPOSE_T value)
{
	VSC_SUB_PURPOSE = value;
}

KADP_VSC_SUB_PURPOSE_T Get_Magnifier_LiveZoom_Mode(void)
{

#if 0
	unsigned int source_width;
	unsigned int source_lenth;
	VIDEO_RECT_T inregion;
	rtk_hal_vsc_GetInputRegion(VIDEO_WID_1, &inregion);

	if (Scaler_DispGetStatus(SLR_SUB_DISPLAY, SLR_DISP_INTERLACE))
		source_lenth = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE)*2;
	else
		source_lenth = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE);

	source_width = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE);

	source_width = source_width*9/10;/*after 90% just scan size*/
	source_lenth = source_lenth*9/10;/*after 90% just scan size*/

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "after 90% just scan size:source_width=%d;source_lenth=%d!!!\n", source_width,source_lenth);
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "webos input_width=%d;input_lenth=%d!!!\n", inregion.w, inregion.h);

	if ((inregion.w>=source_width)&&( inregion.h>=source_lenth))
		return PIP_LIVEZOOM;
	else
		return PIP_MAGNIFIER;
#else
	return VSC_SUB_PURPOSE;
#endif
}

unsigned char get_livezoomode_forvideofw(void)
{
	if(Get_Live_zoom_mode()==LIVE_ZOOM_OFF)
		return FALSE;
	else
		return TRUE;
}

unsigned char magnifier_voinfo_wait(unsigned char channel)
{
	/*wait new vo ready info*/
	unsigned char port ;
	unsigned char inputPort;
	if (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_SEARCH)
	{
		VSC_INPUT_TYPE_T srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
		if (srctype == VSC_INPUTSRC_VDEC) {
			unsigned int timeout;

			if(DbgSclrFlgTkr.LivezoomvoinfocheckFlag == FALSE) {
				timeout = 200;
				DbgSclrFlgTkr.LivezoomvoinfocheckFlag = TRUE;
			} else {
				timeout = 20;
			}
			port = Get_DisplayMode_Port(SLR_MAIN_DISPLAY);
			while (timeout) {
				#if 0
				if(DbgSclrFlgTkr.Main_Scaler_Stop_flag) {
					rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "\r\n####VO already disconnet#####\r\n");
					break;
				}
				#endif
				if(get_vo_change_flag(port)) {
					break;
				}
				msleep(10);
				timeout--;
			}
			if (timeout ==0) {
				rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "[magnifier]#####happen####timeout = %d##########Function:%s;;Line:%d\n",timeout,__FUNCTION__,__LINE__);
				return FALSE;
			}
			rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "[magnifier]#########timeout = %d##########Function:%s;;Line:%d\n",timeout,__FUNCTION__,__LINE__);
                	inputPort = 0;
                	if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
                	{
                		inputPort = DisplayModeInputInfo.resourceIndex;
                	}
                	else if(VencModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
                	{
                		inputPort = VencModeInputInfo.resourceIndex;
                	}
                	else if(MemoryModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
                	{
                		inputPort = MemoryModeInputInfo.resourceIndex;
                	}
                        Scaler_SET_VSCDispinfo_WithVFEDispinfo(SLR_MAIN_DISPLAY, Get_VO_Dispinfo(inputPort));
		}
	}
	return TRUE;
}

unsigned char magnifier_mainscaler_run(unsigned char channel, VSC_INPUT_TYPE_T srctype, VIDEO_RECT_T outregion)
{
#ifdef CONFIG_FORCE_RUN_I3DDMA
	int timeout = 50;
#endif
	/*re run main scaler start*/
#if 0
	StructSrcRect magnifiermaininputsize;
	rtk_hal_vsc_GetInputRegion(VIDEO_WID_0, &magnifiermaininputsize);
	main_input_size.srcx = 0;//no overscan
	main_input_size.srcy = 0;//no overscan
	main_input_size.src_wid = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE);//no overscan
	if(Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE))//interlace timing
		main_input_size.src_height = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) << 1;//no overscan
	else
		main_input_size.src_height = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE);//no overscan
#endif
#if 0
	printk("\n *********************magnifier_mainscaler_run    channel = %d !", channel);
	printk("\n *********************magnifier_mainscaler_run    SLR_DISP_INTERLACE = %d !", Scaler_DispGetStatus(channel, SLR_DISP_INTERLACE));
	printk("\n *********************magnifier_mainscaler_run    SLR_INPUT_IPH_ACT_STA = %d !", Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_STA));
	printk("\n *********************magnifier_mainscaler_run    SLR_INPUT_IPV_ACT_STA = %d !", Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_STA));
	printk("\n *********************magnifier_mainscaler_run    SLR_INPUT_IPH_ACT_WID = %d !", Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID));
	printk("\n *********************magnifier_mainscaler_run    SLR_INPUT_IPV_ACT_LEN = %d !", Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN));
	printk("\n *********************magnifier_mainscaler_run    main_input_size.srcx = %d !", main_input_size.srcx);
	printk("\n *********************magnifier_mainscaler_run    main_input_size.srcy = %d !", main_input_size.srcy);
	printk("\n *********************magnifier_mainscaler_run    main_input_size.src_height = %d !", main_input_size.src_height);
	printk("\n *********************magnifier_mainscaler_run    main_input_size.src_wid = %d !", main_input_size.src_wid);
#endif
	set_input_for_vgip(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
	set_input_for_crop(SLR_MAIN_DISPLAY, main_input_size);
	set_input_timing_for_crop(SLR_MAIN_DISPLAY, main_input_timing);
	Scaler_InputRegionType_Set(SLR_MAIN_DISPLAY,getInputRegionType(SLR_MAIN_DISPLAY));

	set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_LIVEZOOM, TRUE);
	mute_control(SLR_MAIN_DISPLAY, TRUE);

	drvif_memory_compression_rpc(channel);
	msleep(100);


	if(SLR_MAIN_DISPLAY == channel)
		Share_Memory_Set_Scaler_Run_Flag(1);
	//Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH); //Remove by Will
	down(&SetMainOutPutRegion_Semaphore);
	#if 0
	if(align8byte == TRUE) {
		Main_InputRegion_x = drvif_memory_get_data_align(Main_InputRegion_x, 0x04);
		Main_InputRegion_w = drvif_memory_get_data_align(Main_InputRegion_w, 0x04);
		if ((Main_InputRegion_x  + Main_InputRegion_w) > Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE)) {
			Main_InputRegion_w = Main_InputRegion_w -4;
		}
	}
	#endif
	if ((outregion.w + outregion.x > _DISP_WID) || (outregion.h + outregion.y > _DISP_LEN)) {
		main_dispwin.srcx = 0;
		main_dispwin.srcy = 0;
		main_dispwin.src_height = _DISP_LEN;
		main_dispwin.src_wid = _DISP_WID;
	} else {
		main_dispwin.srcx = outregion.x;
		main_dispwin.srcy = outregion.y;
		main_dispwin.src_height = outregion.h;
		main_dispwin.src_wid = outregion.w;
	}

	Scaler_DispWindowSet(main_dispwin);

	up(&SetMainOutPutRegion_Semaphore);
#if 0/*disable vo overscan for need magnifier and livezoom all input size*/
	/*if (DataFramesynclivezoom == TRUE) */{
		if (vo_overscan_disable(srctype)) {
			msleep(20);
			timeout = 50;
			while (timeout--) {
				if(get_vo_change_flag(Get_DisplayMode_Port(SLR_MAIN_DISPLAY))) {
					break;
				}
				msleep(10);
			}
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####func:%s disable VO overscan case. timeout:%d#####\r\n", __FUNCTION__, timeout);
		}
	}
#endif

#ifdef CONFIG_FORCE_RUN_I3DDMA
	//[WOSQRTK-9641] When change to ATV, main path will force i3ddma scaler flow
	if ((srctype == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV)&&((get_force_i3ddma_enable(SLR_MAIN_DISPLAY) == 0)||(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_SEARCH)))
        {
//	 unsigned char port;
	 unsigned char check_Flag ;
         down(&Force_Run_Idma_Semaphore);
         set_force_i3ddma_enable(TRUE);		// clear i3ddma flag

	ATV_forcei3ddma = 1;	//	ATV will force i3ddma scaler flow
	check_Flag = scaler_atv_force_run_idma();
	ATV_forcei3ddma = 0;

         if(check_Flag) {
          up(&Force_Run_Idma_Semaphore);

#ifdef CONFIG_I2RND_ENABLE
          //for APVR and ATV channel changing stage, avoid the race condition issue. @Crixus 20160823
          if((Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_TRIGGER_RUN_MAIN)){
           vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_I3DDMA_RPC;
           //printk(KERN_EMERG"[%s][%d]vsc_i2rnd_main_rerun_stage = %d!!!!\n",__FUNCTION, LINE__, vsc_i2rnd_atv_main_rerun_stage);
          }
#endif
          rtd_printk(KERN_EMERG, TAG_NAME_VSC, "\r\n####Go ATV VO case. timeout:%d#####\r\n", timeout);

         } else {
          if(!DbgSclrFlgTkr.Main_Scaler_Stop_flag) {
           	Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_HDMI, 0xfa);	// desconnect vo
          }
          up(&Force_Run_Idma_Semaphore);
         }

        }
#endif

	down(&VSC_Semaphore);
	DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;

	if (Scaler_InputSrcGetType(SLR_MAIN_DISPLAY) == _SRC_VO) {
		DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = TRUE;
	}

#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE //update rotate info
	set_ori_rotate_mode(get_rotate_mode());
	set_rotate_mode(rotate_mode);
#endif
	set_current_scaler_source_num(SLR_MAIN_DISPLAY);//record current vsc source num
	rtk_output_connect(SLR_MAIN_DISPLAY);
	if (LiveZoom_MEMCClose_Flag == TRUE) {
		down(get_livezoom_memcclose_Semaphore());
		LiveZoom_MEMCClose_Flag = FALSE;
		up(get_livezoom_memcclose_Semaphore());
		memc_setting_displayDtiming_framerate();
	}
#if 0
	main_input_size.srcx = magnifiermaininputsize.srcx;
	main_input_size.srcy = magnifiermaininputsize.srcy;
	main_input_size.src_wid = magnifiermaininputsize.src_wid;
	main_input_size.src_height = magnifiermaininputsize.src_height;
#endif
	up(&VSC_Semaphore);
	set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_LIVEZOOM, FALSE);
	return TRUE;
}

extern void send_vo_freeze_shiftxy_share_memory(void);
unsigned char check_only_xy_shift_case(unsigned char display, StructSrcRect *input, StructSrcRect *inputTiming, StructSrcRect *output)
{
	unsigned char ret = NOT_EQUAL;
	VSC_INPUT_TYPE_T srctype;
#ifdef NEW_INPUT_REGION_BASE_ON_HAL_ORIGINAL_INPUT
	if (getInputRegionType(display) == INPUT_BASE_ON_HAL_ORIGINAL_INPUT) {
		//if hal input timing is different, it will not go shiftxy
		//NEED FIX pool test
		//if input x=50 inputTiming wid=1000, then change to input x=100, inputTiming wid = 2000.
		//the ratio stays the same, so it may run shiftxy flow
		if(inputTiming->srcx != main_input_timing.srcx || inputTiming->srcy != main_input_timing.srcy
		     || inputTiming->src_wid != main_input_timing.src_wid || inputTiming->src_height != main_input_timing.src_height){
			input->srcx = main_input_size.srcx;
			input->srcy = main_input_size.srcy;
			input->src_wid = main_input_size.src_wid;
			input->src_height = main_input_size.src_height;
			inputTiming->srcx = main_input_timing.srcx;
			inputTiming->srcy = main_input_timing.srcy;
			inputTiming->src_wid = main_input_timing.src_wid;
			inputTiming->src_height = main_input_timing.src_height;
			output->srcx = main_dispwin.srcx;
			output->srcy = main_dispwin.srcy;
			output->src_wid = main_dispwin.src_wid;
			output->src_height = main_dispwin.src_height;
			DbgSclrFlgTkr.check_only_xy_shift_same_region = FALSE;
			return ret;
		}
	}
#endif
         if(input->src_wid != main_input_size.src_wid || input->src_height != main_input_size.src_height
         || output->srcx != main_dispwin.srcx || output->srcy != main_dispwin.srcy
         || output->src_wid != main_dispwin.src_wid || output->src_height != main_dispwin.src_height)
         {
         		   input->srcx = main_input_size.srcx;
                   input->srcy = main_input_size.srcy;
                   input->src_wid = main_input_size.src_wid;
                   input->src_height = main_input_size.src_height;
                   output->srcx = main_dispwin.srcx;
                   output->srcy = main_dispwin.srcy;
                   output->src_wid = main_dispwin.src_wid;
                   output->src_height = main_dispwin.src_height;
                   DbgSclrFlgTkr.check_only_xy_shift_same_region = FALSE;
				   return ret;

         }
         else
         {
                   // all region are the same, just run apply_only_xy_shift, but do nothing
                   if(input->srcx == main_input_size.srcx && input->srcy == main_input_size.srcy)
                   {
                            DbgSclrFlgTkr.check_only_xy_shift_same_region = TRUE;
							ret = ALL_EQUAL;
                            return ret;
                   } else if((input->srcx != main_input_size.srcx) &&
				   			(input->srcy != main_input_size.srcy)){
				   			ret = ONLY_SHIFT_XY;
                   } else if(input->srcx != main_input_size.srcx){
				   			ret = ONLY_SHIFT_X;
                   } else if(input->srcy != main_input_size.srcy){
				   			ret = ONLY_SHIFT_Y;
                   }

                   input->srcx = main_input_size.srcx;
                   input->srcy = main_input_size.srcy;
                   input->src_wid = main_input_size.src_wid;
                   input->src_height = main_input_size.src_height;
                   output->srcx = main_dispwin.srcx;
                   output->srcy = main_dispwin.srcy;
                   output->src_wid = main_dispwin.src_wid;
                   output->src_height = main_dispwin.src_height;
                   DbgSclrFlgTkr.check_only_xy_shift_same_region = FALSE;
                   srctype = Get_DisplayMode_Src(display);
                   if(srctype == VSC_INPUTSRC_VDEC)	{
					   if ((!DbgSclrFlgTkr.Main_smooth_toggle_set_flag) && (!DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off)) {// && (!DbgSclrFlgTkr.smoothtoggle_start_flag)) {
							if (!DbgSclrFlgTkr.smoothtoggle_start_flag) {
								 send_vo_freeze_shiftxy_share_memory();
		                           			 return ret;
							} else {
								//wait
								unsigned int timeout = 15;

								while((DbgSclrFlgTkr.Main_smooth_toggle_set_flag ||DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off || DbgSclrFlgTkr.smoothtoggle_start_flag)&&timeout)
									{
										timeout--;
										msleep(10);
									}

								if(!timeout){
									rtd_printk(KERN_INFO, TAG_NAME_VSC, "shiftxf wait smoothtoogh timeout !\n");
									return NOT_EQUAL;
								}else{
									 send_vo_freeze_shiftxy_share_memory();
									return ret;
								}
							}
						} else {
							return NOT_EQUAL;
						}
				  } else {
					return NOT_EQUAL;
				  }
         }
}


void apply_only_xy_shift(unsigned char display, StructSrcRect input, StructSrcRect inputTiming, StructSrcRect output)
{
	int timeout = 30;
	VSC_INPUT_TYPE_T srctype = Get_DisplayMode_Src(display);

#ifdef CONFIG_SDNR_CROP// for VGIP overscan
	scaledown_ich1_uzd_ctrl0_RBUS	ich1_uzd_Ctrl0_REG;
	scaledown_ich1_uzd_db_ctrl_RBUS ich1_uzd_db_ctrl_reg;
	scaledown_ich1_sdnr_cutout_range_hor_RBUS ich1_sdnr_cutout_range_hor_reg;
	scaledown_ich1_sdnr_cutout_range_ver0_RBUS ich1_sdnr_cutout_range_ver0_reg;
	//scaledown_ich1_sdnr_cutout_range_ver1_RBUS ich1_sdnr_cutout_range_ver1_reg;
	StructSrcRect SDNR_size = input;
	//int mid = 0;
#else
	unsigned char src = Scaler_InputSrcGetType(display);
	unsigned int hstart = 0;
	unsigned int vstart = 0;
	vgip_vgip_chn1_ctrl_RBUS vgip_chn1_ctrl_reg;
	vgip_vgip_chn1_act_hsta_width_RBUS vgip_chn1_act_hsta_width_reg;
	vgip_vgip_chn1_act_vsta_length_RBUS vgip_chn1_act_vsta_length_reg;
#endif

	// all region are the same, just run apply_only_xy_shift, but do nothing
	if(DbgSclrFlgTkr.check_only_xy_shift_same_region == TRUE){
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "apply_only_xy_shift do nothing\n");
		return;
	}

#ifdef CONFIG_SDNR_CROP	//for SDNR overscan

#if 0
	printk("========input size============\n");
	printk("x:%d,y:%d,wid:%d,len:%d\n",input.srcx,input.srcy,input.src_wid,input.src_height);
	printk("========output size============\n");
	printk("x:%d,y:%d,wid:%d,len:%d\n",output.srcx,output.srcy,output.src_wid,output.src_height);
	printk("===============================\n");
#endif
	SDNR_size = drvif_cal_SDNR_size(display,input,inputTiming,output);
	pr_emerg("[shiftxy][SDNR]x:%d,y:%d,wid:%d,len:%d\n",SDNR_size.srcx,SDNR_size.srcy,SDNR_size.src_wid,SDNR_size.src_height);
#if 0
	printk("############SDNR size#############\n");
	printk("x:%d,y:%d,wid:%d,len:%d\n",SDNR_size.srcx,SDNR_size.srcy,SDNR_size.src_wid,SDNR_size.src_height);
	printk("################################\n");
#endif
#ifdef CONFIG_I2RND_ENABLE
	if (!Scaler_I2rnd_get_timing_enable())
#endif
	{
		ich1_uzd_db_ctrl_reg.regValue =IoReg_Read32(SCALEDOWN_ICH1_UZD_DB_CTRL_reg);
		while(ich1_uzd_db_ctrl_reg.h_db_en && ich1_uzd_db_ctrl_reg.v_db_en && ich1_uzd_db_ctrl_reg.v_db_apply)
		{
			timeout --;
			mdelay(1); /*wait 1ms 30 counts for vsync */
			if(!timeout) break;
			ich1_uzd_db_ctrl_reg.regValue = IoReg_Read32(SCALEDOWN_ICH1_UZD_DB_CTRL_reg);
		}
		if(timeout == 0) printk("uzd aplly time out !!! :%d\n",timeout);
		//uzu double buffer enbale
		ich1_uzd_db_ctrl_reg.regValue =IoReg_Read32(SCALEDOWN_ICH1_UZD_DB_CTRL_reg);
		ich1_uzd_db_ctrl_reg.h_db_en=1;
		ich1_uzd_db_ctrl_reg.h_db_apply=0;
		ich1_uzd_db_ctrl_reg.v_db_en=1;
		ich1_uzd_db_ctrl_reg.v_db_apply=0;
		IoReg_Write32(SCALEDOWN_ICH1_UZD_DB_CTRL_reg,ich1_uzd_db_ctrl_reg.regValue);
	}

	ich1_sdnr_cutout_range_hor_reg.regValue = IoReg_Read32(SCALEDOWN_ich1_sdnr_cutout_range_hor_reg);
	ich1_sdnr_cutout_range_hor_reg.hor_front = SDNR_size.srcx;
	ich1_sdnr_cutout_range_hor_reg.hor_width = SDNR_size.src_wid; // chip setting need to +1
	IoReg_Write32(SCALEDOWN_ich1_sdnr_cutout_range_hor_reg, ich1_sdnr_cutout_range_hor_reg.regValue);

	if(!Scaler_get_data_framesync(SLR_MAIN_DISPLAY))
	{
		ich1_sdnr_cutout_range_ver0_reg.regValue = IoReg_Read32(SCALEDOWN_ich1_sdnr_cutout_range_ver0_reg);
		ich1_sdnr_cutout_range_ver0_reg.ver_front = SDNR_size.srcy;
		ich1_sdnr_cutout_range_ver0_reg.ver_height = SDNR_size.src_height;// chip setting need to +1
		IoReg_Write32(SCALEDOWN_ich1_sdnr_cutout_range_ver0_reg, ich1_sdnr_cutout_range_ver0_reg.regValue);
	}

	//mid = ich1_sdnr_cutout_range_ver0_reg.ver_back;
	//ich1_sdnr_cutout_range_ver1_reg.regValue = IoReg_Read32(SCALEDOWN_ich1_sdnr_cutout_range_ver1_reg);
	//ich1_sdnr_cutout_range_ver1_reg.ver_mid_top = mid;
	//ich1_sdnr_cutout_range_ver1_reg.ver_mid_bot = mid - 1;
	//IoReg_Write32(SCALEDOWN_ich1_sdnr_cutout_range_ver1_reg, ich1_sdnr_cutout_range_ver1_reg.regValue);

	ich1_uzd_Ctrl0_REG.regValue = IoReg_Read32(SCALEDOWN_ICH1_UZD_Ctrl0_reg);
	ich1_uzd_Ctrl0_REG.cutout_en = 1;
	IoReg_Write32(SCALEDOWN_ICH1_UZD_Ctrl0_reg, ich1_uzd_Ctrl0_REG.regValue);
#ifdef CONFIG_I2RND_ENABLE
	if (!Scaler_I2rnd_get_timing_enable())
#endif
	{
		//uzu double buffer apply
		ich1_uzd_db_ctrl_reg.regValue =IoReg_Read32(SCALEDOWN_ICH1_UZD_DB_CTRL_reg);
		ich1_uzd_db_ctrl_reg.h_db_apply=1;
		ich1_uzd_db_ctrl_reg.v_db_apply=1;
		IoReg_Write32(SCALEDOWN_ICH1_UZD_DB_CTRL_reg,ich1_uzd_db_ctrl_reg.regValue);
	}

#else		// for VGIP overscan

	vgip_chn1_act_hsta_width_reg.regValue = IoReg_Read32(VGIP_VGIP_CHN1_ACT_HSTA_Width_reg);
	while(vgip_chn1_act_hsta_width_reg.ch1_db_rdy && vgip_chn1_act_hsta_width_reg.ch1_db_en)
	{
		timeout --;
		mdelay(1); /*wait 1ms 30 counts for vsync */
		if(!timeout) break;
		vgip_chn1_act_hsta_width_reg.regValue = IoReg_Read32(VGIP_VGIP_CHN1_ACT_HSTA_Width_reg);
	}

	if (Scaler_DispGetStatus(display, SLR_DISP_INTERLACE)) {
		hstart = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPH_ACT_STA_PRE) + input.srcx;
		vstart = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_STA_PRE) + input.srcy/2;
	} else {
		hstart = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPH_ACT_STA_PRE) + input.srcx;
		vstart = Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_STA_PRE) + input.srcy;
	}

	if ((src == _SRC_HDMI) || (src == _SRC_VO)) {
		//if color space is 422 format, it should be even number. @ Crixus
		if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_COLOR_SPACE) == COLOR_YUV422){
			if((hstart%2) != (Scaler_DispGetInputInfoByDisp((SCALER_DISP_CHANNEL)display, SLR_INPUT_IPH_ACT_STA_PRE)%2))
				hstart = hstart - 1;//This means that shift value need even
		}
	}
	vgip_chn1_ctrl_reg.regValue = rtd_inl(VGIP_VGIP_CHN1_CTRL_reg);
	vgip_chn1_act_hsta_width_reg.regValue = IoReg_Read32(VGIP_VGIP_CHN1_ACT_HSTA_Width_reg);
	vgip_chn1_act_hsta_width_reg.ch1_db_en = 1;
	vgip_chn1_act_hsta_width_reg.ch1_db_rdy = 0;
	IoReg_Write32(VGIP_VGIP_CHN1_ACT_HSTA_Width_reg,vgip_chn1_act_hsta_width_reg.regValue);

	vgip_chn1_act_hsta_width_reg.regValue = IoReg_Read32(VGIP_VGIP_CHN1_ACT_HSTA_Width_reg);
	if(vgip_chn1_ctrl_reg.ch1_digital_mode)
		vgip_chn1_act_hsta_width_reg.ch1_ih_act_sta = hstart - Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPH_ACT_STA_PRE);
	else
		vgip_chn1_act_hsta_width_reg.ch1_ih_act_sta = hstart;
	IoReg_Write32(VGIP_VGIP_CHN1_ACT_HSTA_Width_reg, vgip_chn1_act_hsta_width_reg.regValue);
	vgip_chn1_act_vsta_length_reg.regValue = IoReg_Read32(VGIP_VGIP_CHN1_ACT_VSTA_Length_reg);
	if(vgip_chn1_ctrl_reg.ch1_digital_mode)
		vgip_chn1_act_vsta_length_reg.ch1_iv_act_sta = vstart - Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_IPV_ACT_STA_PRE);
	else
		vgip_chn1_act_vsta_length_reg.ch1_iv_act_sta = vstart;
	IoReg_Write32(VGIP_VGIP_CHN1_ACT_VSTA_Length_reg, vgip_chn1_act_vsta_length_reg.regValue);

	vgip_chn1_act_hsta_width_reg.regValue = IoReg_Read32(VGIP_VGIP_CHN1_ACT_HSTA_Width_reg);
	vgip_chn1_act_hsta_width_reg.ch1_db_rdy = 1;
	IoReg_Write32(VGIP_VGIP_CHN1_ACT_HSTA_Width_reg,vgip_chn1_act_hsta_width_reg.regValue);

#endif

	//KTASKWBS-5348  move update info after execution
	if(srctype == VSC_INPUTSRC_VDEC)
		zoom_record_input_output_pre_size(display,main_input_size, main_input_timing, main_dispwin);

}

void Scaler_data_frc_fs_change_adjust_outputregion(unsigned char display,unsigned short disp_height)
{
	return; //k3l always go data frc
#if 0
#ifdef SMOOTH_TOGGLE_DATAFRCFS_TEST
	if(!vbe_disp_get_adaptivestream_fs_mode())
#endif
	{
		if (!vsc_get_adaptivestream_flag()) {
			if(Get_vo_smoothtoggle_timingchange_flag(display) ||(get_HDMI_HDR_mode() ==HDR_DOLBY_HDMI) || (get_HDMI_HDR_mode() ==HDR_HDR10_HDMI)) {
					if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_FRAMESYNC)) {
						if ((drvif_HDR_get_VO_Decompress_Status(Get_DisplayMode_Port(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)))==TRUE) || (get_vo_vp9_flag(Get_DisplayMode_Port(display)))) {
							mute_control(display, TRUE);
							Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
							down(&SetMainOutPutRegion_Semaphore);
							DbgSclrFlgTkr.Main_force_frc_flag = TRUE;
							reset_any_srcrect(&main_dispwin_pre); //Need to Reste previous output value. For run scaler flow
							up(&SetMainOutPutRegion_Semaphore);
						} else {
							if(Get_display_forcebg_mask(display,SLR_FORCE_BG_TYPE_VSC)) {
								if (((Scaler_InputRegionType_Get(display) != INPUT_BASE_ON_HAL_ORIGINAL_INPUT) && ((disp_height!=_DISP_LEN) ||(main_input_size.src_wid!=Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_IPH_ACT_WID_PRE))||(main_input_size.src_height!=Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_IPV_ACT_LEN_PRE))))
									|| ((Scaler_InputRegionType_Get(display) == INPUT_BASE_ON_HAL_ORIGINAL_INPUT) && ((disp_height!=_DISP_LEN) ||(main_input_size.src_wid != main_input_timing.src_wid) || (main_input_size.src_height != main_input_timing.src_height))))
								{
									DbgSclrFlgTkr.Main_force_frc_fs_flag = TRUE;
									Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
									down(&SetMainOutPutRegion_Semaphore);
									reset_any_srcrect(&main_dispwin_pre); //Need to Reste previous output value. For run scaler flow
									up(&SetMainOutPutRegion_Semaphore);
								}
							}
						}
					} else {
						if(Get_display_forcebg_mask(display,SLR_FORCE_BG_TYPE_VSC)) {
							if (drvif_HDR_get_VO_Decompress_Status(Get_DisplayMode_Port(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)))==FALSE) {
								if ((Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_IPH_ACT_WID_PRE)>=3000)&&(Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_V_FREQ)>310))
								{
									if(((Scaler_InputRegionType_Get(display) != INPUT_BASE_ON_HAL_ORIGINAL_INPUT) && (disp_height==_DISP_LEN)&&(main_input_size.src_wid==Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_IPH_ACT_WID_PRE))&&(main_input_size.src_height==Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_IPV_ACT_LEN_PRE)))
										|| ((Scaler_InputRegionType_Get(display) == INPUT_BASE_ON_HAL_ORIGINAL_INPUT) && (disp_height==_DISP_LEN) && (main_input_size.src_wid == main_input_timing.src_wid) && (main_input_size.src_height == main_input_timing.src_height)))
									{
										DbgSclrFlgTkr.Main_force_frc_fs_flag = TRUE;
										Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
										down(&SetMainOutPutRegion_Semaphore);
										reset_any_srcrect(&main_dispwin_pre); //Need to Reste previous output value. For run scaler flow
										up(&SetMainOutPutRegion_Semaphore);
									}
								}
							}
						}
					}
				//}
			} else {//DTV flow
				if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_FRAMESYNC)) {
					if (drvif_HDR_get_VO_Decompress_Status(Get_DisplayMode_Port(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)))==TRUE) {
						mute_control(display, TRUE);
						Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
						down(&SetMainOutPutRegion_Semaphore);
						DbgSclrFlgTkr.Main_force_frc_flag = TRUE;
						reset_any_srcrect(&main_dispwin_pre); //Need to Reste previous output value. For run scaler flow
						up(&SetMainOutPutRegion_Semaphore);
					} else {
						if (Get_display_forcebg_mask(display,SLR_FORCE_BG_TYPE_VSC)) {
							if (((Scaler_InputRegionType_Get(display) != INPUT_BASE_ON_HAL_ORIGINAL_INPUT) && ((disp_height!=_DISP_LEN) ||(main_input_size.src_wid!=Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_IPH_ACT_WID_PRE))||(main_input_size.src_height!=Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_IPV_ACT_LEN_PRE))))
								|| ((Scaler_InputRegionType_Get(display) == INPUT_BASE_ON_HAL_ORIGINAL_INPUT) && ((disp_height!=_DISP_LEN) ||(main_input_size.src_wid != main_input_timing.src_wid) || (main_input_size.src_height != main_input_timing.src_height))))
							{
								Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
								down(&SetMainOutPutRegion_Semaphore);
								DbgSclrFlgTkr.Main_force_frc_flag = TRUE;
								reset_any_srcrect(&main_dispwin_pre); //Need to Reste previous output value. For run scaler flow
								up(&SetMainOutPutRegion_Semaphore);
							}
						}
					}
				}
			}
		}
	}
#endif
}
unsigned char Scaler_data_frc_fs_change_adjust_after_scaler(unsigned char display,unsigned short disp_height)
{
	return TRUE; //k3l always go data frc
#if 0
	if (Scaler_InputSrcGetType(display) == _SRC_VO) {
#ifdef SMOOTH_TOGGLE_DATAFRCFS_TEST
	if(!vbe_disp_get_adaptivestream_fs_mode())
#endif
	{
		if(!vsc_get_adaptivestream_flag() && (Get_vo_smoothtoggle_timingchange_flag(display) || (get_HDMI_HDR_mode() ==HDR_DOLBY_HDMI) || (get_HDMI_HDR_mode() ==HDR_HDR10_HDMI))) {
			if(Scaler_DispGetInputInfoByDisp(display, SLR_INPUT_FRAMESYNC)) {
				if (drvif_HDR_get_VO_Decompress_Status(Get_DisplayMode_Port(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)))==TRUE) {
					mute_control(display, TRUE);
					if(DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE) {
						DbgSclrFlgTkr.Main_force_frc_flag = TRUE;
					}
					Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
					reset_any_srcrect(&main_dispwin_pre); //Need to Reste previous output value. For run scaler flow
					return FALSE;
				} else {
					if (((Scaler_InputRegionType_Get(display) != INPUT_BASE_ON_HAL_ORIGINAL_INPUT) && ((disp_height!=_DISP_LEN) ||(main_input_size.src_wid!=Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_IPH_ACT_WID_PRE))||(main_input_size.src_height!=Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_IPV_ACT_LEN_PRE))))
						|| ((Scaler_InputRegionType_Get(display) == INPUT_BASE_ON_HAL_ORIGINAL_INPUT) && ((disp_height!=_DISP_LEN) ||(main_input_size.src_wid != main_input_timing.src_wid) || (main_input_size.src_height != main_input_timing.src_height))))
					{
						DbgSclrFlgTkr.Main_force_frc_fs_flag = TRUE;
						Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
						reset_any_srcrect(&main_dispwin_pre); //Need to Reste previous output value. For run scaler flow
						return FALSE;
					}
				}
			} else {
				if (drvif_HDR_get_VO_Decompress_Status(Get_DisplayMode_Port(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)))==FALSE) {
					if ((Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_IPH_ACT_WID_PRE)>=3000)&&(Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_V_FREQ)>310))
					{
						if(((Scaler_InputRegionType_Get(display) != INPUT_BASE_ON_HAL_ORIGINAL_INPUT) && (disp_height==_DISP_LEN)&&(main_input_size.src_wid==Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_IPH_ACT_WID_PRE))&&(main_input_size.src_height==Scaler_DispGetInputInfoByDisp(display,SLR_INPUT_IPV_ACT_LEN_PRE)))
							|| ((Scaler_InputRegionType_Get(display) == INPUT_BASE_ON_HAL_ORIGINAL_INPUT) && (disp_height==_DISP_LEN) && (main_input_size.src_wid == main_input_timing.src_wid) && (main_input_size.src_height == main_input_timing.src_height)))
						{
							DbgSclrFlgTkr.Main_force_frc_fs_flag = TRUE;
							Scaler_DispSetInputInfoByDisp(display, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
							reset_any_srcrect(&main_dispwin_pre); //Need to Reste previous output value. For run scaler flow
							return FALSE;
						}
					}
				}
			}
		}
	}
	}
	return TRUE;
#endif
}



extern unsigned char drvif_module_vdc_Read_Vstate(void);
extern void drvif_module_vdc_CheckInputStatus(unsigned char ucInputSrc, unsigned char ucCheckStart);
extern unsigned char drvif_HDR_get_VO_Decompress_Status(unsigned char ch);

unsigned char  CompareATVOutputRegion(unsigned char a_ucChannel, VIDEO_RECT_T *a_ptOutputregion)
{
	if (SLR_MAIN_DISPLAY == a_ucChannel)
	{

		if (DbgSclrFlgTkr.Main_ATV_OutputRegion_x_pre == a_ptOutputregion->x
			&& DbgSclrFlgTkr.Main_ATV_OutputRegion_y_pre == a_ptOutputregion->y
			&& DbgSclrFlgTkr.Main_ATV_OutputRegion_w_pre == a_ptOutputregion->w
			&& DbgSclrFlgTkr.Main_ATV_OutputRegion_h_pre == a_ptOutputregion->h
		)
		{
			return TRUE;
		}
	}
	else
	{
		if (DbgSclrFlgTkr.Sub_ATV_OutputRegion_x_pre == a_ptOutputregion->x
			&& DbgSclrFlgTkr.Sub_ATV_OutputRegion_y_pre == a_ptOutputregion->y
			&& DbgSclrFlgTkr.Sub_ATV_OutputRegion_w_pre == a_ptOutputregion->w
			&& DbgSclrFlgTkr.Sub_ATV_OutputRegion_h_pre == a_ptOutputregion->h
		)
		{
			return TRUE;
		}
	}

	return FALSE;
}


unsigned char  CompareATVInputOutputRegion(unsigned char a_ucChannel, KADP_VIDEO_RECT_T *a_ptOutputregion, KADP_VIDEO_RECT_T *a_ptInputRegion)
{
	if (SLR_MAIN_DISPLAY == a_ucChannel)
	{
		if (DbgSclrFlgTkr.Main_ATV_OutputRegion_x_pre == a_ptOutputregion->x
			&& DbgSclrFlgTkr.Main_ATV_OutputRegion_y_pre == a_ptOutputregion->y
			&& DbgSclrFlgTkr.Main_ATV_OutputRegion_w_pre == a_ptOutputregion->w
			&& DbgSclrFlgTkr.Main_ATV_OutputRegion_h_pre == a_ptOutputregion->h
			&& DbgSclrFlgTkr.Main_ATV_InputRegion_x_pre == a_ptInputRegion->x
			&& DbgSclrFlgTkr.Main_ATV_InputRegion_y_pre == a_ptInputRegion->y
			&& DbgSclrFlgTkr.Main_ATV_InputRegion_w_pre == a_ptInputRegion->w
			&& DbgSclrFlgTkr.Main_ATV_InputRegion_h_pre == a_ptInputRegion->h
		)
		{
			return TRUE;
		}
	}
	else
	{
		if (DbgSclrFlgTkr.Sub_ATV_OutputRegion_x_pre == a_ptOutputregion->x
			&& DbgSclrFlgTkr.Sub_ATV_OutputRegion_y_pre == a_ptOutputregion->y
			&& DbgSclrFlgTkr.Sub_ATV_OutputRegion_w_pre == a_ptOutputregion->w
			&& DbgSclrFlgTkr.Sub_ATV_OutputRegion_h_pre == a_ptOutputregion->h
			&& DbgSclrFlgTkr.Sub_ATV_InputRegion_x_pre == a_ptInputRegion->x
			&& DbgSclrFlgTkr.Sub_ATV_InputRegion_y_pre == a_ptInputRegion->y
			&& DbgSclrFlgTkr.Sub_ATV_InputRegion_w_pre == a_ptInputRegion->w
			&& DbgSclrFlgTkr.Sub_ATV_InputRegion_h_pre == a_ptInputRegion->h
		)
		{
			return TRUE;
		}
	}

	return FALSE;
}

unsigned char uc4_get_main_dispwin_value(unsigned short *x, unsigned short *y, unsigned short *w, unsigned short *h)	//WOSQRTK-7731
{
	if((x !=NULL)&&(y !=NULL)&&(w !=NULL)&&(h !=NULL))
	{
		*x = main_dispwin.srcx;
		*y = main_dispwin.srcy;
		*w = main_dispwin.src_wid;
		*h = main_dispwin.src_height;
	}
	else
		return 1;
	return 0;
}

#if 0
void set_vsc_SetCircle_OutputRegion(KADP_VIDEO_RECT_T outregion, unsigned short W, unsigned short H, UINT32 shape)
{
	//pr_debug("rtk_hal_vsc_SetOutputRegion  x=%d, y=%d, w=%d, h=%d \n", outregion.x, outregion.y, outregion.w, outregion.h);

	//pr_debug("\n ********************* Sub_circle_center_h = %d ", outregion.x+(outregion.w/2));
	//pr_debug("\n ********************* Sub_circle_center_v = %d ", outregion.y+(outregion.h/2));
	//pr_debug("\n ********************* Sub_act_rad_a = %d ", (outregion.w/2 * outregion.w/2));
	//pr_debug("\n ********************* Sub_act_rad_b = %d ", (outregion.h/2 * outregion.h/2));

	ppoverlay_sub_active_rad_a_RBUS           SUB_Active_Red_A_reg;
	ppoverlay_sub_active_rad_b_RBUS           SUB_Active_Red_B_reg;
	ppoverlay_sub_background_rad_a_RBUS ppoverlay_sub_background_rad_a_reg;
	ppoverlay_sub_background_rad_b_RBUS ppoverlay_sub_background_rad_b_reg;
	ppoverlay_sub_den_rad_a_RBUS ppoverlay_sub_den_rad_a_reg;
	ppoverlay_sub_den_rad_b_RBUS ppoverlay_sub_den_rad_b_reg;
	ppoverlay_sub_circle_center_RBUS		SUB_Circle_center_reg;
	int	Circle_x=0, Circle_y=0, Circle_w=0, Circle_h=0;

	unsigned short temp_w=0, temp_h=0;
	unsigned short true_w=0, true_h=0;

	if (outregion.w%2==0)
		temp_w = (outregion.w-1)/2;
	else
		temp_w = (outregion.w)/2;
	true_w = temp_w;

	if (outregion.h%2==0)
		temp_h = (outregion.h-1)/2;
	else
		temp_h = (outregion.h)/2;
	true_h = temp_h;

	if (shape == VSC_MGF_TYPE_CIRCLE)
	{
		if (W%2==0)
			temp_w = (W-1);
		else
			temp_w = (W);

		if (H%2==0)
			temp_h = (H-1);
		else
			temp_h = (H);
	}

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\n ***** 0.SLR_INPUT_DISP_WID=%d ", Scaler_DispGetInputInfoByDisp(1, SLR_INPUT_DISP_WID));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\n ***** 0.SLR_INPUT_DISP_LEN=%d ", Scaler_DispGetInputInfoByDisp(1, SLR_INPUT_DISP_LEN));
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\n ***** 1.set_vsc_OutputRegion  x=%d, y=%d, w=%d, h=%d ", outregion.x, outregion.y, outregion.w, outregion.h);
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\n ***** 2.virtual_w=%d, virtual_h=%d ", W, H);

	if ((outregion.x== 0) && (outregion.y== 0) && (outregion.w >= W) && (outregion.h >= H))
	{
		Circle_x = (int)(outregion.x + outregion.w - W);
		Circle_y = (int)(outregion.y + outregion.h - H);
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\n ***** 3.set_vsc_SetCircleRegion  x=%d, y=%d, w=%d, h=%d ", Circle_x, Circle_y, Circle_w, Circle_h);
	}
	else if ((outregion.x== 0) && (outregion.w >= W) && (outregion.h/2 <=  H))
	{
		Circle_x = (int)(outregion.x + outregion.w - W);
		Circle_y = (int)(outregion.y + H);
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\n ***** 4.set_vsc_SetCircleRegion  x=%d, y=%d, w=%d, h=%d ", Circle_x, Circle_y, Circle_w, Circle_h);
	}
	else if ( (outregion.y== 0) && (outregion.w >= W) && (outregion.h >= H))
	{
		Circle_x = (int)(outregion.x + W);
		Circle_y = (int)(outregion.y + outregion.h - H);
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\n ***** 5.set_vsc_SetCircleRegion  x=%d, y=%d, w=%d, h=%d ", Circle_x, Circle_y, Circle_w, Circle_h);
	}
	else if ( (outregion.y + outregion.h == 2160) && (outregion.h/2 < H))
	{
		Circle_x = (int)(outregion.x + W);
		Circle_y = (int)(outregion.y + H);
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\n ***** 6.set_vsc_SetCircleRegion  x=%d, y=%d, w=%d, h=%d ", Circle_x, Circle_y, Circle_w, Circle_h);
	}
	else if ( (outregion.x + outregion.w == 3840) && (outregion.w/2 < W))
	{
		Circle_x = (int)(outregion.x + W);
		Circle_y = (int)(outregion.y + H);
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\n ***** 7.set_vsc_SetCircleRegion  x=%d, y=%d, w=%d, h=%d ", Circle_x, Circle_y, Circle_w, Circle_h);
	}
	else
	{
		Circle_x = (int)(outregion.x + true_w);
		Circle_y = (int)(outregion.y + true_h);
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\n ***** 8.set_vsc_SetCircleRegion  x=%d, y=%d, w=%d, h=%d ", Circle_x, Circle_y, Circle_w, Circle_h);
	}

	SUB_Active_Red_A_reg.regValue     = IoReg_Read32(PPOVERLAY_SUB_Active_Rad_A_reg);
	SUB_Active_Red_A_reg.sub_act_rad_a= (temp_w*temp_w);
	IoReg_Write32(PPOVERLAY_SUB_Active_Rad_A_reg, SUB_Active_Red_A_reg.regValue);

	SUB_Active_Red_B_reg.regValue     = IoReg_Read32(PPOVERLAY_SUB_Active_Rad_B_reg);
	SUB_Active_Red_B_reg.sub_act_rad_b= (temp_h * temp_h);
	IoReg_Write32(PPOVERLAY_SUB_Active_Rad_B_reg, SUB_Active_Red_B_reg.regValue);

	ppoverlay_sub_background_rad_a_reg.regValue     = IoReg_Read32(PPOVERLAY_SUB_Background_Rad_A_reg);
	ppoverlay_sub_background_rad_a_reg.sub_bg_rad_a= (temp_w*temp_w);
	IoReg_Write32(PPOVERLAY_SUB_Background_Rad_A_reg, ppoverlay_sub_background_rad_a_reg.regValue);

	ppoverlay_sub_background_rad_b_reg.regValue     = IoReg_Read32(PPOVERLAY_SUB_Background_Rad_B_reg);
	ppoverlay_sub_background_rad_b_reg.sub_bg_rad_b= (temp_h * temp_h);
	IoReg_Write32(PPOVERLAY_SUB_Background_Rad_B_reg, ppoverlay_sub_background_rad_b_reg.regValue);

	ppoverlay_sub_den_rad_a_reg.regValue     = IoReg_Read32(PPOVERLAY_SUB_Den_Rad_A_reg);
	ppoverlay_sub_den_rad_a_reg.sub_den_rad_a= (temp_w*temp_w);
	IoReg_Write32(PPOVERLAY_SUB_Den_Rad_A_reg, ppoverlay_sub_den_rad_a_reg.regValue);

	ppoverlay_sub_den_rad_b_reg.regValue     = IoReg_Read32(PPOVERLAY_SUB_Den_Rad_B_reg);
	ppoverlay_sub_den_rad_b_reg.sub_den_rad_b= (temp_h * temp_h);
	IoReg_Write32(PPOVERLAY_SUB_Den_Rad_B_reg, ppoverlay_sub_den_rad_b_reg.regValue);

	if (shape == VSC_MGF_TYPE_CIRCLE)
	{
		SUB_Circle_center_reg.regValue     = IoReg_Read32(PPOVERLAY_SUB_circle_center_reg);
		SUB_Circle_center_reg.sub_circle_center_h= (Circle_x)*2;
		SUB_Circle_center_reg.sub_circle_center_v= (Circle_y)*2;
		SUB_Circle_center_reg.sub_window_form_sel= 1;
		IoReg_Write32(PPOVERLAY_SUB_circle_center_reg, SUB_Circle_center_reg.regValue);
	}
	else
	{
	SUB_Circle_center_reg.regValue     = IoReg_Read32(PPOVERLAY_SUB_circle_center_reg);
	SUB_Circle_center_reg.sub_circle_center_h= (outregion.x+temp_w)*2;
	SUB_Circle_center_reg.sub_circle_center_v= (outregion.y+temp_h)*2;
	SUB_Circle_center_reg.sub_window_form_sel= 0;
	IoReg_Write32(PPOVERLAY_SUB_circle_center_reg, SUB_Circle_center_reg.regValue);
	}
}

void set_vsc_SetMagnifire_shape(UINT32 num)
{

	ppoverlay_sub_circle_center_RBUS		SUB_Circle_center_reg_shape;
	SUB_Circle_center_reg_shape.regValue     = IoReg_Read32(PPOVERLAY_SUB_circle_center_reg);

	if(num==1)
		SUB_Circle_center_reg_shape.sub_window_form_sel= 1;//Circle
	//else if(num==2) //no need in arrow
  	//	SUB_Circle_center_reg.sub_window_form_sel= 2; //arrow
	else
  		SUB_Circle_center_reg_shape.sub_window_form_sel= 0; //rectangle

  	IoReg_Write32(PPOVERLAY_SUB_circle_center_reg, SUB_Circle_center_reg_shape.regValue);

}
#endif

unsigned char check_force_rerun_scaler_condition(unsigned char srctype, unsigned char display)
{
    unsigned char result = FALSE;
    if(display == SLR_MAIN_DISPLAY) {
        if((srctype == VSC_INPUTSRC_HDMI) && (scaler_RGB444Mode_pre != rtk_hal_vsc_GetRGB444Mode()))
            result = TRUE;
    }

#ifdef CONFIG_DUAL_CHANNEL
    else
    {
    }
#endif
    return result;
}

void update_force_rerun_scaler_condition(unsigned char srctype, unsigned char display)
{
    if(display == SLR_MAIN_DISPLAY) {
        if(srctype == VSC_INPUTSRC_HDMI){
            scaler_RGB444Mode_pre = rtk_hal_vsc_GetRGB444Mode();
        }
    }

#ifdef CONFIG_DUAL_CHANNEL
    else
    {
    }
#endif
}

extern unsigned char Scaler_main_imd_pst_get_enable(void);
unsigned char rtk_hal_vsc_SetOutputRegion(VIDEO_WID_T wid, KADP_VIDEO_RECT_T outregion, unsigned short Wide, unsigned short High)
{
	StructSrcRect m_dispwin ; //temp add by will
	VSC_INPUT_TYPE_T srctype;
	unsigned char channel;
	KADP_VIDEO_RECT_T inregion;
	KADP_VIDEO_RECT_T orgInput_Timing;
	unsigned char hal_inputType  = 0;
	unsigned char port_num = 0;
	ppoverlay_dispd_stage1_sm_ctrl_RBUS dispd_stage1_sm_ctrl_reg;
	unsigned char plane=0;
	static unsigned char OutpuLocalDimmingPatMode_pre = FALSE;
	unsigned long flags=0x00;//for spin_lock_irqsave
	//unsigned char avd_small_output_flag = FALSE;
	unsigned char equal_type = NOT_EQUAL;

	extern unsigned char rtk_hal_vsc_dm_connect(unsigned char display, KADP_VSC_HDR_TYPE_T eHdrMode);


	KADP_VIDEO_RECT_T tInputRegion;
	ppoverlay_double_buffer_ctrl_RBUS double_buffer_ctrl_reg;
	KADP_VIDEO_RECT_T magnifiermaininregion;
	KADP_VIDEO_RECT_T magnifiermainoutregion;


#if(LiveZoom_PROFILE == 1)
	magnifierbefore_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
#endif

	//rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "rtk_hal_vsc_SetOutputRegion  x=%d, y=%d, w=%d, h=%d \n", outregion.x, outregion.y, outregion.w, outregion.h);
	//rtd_printk(KERN_EMERG, TAG_NAME_VSC, "rtk_hal_vsc_SetOutputRegion  x=%d, y=%d, w=%d, h=%d \n", outregion.x, outregion.y, outregion.w, outregion.h);
	//frank@0323 add TV006_WB_Pattern_En to support output region function

#ifdef CONFIG_MEMC_BYPASS
	outregion.x = outregion.x/(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_PIXEL_MODE) +1);
	outregion.w = outregion.w/(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_PIXEL_MODE) +1);
	//rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "after memc_bypass rtk_hal_vsc_SetOutputRegion  x=%d, y=%d, w=%d, h=%d \n", outregion.x, outregion.y, outregion.w, outregion.h);
#endif

    if(wid == VIDEO_WID_0)
    {
    	if(1)//Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
    	{
    		rtd_printk(KERN_INFO, TAG_NAME_VSC, "rtk_hal_vsc_SetOutputRegion main output(%d %d %d %d) \n", outregion.x, outregion.y, outregion.w, outregion.h);
    	}
    }
	else
	{
		if(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
    	{
    		rtd_printk(KERN_INFO, TAG_NAME_VSC, "rtk_hal_vsc_SetOutputRegion sub output(%d %d %d %d) \n", outregion.x, outregion.y, outregion.w, outregion.h);
    	}
	}

	if((OutpuLocalDimmingPatMode == TRUE) || (TV006_WB_Pattern_En)){

		osdovl_mixer_ctrl2_RBUS mixer_ctrl2_reg;
		ppoverlay_main_background_h_start_end_RBUS main_background_h_start_end_reg;
		ppoverlay_main_active_h_start_end_RBUS main_active_h_start_end_reg;
		ppoverlay_main_background_v_start_end_RBUS main_background_v_start_end_reg;
		ppoverlay_main_active_v_start_end_RBUS main_active_v_start_end_reg;
		unsigned int timeout=0x3fffff;
		ppoverlay_main_background_color1_RBUS	main_background_color1_reg;
		ppoverlay_main_background_color2_RBUS main_background_color2_reg;
		ppoverlay_main_display_control_rsv_RBUS main_display_control_rsv_reg;
		//ppoverlay_double_buffer_ctrl_RBUS double_buffer_ctrl_reg;
		//ppoverlay_double_buffer_ctrl2_RBUS double_buffer_ctrl2_reg;
		ppoverlay_dispd_smooth_toggle1_RBUS	 dispd_smooth_toggle1_reg;
		if(!TV006_WB_Pattern_En) {
		if((outregion.x ==0)&&(outregion.y == 0)&&(outregion.w == 3840)&&(outregion.h== 2160))
			return TRUE;
		}
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "+++OutpuLocalDimmingPatMode");

		dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
		dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 1;
		IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);

		//set free run timing
		//drivf_scaler_reset_freerun_60Hz();
		//fw_scaler_dtg_double_buffer_enable(TRUE);
		down(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
		spin_lock_irqsave(get_DBreg_spinlock(SLR_MAIN_DISPLAY), flags);//lock double buffer spinlock
		double_buffer_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
		double_buffer_ctrl_reg.dmainreg_dbuf_en = 1;
		IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, double_buffer_ctrl_reg.regValue);
		spin_unlock_irqrestore(get_DBreg_spinlock(SLR_MAIN_DISPLAY), flags);//unlock double buffer spinlock
		up(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
		if(!TV006_WB_Pattern_En){
		// turn off osd mixer
		mixer_ctrl2_reg.regValue = IoReg_Read32(OSDOVL_Mixer_CTRL2_reg);
		mixer_ctrl2_reg.mixer_en = 0;
		IoReg_Write32(OSDOVL_Mixer_CTRL2_reg, mixer_ctrl2_reg.regValue);
		IoReg_Write32(OSDOVL_OSD_Db_Ctrl_reg, 0);
		}

		main_background_h_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Background_H_Start_End_reg);
		main_background_h_start_end_reg.mh_bg_sta = outregion.x;
		main_background_h_start_end_reg.mh_bg_end = outregion.x+outregion.w;
		IoReg_Write32(PPOVERLAY_MAIN_Background_H_Start_End_reg, main_background_h_start_end_reg.regValue);

		main_active_h_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_H_Start_End_reg);
		main_active_h_start_end_reg.mh_act_sta= outregion.x;
		main_active_h_start_end_reg.mh_act_end = outregion.x+outregion.w;
		IoReg_Write32(PPOVERLAY_MAIN_Active_H_Start_End_reg, main_active_h_start_end_reg.regValue);

		main_background_v_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Background_V_Start_End_reg);
		main_background_v_start_end_reg.mv_bg_sta = outregion.y;
		main_background_v_start_end_reg.mv_bg_end = outregion.y+outregion.h;
		IoReg_Write32(PPOVERLAY_MAIN_Background_V_Start_End_reg, main_background_v_start_end_reg.regValue);

		main_active_v_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_V_Start_End_reg);
		main_active_v_start_end_reg.mv_act_sta = outregion.y;
		main_active_v_start_end_reg.mv_act_end = outregion.y+outregion.h;
		IoReg_Write32(PPOVERLAY_MAIN_Active_V_Start_End_reg, main_active_v_start_end_reg.regValue);
		if(!TV006_WB_Pattern_En){
			main_background_color1_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Background_Color1_reg);
			main_background_color2_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Background_Color2_reg);
			main_background_color1_reg.m_bg_b = 0x3fff;
			main_background_color1_reg.m_bg_g = 0x3fff;
			main_background_color2_reg.m_bg_r = 0x3fff;
			IoReg_Write32(PPOVERLAY_Main_Background_Color1_reg, main_background_color1_reg.regValue);
			IoReg_Write32(PPOVERLAY_Main_Background_Color2_reg, main_background_color2_reg.regValue);
			down(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
			spin_lock_irqsave(get_DBreg_spinlock(SLR_MAIN_DISPLAY), flags);//lock double buffer spinlock
			main_display_control_rsv_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Display_Control_RSV_reg);
			main_display_control_rsv_reg.m_force_bg = 1;
			IoReg_Write32(PPOVERLAY_Main_Display_Control_RSV_reg, main_display_control_rsv_reg.regValue);
			spin_unlock_irqrestore(get_DBreg_spinlock(SLR_MAIN_DISPLAY), flags);//unlock double buffer spinlock
			up(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
		}
		dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply=1;
		IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
		do{
			dispd_smooth_toggle1_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_smooth_toggle1_reg);
		}while((dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply==1) && (--timeout));

		if(timeout==0){
			rtd_printk(KERN_INFO, TAG_NAME_VSC, "[%s]WARNING! wait double buf timeout!\n", __FUNCTION__);
			dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply = 0;
			IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
			dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
			dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 0;
			IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
			dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply = 1;
			IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
		}else{
			dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
			dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 0;
			IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
		}

		if(OutpuLocalDimmingPatMode) {
		OutpuLocalDimmingPatMode_pre = TRUE;
		return TRUE;
		}

	}else{

		if(OutpuLocalDimmingPatMode_pre == TRUE){
			ppoverlay_main_background_h_start_end_RBUS main_background_h_start_end_reg;
			ppoverlay_main_background_v_start_end_RBUS main_background_v_start_end_reg;
			ppoverlay_main_active_h_start_end_RBUS main_active_h_start_end_reg;
			ppoverlay_main_active_v_start_end_RBUS main_active_v_start_end_reg;
			ppoverlay_dispd_smooth_toggle1_RBUS	 dispd_smooth_toggle1_reg;
			unsigned int timeout=0x3fffff;

			ppoverlay_dispd_stage1_sm_ctrl_RBUS dispd_stage1_sm_ctrl_reg;
			dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
			dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 1;
			IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);

			down(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
			spin_lock_irqsave(get_DBreg_spinlock(SLR_MAIN_DISPLAY), flags);//lock double buffer spinlock
			double_buffer_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL_reg);
			double_buffer_ctrl_reg.dmainreg_dbuf_en = 1;
			IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL_reg, double_buffer_ctrl_reg.regValue);
			spin_unlock_irqrestore(get_DBreg_spinlock(SLR_MAIN_DISPLAY), flags);//unlock double buffer spinlock
			up(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
			main_background_h_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Background_H_Start_End_reg);
			main_background_h_start_end_reg.mh_bg_sta = Get_DISP_ACT_STA_HPOS();
			main_background_h_start_end_reg.mh_bg_end = Get_DISP_ACT_END_HPOS();
			IoReg_Write32(PPOVERLAY_MAIN_Background_H_Start_End_reg, main_background_h_start_end_reg.regValue);
			main_background_v_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Background_V_Start_End_reg);
			main_background_v_start_end_reg.mv_bg_sta = Get_DISP_ACT_STA_VPOS();
			main_background_v_start_end_reg.mv_bg_end = Get_DISP_ACT_END_VPOS();
			IoReg_Write32(PPOVERLAY_MAIN_Background_V_Start_End_reg, main_background_v_start_end_reg.regValue);
			main_active_h_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_H_Start_End_reg);
			main_active_h_start_end_reg.mh_act_sta= outregion.x;
			main_active_h_start_end_reg.mh_act_end = outregion.x+outregion.w;
			IoReg_Write32(PPOVERLAY_MAIN_Active_H_Start_End_reg, main_active_h_start_end_reg.regValue);
			main_active_v_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_V_Start_End_reg);
			main_active_v_start_end_reg.mv_act_sta = outregion.y;
			main_active_v_start_end_reg.mv_act_end = outregion.y+outregion.h;
			IoReg_Write32(PPOVERLAY_MAIN_Active_V_Start_End_reg, main_active_v_start_end_reg.regValue);
			dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply=1;
			IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
			do{
				dispd_smooth_toggle1_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_smooth_toggle1_reg);
			}while((dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply==1) && (--timeout));

			if(timeout==0){
				rtd_printk(KERN_INFO, TAG_NAME_VSC, "[%s]WARNING! wait double buf timeout!\n", __FUNCTION__);
				dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply = 0;
				IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
				dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
				dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 0;
				IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
				dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply = 1;
				IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
			}else{
				dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
				dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 0;
				IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
			}
			OutpuLocalDimmingPatMode_pre = FALSE;
		}
		else
		OutpuLocalDimmingPatMode_pre = FALSE;

	}



#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	}
#endif
	if (wid ==VIDEO_WID_0) {
		channel = SLR_MAIN_DISPLAY;
	} else if (wid ==VIDEO_WID_1) {
		channel = SLR_SUB_DISPLAY;
	}
	srctype = Get_DisplayMode_Src(channel);

	//rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "rtk_hal_vsc_SetOutputRegion wid=%x  channel=%x\n", wid, channel);

	if(wid == VIDEO_WID_0) {
		down(&Magnifier_Semaphore);
		//if (DbgSclrFlgTkr.LivezoomOffKeepMainForceBG == TRUE) {
			//DbgSclrFlgTkr.LivezoomOffKeepMainForceBG = FALSE;
			//up(&Magnifier_Semaphore);
			//return TRUE;
		//}

		if ((Get_Live_zoom_mode() == LIVE_ZOOM_ON ) && DbgSclrFlgTkr.OuputDisplayMode && DbgSclrFlgTkr.Sub_OuputDisplayMode
			&& (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)) {
				VSC_MAGNIGIER_PARA_T magmsg;
#if 0//livezoom main go pst disbale
				if(Scaler_main_imd_pst_get_enable()== FALSE) {
#ifdef CONFIG_PST_ENABLE
					drvif_scaler_pst_initial(_MAIN_VO_IMD);
					//Scaler_main_imd_pst_set_enable(_ENABLE);
#endif
					//msleep(300);
				}
#endif
#if 1
				if (DbgSclrFlgTkr.LivezoomMainRerunFlag == FALSE) {
					if (main_InputRegion_0000 == 1){
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"main inputregion is 0,0,0,0 \n");
						up(&Magnifier_Semaphore);
						return TRUE;
					}
					DbgSclrFlgTkr.Main_smooth_toggle_set_flag = false;
					DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = FALSE;
					DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag =false;
					DbgSclrFlgTkr.Main_Output_Set_flag = false;
					rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"[livezoom/magnifier][started]Main re run scaler flow self firstly when open pip!!\n");

					// move to reset mode and scaler
					//clear_imd_smooth_toggle_clk_time2switch_en(SLR_MAIN_DISPLAY);
					//set_zoom_reset_double_state(_DISABLE,SLR_MAIN_DISPLAY);
					//set_zoom_reset_double_state(_DISABLE,SLR_SUB_DISPLAY);

					if (Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
					{
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"DbgSclrFlgTkr.magnifier_mainscaler_run_livezoom = true\n");
						DbgSclrFlgTkr.magnifier_mainscaler_run_livezoom = true;
					} else {
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"DbgSclrFlgTkr.magnifier_mainscaler_run_livezoom = false\n");
						DbgSclrFlgTkr.magnifier_mainscaler_run_livezoom = false;
					}

					if (magnifier_voinfo_wait(SLR_MAIN_DISPLAY) == FALSE){
						DbgSclrFlgTkr.magnifier_mainscaler_run_livezoom = false;
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"main wait vo info time out happen in main self\n");
						up(&Magnifier_Semaphore);
						return TRUE;
					}
					magnifier_mainscaler_run(wid, srctype,(VIDEO_RECT_T){0,0,_DISP_WID,_DISP_LEN});

					DbgSclrFlgTkr.magnifier_mainscaler_run_livezoom = false;
					#if 0
					if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE)==_MODE_STATE_ACTIVE))//recheck, timing may under changing
					{
						mute_control(SLR_MAIN_DISPLAY, FALSE);
					}
					#endif
					DbgSclrFlgTkr.LivezoomMainRerunFlag = TRUE;
					DbgSclrFlgTkr.LivezoomMainRerunEndneedOpenforcebgFlag = TRUE;
#if 1// m domain overscan
					rtk_hal_vsc_GetInputRegion(VIDEO_WID_0, &magnifiermaininregion);
					rtk_hal_vsc_GetOutputRegion(VIDEO_WID_0, &magnifiermainoutregion);
					Scaler_DispWindowZoomin(SLR_MAIN_DISPLAY, magnifiermaininregion, magnifiermainoutregion,0,0,FALSE);
#endif
					msleep(100);
					if (DbgSclrFlgTkr.mainVscFreezeFlag) {
						Scaler_SetFreeze(SLR_MAIN_DISPLAY, DbgSclrFlgTkr.mainVscFreezeFlag);
					}
					if (DbgSclrFlgTkr.subVscFreezeFlag) {
						Scaler_SetFreeze(SLR_SUB_DISPLAY, DbgSclrFlgTkr.subVscFreezeFlag);
					}

					if(DbgSclrFlgTkr.LivezoomSubRerunEndneedOpenforcebgFlag&&DbgSclrFlgTkr.LivezoomSubRerunFlag)
					{
						mute_control(SLR_SUB_DISPLAY, FALSE);
						DbgSclrFlgTkr.LivezoomSubRerunEndneedOpenforcebgFlag = FALSE;
					}

					if(DbgSclrFlgTkr.LivezoomMainRerunEndneedOpenforcebgFlag/*&&DbgSclrFlgTkr.LivezoomSubRerunFlag*/)
					{
						mute_control(SLR_MAIN_DISPLAY, FALSE);
						DbgSclrFlgTkr.LivezoomMainRerunEndneedOpenforcebgFlag = FALSE;
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"[livezoom/magnifier]LivezoomMainRerunEndneedOpenforcebg at main!!\n");
					}
					rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"[livezoom/magnifier][ended]Main re run scaler flow self firstly when open pip!!\n");
				} else
#endif
				{
#if 1
					if(DbgSclrFlgTkr.LivezoomSubRerunEndneedOpenforcebgFlag&&DbgSclrFlgTkr.LivezoomSubRerunFlag)
					{
						mute_control(SLR_SUB_DISPLAY, FALSE);
						DbgSclrFlgTkr.LivezoomSubRerunEndneedOpenforcebgFlag = FALSE;
					}

					if(DbgSclrFlgTkr.LivezoomMainRerunEndneedOpenforcebgFlag/*&&DbgSclrFlgTkr.LivezoomSubRerunFlag*/)
					{
						mute_control(SLR_MAIN_DISPLAY, FALSE);
						DbgSclrFlgTkr.LivezoomMainRerunEndneedOpenforcebgFlag = FALSE;
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"[livezoom/magnifier]LivezoomMainRerunEndneedOpenforcebg at main!!\n");
					}
#endif
					/*live zoom md smootoggle flow*/
					set_input_for_vgip(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
					set_input_for_crop(SLR_MAIN_DISPLAY, main_input_size);
					set_input_timing_for_crop(SLR_MAIN_DISPLAY, main_input_timing);
					Scaler_InputRegionType_Set(SLR_MAIN_DISPLAY,getInputRegionType(SLR_MAIN_DISPLAY));
					//FIX ME , pool test
					/*if (((Main_InputRegion_w + Main_InputRegion_x) > Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE))
						|| ((Main_InputRegion_h + Main_InputRegion_y) > (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE) ? 2*Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) : Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE)))) {
						Main_InputRegion_x = 0;
						Main_InputRegion_y = 0;
						Main_InputRegion_w = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE);
						Main_InputRegion_h = (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE) ? 2*Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) : Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE));
					}*/
#if 0
					inregion.x = drvif_memory_get_data_align(Main_InputRegion_x, 4);
					inregion.y = Main_InputRegion_y;
					inregion.w = drvif_memory_get_data_align(Main_InputRegion_w, 4);
					inregion.h = Main_InputRegion_h;
					if ((inregion.x  + inregion.w) > Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE)) {
						inregion.w = inregion.w -4;
					}
#else
					inregion.x = Main_InputRegion_x;
					inregion.y = Main_InputRegion_y;
					inregion.w = Main_InputRegion_w;
					inregion.h = Main_InputRegion_h;
					orgInput_Timing = inregion;
					#ifdef NEW_INPUT_REGION_BASE_ON_HAL_ORIGINAL_INPUT
					inregion.x = Scaler_intputRegion[SLR_MAIN_DISPLAY].srcx;
					inregion.y = Scaler_intputRegion[SLR_MAIN_DISPLAY].srcy;
					inregion.w = Scaler_intputRegion[SLR_MAIN_DISPLAY].src_wid;
					inregion.h = Scaler_intputRegion[SLR_MAIN_DISPLAY].src_height;
					orgInput_Timing.x = Scaler_intputTiming[SLR_MAIN_DISPLAY].srcx;
					orgInput_Timing.y = Scaler_intputTiming[SLR_MAIN_DISPLAY].srcy;
					orgInput_Timing.w = Scaler_intputTiming[SLR_MAIN_DISPLAY].src_wid;
					orgInput_Timing.h = Scaler_intputTiming[SLR_MAIN_DISPLAY].src_height;
					hal_inputType = getInputRegionType(SLR_MAIN_DISPLAY);
					#endif
#endif
#if 1//remove m domain overscan
					magmsg.magnifierWid = wid;
					magmsg.magnifierinregion = inregion;
					magmsg.magnifierinputTiming = orgInput_Timing;
					magmsg.magnifieroutregion = outregion;
					magmsg.inputType = hal_inputType;
					magmsg.W = 0;
					magmsg.H = 0;

//					sub_window_type = 0;
//					set_vsc_SetCircle_OutputRegion(outregion, 0);
					magnifier_message_push(magmsg);
					//Scaler_DispWindowZoomin(SLR_MAIN_DISPLAY, inregion, outregion,FALSE);
#else
					/*livezoom main window change go video fw smoothtoggle*/
					down(&VSC_Semaphore);
					zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, inregion.x, inregion.y, inregion.w, inregion.h, ZOOM_CROP);
					zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, outregion.x, outregion.y, outregion.w, outregion.h, ZOOM_DISP);
					up(&VSC_Semaphore);
#endif
				}
				up(&Magnifier_Semaphore);
		} else {
			up(&Magnifier_Semaphore);

#ifdef SPEEDUP_NEW_SCALER_FLOW
			if(main_InputRegion_0000)
			{
				pr_err("#####[%s(%d)]input is zero, return\n",__func__,__LINE__);
				return TRUE;
			}
#endif
#if 1//def CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
			if ((outregion.w < 1) || (outregion.h < 1)) {
				down(&SetMainOutPutRegion_Semaphore);
				DbgSclrFlgTkr.Main_Output_Set_flag = FALSE;
				main_dispwin.srcx = outregion.x;
				main_dispwin.srcy = outregion.y;
				main_dispwin.src_height = outregion.h;
				main_dispwin.src_wid = outregion.w;
				check_input_and_output_the_same(SLR_MAIN_DISPLAY);
				up(&SetMainOutPutRegion_Semaphore);
				pr_emerg("outputregion is zero, return\n");
				return TRUE;
			}
#endif


			if((srctype == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
			{//For ATV case
				unsigned ucVDTimingChange;
				if ((outregion.w + outregion.x > _DISP_WID) || (outregion.h + outregion.y > _DISP_LEN)) {
					m_dispwin.srcx = 0;
					m_dispwin.srcy = 0;
					m_dispwin.src_height = _DISP_LEN;
					m_dispwin.src_wid = _DISP_WID;
				}else {
					m_dispwin.srcx = outregion.x;
					m_dispwin.srcy = outregion.y;
					m_dispwin.src_height = outregion.h;
					m_dispwin.src_wid = outregion.w;
				}
//				if(DbgSclrFlgTkr.Main_ATV_Go_Smooth_Toggle_flag){//This means that currently force bg is disabled, so directly run scaler flow
				ucVDTimingChange = Scaler_AVD_GetRunSearchState(SLR_MAIN_DISPLAY); // it will not clear ATV run search state flag
#ifdef CONFIG_ENABLE_VD_27MHZ_MODE
#if 1
					if (Get_LivezoomOffMainRunScaler() == TRUE){
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"[livezoom/magnifier][started][ATV]Main re run scaler flow when pip close!!\n");
						down(&VSC_Semaphore);
						set_input_for_vgip(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
						set_input_for_crop(SLR_MAIN_DISPLAY, main_input_size);
						set_input_timing_for_crop(SLR_MAIN_DISPLAY, main_input_timing);
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_LIVEZOOM, TRUE);
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						if(SLR_MAIN_DISPLAY == channel)
							Share_Memory_Set_Scaler_Run_Flag(1);

						Scaler_DispWindowSet(m_dispwin);
						Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
						//zoom_imd_smooth_toggle_config(wid, outregion.x, outregion.y, outregion.w, outregion.h, ZOOM_DISP);
						DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;
#if 1
						if (Scaler_InputSrcGetType(SLR_MAIN_DISPLAY) == _SRC_VO) {
							DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = TRUE;
						}
#endif

						set_current_scaler_source_num(SLR_MAIN_DISPLAY);//record current vsc source num
						rtk_output_connect(SLR_MAIN_DISPLAY);
						up(&VSC_Semaphore);//Rika

						msleep(50);
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_LIVEZOOM, FALSE);
						mute_control(SLR_MAIN_DISPLAY, FALSE);
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "open bg for live zoom off....\n");
						Set_LivezoomOffMainRunScaler(FALSE);
						zoom_clear_input_output_region_record(SLR_MAIN_DISPLAY);
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"[livezoom/magnifier][ended][ATV]Main re run scaler flow when pip close!!\n");
						return TRUE;

					}

#endif
				//if(DbgSclrFlgTkr.Main_ATV_Go_Smooth_Toggle_flag && !ucVDTimingChange && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) && !avd_small_output_flag)
				if(DbgSclrFlgTkr.Main_ATV_Go_Smooth_Toggle_flag && !ucVDTimingChange && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
#else
				if(DbgSclrFlgTkr.Main_ATV_Go_Smooth_Toggle_flag && !ucVDTimingChange && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
#endif
				{//This means that currently force bg is disabled and color std is not changed, so run smooth toggle flow //For Sub black video issue patch will 20151211
					set_input_for_vgip(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
					set_input_for_crop(SLR_MAIN_DISPLAY, main_input_size);
					set_input_timing_for_crop(SLR_MAIN_DISPLAY, main_input_timing);
					Scaler_InputRegionType_Set(SLR_MAIN_DISPLAY,getInputRegionType(SLR_MAIN_DISPLAY));
					rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "2 rtk_hal_vsc_SetOutputRegion  x=%d, y=%d, w=%d, h=%d \n", outregion.x, outregion.y, outregion.w, outregion.h);
					main_dispwin.srcx = m_dispwin.srcx;
					main_dispwin.srcy = m_dispwin.srcy;
					main_dispwin.src_height = m_dispwin.src_height;
					main_dispwin.src_wid = m_dispwin.src_wid;

					//back up output region	//WOSQRTK-6617
					DbgSclrFlgTkr.Main_ATV_OutputRegion_x_pre = outregion.x;
					DbgSclrFlgTkr.Main_ATV_OutputRegion_y_pre = outregion.y;
					DbgSclrFlgTkr.Main_ATV_OutputRegion_w_pre = outregion.w;
					DbgSclrFlgTkr.Main_ATV_OutputRegion_h_pre = outregion.h;

					down(&VSC_Semaphore);
					Scaler_DispWindowSet(m_dispwin);
					rtd_printk(KERN_INFO, TAG_NAME_VSC, "####[%s(%d)] atv smooth toggle#####\r\n", __FUNCTION__,__LINE__);
					Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);

					//zoom_imd_smooth_toggle_config(wid, outregion.x, outregion.y, outregion.w, outregion.h, ZOOM_DISP);
					zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, getInputRegionType(SLR_MAIN_DISPLAY), main_input_size, main_input_timing, main_dispwin);

					up(&VSC_Semaphore);
				} else {//This means that currently force bg is enabled. Need to check run smooth toggle or scaler
					down(&SetMainOutPutRegion_Semaphore);

					if(DbgSclrFlgTkr.Main_ATV_Go_Smooth_Toggle_flag && ucVDTimingChange)//This means that currently force bg is disabled and color std is changed, so directly run scaler flow
					{
						DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;//Special case:mute off=>set ARC have to run
						DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;
						Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "####[%s(%d)] [special case]request atv run main scaler flow atv#####\r\n", __FUNCTION__,__LINE__);
					}
					else{
						if((Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE) && (Scaler_AVD_GetRunSearchState(SLR_MAIN_DISPLAY) == FALSE)) {
							DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;//This is special case for VIP test
							DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;//Let scaler can be run
							rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "####[%s(%d)] no mute on, so request run main scaler flow for atv directly####\r\n",__func__,__LINE__);
						} else {
							DbgSclrFlgTkr.Main_Output_Set_flag = TRUE;//Set output flag for setwinblank to request scaler
						#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
							DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;//Let scaler can be run
						#endif
							rtd_printk(KERN_INFO, TAG_NAME_VSC, "####[%s(%d)] request atv run main scaler flow atv#####\r\n",__func__,__LINE__);
						}
					}
					reset_any_srcrect(&main_dispwin_for_only_xy);
					DbgSclrFlgTkr.Main_ATV_PassThrought_output_flag = TRUE;//in ATV set this flag to check ATV will run scaler flow.
					main_dispwin.srcx = m_dispwin.srcx;
					main_dispwin.srcy = m_dispwin.srcy;
					main_dispwin.src_height = m_dispwin.src_height;
					main_dispwin.src_wid = m_dispwin.src_wid;

					//back up output region	//WOSQRTK-6617
					DbgSclrFlgTkr.Main_ATV_OutputRegion_x_pre = outregion.x;
					DbgSclrFlgTkr.Main_ATV_OutputRegion_y_pre = outregion.y;
					DbgSclrFlgTkr.Main_ATV_OutputRegion_w_pre = outregion.w;
					DbgSclrFlgTkr.Main_ATV_OutputRegion_h_pre = outregion.h;

					if (DbgSclrFlgTkr.main_opensourceID == _UNKNOWN_INPUT) {
						set_source_info_forPQ(SLR_MAIN_DISPLAY);//Set source info for PQ request befor scaler
					}
					up(&SetMainOutPutRegion_Semaphore);
				}
				complete(&vsc_scaler_tsk_completion);
				return TRUE;
			}
			if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
			{
				if (srctype == VSC_INPUTSRC_VDEC || srctype == VSC_INPUTSRC_JPEG)
				{
					port_num = Get_DisplayMode_Port(SLR_MAIN_DISPLAY);

					if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
					{
						down(get_vo_infosemaphore());
						if(get_vo_change_flag(port_num))
						{
							up(get_vo_infosemaphore());
							if (Get_vo_smoothtoggle_timingchange_flag(SLR_MAIN_DISPLAY)) {
								if(get_vo_run_smooth_toggle_enable(SLR_MAIN_DISPLAY)) {
								} else {
									if (get_vo_smoothtoggle_state(SLR_MAIN_DISPLAY) == SLR_SMOOTH_TOGGLE_ACTIVE) {
										plane = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_VODMA_PLANE);;
										//vo_force_data_mode_set_enable(vo_force_data_mode_get_enable(SLR_MAIN_DISPLAY), SLR_MAIN_DISPLAY);
										set_vo_smoothtoggle_state(SLR_SMOOTH_TOGGLE_INIT, SLR_MAIN_DISPLAY,plane);
										smooth_toggle_state_info_rpc(SLR_MAIN_DISPLAY);
										rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "set_vo_smoothtoggle_state=SLR_SMOOTH_TOGGLE_INIT\n");
									}
									if(SLR_MAIN_DISPLAY == (SCALER_DISP_CHANNEL)wid)
										Share_Memory_Set_Scaler_Run_Flag(1);
									rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "\r\n####Voinfo is change. Active to search 1####\r\n");
									Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
								}
							} else {
								rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "\r\n####Voinfo is change. Active to search 2####\r\n");
								Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
							}
						} else {
							up(get_vo_infosemaphore());
						}

					}
					if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_SEARCH) {
						down(&SetMainOutPutRegion_Semaphore);
						reset_any_srcrect(&main_dispwin_pre); //Need to Reste previous output value. For run scaler flow
						up(&SetMainOutPutRegion_Semaphore);
					}
				}
			}
			if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE && get_3D_mode_enable())
			{
				Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
				down(&SetMainOutPutRegion_Semaphore);
				reset_any_srcrect(&main_dispwin_pre); //Need to Reste previous output value. For run scaler flow
				up(&SetMainOutPutRegion_Semaphore);
			}

			if ((outregion.w + outregion.x > _DISP_WID) || (outregion.h + outregion.y > _DISP_LEN)) {
				m_dispwin.srcx = 0;
				m_dispwin.srcy = 0;
				m_dispwin.src_height = _DISP_LEN;
				m_dispwin.src_wid = _DISP_WID;
			}else {
				m_dispwin.srcx = outregion.x;
				m_dispwin.srcy = outregion.y;
				m_dispwin.src_height = outregion.h;
				m_dispwin.src_wid = outregion.w;
			}
			if (((srctype == VSC_INPUTSRC_VDEC) ||(((srctype == VSC_INPUTSRC_HDMI)&& (get_HDMI_HDR_mode() ==HDR_DOLBY_HDMI)) || (get_HDMI_HDR_mode() ==HDR_HDR10_HDMI))) && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)) {
				Scaler_data_frc_fs_change_adjust_outputregion(SLR_MAIN_DISPLAY,m_dispwin.src_height);
			}
#if 0
			if ((srctype == VSC_INPUTSRC_JPEG) && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)) {
				ppoverlay_main_active_h_start_end_RBUS main_active_h_start_end_reg;
				ppoverlay_main_active_v_start_end_RBUS main_active_v_start_end_reg;
				main_active_h_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_H_Start_End_reg);/* Main Active H pos*/
				main_active_v_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_V_Start_End_reg);

				if((m_dispwin.src_wid != (main_active_h_start_end_reg.mh_act_end - main_active_h_start_end_reg.mh_act_sta))||
				(m_dispwin.src_height != (main_active_v_start_end_reg.mv_act_end - main_active_v_start_end_reg.mv_act_sta))) {
					Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
					down(&SetMainOutPutRegion_Semaphore);
					reset_any_srcrect(&main_dispwin_pre); //Need to Reste previous output value. For run scaler flow
					up(&SetMainOutPutRegion_Semaphore);
				}
			}
#endif

#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
			if ((get_rotate_mode()!=rotate_mode) &&((get_rotate_mode()!=DIRECT_VO_FRAME_ORIENTATION_DEFAULT) ||(rotate_mode!=0)))
			{
				if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
				{
					pr_emerg("[Qing]output rotate run=%d,%d\n",get_rotate_mode(),rotate_mode);
					down(&SetMainOutPutRegion_Semaphore);
					reset_any_srcrect(&main_dispwin_for_only_xy);
					main_dispwin.srcx = m_dispwin.srcx;
					main_dispwin.srcy = m_dispwin.srcy;
					main_dispwin.src_wid = m_dispwin.src_wid;
					main_dispwin.src_height = m_dispwin.src_height;
					if (rotate_mode == DIRECT_VO_FRAME_ORIENTATION_ROTATE_0) {
						DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = TRUE;
					}
					if (Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE) {
						ppoverlay_main_display_control_rsv_RBUS main_display_control_rsv_reg;
						DbgSclrFlgTkr.rotate_run_scaler_flag = TRUE;
						DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;
						up(&SetMainOutPutRegion_Semaphore);
						rtd_printk(KERN_EMERG, TAG_NAME_VSC,"[Rotate]active case run rotate scaler\n");
						main_display_control_rsv_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Display_Control_RSV_reg);
						if (!main_display_control_rsv_reg.m_force_bg) {
							rtd_printk(KERN_EMERG, TAG_NAME_VSC,"[Rotate]force to forcbg \n");
							down(get_forcebg_semaphore());
							scalerdisplay_force_bg_enable(SLR_MAIN_DISPLAY, TRUE);
							up(get_forcebg_semaphore());
						}
					} else {
						DbgSclrFlgTkr.rotate_muteoff_request_flag = TRUE;
						//DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;
						up(&SetMainOutPutRegion_Semaphore);
						rtd_printk(KERN_EMERG, TAG_NAME_VSC,"[Rotate] active case mute off go rotate\n");
					}
				} else {
					down(&SetMainOutPutRegion_Semaphore);
					reset_any_srcrect(&main_dispwin_for_only_xy);
					main_dispwin.srcx = m_dispwin.srcx;
					main_dispwin.srcy = m_dispwin.srcy;
					main_dispwin.src_wid = m_dispwin.src_wid;
					main_dispwin.src_height = m_dispwin.src_height;
					if(check_input_and_output_the_same(SLR_MAIN_DISPLAY) == FALSE)
					{
						if(SLR_MAIN_DISPLAY == (SCALER_DISP_CHANNEL)wid)
							Share_Memory_Set_Scaler_Run_Flag(1);
						DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = TRUE;

						if (DbgSclrFlgTkr.main_opensourceID == _UNKNOWN_INPUT) {
							set_source_info_forPQ(SLR_MAIN_DISPLAY);//Set source info for PQ request befor scaler
						}

						DbgSclrFlgTkr.rotate_muteoff_request_flag = TRUE;
						DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;
						rtd_printk(KERN_EMERG, TAG_NAME_VSC,"[Rotate] search case mute off go rotate\n");
					}
					up(&SetMainOutPutRegion_Semaphore);
				}
			}else
#endif
			if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) && (DbgSclrFlgTkr.OuputDisplayMode || DbgSclrFlgTkr.OutputMemoryMode)) {
				if ((outregion.w == 0) || (outregion.h == 0)) {
					/*if main output region all are zero, do nothing @Crixus 20160118*/
					/*
					down(get_forcebg_semaphore());
					drvif_scalerdisplay_enable_display(SLR_MAIN_DISPLAY, _DISABLE);
					up(get_forcebg_semaphore());
					main_wind0000 = TRUE;
					*/
				} else {
					down(&SetMainOutPutRegion_Semaphore);

					main_dispwin.srcx = m_dispwin.srcx;
					main_dispwin.srcy = m_dispwin.srcy;
					main_dispwin.src_wid = m_dispwin.src_wid;
					main_dispwin.src_height = m_dispwin.src_height;
#if 1
					if (Get_LivezoomOffMainRunScaler() == TRUE){
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"[livezoom/magnifier][started]Main re run scaler flow when pip close!!\n");
						up(&SetMainOutPutRegion_Semaphore);
						down(&VSC_Semaphore);
						set_input_for_vgip(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
						set_input_for_crop(SLR_MAIN_DISPLAY, main_input_size);
						set_input_timing_for_crop(SLR_MAIN_DISPLAY, main_input_timing);
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_LIVEZOOM, TRUE);
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						if(SLR_MAIN_DISPLAY == channel)
							Share_Memory_Set_Scaler_Run_Flag(1);

						Scaler_DispWindowSet(m_dispwin);
						Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
						//zoom_imd_smooth_toggle_config(wid, outregion.x, outregion.y, outregion.w, outregion.h, ZOOM_DISP);
#if 0//if should run back data framesync,should let vo do smoothtoggle
						if ((drvif_HDR_get_VO_Decompress_Status(Get_DisplayMode_Port(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY)))==FALSE)&&(DbgSclrFlgTkr.DataFramesynclivezoom == TRUE)) {
							int timeout = 50;
							if (vo_overscan_adjust(srctype)) {
								msleep(20);
								timeout = 50;
								while (timeout--) {
									if(get_vo_change_flag(Get_DisplayMode_Port(SLR_MAIN_DISPLAY))) {
										break;
									}
									msleep(10);
								}
								rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####func:%s disable VO overscan case. timeout:%d#####\r\n", __FUNCTION__, timeout);
							}
						}
#endif
						DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;
						if (Scaler_InputSrcGetType(SLR_MAIN_DISPLAY) == _SRC_VO) {
							DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = TRUE;
						}

						set_current_scaler_source_num(SLR_MAIN_DISPLAY);//record current vsc source num
						rtk_output_connect(SLR_MAIN_DISPLAY);
						up(&VSC_Semaphore);//Rika

						msleep(50);
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_LIVEZOOM, FALSE);
						zoom_clear_input_output_region_record(SLR_MAIN_DISPLAY);
						mute_control(SLR_MAIN_DISPLAY, FALSE);
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "open bg for live zoom off....\n");
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"[livezoom/magnifier][ended]Main re run scaler flow when pip close!!\n");
					}

#if 0//def CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
					else if (Get_rotate_function() && (Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == TRUE)) {
						DbgSclrFlgTkr.Main_Output_Set_flag = TRUE;//Set output flag for setwinblank to request scaler
						Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE,_MODE_STATE_SEARCH);
						up(&SetMainOutPutRegion_Semaphore);
						}
#endif
#endif
					if((srctype != VSC_INPUTSRC_AVD) && ((equal_type = check_only_xy_shift_case(SLR_MAIN_DISPLAY, &main_input_size_pre, &main_input_timing_pre, &main_dispwin_for_only_xy)) != 0)//need to updatemain_input_size_pre and main_dispwin_for_only_xy always
						&& (Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE)
#ifdef CONFIG_PST_ENABLE
						&& (Scaler_main_imd_pst_get_enable()==FALSE)
#endif
						){
						up(&SetMainOutPutRegion_Semaphore);
					#if 1 //def CONFIG_ALL_SOURCE_DATA_FS
						if ((srctype == VSC_INPUTSRC_VDEC) &&  Scaler_get_data_framesync(SLR_MAIN_DISPLAY)
							&& (equal_type == ONLY_SHIFT_XY || equal_type == ONLY_SHIFT_Y)) {
							down(&VSC_Semaphore);
							zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, getInputRegionType(SLR_MAIN_DISPLAY), main_input_size, main_input_timing, main_dispwin);
							up(&VSC_Semaphore);
						} else
					#endif
						{
							rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "apply_only_xy_shift...\n");
							apply_only_xy_shift(SLR_MAIN_DISPLAY, main_input_size, main_input_timing, main_dispwin_for_only_xy);
						}
					} else {
						if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE){

							rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####func:%s line:%d request run smooth toggle flow####\r\n", __FUNCTION__, __LINE__);
							DbgSclrFlgTkr.Main_smooth_toggle_set_flag = TRUE;
						} else {
							rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####func:%s line:%d request mute off to run smooth toggle####\r\n", __FUNCTION__, __LINE__);
							DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag = TRUE;
						}
						up(&SetMainOutPutRegion_Semaphore);

					}
					/*if main output region all are zero, do nothing @Crixus 20160118*/
					/*
					if(main_wind0000 == TRUE) {
						down(get_forcebg_semaphore());
						drvif_scalerdisplay_enable_display(SLR_MAIN_DISPLAY, _ENABLE);
						up(get_forcebg_semaphore());
						main_wind0000 = FALSE;
					}
					*/
				}
			}
			else if (DbgSclrFlgTkr.OutputVencMode || DbgSclrFlgTkr.OutputMemoryMode || DbgSclrFlgTkr.OutputAveMode || DbgSclrFlgTkr.OuputDisplayMode) {
				down(&SetMainOutPutRegion_Semaphore);
				reset_any_srcrect(&main_dispwin_for_only_xy);
				main_dispwin.srcx = m_dispwin.srcx;
				main_dispwin.srcy = m_dispwin.srcy;
				main_dispwin.src_height = m_dispwin.src_height;
				main_dispwin.src_wid = m_dispwin.src_wid;
                if(check_force_rerun_scaler_condition(srctype, SLR_MAIN_DISPLAY) == TRUE){
					rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "\r\n####[SEARCH] condition changed[RGB444 %d/%d], so force re-run scaler####\r\n", scaler_RGB444Mode_pre , rtk_hal_vsc_GetRGB444Mode());
					DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;//trigger run scaler
					DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;//Let scaler can be run
					vsc_force_rerun_main_scaler = TRUE;
					update_force_rerun_scaler_condition(srctype, SLR_MAIN_DISPLAY);
				}
				else if(check_input_and_output_the_same(SLR_MAIN_DISPLAY) == FALSE) {
					if(SLR_MAIN_DISPLAY == (SCALER_DISP_CHANNEL)wid)
						Share_Memory_Set_Scaler_Run_Flag(1);
					DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = TRUE;
					if((Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE)) {
						DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;//This is special case for VIP test
						DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;//Let scaler can be run
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "\r\n####no mute on, so request run main scaler flow directly####\r\n");
					} else {
#ifdef SPEEDUP_NEW_SCALER_FLOW
						if((srctype == VSC_INPUTSRC_HDMI) && vfe_hdmi_drv_timing_ready())
						{
							DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;//directly to run scaler
							rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "\r\n####func:%s hdmi directly run main scaler flow#####\r\n", __FUNCTION__);
						}
						else
						{
							DbgSclrFlgTkr.Main_Output_Set_flag = TRUE;//Set output flag for setwinblank to request scaler
							rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "\r\n####func:%s src:%d request run main scaler flow#####\r\n", __FUNCTION__, srctype);
						}
						DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;//Let scaler can be run
#else
						DbgSclrFlgTkr.Main_Output_Set_flag = TRUE;//Set output flag for setwinblank to request scaler
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "\r\n####func:%s src:%d request run main scaler flow#####\r\n", __FUNCTION__, srctype);
#endif
					}
					if (DbgSclrFlgTkr.main_opensourceID == _UNKNOWN_INPUT) {
						set_source_info_forPQ(SLR_MAIN_DISPLAY);//Set source info for PQ request befor scaler
					}

					complete(&vsc_scaler_tsk_completion);
				} else {
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####func:%s src:%d main the input and output is the same#####\r\n", __FUNCTION__, srctype);
				}
				if(srctype == VSC_INPUTSRC_JPEG) {
					DbgSclrFlgTkr.JPEG_Scaler_SM = 1;
				} else {
					DbgSclrFlgTkr.JPEG_Scaler_SM = 0;
				}
				up(&SetMainOutPutRegion_Semaphore);

			}
			if (Get_LivezoomOffMainRunScaler() == TRUE) {
				Set_LivezoomOffMainRunScaler(FALSE);
			}

		}
	}
	else if (wid == VIDEO_WID_1)
	{
#ifdef CONFIG_DUAL_CHANNEL
		down(&Magnifier_Semaphore);
		if ((Get_Live_zoom_mode() == LIVE_ZOOM_ON ) && (Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) && DbgSclrFlgTkr.Sub_OuputDisplayMode) {
#if 1
			if(DbgSclrFlgTkr.LivezoomMainRerunEndneedOpenforcebgFlag && DbgSclrFlgTkr.LivezoomMainRerunFlag)
			{
				mute_control(SLR_MAIN_DISPLAY, FALSE);
				DbgSclrFlgTkr.LivezoomMainRerunEndneedOpenforcebgFlag = FALSE;
				rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"[livezoom/magnifier]LivezoomMainRerunEndneedOpenforcebg at sub!!\n");
			}
#endif
			//magnifier md smootoggle flow
			if ((outregion.w == 0) || (outregion.h == 0))
			{
				sub_dispwin.srcx = 0;
				sub_dispwin.srcy = 0;
				sub_dispwin.src_height = 0;
				sub_dispwin.src_wid = 0;
				Scaler_SubDispWindowSet(sub_dispwin);
				down(get_forcebg_semaphore());
				drvif_scalerdisplay_subdisplay_hidenfunc(_ENABLE);
				up(get_forcebg_semaphore());
				DbgSclrFlgTkr.sub_wind0000 = TRUE;

			} else {
				VSC_MAGNIGIER_PARA_T magmsg;

				if ((outregion.w + outregion.x > _DISP_WID) || (outregion.h + outregion.y > _DISP_LEN)) {
					outregion.x = 0;
					outregion.y = 0;
					outregion.h = _DISP_LEN;
					outregion.w = _DISP_WID;
				}

				set_input_for_vgip(SLR_SUB_DISPLAY, sub_input_size.srcx, sub_input_size.srcy, sub_input_size.src_wid, sub_input_size.src_height);
				set_input_for_crop(SLR_SUB_DISPLAY, sub_input_size);
				set_input_timing_for_crop(SLR_SUB_DISPLAY, sub_input_timing);
				Scaler_InputRegionType_Set(SLR_SUB_DISPLAY,getInputRegionType(SLR_SUB_DISPLAY));
				//FIX ME , pool test
				/*if (((Sub_InputRegion_w + Sub_InputRegion_x) > Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE))
					|| ((Sub_InputRegion_h + Sub_InputRegion_y) > (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE) ? 2*Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) : Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE)))) {
					Sub_InputRegion_x = 0;
					Sub_InputRegion_y = 0;
					Sub_InputRegion_w = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE);
					Sub_InputRegion_h = (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE) ? 2*Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) : Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE));
				}*/

#if 0
				inregion.x = drvif_memory_get_data_align(Sub_InputRegion_x, 4);
				inregion.y = Sub_InputRegion_y;
				inregion.w = drvif_memory_get_data_align(Sub_InputRegion_w, 4);
				inregion.h = Sub_InputRegion_h;
				if ((inregion.x  + inregion.w) > Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE)) {
					inregion.w = inregion.w -4;
				}
#else
				inregion.x = Sub_InputRegion_x;
				inregion.y = Sub_InputRegion_y;
				inregion.w = Sub_InputRegion_w;
				inregion.h = Sub_InputRegion_h;
				orgInput_Timing = inregion;
				#ifdef NEW_INPUT_REGION_BASE_ON_HAL_ORIGINAL_INPUT
				inregion.x = Scaler_intputRegion[SLR_SUB_DISPLAY].srcx;
				inregion.y = Scaler_intputRegion[SLR_SUB_DISPLAY].srcy;
				inregion.w = Scaler_intputRegion[SLR_SUB_DISPLAY].src_wid;
				inregion.h = Scaler_intputRegion[SLR_SUB_DISPLAY].src_height;
				orgInput_Timing.x = Scaler_intputTiming[SLR_SUB_DISPLAY].srcx;
				orgInput_Timing.y = Scaler_intputTiming[SLR_SUB_DISPLAY].srcy;
				orgInput_Timing.w = Scaler_intputTiming[SLR_SUB_DISPLAY].src_wid;
				orgInput_Timing.h = Scaler_intputTiming[SLR_SUB_DISPLAY].src_height;
				hal_inputType = getInputRegionType(wid);
				#endif
#endif


				//set_vsc_SetMagnifire_shape(1);
				magmsg.magnifierWid = wid;
				magmsg.magnifierinregion = inregion;
				magmsg.magnifierinputTiming = orgInput_Timing;
				magmsg.magnifieroutregion = outregion;
				magmsg.inputType = hal_inputType;
				magmsg.W = Wide;
				magmsg.H = High;

//					set_vsc_SetCircle_OutputRegion(outregion, 1);
				//sub_window_type = 1;
				magnifier_message_push(magmsg);
				/*Scaler_DispWindowZoomin(SLR_SUB_DISPLAY, inregion, outregion,TRUE);*/


				if(DbgSclrFlgTkr.sub_wind0000 == TRUE) {
					down(get_forcebg_semaphore());
					drvif_scalerdisplay_subdisplay_hidenfunc( _DISABLE);
					up(get_forcebg_semaphore());
					DbgSclrFlgTkr.sub_wind0000 = FALSE;
				}
			}
			up(&Magnifier_Semaphore);
		} else if (DbgSclrFlgTkr.Sub_OuputDisplayMode && (Get_Live_zoom_mode() == LIVE_ZOOM_ON )
			/*&& (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)*/) {
			if ((outregion.w == 0) || (outregion.h == 0)) {
				sub_dispwin.srcx = 0;
				sub_dispwin.srcy = 0;
				sub_dispwin.src_height = 0;
				sub_dispwin.src_wid = 0;
				Scaler_SubDispWindowSet(sub_dispwin);
#if 0
				if (Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) {
					down(get_forcebg_semaphore());
					drvif_scalerdisplay_subdisplay_hidenfunc( _ENABLE);
					up(get_forcebg_semaphore());
					DbgSclrFlgTkr.sub_wind0000 = TRUE;
				} else {
					mute_control(SLR_MAIN_DISPLAY, FALSE);
				}
#else
#if 1/*remove main scaler flow */
				if ((DbgSclrFlgTkr.Main_Output_Set_flag == TRUE)||(DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag==TRUE)) {
					DbgSclrFlgTkr.Main_Output_Set_flag = FALSE;
					DbgSclrFlgTkr.Main_smooth_toggle_set_flag = false;
					DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = FALSE;
					DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag =false;
					if (DbgSclrFlgTkr.LivezoomMainRerunFlag == FALSE) {
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"[livezoom/magnifier][started]00Main re run scaler flow by sub firstly when open pip!!\n");
						/*re run main scaler start*/
						if (magnifier_voinfo_wait(SLR_SUB_DISPLAY) == FALSE){
							rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"main wait vo info time out happen11\n");
							set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_LIVEZOOM, FALSE);
							up(&Magnifier_Semaphore);
							return FALSE;
						}
						magnifier_mainscaler_run(wid, srctype, (VIDEO_RECT_T){0,0,_DISP_WID,_DISP_LEN});

						rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"[livezoom/magnifier][ended]00Main re run scaler flow by sub firstly when open pip!!\n");
						DbgSclrFlgTkr.LivezoomMainRerunFlag = TRUE;
						DbgSclrFlgTkr.LivezoomMainRerunEndneedOpenforcebgFlag = TRUE;
					}
#if 1// m domain overscan
					rtk_hal_vsc_GetInputRegion(VIDEO_WID_0, &magnifiermaininregion);
					rtk_hal_vsc_GetOutputRegion(VIDEO_WID_0, &magnifiermainoutregion);
					Scaler_DispWindowZoomin(SLR_MAIN_DISPLAY, magnifiermaininregion, magnifiermainoutregion,0,0,FALSE);
#endif
#if 0
					if(DbgSclrFlgTkr.LivezoomMainRerunEndneedOpenforcebgFlag)
					{
						mute_control(SLR_MAIN_DISPLAY, FALSE);
						DbgSclrFlgTkr.LivezoomMainRerunEndneedOpenforcebgFlag = FALSE;
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"[livezoom/magnifier]11LivezoomMainRerunEndneedOpenforcebg at sub!!\n");
					}
#endif
				}
#endif

#endif
			} else {
				if ((outregion.w + outregion.x > _DISP_WID) || (outregion.h + outregion.y > _DISP_LEN)) {
					outregion.x = 0;
					outregion.y = 0;
					outregion.h = _DISP_LEN;
					outregion.w = _DISP_WID;
				}
				sub_dispwin.srcx = outregion.x;
				sub_dispwin.srcy = outregion.y;
				sub_dispwin.src_height = outregion.h;
				sub_dispwin.src_wid = outregion.w;
				Scaler_SubDispWindowSet(sub_dispwin);

				/*let main go 8 bit and 422 cap, main and sub should keep the same format for switch buffer*/
				//clear_imd_smooth_toggle_clk_time2switch_en(SLR_MAIN_DISPLAY);
				//imd_smooth_enable_main_double_buffer(FALSE);
				//imd_smooth_enable_sub_double_buffer(FALSE);
				//set_zoom_reset_double_state(_DISABLE,SLR_MAIN_DISPLAY);
				//set_zoom_reset_double_state(_DISABLE,SLR_SUB_DISPLAY);
				set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_LIVEZOOM, TRUE);

#if 1/*remove main scaler flow */
				if ((DbgSclrFlgTkr.Main_Output_Set_flag == TRUE)||(DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag==TRUE)) {
					DbgSclrFlgTkr.Main_Output_Set_flag = FALSE;
					DbgSclrFlgTkr.Main_smooth_toggle_set_flag = false;
					DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = FALSE;
					DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag =false;
					if (DbgSclrFlgTkr.LivezoomMainRerunFlag == FALSE) {
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"[livezoom/magnifier][started]11Main re run scaler flow by sub firstly when open pip!!\n");
						/*re run main scaler start*/
						if (magnifier_voinfo_wait(SLR_SUB_DISPLAY) == FALSE){
							rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"main wait vo info time out happen11\n");
							set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_LIVEZOOM, FALSE);
							up(&Magnifier_Semaphore);
							return FALSE;
						}
						magnifier_mainscaler_run(wid, srctype, (VIDEO_RECT_T){0,0,_DISP_WID,_DISP_LEN});

						rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"[livezoom/magnifier][ended]11Main re run scaler flow by sub firstly when open pip!!\n");
						DbgSclrFlgTkr.LivezoomMainRerunFlag = TRUE;
						DbgSclrFlgTkr.LivezoomMainRerunEndneedOpenforcebgFlag = TRUE;
					}
#if 1// m domain overscan
					rtk_hal_vsc_GetInputRegion(VIDEO_WID_0, &magnifiermaininregion);
					rtk_hal_vsc_GetOutputRegion(VIDEO_WID_0, &magnifiermainoutregion);
					Scaler_DispWindowZoomin(SLR_MAIN_DISPLAY, magnifiermaininregion, magnifiermainoutregion,0,0,FALSE);
#endif
#if 0
					if(DbgSclrFlgTkr.LivezoomMainRerunEndneedOpenforcebgFlag)
					{
						mute_control(SLR_MAIN_DISPLAY, FALSE);
						DbgSclrFlgTkr.LivezoomMainRerunEndneedOpenforcebgFlag = FALSE;
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"[livezoom/magnifier]11LivezoomMainRerunEndneedOpenforcebg at sub!!\n");
					}
#endif
				}
#endif
#if 1/*k4lp main sub no relationship, so no need run main scaler firstly for sub*/
				else /*if (((Get_Magnifier_LiveZoom_Mode()==VSC_SUB_PURPOSE_LIVE_ZOOM)&&(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_SEARCH))
					||((Get_Magnifier_LiveZoom_Mode()==VSC_SUB_PURPOSE_MAGNIFIER)))*/{
					if (DbgSclrFlgTkr.LivezoomMainRerunFlag == FALSE) {
						DbgSclrFlgTkr.Main_smooth_toggle_set_flag = false;
						DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = FALSE;
						DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag =false;
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"[livezoom/magnifier][started]22Main re run scaler flow by sub firstly when open pip!!\n");
						/*re run main scaler start*/
						if (magnifier_voinfo_wait(SLR_SUB_DISPLAY) == FALSE) {
							rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"main wait vo info time out happen22\n");
							set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_LIVEZOOM, FALSE);
							up(&Magnifier_Semaphore);
							return FALSE;
						}

						magnifier_mainscaler_run(wid, srctype, (VIDEO_RECT_T){0,0,_DISP_WID,_DISP_LEN});
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"[livezoom/magnifier][ended]22Main re run scaler flow by sub firstly when open pip!!\n");
						DbgSclrFlgTkr.LivezoomMainRerunFlag = TRUE;
						DbgSclrFlgTkr.LivezoomMainRerunEndneedOpenforcebgFlag = TRUE;
#if 0
						if(DbgSclrFlgTkr.LivezoomMainRerunEndneedOpenforcebgFlag)
						{
							mute_control(SLR_MAIN_DISPLAY, FALSE);
							DbgSclrFlgTkr.LivezoomMainRerunEndneedOpenforcebgFlag = FALSE;
							rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"[livezoom/magnifier]22LivezoomMainRerunEndneedOpenforcebg at sub!!\n");
						}
#endif
					}
				}
#if 0 //LiveZoom_MainMuteAtSub_Flag
				else {
					mute_control(SLR_MAIN_DISPLAY, TRUE);
					DbgSclrFlgTkr.LivezoomMainRerunEndneedOpenforcebgFlag = TRUE;
					rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"[livezoom/magnifier]main forcebg for main and sub mute at the same time\n");

				}
#endif
#endif

				set_input_for_vgip(SLR_SUB_DISPLAY, sub_input_size.srcx, sub_input_size.srcy, sub_input_size.src_wid, sub_input_size.src_height);
				set_input_for_crop(SLR_SUB_DISPLAY, sub_input_size);
				set_input_timing_for_crop(SLR_SUB_DISPLAY, sub_input_timing);
				Scaler_InputRegionType_Set(SLR_SUB_DISPLAY,getInputRegionType(SLR_SUB_DISPLAY));
				//FIX ME , pool test
				/*if (((Sub_InputRegion_w + Sub_InputRegion_x) > Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE))
					|| ((Sub_InputRegion_h + Sub_InputRegion_y) > (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE) ? 2*Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) : Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE)))) {
					Sub_InputRegion_x = 0;
					Sub_InputRegion_y = 0;
					Sub_InputRegion_w = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE);
					Sub_InputRegion_h = (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE) ? 2*Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) : Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE));
				}*/
				rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"[livezoom/magnifier][started]sub run scaler flow by self when open pip!!\n");
				mute_control(SLR_SUB_DISPLAY, TRUE);
#if 0
				if (Get_Magnifier_LiveZoom_Mode()==VSC_SUB_PURPOSE_LIVE_ZOOM) {
					/*livezoom, sub disp sub*/
					sub_window_type = 0;
				}
#endif
#if 0
				if (magnifier_voinfo_wait(SLR_SUB_DISPLAY) == FALSE){
					up(&Magnifier_Semaphore);
					return FALSE;
				}
#endif
				down(&VSC_Semaphore);
				DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;
				set_current_scaler_source_num(SLR_SUB_DISPLAY);//record current vsc source num
				rtk_output_connect(SLR_SUB_DISPLAY);
				up(&VSC_Semaphore);
				DbgSclrFlgTkr.LivezoomSubRerunFlag = TRUE;
				DbgSclrFlgTkr.LivezoomSubRerunEndneedOpenforcebgFlag = TRUE;

				//change main M-domain to 3-buffer
				down(&GameMode_Check_Semaphore);
				if((drv_memory_get_game_mode() == _ENABLE)
					&& ((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_ADC) || (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) ||((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD)  && (get_AVD_Input_Source() != _SRC_TV)))){
					drv_memory_GameMode_Switch_TripleBuffer();
					rtd_printk(KERN_DEBUG, TAG_NAME_NEW_GAME_MODE, "enter livezoom, change to 3-buffer\n");
				}
				up(&GameMode_Check_Semaphore);
#if 1// m domain overscan
				if (Get_Magnifier_LiveZoom_Mode()==KADP_VSC_SUB_PURPOSE_MAGNIFIER) {
					/*magnifier, sub disp change to main buffer*/
					rtk_hal_vsc_GetInputRegion(VIDEO_WID_0, &magnifiermaininregion);
					rtk_hal_vsc_GetOutputRegion(VIDEO_WID_0, &magnifiermainoutregion);
					Scaler_DispWindowZoomin(SLR_MAIN_DISPLAY, magnifiermaininregion, magnifiermainoutregion,0,0,FALSE);

					inregion.x = Sub_InputRegion_x;
					inregion.y = Sub_InputRegion_y;
					inregion.w =Sub_InputRegion_w;
					inregion.h = Sub_InputRegion_h;

					//set_vsc_SetMagnifire_shape(1);
					if (inregion.w > outregion.w)
						inregion.w = outregion.w;
					if (inregion.h > outregion.h)
						inregion.h = outregion.h;
					//sub_window_type = 1;
					Scaler_DispWindowZoomin(SLR_SUB_DISPLAY, inregion, outregion,Wide,High,TRUE);
				}
#endif
				set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_LIVEZOOM, FALSE);
#if 1
				if (Get_Magnifier_LiveZoom_Mode()==KADP_VSC_SUB_PURPOSE_MAGNIFIER) {

					if (DbgSclrFlgTkr.mainVscFreezeFlag) {
						Scaler_SetFreeze(SLR_MAIN_DISPLAY, DbgSclrFlgTkr.mainVscFreezeFlag);
					}
					if (DbgSclrFlgTkr.subVscFreezeFlag) {
						Scaler_SetFreeze(SLR_SUB_DISPLAY, DbgSclrFlgTkr.subVscFreezeFlag);
					}

					if (DbgSclrFlgTkr.LivezoomSubRerunEndneedOpenforcebgFlag)
					{
						mute_control(SLR_SUB_DISPLAY, FALSE);
						DbgSclrFlgTkr.LivezoomSubRerunEndneedOpenforcebgFlag = FALSE;
					}

					if(DbgSclrFlgTkr.LivezoomMainRerunEndneedOpenforcebgFlag)
					{
						mute_control(SLR_MAIN_DISPLAY, FALSE);
						DbgSclrFlgTkr.LivezoomMainRerunEndneedOpenforcebgFlag = FALSE;
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"[magnifier]LivezoomMainRerunEndneedOpenforcebg at sub!!\n");
					}
				} else
#endif

#if 1
				/*for livezoom:main setting window before sub window setting case*/
				if (DbgSclrFlgTkr.LivezoomMainRerunFlag) {
					if (DbgSclrFlgTkr.mainVscFreezeFlag) {
						Scaler_SetFreeze(SLR_MAIN_DISPLAY, DbgSclrFlgTkr.mainVscFreezeFlag);
					}

					if (DbgSclrFlgTkr.subVscFreezeFlag) {
						Scaler_SetFreeze(SLR_SUB_DISPLAY, DbgSclrFlgTkr.subVscFreezeFlag);
					}

					if(DbgSclrFlgTkr.LivezoomMainRerunEndneedOpenforcebgFlag)
					{
						mute_control(SLR_MAIN_DISPLAY, FALSE);
						DbgSclrFlgTkr.LivezoomMainRerunEndneedOpenforcebgFlag = FALSE;
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"[livezoom]LivezoomMainRerunEndneedOpenforcebg at sub!!\n");
					}
				}
#endif
				if (DbgSclrFlgTkr.LivezoomSubRerunEndneedOpenforcebgFlag)
				{
					mute_control(SLR_SUB_DISPLAY, FALSE);
					DbgSclrFlgTkr.LivezoomSubRerunEndneedOpenforcebgFlag = FALSE;
				}

				if(DbgSclrFlgTkr.sub_wind0000 == TRUE) {
					down(get_forcebg_semaphore());
					drvif_scalerdisplay_subdisplay_hidenfunc( _DISABLE);
					up(get_forcebg_semaphore());
					DbgSclrFlgTkr.sub_wind0000 = FALSE;
				}

				set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_LIVEZOOM, FALSE);
				rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"[livezoom/magnifier][ended]sub run scaler flow by self when open pip!!\n");
#if 0/*qiangzhou marked, becasue webos will set winblank off*/
				if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE)==_MODE_STATE_ACTIVE) && (Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE)==_MODE_STATE_ACTIVE))//recheck, timing may under changing
				{
					mute_control(SLR_MAIN_DISPLAY, FALSE);
				}
#endif
			}
			up(&Magnifier_Semaphore);
		} else if ((DbgSclrFlgTkr.Sub_OuputDisplayMode || DbgSclrFlgTkr.Sub_OutputVencMode || DbgSclrFlgTkr.Sub_OutputMemoryMode || DbgSclrFlgTkr.Sub_OutputAveMode) && (Get_Live_zoom_mode() == LIVE_ZOOM_OFF)) {
			up(&Magnifier_Semaphore);

			if ((outregion.w < 1) || (outregion.h < 1))
			{
					down(&SetSubOutPutRegion_Semaphore);
					DbgSclrFlgTkr.Sub_Output_Set_flag = FALSE;
					sub_dispwin_pre.srcx = outregion.x;
					sub_dispwin_pre.srcy = outregion.y;
					sub_dispwin_pre.src_height = outregion.h;
					sub_dispwin_pre.src_wid = outregion.w;
					up(&SetSubOutPutRegion_Semaphore);
					pr_err("sub outputregion is zero, return\n");
					return TRUE;
			}

			if((srctype == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
			{
				if ((outregion.w + outregion.x > _DISP_WID) || (outregion.h + outregion.y > _DISP_LEN)) {
					m_dispwin.srcx = 0;
					m_dispwin.srcy = 0;
					m_dispwin.src_height = _DISP_LEN;
					m_dispwin.src_wid = _DISP_WID;
				}else {
					m_dispwin.srcx = outregion.x;
					m_dispwin.srcy = outregion.y;
					m_dispwin.src_height = outregion.h;
					m_dispwin.src_wid = outregion.w;
				}


				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "SetOutputRegion DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag=%x\n", DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag);
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "SetOutputRegion scaler state=%x\n", Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE));
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "SetOutputRegion Check_AP_Set_Enable_ForceBG(SLR_SUB_DISPLAY)=%x\n", Check_AP_Set_Enable_ForceBG(SLR_SUB_DISPLAY));

				//rtd_printk(KERN_EMERG, TAG_NAME_VSC, "SetOutputRegion DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag=%x\n", DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag);
				//rtd_printk(KERN_EMERG, TAG_NAME_VSC, "SetOutputRegion scaler state=%x\n", Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE));
				//rtd_printk(KERN_EMERG, TAG_NAME_VSC, "SetOutputRegion Check_AP_Set_Enable_ForceBG(SLR_SUB_DISPLAY)=%x\n", Check_AP_Set_Enable_ForceBG(SLR_SUB_DISPLAY));

				rtk_hal_vsc_GetInputRegion(1, &tInputRegion);

				//rtd_printk(KERN_EMERG, TAG_NAME_VSC, "SetOutputRegion rtk_hal_vsc_GetInputRegion InputRegion_x=%d, y=%d, w=%d, h=%d\n", tInputRegion.x, tInputRegion.y, tInputRegion.w, tInputRegion.h);
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "SetOutputRegion rtk_hal_vsc_GetInputRegion InputRegion_x=%d, y=%d, w=%d, h=%d\n", tInputRegion.x, tInputRegion.y, tInputRegion.w, tInputRegion.h);


				if (DbgSclrFlgTkr.Sub_OutputVencMode) {
					down(&SetSubOutPutRegion_Semaphore);
					sub_dispwin.srcx = outregion.x;
					sub_dispwin.srcy = outregion.y;
					sub_dispwin.src_height = outregion.h;
					sub_dispwin.src_wid = outregion.w;

					set_input_for_vgip(SLR_SUB_DISPLAY, sub_input_size.srcx, sub_input_size.srcy, sub_input_size.src_wid, sub_input_size.src_height);
					set_input_for_crop(SLR_SUB_DISPLAY, sub_input_size);
					set_input_timing_for_crop(SLR_SUB_DISPLAY, sub_input_timing);
					Scaler_InputRegionType_Set(SLR_SUB_DISPLAY,getInputRegionType(SLR_SUB_DISPLAY));

					Scaler_SubDispWindowSet(sub_dispwin);
					DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;
					DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;
					up(&SetSubOutPutRegion_Semaphore);
					return TRUE;
				} else if(DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag && (Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)) {//For Sub black video issue patch will 20151211


					if (CompareATVInputOutputRegion(SLR_SUB_DISPLAY, &outregion, &tInputRegion))
					{
						//rtd_printk(KERN_EMERG, TAG_NAME_VSC, "0  ATV sub path, no forcebg, intput and output region are the same\n");
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "0  ATV sub path, no forcebg, intput and output region are the same\n");
						return TRUE;
					}
					mute_control(SLR_SUB_DISPLAY, TRUE);/*Auto BG. Add by Will*/
					down(&SetSubOutPutRegion_Semaphore);
					sub_dispwin.srcx = outregion.x;
					sub_dispwin.srcy = outregion.y;
					sub_dispwin.src_height = outregion.h;
					sub_dispwin.src_wid = outregion.w;
					set_sub_mutewin(sub_dispwin);//notice mute on driver the sub window area
					//Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
					DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;//For Sub black video issue patch will 20151211
					DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;

					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####func:%s sub smooth toggle temp flow#####\r\n", __FUNCTION__);
					up(&SetSubOutPutRegion_Semaphore);
					return TRUE;
				}
				else if(Check_AP_Set_Enable_ForceBG(SLR_SUB_DISPLAY) == FALSE && (Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
				{
					if (CompareATVInputOutputRegion(SLR_SUB_DISPLAY, &outregion, &tInputRegion))
					{
						//rtd_printk(KERN_EMERG, TAG_NAME_VSC, "1  ATV sub path, no forcebg, intput and output region are the same\n");
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "1  ATV sub path, no forcebg, intput and output region are the same\n");
						DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;
						DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;
						return TRUE;
					}
				}
				down(&SetSubOutPutRegion_Semaphore);
				sub_dispwin.srcx = outregion.x;
				sub_dispwin.srcy = outregion.y;
				sub_dispwin.src_height = outregion.h;
				sub_dispwin.src_wid = outregion.w;

				set_sub_mutewin(sub_dispwin);//notice mute on driver the sub window area

				if((Check_AP_Set_Enable_ForceBG(SLR_SUB_DISPLAY) == FALSE)) {
					DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;//This is special case for VIP test
					DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;//Let scaler can be run
					rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "\r\n####no mute on, so request run sub scaler flow for atv directly####\r\n");
				} else {
					DbgSclrFlgTkr.Sub_Output_Set_flag = TRUE;//Set output flag for setwinblank to request scaler

					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####func:%s request atv run sub scaler flow atv#####\r\n", __FUNCTION__);
				}
				if (DbgSclrFlgTkr.sub_opensourceID == _UNKNOWN_INPUT) {
					set_source_info_forPQ(SLR_SUB_DISPLAY);//Set source info for PQ request befor scaler
				}
				up(&SetSubOutPutRegion_Semaphore);
				return TRUE;
			}
#if 1//for sub smooth toggle test
//if sub supports timing change flow ,need mark this code
			if(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
			{
				if (srctype == VSC_INPUTSRC_VDEC || srctype == VSC_INPUTSRC_JPEG)
				{
					down(get_vo_infosemaphore());
					if(get_vo_change_flag(Get_DisplayMode_Port(SLR_SUB_DISPLAY)))
					{
							rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####Voinfo is change. Active to search 3####\r\n");
							Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
					}
					up(get_vo_infosemaphore());
					if(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_SEARCH) {
						down(&SetSubOutPutRegion_Semaphore);
						reset_any_srcrect(&sub_dispwin_pre); //Need to Reste previous output value. For run scaler flow
						up(&SetSubOutPutRegion_Semaphore);
					}
				}
			}
#endif
			if ((outregion.w == 0) || (outregion.h == 0)) {
				sub_dispwin.srcx = 0;
				sub_dispwin.srcy = 0;
				sub_dispwin.src_height = 0;
				sub_dispwin.src_wid = 0;
				Scaler_SubDispWindowSet(sub_dispwin);
				if (Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) {
					down(get_forcebg_semaphore());
					drvif_scalerdisplay_subdisplay_hidenfunc( _ENABLE);
					up(get_forcebg_semaphore());
					DbgSclrFlgTkr.sub_wind0000 = TRUE;
				}
			} else {
				if ((outregion.w + outregion.x > _DISP_WID) || (outregion.h + outregion.y > _DISP_LEN)) {
					outregion.x = 0;
					outregion.y = 0;
					outregion.h = _DISP_LEN;
					outregion.w = _DISP_WID;
				}
				if (DbgSclrFlgTkr.Sub_OutputVencMode) {
					down(&VSC_Semaphore);
					sub_dispwin.srcx = outregion.x;
					sub_dispwin.srcy = outregion.y;
					sub_dispwin.src_height = outregion.h;
					sub_dispwin.src_wid = outregion.w;
					set_input_for_vgip(SLR_SUB_DISPLAY, sub_input_size.srcx, sub_input_size.srcy, sub_input_size.src_wid, sub_input_size.src_height);
					set_input_for_crop(SLR_SUB_DISPLAY, sub_input_size);
					set_input_timing_for_crop(SLR_SUB_DISPLAY, sub_input_timing);
					Scaler_InputRegionType_Set(SLR_SUB_DISPLAY,getInputRegionType(SLR_SUB_DISPLAY));

					Scaler_SubDispWindowSet(sub_dispwin);
					DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;
					set_current_scaler_source_num(SLR_SUB_DISPLAY);//record current vsc source num
					rtk_output_connect(SLR_SUB_DISPLAY);
					Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);//avoid main path display flag wrong
					up(&VSC_Semaphore);

				} else if (Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) {
#if 0
										//Need smooth toggle flow. Not yet
										mute_control(SLR_SUB_DISPLAY, TRUE);/*Auto BG. Add by Will*/
										down(&SetSubOutPutRegion_Semaphore);
										sub_dispwin.srcx = outregion.x;
										sub_dispwin.srcy = outregion.y;
										sub_dispwin.src_height = outregion.h;
										sub_dispwin.src_wid = outregion.w;
										set_sub_mutewin(sub_dispwin);//notice mute on driver the sub window area
										Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
										DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;
#else// for sub smooth toggle test


					if(decide_run_sub_smoothtoggle_case()){
						down(&SetSubOutPutRegion_Semaphore);
						//Scaler_SetCurrentDispInfo(SLR_SUB_DISPLAY);

						sub_dispwin.srcx = outregion.x;
						sub_dispwin.srcy = outregion.y;
						sub_dispwin.src_height = outregion.h;
						sub_dispwin.src_wid = outregion.w;
						set_sub_mutewin(sub_dispwin);//notice mute on driver the sub window area
						DbgSclrFlgTkr.Sub_smooth_toggle_set_flag = TRUE;
						//DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;
						//DbgSclrFlgTkr.Sub_Run_Scaler_flag = FALSE;
						up(&SetSubOutPutRegion_Semaphore);
						rtd_printk(KERN_EMERG, TAG_NAME_VSC, "\r\n####func:%s sub smooth toggle flow#####\r\n", __FUNCTION__);
					}else{
						//Need smooth toggle flow. Not yet
						down(get_forcebg_semaphore());
						scalerdisplay_force_bg_enable(SLR_SUB_DISPLAY, TRUE);/*Auto BG. Add by Will*/
						up(get_forcebg_semaphore());
						down(&SetSubOutPutRegion_Semaphore);
						sub_dispwin.srcx = outregion.x;
						sub_dispwin.srcy = outregion.y;
						sub_dispwin.src_height = outregion.h;
						sub_dispwin.src_wid = outregion.w;
						set_sub_mutewin(sub_dispwin);//notice mute on driver the sub window area
						Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
						DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;
						DbgSclrFlgTkr.Sub_smooth_toggle_set_flag = FALSE;
						up(&SetSubOutPutRegion_Semaphore);
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "\r\n####sub smooth toggle: fast mode, re-run scaler#####\r\n");
					}
#endif
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####func:%s sub smooth toggle temp flow#####\r\n", __FUNCTION__);
					up(&SetSubOutPutRegion_Semaphore);
				} else {
					down(&SetSubOutPutRegion_Semaphore);
					sub_dispwin.srcx = outregion.x;
					sub_dispwin.srcy = outregion.y;
					sub_dispwin.src_height = outregion.h;
					sub_dispwin.src_wid = outregion.w;
					set_sub_mutewin(sub_dispwin);//notice mute on driver the sub window area
					if(check_input_and_output_the_same(SLR_SUB_DISPLAY) == FALSE){//Check input and output parameter is the same or not
						if((Check_AP_Set_Enable_ForceBG(SLR_SUB_DISPLAY) == FALSE)) {
							DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;//This is special case for VIP test
							DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;//Let scaler can be run
							rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "\r\n####no mute on, so request run sub scaler flow directly####\r\n");
						} else {
							DbgSclrFlgTkr.Sub_Output_Set_flag = TRUE;//Set output flag for setwinblank to request scaler

							rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####func:%s src:%d request run sub scaler flow#####\r\n", __FUNCTION__, srctype);
						}
						if (DbgSclrFlgTkr.sub_opensourceID == _UNKNOWN_INPUT) {
							set_source_info_forPQ(SLR_SUB_DISPLAY);//Set source info for PQ request befor scaler
						}
					} else {
						rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####func:%s src:%d sub the input and output is the same#####\r\n", __FUNCTION__, srctype);
					}
					up(&SetSubOutPutRegion_Semaphore);
				}
				if(DbgSclrFlgTkr.sub_wind0000 == TRUE) {
					down(get_forcebg_semaphore());
					drvif_scalerdisplay_subdisplay_hidenfunc( _DISABLE);
					up(get_forcebg_semaphore());
					DbgSclrFlgTkr.sub_wind0000 = FALSE;
				}
			}
		} else {
			up(&Magnifier_Semaphore);/*added by qiangzhou, can not remove*/
		}

#endif
	}



#if(LiveZoom_PROFILE == 1)
	magnifierafter_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
	rtd_printk(KERN_EMERG, TAG_NAME_VSC, "\nVSC rtk_hal_vsc_SetOutputRegion time=%d ms\n",(magnifierafter_time-magnifierbefore_time));
	magnifierbefore_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
#endif
	return TRUE;
}

unsigned char check_input_output_valid(KADP_VIDEO_RECT_T inregion_parm, KADP_VIDEO_RECT_T originalInput_parm, KADP_VIDEO_RECT_T outregion_parm)
{//check input and output parameter is supported or not.  return TURE: valid, return False: unsupport
	#define MAX_SCALING_UP_FACTOR 32
	#define MAX_SCALING_DOWN_FACTOR 32

	if((inregion_parm.w > originalInput_parm.w) || (inregion_parm.h > originalInput_parm.h))
		return FALSE;//crop size bigger than source resolution
	if((outregion_parm.w > _DISP_WID) || (outregion_parm.h > _DISP_LEN))
		return FALSE;// output bigger than panel size.
	if(inregion_parm.w < outregion_parm.w)
	{//w scaling up case
		if((unsigned int)inregion_parm.w * MAX_SCALING_UP_FACTOR < (unsigned int)outregion_parm.w)//scaling up bigger than 32x
			return FALSE;
	}
	else if(inregion_parm.w > outregion_parm.w)
	{//w scaling down case
		if((unsigned int)outregion_parm.w * MAX_SCALING_DOWN_FACTOR < (unsigned int)inregion_parm.w)//scaling down bigger than 32x
			return FALSE;
	}

	if(inregion_parm.h < outregion_parm.h)
	{//h scaling up case
		if((unsigned int)inregion_parm.h * MAX_SCALING_UP_FACTOR < (unsigned int)outregion_parm.h)//scaling up bigger than 32x
			return FALSE;
	}
	else if(inregion_parm.h > outregion_parm.h)
	{//h scaling down case
		if((unsigned int)outregion_parm.h * MAX_SCALING_DOWN_FACTOR < (unsigned int)inregion_parm.h)//scaling down bigger than 32x
			return FALSE;
	}

	return TRUE;
}

void vsc_adaptivestream_save_region(KADP_VIDEO_WID_T wid, KADP_VIDEO_RECT_T outregion)
{
	if(vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY) < ADAPTIVE_AIR_MODE)
		return;

	if((outregion.w == 0) || (outregion.h == 0))
		return;

	if(wid == KADP_VIDEO_WID_0) {
		air_mode_save_outregion_parm[SLR_MAIN_DISPLAY] = outregion;
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if(wid == KADP_VIDEO_WID_1) {
		air_mode_save_outregion_parm[SLR_SUB_DISPLAY] = outregion;
	}
#endif
}


void scaler_airModeSendDispSize(unsigned char display, KADP_VIDEO_RECT_T outregion)
{
    int ret = 0;
    unsigned long i = 0, ulItemCount = 0;
    unsigned short *pulTemp = NULL;
    AIRMODE_DISP_SIZE_INFO sendDispInfo = {0};

	ulItemCount = sizeof(AIRMODE_DISP_SIZE_INFO) / sizeof(unsigned short);

	sendDispInfo.display = display;
	if(display == SLR_MAIN_DISPLAY)
	{
	    sendDispInfo.main_output_x =  outregion.x;
	    sendDispInfo.main_output_y =  outregion.y;
	    sendDispInfo.main_output_w =  outregion.w;
	    sendDispInfo.main_output_h =  outregion.h;
	} else if(display == SLR_SUB_DISPLAY) {
		sendDispInfo.sub_output_x =  outregion.x;
	    sendDispInfo.sub_output_y =  outregion.y;
	    sendDispInfo.sub_output_w =  outregion.w;
	    sendDispInfo.sub_output_h =  outregion.h;
	}

    pulTemp = (unsigned short *)&sendDispInfo;

	// change endian
	for (i = 0; i < ulItemCount; i++)
		pulTemp[i] = Scaler_ChangeUINT16Endian(pulTemp[i]);

	// copy from RPC share memory
	memcpy((unsigned char*)Scaler_GetShareMemVirAddr(SCALER_AIRMODE_SEND_DISP_SIZE), &sendDispInfo, sizeof(AIRMODE_DISP_SIZE_INFO));

	if ((ret = Scaler_SendRPC(SCALER_AIRMODE_SEND_DISP_SIZE, 0, 0)) < 0)
	{
		rtd_printk(KERN_EMERG, TAG_NAME_VSC, "ret = %d, set SCALER_AIRMODE_SEND_DISP_SIZE to video fw fail !!!\n", ret );
		return;
	}

}


void vsc_adaptivestream_calc_outregion(unsigned char display)
{
	SLR_VOINFO* VOInfo = Scaler_VOInfoPointer(Get_DisplayMode_Port(display));
	unsigned int v_length = (VOInfo->progressive ? VOInfo->v_length : VOInfo->v_length*2);
	unsigned int panel_ratio = 0;
	unsigned int source_ratio = 0;
	unsigned int oriWidth = 0;
	unsigned int oriHeight = 0;

	if(display == SLR_MAIN_DISPLAY) {
		if (vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY) == ADAPTIVE_AIR_MODE) {
			panel_ratio = (unsigned int)v_length * ap_main_outregion_parm.w;
			source_ratio = (unsigned int)VOInfo->h_width * ap_main_outregion_parm.h;
			oriWidth = ap_main_outregion_parm.w;
			oriHeight = ap_main_outregion_parm.h;

			if(panel_ratio >= source_ratio){//Change panel width
				main_dispwin.src_wid = ((ap_main_outregion_parm.h * VOInfo->h_width * 100) / v_length + 50)/100;
				main_dispwin.src_height = ap_main_outregion_parm.h;
				main_dispwin.srcx = ap_main_outregion_parm.x + (ABS(main_dispwin.src_wid, oriWidth))/2;
				main_dispwin.srcy = ap_main_outregion_parm.y;
			}/*else if(panel_ratio < source_ratio) {//Change panel height
				main_dispwin.src_height = ((ap_main_outregion_parm.w * v_length * 100) / VOInfo->h_width + 50)/100;
				//main_dispwin.src_wid = ap_main_outregion_parm.w;
				main_dispwin.srcy = ap_main_outregion_parm.y + (ABS(main_dispwin.src_height, oriHeight))/2;
				//main_dispwin.srcx = ap_main_outregion_parm.x;
			}*/

			Scaler_DispWindowSet(main_dispwin);
			scaler_airModeSendDispSize(display, air_mode_save_outregion_parm[display]);

			printk(KERN_INFO "adaptive stream air mode change display size (%d,%d,%d,%d)->(%d,%d,%d,%d)\r\n",  ap_main_outregion_parm.x, ap_main_outregion_parm.y,
				ap_main_outregion_parm.w, ap_main_outregion_parm.h, main_dispwin.srcx, main_dispwin.srcy, main_dispwin.src_wid, main_dispwin.src_height);
		}
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if(display == SLR_SUB_DISPLAY) {
		if (vsc_get_adaptivestream_flag(SLR_SUB_DISPLAY) == ADAPTIVE_AIR_MODE) {
			panel_ratio = (unsigned int)v_length * ap_sub_outregion_parm.w;
			source_ratio = (unsigned int)VOInfo->h_width * ap_sub_outregion_parm.h;
			oriWidth = ap_sub_outregion_parm.w;
			oriHeight = ap_sub_outregion_parm.h;

			if(panel_ratio >= source_ratio){//Change panel width
				sub_dispwin.src_wid = ((ap_sub_outregion_parm.h * VOInfo->h_width * 100) / v_length + 50)/100;
				sub_dispwin.src_height = ap_sub_outregion_parm.h;
				sub_dispwin.srcx = ap_sub_outregion_parm.x + (ABS(sub_dispwin.src_wid, oriWidth))/2;
				sub_dispwin.srcy = ap_sub_outregion_parm.y;
			}/*else if(panel_ratio < source_ratio) {//Change panel height
				sub_dispwin.src_height = ((ap_sub_outregion_parm.w * v_length * 100) / VOInfo->h_width + 50)/100;
				//sub_dispwin.src_wid = ap_sub_outregion_parm.w;
				sub_dispwin.srcy = ap_sub_outregion_parm.y + (ABS(sub_dispwin.src_height, oriHeight))/2;
				//sub_dispwin.srcx = ap_sub_outregion_parm.x;
			}*/

			Scaler_SubDispWindowSet(sub_dispwin);
			scaler_airModeSendDispSize(display, air_mode_save_outregion_parm[display]);

			printk(KERN_INFO "sub adaptive stream air mode change display size (%d,%d,%d,%d)->(%d,%d,%d,%d)\r\n",  ap_sub_outregion_parm.x, ap_sub_outregion_parm.y,
				ap_sub_outregion_parm.w, ap_sub_outregion_parm.h, sub_dispwin.srcx, sub_dispwin.srcy, sub_dispwin.src_wid, sub_dispwin.src_height);
		}
	}
#endif

}


void scaler_SendDispSize(StructSrcRect outregion)
{
	int ret;
	unsigned long i = 0, ulItemCount = 0;
	unsigned short *pulTemp;
    SEND_DISP_SIZE_INFO sendDispInfo;

	ulItemCount = sizeof(SEND_DISP_SIZE_INFO) / sizeof(unsigned short);

    sendDispInfo.output_x =  outregion.srcx;
    sendDispInfo.output_y =  outregion.srcy;
    sendDispInfo.output_w =  outregion.src_wid;
    sendDispInfo.output_h =  outregion.src_height;
    sendDispInfo.rotate_type = (unsigned short)get_rotate_mode();

    pulTemp = (unsigned short *)&sendDispInfo;

	// change endian
	for (i = 0; i < ulItemCount; i++)
		pulTemp[i] = Scaler_ChangeUINT16Endian(pulTemp[i]);

	// copy from RPC share memory
	memcpy((unsigned char*)Scaler_GetShareMemVirAddr(SCALER_SEND_DISP_SIZE_RERUN_VO), &sendDispInfo, sizeof(SEND_DISP_SIZE_INFO));

	if ((ret = Scaler_SendRPC(SCALER_SEND_DISP_SIZE_RERUN_VO, 0, 0)) < 0)
	{
		rtd_printk(KERN_EMERG, TAG_NAME_VSC, "ret = %d, set SCALER_SEND_DISP_SIZE_RERUN_VO to video fw fail !!!\n", ret );
		return;
	}

}

unsigned char rtk_hal_vsc_SetInputRegion_OutputRegion(KADP_VIDEO_WID_T wid, KADP_VSC_ROTATE_T rotate_type, KADP_VIDEO_RECT_T  inregion,
	KADP_VIDEO_RECT_T originalInput, KADP_VIDEO_RECT_T outregion, unsigned char null_input, unsigned char null_output)
{


#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG
    VSC_INPUT_TYPE_T srctype;

	extern unsigned char check_pst_active_state(unsigned char display);//Return TRUE: active state can run pst. Return False: not active state can not run pst
	unsigned long flags;//for spin_lock_irqsave
	unsigned char is_atv = FALSE;
	static unsigned int pre_inregion_x = 0, pre_inregion_y = 0;

	if(null_input && null_output)
	{
		return TRUE;//input output both are null. directly return for LG spec
	}

	if( (pre_inregion_x!=inregion.x) || (pre_inregion_y!=inregion.y)){
		AspectRation_Zoom_MEMCClose_Flag =1;
	}else{
		AspectRation_Zoom_MEMCClose_Flag =0;
	}
	pre_inregion_x=inregion.x;
	pre_inregion_y=inregion.y;
	/*
	printk(KERN_DEBUG "rtk_hal_vsc_SetInputRegion_OutputRegion()\n");
	printk(KERN_DEBUG "wid=%x, inregion x=%d, y=%d, width=%d, height=%d\n", wid, inregion.x, inregion.y, inregion.w, inregion.h);
	printk(KERN_DEBUG "wid=%x, outregion x=%d, y=%d, width=%d, height=%d\n", wid, outregion.x, outregion.y, outregion.w, outregion.h);
	printk(KERN_DEBUG "null_input=%x, null_output=%x\n", null_input, null_output);
	*/
	if(wid == KADP_VIDEO_WID_0)
	{
		if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_MAXN)
			return TRUE;//no connect source
		if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
			is_atv = TRUE;//vsc connect atv

		down(&new_input_output_main_sem);//lock semaphore
		if (!vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY) || is_atv || (check_pst_active_state(SLR_MAIN_DISPLAY) == FALSE))//PST not ready state. or ATV case
		{//atv alwasy set original input and output
			if(null_input)
			{//input is null
				if((outregion.w == 0) || (outregion.h == 0))
				{//output is zero not null. need to mute
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_MAIN_DISPLAY, TRUE);
					up(&new_input_output_main_sem);//unlock semaphore
					printk(KERN_INFO "\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				else
				{//no need to copy input. input is null
					if(!check_input_output_valid(ap_main_inregion_parm, ap_main_originalInput_parm, outregion))
					{//not support case mute on
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						printk(KERN_INFO "\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}

					spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
					ap_rotate_type_parm = rotate_type;//copy rotate type
					//copy output region
					ap_main_outregion_parm.x = outregion.x;
					ap_main_outregion_parm.y = outregion.y;
					ap_main_outregion_parm.w = outregion.w;
					ap_main_outregion_parm.h = outregion.h;
					main_arc_change_flag = TRUE;
					spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
					wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk
					if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
					{//previou mute on
						rtd_printk(KERN_INFO, TAG_NAME_VSC, "####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
						trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
					}
				}
			}
			else if(null_output)
			{//output is null
				if((inregion.w == 0) || (inregion.h == 0))
				{//input is zero not null. need to mute
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_MAIN_DISPLAY, TRUE);
					up(&new_input_output_main_sem);//unlock semaphore
					printk(KERN_INFO "\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				else
				{//no need to copy output. output is null
					if(!check_input_output_valid(inregion, originalInput, ap_main_outregion_parm))
					{//not support case mute on
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						printk(KERN_INFO "\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
					ap_rotate_type_parm = rotate_type;//copy rotate type
					//copy input region
					ap_main_inregion_parm.x = inregion.x;
					ap_main_inregion_parm.y = inregion.y;
					ap_main_inregion_parm.w = inregion.w;
					ap_main_inregion_parm.h = inregion.h;

					//copy original input region
					ap_main_originalInput_parm.x = originalInput.x;
					ap_main_originalInput_parm.y = originalInput.y;
					ap_main_originalInput_parm.w = originalInput.w;
					ap_main_originalInput_parm.h = originalInput.h;
					main_arc_change_flag = TRUE;
					spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
					wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk
					if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
					{//previou mute on
						rtd_printk(KERN_INFO, TAG_NAME_VSC, "####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
						trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
					}
				}
			}
			else
			{
				//RTKREQ-456 : patch for scaler flow update osd callback delay to webos.
				if(vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY))
					Scaler_ForceUpdate_Callback_Delay_Info_by_InputOutput_Region(outregion);

				if((outregion.w == 0) || (outregion.h == 0))
				{//output is zero not null. need to mute
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_MAIN_DISPLAY, TRUE);
					up(&new_input_output_main_sem);//unlock semaphore
					printk(KERN_INFO "\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				else if((inregion.w == 0) || (inregion.h == 0))
				{//input zero but output is not zero
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_MAIN_DISPLAY, TRUE);
					printk(KERN_INFO "\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
					if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
					{
						spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
						ap_rotate_type_parm = rotate_type;//copy rotate type
						//copy output region
						ap_main_outregion_parm.x = outregion.x;
						ap_main_outregion_parm.y = outregion.y;
						ap_main_outregion_parm.w = outregion.w;
						ap_main_outregion_parm.h = outregion.h;
						main_arc_change_flag = TRUE;
						spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
						wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk
					}
				}
				else
				{
                    srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
					if(!check_input_output_valid(inregion, originalInput, outregion))
					{//not support case mute on
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						printk(KERN_INFO "\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
                    if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE) || ((srctype == VSC_INPUTSRC_VDEC) && (get_vo_avsync_flag(0) == FALSE)))
					{//change source or change channel case
						printk(KERN_INFO "### func:%s line:%d change source or channel reset output##\r\n",__FUNCTION__, __LINE__);
						down(&SetMainOutPutRegion_Semaphore);
						reset_any_srcrect(&main_dispwin_pre);
						reset_any_srcrect(&main_dispwin_for_only_xy);
						up(&SetMainOutPutRegion_Semaphore);
					}

					spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
					ap_rotate_type_parm = rotate_type;//copy rotate type
					//copy input region
					ap_main_inregion_parm.x = inregion.x;
					ap_main_inregion_parm.y = inregion.y;
					ap_main_inregion_parm.w = inregion.w;
					ap_main_inregion_parm.h = inregion.h;

					//copy original input region
					ap_main_originalInput_parm.x = originalInput.x;
					ap_main_originalInput_parm.y = originalInput.y;
					ap_main_originalInput_parm.w = originalInput.w;
					ap_main_originalInput_parm.h = originalInput.h;

					//copy output region
					ap_main_outregion_parm.x = outregion.x;
					ap_main_outregion_parm.y = outregion.y;
					ap_main_outregion_parm.w = outregion.w;
					ap_main_outregion_parm.h = outregion.h;

					main_arc_change_flag = TRUE;
					spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
					wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk
					if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
					{//previou mute on
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
						if(is_atv){//avoid of mute off earlier video output
							//rtd_printk(KERN_INFO, TAG_NAME_VSC, "#####[%s(%d)]Scaler_AVD_GetRunSearchState=%d\n",__func__,__LINE__,Scaler_AVD_GetRunSearchState(SLR_MAIN_DISPLAY));
							//if(Scaler_AVD_GetRunSearchState(SLR_MAIN_DISPLAY) == FALSE)
							//	trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
						}else{

							if (srctype == VSC_INPUTSRC_VDEC) {
								unsigned char wait_mute_off = FALSE;
								int port = Get_DisplayMode_Port(SLR_MAIN_DISPLAY);
								down(get_vo_infosemaphore());
								if ((get_vo_change_flag(Get_DisplayMode_Port(SLR_MAIN_DISPLAY)) == false) && (get_vo_avsync_flag(port) == TRUE)) {//vo no change and vo av sync ready
									trigger_mute_off(SLR_MAIN_DISPLAY, 1);
								}
								else
								{
									wait_mute_off = TRUE;
								}
								up(get_vo_infosemaphore());
								if(wait_mute_off)
								{
									printk(KERN_INFO "### func:%s line:%d wait scaler or smooth toggle mute off##\r\n",__FUNCTION__, __LINE__);
								}
							} else {
								trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
							}
						}
					}

				}
			}
		}
		else
		{//active state
			if(rotate_type != ap_rotate_type_parm)
			{//rotate case
				if(null_input)
				{//input is null
					if((outregion.w == 0) || (outregion.h == 0))
					{//output is zero not null. need to mute
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						printk(KERN_INFO "\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					else
					{//no need to copy input. input is null
						if(!check_input_output_valid(ap_main_inregion_parm, ap_main_originalInput_parm, outregion))
						{//not support case mute on
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
							mute_control(SLR_MAIN_DISPLAY, TRUE);
							up(&new_input_output_main_sem);//unlock semaphore
							printk(KERN_INFO "\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
							return TRUE;
						}
						spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
						ap_rotate_type_parm = rotate_type;//copy rotate type
						//copy output region
						ap_main_outregion_parm.x = outregion.x;
						ap_main_outregion_parm.y = outregion.y;
						ap_main_outregion_parm.w = outregion.w;
						ap_main_outregion_parm.h = outregion.h;
						main_arc_change_flag = TRUE;
						spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
						wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk
						if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
						{//previou mute on
							rtd_printk(KERN_INFO, TAG_NAME_VSC, "####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
							trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
						}


					}
				}
				else if(null_output)
				{//output is null
					if((inregion.w == 0) || (inregion.h == 0))
					{//input is zero not null. need to mute
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						printk(KERN_INFO "\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					else
					{//no need to copy output. output is null
						if(!check_input_output_valid(inregion, originalInput, ap_main_outregion_parm))
						{//not support case mute on
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
							mute_control(SLR_MAIN_DISPLAY, TRUE);
							up(&new_input_output_main_sem);//unlock semaphore
							printk(KERN_INFO "\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
							return TRUE;
						}
						spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
						ap_rotate_type_parm = rotate_type;//copy rotate type
						//copy input region
						ap_main_inregion_parm.x = inregion.x;
						ap_main_inregion_parm.y = inregion.y;
						ap_main_inregion_parm.w = inregion.w;
						ap_main_inregion_parm.h = inregion.h;

						//copy original input region
						ap_main_originalInput_parm.x = originalInput.x;
						ap_main_originalInput_parm.y = originalInput.y;
						ap_main_originalInput_parm.w = originalInput.w;
						ap_main_originalInput_parm.h = originalInput.h;
						main_arc_change_flag = TRUE;
						spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
						wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk
						if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
						{//previou mute on
							rtd_printk(KERN_INFO, TAG_NAME_VSC, "####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
							trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
						}
					}
				}
				else
				{
					if((outregion.w == 0) || (outregion.h == 0))
					{//output is zero not null. need to mute
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						printk(KERN_INFO "\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					else if((inregion.w == 0) || (inregion.h == 0))
					{//input zero
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						printk(KERN_INFO "\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
						{
							spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
							ap_rotate_type_parm = rotate_type;//copy rotate type
							//copy output region
							ap_main_outregion_parm.x = outregion.x;
							ap_main_outregion_parm.y = outregion.y;
							ap_main_outregion_parm.w = outregion.w;
							ap_main_outregion_parm.h = outregion.h;
							main_arc_change_flag = TRUE;
							spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
							wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk
						}
					}
					else
					{
						if(!check_input_output_valid(inregion, originalInput, outregion))
						{//not support case mute on
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
							mute_control(SLR_MAIN_DISPLAY, TRUE);
							up(&new_input_output_main_sem);//unlock semaphore
							printk(KERN_INFO "\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
							return TRUE;
						}
						spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
						ap_rotate_type_parm = rotate_type;//copy rotate type
						//copy input region
						ap_main_inregion_parm.x = inregion.x;
						ap_main_inregion_parm.y = inregion.y;
						ap_main_inregion_parm.w = inregion.w;
						ap_main_inregion_parm.h = inregion.h;

						//copy original input region
						ap_main_originalInput_parm.x = originalInput.x;
						ap_main_originalInput_parm.y = originalInput.y;
						ap_main_originalInput_parm.w = originalInput.w;
						ap_main_originalInput_parm.h = originalInput.h;

						//copy output region
						ap_main_outregion_parm.x = outregion.x;
						ap_main_outregion_parm.y = outregion.y;
						ap_main_outregion_parm.w = outregion.w;
						ap_main_outregion_parm.h = outregion.h;

						main_arc_change_flag = TRUE;
						spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
						wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk
						if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
						{//previou mute on
							rtd_printk(KERN_INFO, TAG_NAME_VSC, "####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute on. set the mask
							trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
						}

					}
				}

			}
			else
			{//non rotate case
#ifdef CONFIG_PST_ENABLE
#ifdef ENABLE_IMD_PST_SMOOTHTOGGLE
				//ensure pst can work on inerrupt.
				scaler_imd_pst_enable_interrupt();
#endif
#endif
				if(null_input)
				{//input is snull
					if((outregion.w == 0) || (outregion.h == 0))
					{//output is zero not null. need to mute
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						printk(KERN_INFO "\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					else
					{//no need to copy input. input is null
						if(!check_input_output_valid(ap_main_inregion_parm, ap_main_originalInput_parm, outregion))
						{//not support case mute on
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
							mute_control(SLR_MAIN_DISPLAY, TRUE);
							up(&new_input_output_main_sem);//unlock semaphore
							printk(KERN_INFO "\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
							return TRUE;
						}
						spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
						ap_rotate_type_parm = rotate_type;//copy rotate type
						//copy output region
						ap_main_outregion_parm.x = outregion.x;
						ap_main_outregion_parm.y = outregion.y;
						ap_main_outregion_parm.w = outregion.w;
						ap_main_outregion_parm.h = outregion.h;
						spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
						//update to share memory
						update_arc_cmd_to_ring_buffer_sharemem(SLR_MAIN_DISPLAY, ap_main_inregion_parm, ap_main_originalInput_parm, ap_main_outregion_parm);

						if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
						{//previou mute on
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
							trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
						}


					}
				}
				else if(null_output)
				{//output is null
					if((inregion.w == 0) || (inregion.h == 0))
					{//input is zero not null. need to mute
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						printk(KERN_INFO "\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					else
					{//no need to copy output. output is null
						if(!check_input_output_valid(inregion, originalInput, ap_main_outregion_parm))
						{//not support case mute on
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
							mute_control(SLR_MAIN_DISPLAY, TRUE);
							up(&new_input_output_main_sem);//unlock semaphore
							printk(KERN_INFO "\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
							return TRUE;
						}
						spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
						ap_rotate_type_parm = rotate_type;//copy rotate type
						//copy input region
						ap_main_inregion_parm.x = inregion.x;
						ap_main_inregion_parm.y = inregion.y;
						ap_main_inregion_parm.w = inregion.w;
						ap_main_inregion_parm.h = inregion.h;

						//copy original input region
						ap_main_originalInput_parm.x = originalInput.x;
						ap_main_originalInput_parm.y = originalInput.y;
						ap_main_originalInput_parm.w = originalInput.w;
						ap_main_originalInput_parm.h = originalInput.h;
						spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
						//update to share memory
						update_arc_cmd_to_ring_buffer_sharemem(SLR_MAIN_DISPLAY, ap_main_inregion_parm, ap_main_originalInput_parm, ap_main_outregion_parm);

						if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
						{//previou mute on
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute on. set the mask
							trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
						}
					}
				}
				else
				{//input and output is not null
					if((outregion.w == 0) || (outregion.h == 0))
					{//output is zero not null. need to mute
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						printk(KERN_INFO "\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					else if((inregion.w == 0) || (inregion.h == 0))
					{//input zero
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						printk(KERN_INFO "\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
						ap_rotate_type_parm = rotate_type;//copy rotate type
						//copy output region
						ap_main_outregion_parm.x = outregion.x;
						ap_main_outregion_parm.y = outregion.y;
						ap_main_outregion_parm.w = outregion.w;
						ap_main_outregion_parm.h = outregion.h;
						spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
						//update to share memory
						update_arc_cmd_to_ring_buffer_sharemem(SLR_MAIN_DISPLAY, ap_main_inregion_parm, ap_main_originalInput_parm, ap_main_outregion_parm);

					}
					else
					{//normal case
						if(!check_input_output_valid(inregion, originalInput, outregion))
						{//not support case mute on
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
							mute_control(SLR_MAIN_DISPLAY, TRUE);
							up(&new_input_output_main_sem);//unlock semaphore
							printk(KERN_INFO "\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
							return TRUE;
						}
						spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
						ap_rotate_type_parm = rotate_type;//copy rotate type
						//copy input region
						ap_main_inregion_parm.x = inregion.x;
						ap_main_inregion_parm.y = inregion.y;
						ap_main_inregion_parm.w = inregion.w;
						ap_main_inregion_parm.h = inregion.h;

						//copy original input region
						ap_main_originalInput_parm.x = originalInput.x;
						ap_main_originalInput_parm.y = originalInput.y;
						ap_main_originalInput_parm.w = originalInput.w;
						ap_main_originalInput_parm.h = originalInput.h;

						//copy output region
						ap_main_outregion_parm.x = outregion.x;
						ap_main_outregion_parm.y = outregion.y;
						ap_main_outregion_parm.w = outregion.w;
						ap_main_outregion_parm.h = outregion.h;

						spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);
						//update to share memory
						update_arc_cmd_to_ring_buffer_sharemem(SLR_MAIN_DISPLAY, ap_main_inregion_parm, ap_main_originalInput_parm, ap_main_outregion_parm);

						if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
						{//previou mute on
							set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
							trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
						}

					}
				}

			}
		}
        /*
		if((vbe_disp_oled_orbit_mode ==_VBE_PANEL_ORBIT_AUTO_MODE|| vbe_disp_oled_orbit_mode ==_VBE_PANEL_ORBIT_STORE_MODE) && vbe_disp_oled_orbit_enable)
	        {
				vbe_disp_orbit_set_vo_overscan(0);
				ori_input_width = inregion.w;
				ori_input_height = inregion.h;
				vbe_orbit_input_size.srcx  = inregion.x;
				vbe_orbit_input_size.srcy = inregion.y;
				vbe_orbit_input_size.src_wid = inregion.w;
				vbe_orbit_input_size.src_height = inregion.h;
				vbe_orbit_output_size.srcx = outregion.x;
				vbe_orbit_output_size.srcy = outregion.y;
				vbe_orbit_output_size.src_wid = outregion.w;
				vbe_orbit_output_size.src_height = outregion.h;
				rtd_printk(KERN_INFO, TAG_NAME_VSC, "[%s(%d)] update orbit input size vbe_orbit_input_size.src_wid =%d,vbe_orbit_input_size.src_height=%d\n",__func__,__LINE__,vbe_orbit_input_size.src_wid,vbe_orbit_input_size.src_height);
	        }
	        */
		vsc_adaptivestream_save_region(wid, ap_main_outregion_parm);
		up(&new_input_output_main_sem);//unlock semaphore
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if(wid == KADP_VIDEO_WID_1)
	{
		if(Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_MAXN)
				return TRUE;//no connect source

		down(&new_input_output_sub_sem);//lock semaphore
		if(check_pst_active_state(SLR_SUB_DISPLAY) == FALSE){
			if(null_input)
			{//input is null

				if((outregion.w == 0) || (outregion.h == 0))
				{//output is zero not null. need to mute
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					printk(KERN_INFO "\r\n### func:%s line:%d sub hidden###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				else
				{

					if(!check_input_output_valid(ap_sub_inregion_parm, ap_sub_originalInput_parm, outregion))
					{//not support case mute on
						set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_SUB_DISPLAY, TRUE);
						up(&new_input_output_sub_sem);//unlock semaphore
						printk(KERN_INFO "\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					sub_hidden = FALSE;
					if(Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE) || Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN))
					{//previou mute on
						rtd_printk(KERN_INFO, TAG_NAME_VSC, "####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
						set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
						set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 0);//LG spec need to mute off
						//trigger_mute_off(SLR_SUB_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
					}
					spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
					//copy output region
					ap_sub_outregion_parm.x = outregion.x;
					ap_sub_outregion_parm.y = outregion.y;
					ap_sub_outregion_parm.w = outregion.w;
					ap_sub_outregion_parm.h = outregion.h;
					sub_arc_change_flag = TRUE;
					spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);
					wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk

				}
			}
			else if(null_output)
			{//output is null
				if((inregion.w == 0) || (inregion.h == 0))
				{//input is zero not null. need to mute
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					printk(KERN_INFO "\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				if(!check_input_output_valid(inregion, originalInput, ap_sub_outregion_parm))
				{//not support case mute on
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					printk(KERN_INFO "\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				sub_hidden = FALSE;
				if(Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE) || Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN))
				{//previou mute on
					rtd_printk(KERN_INFO, TAG_NAME_VSC, "####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 0);//LG spec need to mute off
					//trigger_mute_off(SLR_SUB_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
				}
				spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
				//copy input region
				ap_sub_inregion_parm.x = inregion.x;
				ap_sub_inregion_parm.y = inregion.y;
				ap_sub_inregion_parm.w = inregion.w;
				ap_sub_inregion_parm.h = inregion.h;

				//copy original input region
				ap_sub_originalInput_parm.x = originalInput.x;
				ap_sub_originalInput_parm.y = originalInput.y;
				ap_sub_originalInput_parm.w = originalInput.w;
				ap_sub_originalInput_parm.h = originalInput.h;
				sub_arc_change_flag = TRUE;
				spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);
				wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk

			}
			else
			{
				if((outregion.w == 0) || (outregion.h == 0))
				{//output is zero not null. need to mute
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					printk(KERN_INFO "\r\n### func:%s line:%d sub hidden###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				if((inregion.w == 0) || (inregion.h == 0))
				{//input is zero not null. need to mute
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					printk(KERN_INFO "\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
					if(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
					{
						spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
						//copy output region
						ap_sub_outregion_parm.x = outregion.x;
						ap_sub_outregion_parm.y = outregion.y;
						ap_sub_outregion_parm.w = outregion.w;
						ap_sub_outregion_parm.h = outregion.h;
						sub_arc_change_flag = TRUE;
						spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);
						wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk
					}
					up(&new_input_output_sub_sem);//unlock semaphore
					return TRUE;
				}
				if(!check_input_output_valid(inregion, originalInput, outregion))
				{//not support case mute on
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					printk(KERN_INFO "\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				sub_hidden = FALSE;
				if(Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE) || Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN))
				{//previou mute on
					rtd_printk(KERN_INFO, TAG_NAME_VSC, "####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 0);//LG spec need to mute off
					//trigger_mute_off(SLR_SUB_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
				}
				spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
				//copy input region
				ap_sub_inregion_parm.x = inregion.x;
				ap_sub_inregion_parm.y = inregion.y;
				ap_sub_inregion_parm.w = inregion.w;
				ap_sub_inregion_parm.h = inregion.h;

				//copy original input region
				ap_sub_originalInput_parm.x = originalInput.x;
				ap_sub_originalInput_parm.y = originalInput.y;
				ap_sub_originalInput_parm.w = originalInput.w;
				ap_sub_originalInput_parm.h = originalInput.h;

				//copy output region
				ap_sub_outregion_parm.x = outregion.x;
				ap_sub_outregion_parm.y = outregion.y;
				ap_sub_outregion_parm.w = outregion.w;
				ap_sub_outregion_parm.h = outregion.h;

				sub_arc_change_flag = TRUE;
				spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);
				wake_up(&ARC_CONTROL_WAIT_QUEUE);//wake arc tsk

			}
		} else {
#ifdef CONFIG_PST_ENABLE
#ifdef ENABLE_IMD_PST_SMOOTHTOGGLE
			//ensure pst can work on inerrupt.
			scaler_imd_pst_enable_interrupt();
#endif
#endif
			if(null_input)
			{//input is null
				if((outregion.w == 0) || (outregion.h == 0))
				{//output is zero not null. need to mute
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					printk(KERN_INFO "\r\n### func:%s line:%d sub hidden###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				else
				{

					if(!check_input_output_valid(ap_sub_inregion_parm, ap_sub_originalInput_parm, outregion))
					{//not support case mute on
						set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_SUB_DISPLAY, TRUE);
						up(&new_input_output_sub_sem);//unlock semaphore
						printk(KERN_INFO "\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
					//copy output region
					ap_sub_outregion_parm.x = outregion.x;
					ap_sub_outregion_parm.y = outregion.y;
					ap_sub_outregion_parm.w = outregion.w;
					ap_sub_outregion_parm.h = outregion.h;
					spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);
					update_arc_cmd_to_ring_buffer_sharemem(SLR_SUB_DISPLAY, ap_sub_inregion_parm, ap_sub_originalInput_parm, ap_sub_outregion_parm);
					if(Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE) || Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN))
					{//previou mute on
						rtd_printk(KERN_INFO, TAG_NAME_VSC, "####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
						set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
						set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 0);//LG spec need to mute off
						trigger_mute_off(SLR_SUB_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
					}
					#if 0 //for hidden
					if(sub_hidden)
					{
						sub_hidden = FALSE;
						drvif_color_setpiprgbcontrastbrightness(0);//disable hidden
					}
					#endif
				}
			}
			else if(null_output)
			{//output is null
				if((inregion.w == 0) || (inregion.h == 0))
				{//input is zero not null. need to mute
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					printk(KERN_INFO "\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				if(!check_input_output_valid(inregion, originalInput, ap_sub_outregion_parm))
				{//not support case mute on
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					printk(KERN_INFO "\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
				//copy input region
				ap_sub_inregion_parm.x = inregion.x;
				ap_sub_inregion_parm.y = inregion.y;
				ap_sub_inregion_parm.w = inregion.w;
				ap_sub_inregion_parm.h = inregion.h;

				//copy original input region
				ap_sub_originalInput_parm.x = originalInput.x;
				ap_sub_originalInput_parm.y = originalInput.y;
				ap_sub_originalInput_parm.w = originalInput.w;
				ap_sub_originalInput_parm.h = originalInput.h;
				spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);
				update_arc_cmd_to_ring_buffer_sharemem(SLR_SUB_DISPLAY, ap_sub_inregion_parm, ap_sub_originalInput_parm, ap_sub_outregion_parm);
				if(Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE) || Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN))
				{//previou mute on
					rtd_printk(KERN_INFO, TAG_NAME_VSC, "####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 0);//LG spec need to mute off
					trigger_mute_off(SLR_SUB_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
				}
				#if 0//for hidden
				if(sub_hidden)
				{
					sub_hidden = FALSE;
					drvif_color_setpiprgbcontrastbrightness(0);//disable hidden
				}
				#endif
			}
			else
			{
				if((outregion.w == 0) || (outregion.h == 0))
				{//output is zero not null. need to mute
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					printk(KERN_INFO "\r\n### func:%s line:%d sub hidden###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				if((inregion.w == 0) || (inregion.h == 0))
				{//input is zero not null. need to mute
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					printk(KERN_INFO "\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
					spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
					//copy output region
					ap_sub_outregion_parm.x = outregion.x;
					ap_sub_outregion_parm.y = outregion.y;
					ap_sub_outregion_parm.w = outregion.w;
					ap_sub_outregion_parm.h = outregion.h;
					spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);
					update_arc_cmd_to_ring_buffer_sharemem(SLR_SUB_DISPLAY, ap_sub_inregion_parm, ap_sub_originalInput_parm, ap_sub_outregion_parm);
					up(&new_input_output_sub_sem);//unlock semaphore
					return TRUE;
				}
				if(!check_input_output_valid(inregion, originalInput, outregion))
				{//not support case mute on
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_SUB_DISPLAY, TRUE);
					up(&new_input_output_sub_sem);//unlock semaphore
					printk(KERN_INFO "\r\n### func:%s line:%d sub special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
				//copy input region
				ap_sub_inregion_parm.x = inregion.x;
				ap_sub_inregion_parm.y = inregion.y;
				ap_sub_inregion_parm.w = inregion.w;
				ap_sub_inregion_parm.h = inregion.h;

				//copy original input region
				ap_sub_originalInput_parm.x = originalInput.x;
				ap_sub_originalInput_parm.y = originalInput.y;
				ap_sub_originalInput_parm.w = originalInput.w;
				ap_sub_originalInput_parm.h = originalInput.h;
				//copy output region
				ap_sub_outregion_parm.x = outregion.x;
				ap_sub_outregion_parm.y = outregion.y;
				ap_sub_outregion_parm.w = outregion.w;
				ap_sub_outregion_parm.h = outregion.h;
				spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);
				update_arc_cmd_to_ring_buffer_sharemem(SLR_SUB_DISPLAY, ap_sub_inregion_parm, ap_sub_originalInput_parm, ap_sub_outregion_parm);
				if(Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE) || Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN))
				{//previou mute on
					rtd_printk(KERN_INFO, TAG_NAME_VSC, "####[%s(%d)] trigger_mute_off\n",__func__,__LINE__);
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HIDDEN, 0);//LG spec need to mute off
					trigger_mute_off(SLR_SUB_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
				}
				#if 0//for hidden
				if(sub_hidden)
				{
					sub_hidden = FALSE;
					drvif_color_setpiprgbcontrastbrightness(0);//disable hidden
				}
				#endif
			}
		}
		up(&new_input_output_sub_sem);//unlock semaphore
	}
	return TRUE;
#endif

#else//#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG //original input and output flow
	VIDEO_RECT_T inregion_parm;//for new input output.
	VIDEO_RECT_T originalInput_parm;//for new input output. input resolution parameter
	unsigned char mute_off_flag = FALSE;//currently parameter is normal mute off

	printk(KERN_INFO "\r\n#### func:%s null(%d %d) in(%d %d %d %d) ori(%d %d %d %d) out(%d %d %d %d)####\r\n", __FUNCTION__, null_input, null_output, inregion.x, inregion.y, inregion.w, inregion.h,
	originalInput.x, originalInput.y, originalInput.w, originalInput.h, outregion.x, outregion.y, outregion.w, outregion.h);


	if(null_input && null_output)
	{
		return TRUE;//input output both are null. directly return for LG spec
	}

	if(wid == KADP_VIDEO_WID_0)
		;//window_id = VIDEO_WID_0;
	else if(wid == KADP_VIDEO_WID_1)
		;//window_id = VIDEO_WID_1;
	else
	{
		printk(KERN_ERR "\r\n### func:%s wid:%d error###\r\n",__FUNCTION__, wid);
		return FALSE;
	}

	if(wid == KADP_VIDEO_WID_0)
	{
		if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_MAXN)
			return TRUE;//no connect source
		down(&new_input_output_main_sem);//lock semaphore
#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
		//rotate part
		down(&SetMainOutPutRegion_Semaphore);
		rotate_mode_pre = rotate_mode;
		rotate_mode = rotate_type;
		up(&SetMainOutPutRegion_Semaphore);

#endif
		virtual_w = true_wide;//magnify and livezoom use
		virtual_h = true_high;//magnify and livezoom use
		if(null_input)
		{//input is snull
			if((outregion.w == 0) || (outregion.h == 0))
			{//output is zero not null. need to mute
				set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
				mute_control(SLR_MAIN_DISPLAY, TRUE);
				up(&new_input_output_main_sem);//unlock semaphore
				printk(KERN_INFO "\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
				return TRUE;
			}
			else
			{//no need to copy input. input is null
				//copy output region
				ap_main_outregion_parm.x = outregion.x;
				ap_main_outregion_parm.y = outregion.y;
				ap_main_outregion_parm.w = outregion.w;
				ap_main_outregion_parm.h = outregion.h;
				if(!check_input_output_valid(ap_main_inregion_parm, ap_main_originalInput_parm, ap_main_outregion_parm))
				{//not support case mute on
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_MAIN_DISPLAY, TRUE);
					up(&new_input_output_main_sem);//unlock semaphore
					printk(KERN_INFO "\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				mute_off_flag = TRUE;//need try mute off
			}
		}
		else if(null_output)
		{//output is null
			if((inregion.w == 0) || (inregion.h == 0))
			{//input is zero not null. need to mute
				set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
				mute_control(SLR_MAIN_DISPLAY, TRUE);
				up(&new_input_output_main_sem);//unlock semaphore
				printk(KERN_INFO "\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
				return TRUE;
			}
			else
			{//no need to copy output. output is null

				//copy input region
				ap_main_inregion_parm.x = inregion.x;
				ap_main_inregion_parm.y = inregion.y;
				ap_main_inregion_parm.w = inregion.w;
				ap_main_inregion_parm.h = inregion.h;

				//copy original input region
				ap_main_originalInput_parm.x = originalInput.x;
				ap_main_originalInput_parm.y = originalInput.y;
				ap_main_originalInput_parm.w = originalInput.w;
				ap_main_originalInput_parm.h = originalInput.h;
				if(!check_input_output_valid(ap_main_inregion_parm, ap_main_originalInput_parm, ap_main_outregion_parm))
				{//not support case mute on
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_MAIN_DISPLAY, TRUE);
					up(&new_input_output_main_sem);//unlock semaphore
					printk(KERN_INFO "\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}

				mute_off_flag = TRUE;//need try mute off
			}
		}
		else
		{
				if((outregion.w == 0) || (outregion.h == 0))
				{//output is zero not null. need to mute
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_MAIN_DISPLAY, TRUE);
					up(&new_input_output_main_sem);//unlock semaphore
					printk(KERN_INFO "\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
					return TRUE;
				}
				else if((inregion.w == 0) || (inregion.h == 0))
				{//input zero but output is not zero
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
					mute_control(SLR_MAIN_DISPLAY, TRUE);

					//copy output region
					ap_main_outregion_parm.x = outregion.x;
					ap_main_outregion_parm.y = outregion.y;
					ap_main_outregion_parm.w = outregion.w;
					ap_main_outregion_parm.h = outregion.h;
					mute_off_flag = FALSE;
				}
				else
				{
					//copy input region
					ap_main_inregion_parm.x = inregion.x;
					ap_main_inregion_parm.y = inregion.y;
					ap_main_inregion_parm.w = inregion.w;
					ap_main_inregion_parm.h = inregion.h;

					//copy original input region
					ap_main_originalInput_parm.x = originalInput.x;
					ap_main_originalInput_parm.y = originalInput.y;
					ap_main_originalInput_parm.w = originalInput.w;
					ap_main_originalInput_parm.h = originalInput.h;

					//copy output region
					ap_main_outregion_parm.x = outregion.x;
					ap_main_outregion_parm.y = outregion.y;
					ap_main_outregion_parm.w = outregion.w;
					ap_main_outregion_parm.h = outregion.h;
					if(!check_input_output_valid(ap_main_inregion_parm, ap_main_originalInput_parm, ap_main_outregion_parm))
					{//not support case mute on
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 1);//LG spec need to mute on. set the mask
						mute_control(SLR_MAIN_DISPLAY, TRUE);
						up(&new_input_output_main_sem);//unlock semaphore
						printk(KERN_INFO "\r\n### func:%s line:%d special para mute on###\r\n",__FUNCTION__, __LINE__);
						return TRUE;
					}
					mute_off_flag = TRUE;//need try mute off
				}
		}

		//copy input
		inregion_parm.x = ap_main_inregion_parm.x;
		inregion_parm.y = ap_main_inregion_parm.y;
		inregion_parm.w = ap_main_inregion_parm.w;
		inregion_parm.h = ap_main_inregion_parm.h;

		//copy input
		originalInput_parm.x = ap_main_originalInput_parm.x;
		originalInput_parm.y = ap_main_originalInput_parm.y;
		originalInput_parm.w = ap_main_originalInput_parm.w;
		originalInput_parm.h = ap_main_originalInput_parm.h;

		rtk_hal_vsc_SetInputRegionEx(VIDEO_WID_0, inregion_parm, originalInput_parm);//normal parameter case to call input
		rtk_hal_vsc_SetOutputRegion(VIDEO_WID_0, ap_main_outregion_parm, virtual_w, virtual_h);//normal parameter case to call output
		if(mute_off_flag)
		{//norma parameter case need to mute off
			if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE))
			{//previou mute on
				rtd_printk(KERN_INFO, TAG_NAME_VSC, "#####[%s(%d)] trigger_mute_off\r\n",__func__,__LINE__);
				set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ZERO_NULL_ARC_MUTE, 0);//LG spec need to mute off
				trigger_mute_off(SLR_MAIN_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
			}
		}
		up(&new_input_output_main_sem);//unlock semaphore
	}
#ifdef CONFIG_DUAL_CHANNEL
	else if(wid == KADP_VIDEO_WID_1)
	{
		if(Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_MAXN)
			return TRUE;//no connect source
		down(&new_input_output_sub_sem);//lock semaphore
		virtual_w = true_wide;//magnify and livezoom use
		virtual_h = true_high;//magnify and livezoom use
		//copy input region
		ap_sub_inregion_parm.x = inregion.x;
		ap_sub_inregion_parm.y = inregion.y;
		ap_sub_inregion_parm.w = inregion.w;
		ap_sub_inregion_parm.h = inregion.h;

		//copy original input region
		ap_sub_originalInput_parm.x = originalInput.x;
		ap_sub_originalInput_parm.y = originalInput.y;
		ap_sub_originalInput_parm.w = originalInput.w;
		ap_sub_originalInput_parm.h = originalInput.h;

		//copy output region
		ap_sub_outregion_parm.x = outregion.x;
		ap_sub_outregion_parm.y = outregion.y;
		ap_sub_outregion_parm.w = outregion.w;
		ap_sub_outregion_parm.h = outregion.h;

		inregion_parm.x = ap_sub_inregion_parm.x;
		inregion_parm.y = ap_sub_inregion_parm.y;
		inregion_parm.w = ap_sub_inregion_parm.w;
		inregion_parm.h = ap_sub_inregion_parm.h;


		originalInput_parm.x = ap_sub_originalInput_parm.x;
		originalInput_parm.y = ap_sub_originalInput_parm.y;
		originalInput_parm.w = ap_sub_originalInput_parm.w;
		originalInput_parm.h = ap_sub_originalInput_parm.h;

		vsc_adaptivestream_save_region(wid, ap_sub_outregion_parm);

		rtk_hal_vsc_SetInputRegionEx(VIDEO_WID_1, inregion_parm, originalInput_parm);
		rtk_hal_vsc_SetOutputRegion(VIDEO_WID_1, ap_sub_outregion_parm, virtual_w, virtual_h);
		up(&new_input_output_sub_sem);//unlock semaphore


	}
#endif
	return TRUE;
#endif
}


unsigned char rtk_hal_vsc_SetSplitInfoForHDMI(void)
{
	rtd_printk(KERN_INFO, TAG_NAME_VSC, "rtk_hal_vsc_SetSplitInfoForHDMI() called\n");

	//TODO: implement API


	return TRUE;
}


unsigned char rtk_hal_vsc_SetWinFreeze(VIDEO_WID_T wid, bool bonoff)
{
	SCALER_DISP_CHANNEL channel = SLR_MAIN_DISPLAY;

	if (wid == VIDEO_WID_0) {
  		channel = SLR_MAIN_DISPLAY;
 		// DbgSclrFlgTkr.mainVscFreezeFlag = bonoff;
 	} else if (wid == VIDEO_WID_1) {
  		channel = SLR_SUB_DISPLAY;
 		// DbgSclrFlgTkr.subVscFreezeFlag = bonoff;
	}

#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid != VIDEO_WID_0)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	}
#endif
	down(&Magnifier_Semaphore);
	down(&VSC_Semaphore);
	if (wid == VIDEO_WID_0) {
		channel = SLR_MAIN_DISPLAY;
		DbgSclrFlgTkr.mainVscFreezeFlag = bonoff;
	} else if (wid == VIDEO_WID_1) {
		channel = SLR_SUB_DISPLAY;
		DbgSclrFlgTkr.subVscFreezeFlag = bonoff;
	}
	if(Get_Live_zoom_mode()!=LIVE_ZOOM_OFF)
	{
		Check_smooth_toggle_update_flag(SLR_SUB_DISPLAY);
		Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
 	}
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);

	if ((channel == SLR_MAIN_DISPLAY) && (Get_DisplayMode_Src(channel) == VSC_INPUTSRC_AVD) && (Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)) {
		DbgSclrFlgTkr.main_winfreeze=bonoff;
	} else {
		Scaler_SetFreeze(channel, bonoff);
	}
	up(&VSC_Semaphore);
	up(&Magnifier_Semaphore);
	return TRUE;
}


static unsigned char ForceSmoothtoggleGo = FALSE;

unsigned char get_ForceSmoothtoggleGo(void)
{
	return ForceSmoothtoggleGo;
}

void SelfDiagnosis_mainscaler_run(SCALER_DISP_CHANNEL channel, VIDEO_RECT_T inregion, VIDEO_RECT_T outregion)
{
	if (channel == SLR_MAIN_DISPLAY) {
		/*re run main scaler start*/
		main_input_size.srcx = inregion.x;
		main_input_size.srcy = inregion.y;
		main_input_size.src_wid = inregion.w;
		main_input_size.src_height = inregion.h;
		set_input_for_vgip(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
		set_input_for_crop(SLR_MAIN_DISPLAY, main_input_size);
		set_input_timing_for_crop(SLR_MAIN_DISPLAY, main_input_timing);

		set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, TRUE);//Enable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
		mute_control(SLR_MAIN_DISPLAY, TRUE);
		//Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH); //Remove by Will
		down(&SetMainOutPutRegion_Semaphore);
		if ((outregion.w + outregion.x > _DISP_WID) || (outregion.h + outregion.y > _DISP_LEN)) {
			main_dispwin.srcx = 0;
			main_dispwin.srcy = 0;
			main_dispwin.src_height = _DISP_LEN;
			main_dispwin.src_wid = _DISP_WID;
		} else {
			main_dispwin.srcx = outregion.x;
			main_dispwin.srcy = outregion.y;
			main_dispwin.src_height = outregion.h;
			main_dispwin.src_wid = outregion.w;
		}
		Scaler_DispWindowSet(main_dispwin);
		up(&SetMainOutPutRegion_Semaphore);

		down(&VSC_Semaphore);
		DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;
		if (Scaler_InputSrcGetType(SLR_MAIN_DISPLAY) == _SRC_VO) {
			DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = TRUE;
		}
		set_current_scaler_source_num(SLR_MAIN_DISPLAY);//record current vsc source num
		rtk_output_connect(SLR_MAIN_DISPLAY);
		up(&VSC_Semaphore);
		mute_control(SLR_MAIN_DISPLAY, FALSE);
	} else if (channel == SLR_SUB_DISPLAY) {
		/*re run sub scaler start*/
		sub_input_size.srcx = inregion.x;
		sub_input_size.srcy = inregion.y;
		sub_input_size.src_wid = inregion.w;
		sub_input_size.src_height = inregion.h;
		set_input_for_vgip(SLR_SUB_DISPLAY, sub_input_size.srcx, sub_input_size.srcy, sub_input_size.src_wid, sub_input_size.src_height);
		set_input_for_crop(SLR_SUB_DISPLAY, sub_input_size);
		set_input_timing_for_crop(SLR_SUB_DISPLAY, sub_input_timing);
		mute_control(SLR_SUB_DISPLAY, TRUE);
		//Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH); //Remove by Will
		down(&SetSubOutPutRegion_Semaphore);
		if ((outregion.w + outregion.x > _DISP_WID) || (outregion.h + outregion.y > _DISP_LEN)) {
			sub_dispwin.srcx = 0;
			sub_dispwin.srcy = 0;
			sub_dispwin.src_height = _DISP_LEN;
			sub_dispwin.src_wid = _DISP_WID;
		} else {
			sub_dispwin.srcx = outregion.x;
			sub_dispwin.srcy = outregion.y;
			sub_dispwin.src_height = outregion.h;
			sub_dispwin.src_wid = outregion.w;
		}
		Scaler_SubDispWindowSet(sub_dispwin);
		up(&SetSubOutPutRegion_Semaphore);

		down(&VSC_Semaphore);
		DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;
		set_current_scaler_source_num(SLR_SUB_DISPLAY);//record current vsc source num
		rtk_output_connect(SLR_SUB_DISPLAY);
		up(&VSC_Semaphore);
		mute_control(SLR_SUB_DISPLAY, FALSE);
	}
}



unsigned static char Factory_SelfDiagnosis_Mode = FALSE;

unsigned char Get_Factory_SelfDiagnosis_Mode(void)
{
	return Factory_SelfDiagnosis_Mode;
}

unsigned char change_vscinput_with_vfetiming(SCALER_DISP_CHANNEL channel)
{
	VIDEO_RECT_T  inregion;
	VIDEO_RECT_T outregion;
	unsigned int timeoutcount;

	timeoutcount = 60;
	do {
		if((Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
			&&(Check_ForceBG_Mask_Enable(channel, TRUE)==FALSE))
		{
			break;
		} else {
			msleep(200);
		}
		timeoutcount--;
	} while(timeoutcount);

	if(timeoutcount==0)
		rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "wait active timeoutcount 0#####[%s(%d)]\n", __FUNCTION__, __LINE__);


	if(Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) {
		if(channel == SLR_MAIN_DISPLAY) {
#ifdef CONFIG_ENABLE_VD_27MHZ_MODE
			//self-dianosis AV source have to do no overscan @Crixus 20151201
			if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD){
				//self-dianosis AV source, rzhen@2016-09-01
				if(read_buffer_first_flag) return TRUE;
				read_buffer_first_flag = 1;

				inregion.x = 0;
				inregion.y = 0;
				inregion.w = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE);
				inregion.h = (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE) ? 2*Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) : Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE));

				main_input_size.srcx = inregion.x;
				main_input_size.srcy = inregion.y;
				main_input_size.src_wid = inregion.w;
				main_input_size.src_height = inregion.h;
				set_input_for_vgip(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);

				outregion.x = 0;
				outregion.y = 0;
				outregion.w = _DISP_WID;
				outregion.h = _DISP_LEN;

				main_dispwin.srcx = outregion.x;
				main_dispwin.srcy = outregion.y;
				main_dispwin.src_height = outregion.h;
				main_dispwin.src_wid = outregion.w;
				Scaler_DispWindowSet(main_dispwin);

				if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY) == FALSE){
					mute_control(SLR_MAIN_DISPLAY, TRUE);/*Auto BG. Add by Will*/
				}

				Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);//Let main path to search state. In order to request VO
				down(&SetMainOutPutRegion_Semaphore);
				DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;//Let main path run scaler again
				up(&SetMainOutPutRegion_Semaphore);
				msleep(1000);
			}
			else
#endif
			{
				StructSrcRect maindispwind;

				inregion.x = 0;
				inregion.y = 0;
				inregion.w = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE);
				inregion.h = (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE) ? 2*Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) : Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE));

				outregion.x = 0;
				outregion.y = 0;
				outregion.w = _DISP_WID;
				outregion.h = _DISP_LEN;
				maindispwind = Scaler_DispWindowGet();
				if((inregion.x != Main_InputRegion_x)
					||(inregion.y != Main_InputRegion_y)
					||(inregion.w != Main_InputRegion_w)
					||(inregion.h != Main_InputRegion_h)
					||(maindispwind.srcx != outregion.x)
					||(maindispwind.srcy != outregion.y)
					||(maindispwind.src_wid != outregion.w)
					||(maindispwind.src_height != outregion.h)
					||dvrif_memory_compression_get_enable(SLR_MAIN_DISPLAY)
					){

					rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "#####[%s(%d)] \n", __FUNCTION__, __LINE__);
					SelfDiagnosis_mainscaler_run(SLR_MAIN_DISPLAY, inregion, outregion);
					msleep(1000);
				}
			}
		} else if (channel == SLR_SUB_DISPLAY){
#if 0//def CONFIG_ENABLE_VD_27MHZ_MODE
			//self-dianosis AV source have to do no overscan @Crixus 20151201
			if(Get_DisplayMode_Src(SLR_SUB_DISPLAY) == KADP_VSC_INPUTSRC_AVD){
				if(read_buffer_first_flag == 0){
					read_buffer_first_flag = 1;
					Scaler_AVD_EnableVD27MMode(VD_27M_OFF);
					msleep(1000);
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "[self-dianosis]read buffrt 27M on !!\n");
				}
			} else
#endif
			{
				StructSrcRect subdispwind;
				inregion.x = 0;
				inregion.y = 0;
				inregion.w = Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE);
				inregion.h = (Scaler_DispGetStatus(SLR_SUB_DISPLAY, SLR_DISP_INTERLACE) ? 2*Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) : Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE));

				outregion.x = 0;
				outregion.y = 0;
				outregion.w = _DISP_WID;
				outregion.h = _DISP_LEN;
				subdispwind = Scaler_SubDispWindowGet();
				if((inregion.x != Main_InputRegion_x)
					||(inregion.y != Main_InputRegion_y)
					||(inregion.w != Main_InputRegion_w)
					||(inregion.h != Main_InputRegion_h)
					||(subdispwind.srcx != outregion.x)
					||(subdispwind.srcy != outregion.y)
					||(subdispwind.src_wid != outregion.w)
					||(subdispwind.src_height != outregion.h)
					) {
					SelfDiagnosis_mainscaler_run(SLR_SUB_DISPLAY, inregion, outregion);
				}
			}
		}
		return TRUE;
	} else {
		rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "wait active NG#####[%s(%d)]\n", __FUNCTION__, __LINE__);
		return FALSE;
	}
}

unsigned char rtk_hal_vsc_FreezeVideoFrameBuffer(VIDEO_WID_T wid, bool bonoff)
{
	SCALER_DISP_CHANNEL channel;
#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN) || (wid > VIDEO_WID_MAX))
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	}
#endif

	if (wid ==VIDEO_WID_0) {
		channel = SLR_MAIN_DISPLAY;
	} else if (wid ==VIDEO_WID_1) {
		channel = SLR_SUB_DISPLAY;
	}

	if(change_vscinput_with_vfetiming(channel) == FALSE){/*for self diagnosis vfe vsc no overscan*/
		rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "change_vscinput_with_vfetiming not ok\n");
		return FALSE;
	}

	drvif_scalerdisplay_set_freeze(channel, bonoff);
	Scaler_SetDisplaySingleBufferMode(channel, bonoff);
	return TRUE;
}

unsigned char rtk_hal_vsc_ReadVideoFrameBuffer(VIDEO_WID_T wid, VIDEO_RECT_T * pin,KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T * pRead, KADP_VIDEO_DDI_COLOR_STANDARD_T *pColor_standard, KADP_VIDEO_DDI_PIXEL_COLOR_FORMAT_T * pPixelColorFormat)
{
	unsigned int linesize;
	unsigned char * capturebufferaddr;
	unsigned int capturebuffersize;
	unsigned int capturebufferphyaddr;

	SCALER_DISP_CHANNEL channel;
	KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T * readaddr = pRead;
#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	}
#endif

	if (wid ==VIDEO_WID_0) {
		channel = SLR_MAIN_DISPLAY;
	} else if (wid ==VIDEO_WID_1) {
		channel = SLR_SUB_DISPLAY;
	}

	if(change_vscinput_with_vfetiming(channel) == FALSE){/*for self diagnosis vfe vsc no overscan*/
		rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "change_vscinput_with_vfetiming not ok\n");
		return FALSE;
	}

	if (pRead == NULL) {
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "pRead == NULL not ok\n");
		return FALSE;
	}

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "x=%d;;y=%d;;w=%d;;h=%d\n", pin->x, pin->y, pin->w,pin->h);
	if(((pin->x+pin->w)>Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_CAP_WID)) || ((pin->y+pin->h)>Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_CAP_LEN)))
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wrong ReadVideoFrameBuffer size!!!!!!!\n");
		return FALSE;
	}

	//linesize = memory_get_capture_size(channel, MEMCAPTYPE_LINE);
	//linesize = drvif_memory_get_data_align(linesize, DMA_SPEEDUP_ALIGN_VALUE/8);

	//linesize = SHL(linesize, 3); //unit conversion. 64bits to 8bits

	if (channel == SLR_MAIN_DISPLAY) {
		linesize = IoReg_Read32(MDOMAIN_DISP_DDR_MainLineStep_reg);
		capturebufferaddr = (unsigned char *)drvif_memory_get_mainblock_viraddr();
		capturebuffersize = drvif_memory_get_block_size(MEMIDX_MAIN);
		capturebufferphyaddr = drvif_memory_get_block_addr(MEMIDX_MAIN);
	} else if (channel == SLR_SUB_DISPLAY) {
		linesize = IoReg_Read32(MDOMAIN_DISP_DDR_SubLineStep_reg);
		capturebufferaddr = (unsigned char *)drvif_memory_get_subblock_viraddr();
		capturebuffersize = drvif_memory_get_block_size(MEMIDX_SUB);
		capturebufferphyaddr = drvif_memory_get_block_addr(MEMIDX_SUB);
	}

	//dmac_inv_range(capturebufferaddr, capturebufferaddr + capturebuffersize);
	//outer_inv_range(capturebufferphyaddr, capturebufferphyaddr + capturebuffersize);

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "linesize==%d\n",linesize);
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "capturebufferaddr==%lx\n",drvif_memory_get_mainblock_viraddr());
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "m domain pixel:%x;%x;%x;%x\n",capturebufferaddr[0],capturebufferaddr[1],capturebufferaddr[2],capturebufferaddr[3]);
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "m domain pixel:%x;%x;%x;%x\n",capturebufferaddr[4],capturebufferaddr[5],capturebufferaddr[6],capturebufferaddr[7]);
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "m domain pixel:%x;%x;%x;%x\n",capturebufferaddr[8],capturebufferaddr[9],capturebufferaddr[10],capturebufferaddr[11]);
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "m domain pixel:%x;%x;%x;%x\n",capturebufferaddr[12],capturebufferaddr[13],capturebufferaddr[14],capturebufferaddr[15]);
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "SLR_DISP_10BIT = %x\n",(Scaler_DispGetStatus(channel, SLR_DISP_10BIT)));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "SLR_DISP_422CAP = %x\n",(Scaler_DispGetStatus(channel, SLR_DISP_422CAP)));


	if(Scaler_DispGetStatus(channel, SLR_DISP_10BIT))
	{
		rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "SLR_DISP_10BIT no support read write m domain\n");
		return FALSE;
#if	0
		* pPixelColorFormat = KADP_VIDEO_DDI_PIXEL_10BIT;
		* pColor_standard = KADP_VIDEO_DDI_COLOR_STANDARD_YUV;
		if(Scaler_DispGetStatus(channel, SLR_DISP_422CAP))//10bit 422 format
		{
			unsigned int*  linebuffer=NULL;
			unsigned int* srclineptr;
			unsigned int tempvalue;
			unsigned int arraynum = ((pin->x+pin->w)%2)?(pin->x+pin->w+1):(pin->x+pin->w);
			KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *linepixel = NULL;
			unsigned int remainbit;
			unsigned int highvalue,lowvalue;
			unsigned int value4byte;
			unsigned int colorindex;
			unsigned int i;
			unsigned int j ;
			unsigned int p;
#if 0
			linebuffer = (unsigned int*)dvr_malloc(linesize);
			linepixel = (VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc(arraynum*sizeof(VIDEO_DDI_PIXEL_STANDARD_COLOR_T));
#else
			linebuffer = (unsigned int*)dvr_malloc_specific(linesize, GFP_DCU1_FIRST);
			linepixel = (KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc_specific(arraynum*sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T), GFP_DCU1_FIRST);
#endif
			if(linebuffer == NULL)
			{
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "rtk_hal_vsc_ReadVideoFrameBuffer:allocate memoty fail!!!!!\n");
				return FALSE;
			}
			for(p=0;p<pin->h;p++)
			{
				srclineptr = (unsigned int*)(capturebufferaddr+(pin->y+p)*linesize);
				//Do Swap start
				for(i=0; i<(linesize>>2);i++)
				{
					linebuffer[i] =( (srclineptr[i]&0x000000ff)<<24 )|( (srclineptr[i]&0x0000ff00)<<8 )| ( (srclineptr[i]&0x00ff0000)>>8 )|( (srclineptr[i]&0xff000000)>>24 );
				}
				for(i=0; i<(linesize>>2);i+=2)
				{
					tempvalue  = linebuffer[i];
					linebuffer[i] = linebuffer[i+1];
					linebuffer[i+1] = tempvalue;
				}
				//Do Swap end

				remainbit = 0;
				value4byte =0;
				i=0;
				j =0;
				colorindex = 0;
				for(i=0;i<arraynum;)
				{
					if(remainbit<10)
					{
						lowvalue = value4byte;
						value4byte = linebuffer[j++];
						highvalue = (value4byte&(0x000003ff>>remainbit))<<remainbit;
						highvalue = highvalue|lowvalue;
						value4byte = value4byte >> (10-remainbit);
						remainbit = 32-(10-remainbit);
					}
					else
					{
						highvalue = value4byte&0x000003ff;
						value4byte = value4byte>>10;
						remainbit = remainbit - 10;
					}
					switch(colorindex)
					{
						case 0:
							linepixel[i].pixelStandardCb = highvalue;
							linepixel[i+1].pixelStandardCb = highvalue;
							colorindex = 1;
							break;
						case 1:
							linepixel[i].pixelStandardY = highvalue;
							colorindex = 2;
							break;
						case 2:
							linepixel[i].pixelStandardCr= highvalue;
							linepixel[i+1].pixelStandardCr = highvalue;
							colorindex = 3;
							break;
						case 3:
							linepixel[i+1].pixelStandardY = highvalue;
							colorindex = 0;
							i = i+2;
							break;
					}
				}
				memcpy((unsigned char *)(readaddr+p*pin->w), (unsigned char *)(linepixel+pin->x), (pin->w)*sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T));
			}
			dvr_free((void *)linebuffer);
			dvr_free((void *)linepixel);
		}
		else//10bit 444 format
		{
			unsigned int *linebuffer=NULL;
			unsigned int *srclineptr;
			unsigned int tempvalue;
			unsigned int arraynum = pin->x+pin->w;
			KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *linepixel = NULL;
			unsigned int remainbit;
			unsigned int highvalue,lowvalue;
			unsigned int value4byte;
			unsigned int colorindex;
			unsigned int i;
			unsigned int j ;
			unsigned int p;
#if 0
			linebuffer = (unsigned int*)dvr_malloc(linesize);
			linepixel = (VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc(arraynum*sizeof(VIDEO_DDI_PIXEL_STANDARD_COLOR_T));
#else
			linebuffer = (unsigned int*)dvr_malloc_specific(linesize, GFP_DCU1_FIRST);
			linepixel = (KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc_specific(arraynum*sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T), GFP_DCU1_FIRST);
#endif
			if(linebuffer == NULL)
			{
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "rtk_hal_vsc_ReadVideoFrameBuffer:allocate memoty fail!!!!!\n");
				return FALSE;
			}
			for(p=0;p<pin->h;p++)
			{
				srclineptr = (unsigned int*)(capturebufferaddr+(pin->y+p)*linesize);
				//Do Swap start
				for(i=0; i<(linesize>>2);i++)
				{
					linebuffer[i] =( (srclineptr[i]&0x000000ff)<<24 )|( (srclineptr[i]&0x0000ff00)<<8 )| ( (srclineptr[i]&0x00ff0000)>>8 )|( (srclineptr[i]&0xff000000)>>24 );
				}
	    			for(i=0; i<(linesize>>2);i+=2)
				{
					tempvalue  = linebuffer[i];
					linebuffer[i] = linebuffer[i+1];
					linebuffer[i+1] = tempvalue;
				}
				//Do Swap end

				remainbit = 0;
				value4byte =0;
				i=0;
				j =0;
				colorindex = 0;
				for(i=0;i<(pin->x+pin->w);)
				{
					if(remainbit<10)
			       		 {
			           		lowvalue = value4byte;
			        		value4byte = linebuffer[j++];
						highvalue = (value4byte&(0x000003ff>>remainbit))<<remainbit;
					    	highvalue = highvalue|lowvalue;
						value4byte = value4byte >> (10-remainbit);
						remainbit = 32-(10-remainbit);
			        	}
					else
					{
						highvalue = value4byte&0x000003ff;
						value4byte = value4byte>>10;
						remainbit = remainbit - 10;
					}
					switch(colorindex)
					{
						case 0:
							linepixel[i].pixelStandardCr = highvalue;
							colorindex = 1;
							break;
						case 1:
							linepixel[i].pixelStandardCb = highvalue;
							colorindex = 2;
							break;
						case 2:
							linepixel[i].pixelStandardY= highvalue;
							colorindex = 0;
							i++;
							break;
					}
				}
				memcpy((unsigned char *)(readaddr+p*pin->w), (unsigned char *)(linepixel+pin->x), (pin->w)*sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T));
			}
			dvr_free((void *)linebuffer);
			dvr_free((void *)linepixel);
		}
		return TRUE;
#endif
	}
	else
	{
		unsigned int i,k;
		* pPixelColorFormat = KADP_VIDEO_DDI_PIXEL_8BIT;
		* pColor_standard = KADP_VIDEO_DDI_COLOR_STANDARD_YUV;
		if(Scaler_DispGetStatus(channel, SLR_DISP_422CAP))//8bit 422 format
		{
			for(i=pin->y;i<(pin->y + pin->h);i++)
			{
				for(k=pin->x;k<(pin->x + pin->w);k++)
				{
					readaddr->pixelStandardY = capturebufferaddr[i*linesize+2*k];
					readaddr->pixelStandardCb = capturebufferaddr[i*linesize+2*(k/2)*2+1];
					readaddr->pixelStandardCr = capturebufferaddr[i*linesize+2*(k/2)*2+3];
					readaddr ++;
				}
			}
		}
		else//8bit 444 fromat
		{
			for(i=pin->y;i<(pin->y + pin->h);i++)
			{
				for(k=pin->x;k<(pin->x + pin->w);k++)
				{
					readaddr->pixelStandardY= capturebufferaddr[i*linesize+3*k+2];
					readaddr->pixelStandardCb= capturebufferaddr[i*linesize+3*k+1];
					readaddr->pixelStandardCr= capturebufferaddr[i*linesize+3*k];
					readaddr++;
				}
			}
		}
		return TRUE;
	}
}

unsigned char rtk_hal_vsc_WriteVideoFrameBuffer(KADP_VIDEO_WID_T wid, KADP_VIDEO_RECT_T * pin,KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T * pWrite)
{
	unsigned int linesize;
	unsigned char * capturebufferaddr;
	unsigned int capturebuffersize;
	unsigned int capturebufferphyaddr;

	SCALER_DISP_CHANNEL channel;
	KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T * writeaddr = pWrite;
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "pWrite = %lx\n",(unsigned long)pWrite);
#ifdef CONFIG_DUAL_CHANNEL
	if((wid < KADP_VIDEO_WID_MIN)||(wid > KADP_VIDEO_WID_MAX))
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=KADP_VIDEO_WID_0)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
		return FALSE;
	}
#endif

	if (wid ==KADP_VIDEO_WID_0) {
		channel = SLR_MAIN_DISPLAY;
	} else if (wid ==KADP_VIDEO_WID_1) {
		channel = SLR_SUB_DISPLAY;
	}

	if(change_vscinput_with_vfetiming(channel) == FALSE){/*for self diagnosis vfe vsc no overscan*/
		rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "change_vscinput_with_vfetiming not ok\n");
		return FALSE;
	}

	if(pWrite == NULL)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "pWrite == NULL not ok\n");
		return FALSE;
	}
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "x=%d;;y=%d;;w=%d;;h=%d\n", pin->x, pin->y, pin->w, pin->h);

	if(((pin->x+pin->w)>Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_CAP_WID))||((pin->y+pin->h)>Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_CAP_LEN)))
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wrong WriteVideoFrameBuffer size!!!!!!!\n");
		return FALSE;
	}

	//linesize = memory_get_capture_size(channel, MEMCAPTYPE_LINE);
	//linesize = SHL(linesize, 3); //unit conversion. 64bits to 8bits


	if (channel == SLR_MAIN_DISPLAY) {
		linesize = IoReg_Read32(MDOMAIN_DISP_DDR_MainLineStep_reg);
		capturebufferaddr = (unsigned char *)drvif_memory_get_mainblock_viraddr();
		capturebuffersize = drvif_memory_get_block_size(MEMIDX_MAIN);
		capturebufferphyaddr = drvif_memory_get_block_addr(MEMIDX_MAIN);
	} else if (channel == SLR_SUB_DISPLAY) {
		linesize = IoReg_Read32(MDOMAIN_DISP_DDR_SubLineStep_reg);
		capturebufferaddr = (unsigned char *)drvif_memory_get_subblock_viraddr();
		capturebuffersize = drvif_memory_get_block_size(MEMIDX_SUB);
		capturebufferphyaddr = drvif_memory_get_block_addr(MEMIDX_SUB);
	}
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "linesize = %d\n",linesize);
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "capturebufferaddr = %lx\n",(unsigned long)capturebufferaddr);
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "SLR_DISP_10BIT = %x\n",(Scaler_DispGetStatus(channel, SLR_DISP_10BIT)));
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "SLR_DISP_422CAP = %x\n",(Scaler_DispGetStatus(channel, SLR_DISP_422CAP)));

	if(Scaler_DispGetStatus(channel, SLR_DISP_10BIT))
	{
		rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "SLR_DISP_10BIT no support read write m domain\n");

		return FALSE;
#if 0
		if(Scaler_DispGetStatus(channel, SLR_DISP_422CAP))//422 10bit fomat
		{
			unsigned int arraynum = Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_CAP_WID);
			unsigned int*  linebuffer=NULL;
			unsigned int* srclineptr;
			unsigned int tempvalue;
			KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *linepixel=NULL;
			unsigned int remainbit;
			unsigned int highvalue,lowvalue;
			unsigned int value4byte;
			unsigned int colorindex;
			unsigned int i;
			unsigned int j ;
			unsigned int p;

			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "arraynum = %d\n",arraynum);
#if 0
			linebuffer = (unsigned int*)dvr_malloc(linesize);
			linepixel = (VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc(arraynum*sizeof(VIDEO_DDI_PIXEL_STANDARD_COLOR_T));
#else
			linebuffer = (unsigned int*)dvr_malloc_specific(linesize, GFP_DCU1_FIRST);
			linepixel = (KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc_specific(arraynum*sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T), GFP_DCU1_FIRST);
#endif

			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "linebuffer = %lx\n",(unsigned long)linebuffer);
			if(linebuffer == NULL)
			{
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "rtk_hal_vsc_ReadVideoFrameBuffer:allocate memoty fail!!!!!\n");
				return FALSE;
			}
			for(p=0;p<pin->h;p++)
			{
				srclineptr = (unsigned int*)(capturebufferaddr+(pin->y+p)*linesize);
				//Do Swap start
				for(i=0; i<(linesize>>2);i++)
				{
					linebuffer[i] =( (srclineptr[i]&0x000000ff)<<24 )|( (srclineptr[i]&0x0000ff00)<<8 )| ( (srclineptr[i]&0x00ff0000)>>8 )|( (srclineptr[i]&0xff000000)>>24 );
				}
				for(i=0; i<(linesize>>2);i+=2)
				{
					tempvalue  = linebuffer[i];
					linebuffer[i] = linebuffer[i+1];
					linebuffer[i+1] = tempvalue;
				}
				//Do Swap end

				remainbit = 0;
				value4byte =0;
				i=0;
				j =0;
				colorindex = 0;
				for(i=0;i<arraynum;)
				{
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "arraynum = %d\n",arraynum);
					if((remainbit<10)&&(remainbit>=0))
					{
						lowvalue = value4byte;
						value4byte = linebuffer[j++];
						highvalue = (value4byte&(0x000003ff>>remainbit))<<remainbit;
						highvalue = highvalue|lowvalue;
						value4byte = value4byte >> (10-remainbit);
						remainbit = 32-(10-remainbit);
					}
					else if((remainbit>=10)&&(remainbit<=32))
					{
						highvalue = value4byte&0x000003ff;
						value4byte = value4byte>>10;
						remainbit = remainbit - 10;
					}
					switch(colorindex)
					{
						case 0:
							linepixel[i].pixelStandardCb = highvalue;
							linepixel[i+1].pixelStandardCb = highvalue;
							colorindex = 1;
							break;
						case 1:
							linepixel[i].pixelStandardY = highvalue;
							colorindex = 2;
							break;
						case 2:
							linepixel[i].pixelStandardCr= highvalue;
							linepixel[i+1].pixelStandardCr = highvalue;
							colorindex = 3;
							break;
						case 3:
							linepixel[i+1].pixelStandardY = highvalue;
							colorindex = 0;
							i = i+2;
							break;
					}
				}
				//write user's pixel to linepixel array
				memcpy((unsigned char *)(linepixel+pin->x),(unsigned char *)(writeaddr+p*pin->w), (pin->w)*sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T));
				//clear linebuffer
				memset((unsigned char *)linebuffer, 0,linesize);
				//linepixel is the new pixel line should be written in memory. so next do
				remainbit = 32;
				value4byte =0;
				i=0;
				j =0;
				colorindex = 0;
				for(i=0;i<arraynum;)
				{
					switch(colorindex)
					{
						case 0:
							value4byte = linepixel[i].pixelStandardCb;
							colorindex = 1;
							break;
						case 1:
							value4byte = linepixel[i].pixelStandardY;
							colorindex = 2;
							break;
						case 2:
							value4byte = linepixel[i].pixelStandardCr;
							colorindex = 3;
							break;
						case 3:
							value4byte = linepixel[i+1].pixelStandardY;
							colorindex = 0;
							i = i+2;
							break;
					}

					if(remainbit==0)
			       	{
						//lowvalue = value4byte&0;
						highvalue = (value4byte&0x000003ff);
						linebuffer[j] = linebuffer[j];
						j++;
						linebuffer[j] = linebuffer[j] |highvalue;
						remainbit = 32-(10-remainbit);
			        }
					else if(remainbit<10)&&(remainbit>0)
			       	{
						lowvalue = value4byte&(0x000003ff>>(10-remainbit));
						highvalue = (value4byte&0x000003ff)>>remainbit;
						linebuffer[j] = linebuffer[j] |(lowvalue<<(32-remainbit));
						j++;
						linebuffer[j] = linebuffer[j] |highvalue;
						remainbit = 32-(10-remainbit);
			        }
					else if((remainbit>=10)&&(remainbit<=32))
					{
				        linebuffer[j] =  linebuffer[j] |(value4byte&0x000003ff)<<(32-remainbit);
				        remainbit = remainbit - 10;
					}
				}
				//Do Swap start
				for(i=0; i<(linesize>>2);i++)
				{
					srclineptr[i] =( (linebuffer[i]&0x000000ff)<<24 )|( (linebuffer[i]&0x0000ff00)<<8 )| ( (linebuffer[i]&0x00ff0000)>>8 )|( (linebuffer[i]&0xff000000)>>24 );
				}
	    			for(i=0; i<(linesize>>2);i+=2)
				{
					tempvalue  = srclineptr[i];
					srclineptr[i] = srclineptr[i+1];
					srclineptr[i+1] = tempvalue;
				}
				//Do Swap end
			}
			dvr_free((void *)linebuffer);
			dvr_free((void *)linepixel);
		}
		else//444 10bit format
		{
			unsigned int arraynum = Scaler_DispGetInputInfoByDisp(channel, SLR_INPUT_CAP_WID);
			unsigned int*  linebuffer=NULL;
			unsigned int* srclineptr;
			unsigned int tempvalue;
			KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *linepixel = NULL;
			unsigned int remainbit;
			unsigned int highvalue,lowvalue;
			unsigned int value4byte;
			unsigned int colorindex;
			unsigned int i;
			unsigned int j ;
			unsigned int p;

#if 0
			linebuffer = (unsigned int*)dvr_malloc(linesize);
			linepixel = (VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc(arraynum*sizeof(VIDEO_DDI_PIXEL_STANDARD_COLOR_T));
#else
			linebuffer = (unsigned int*)dvr_malloc_specific(linesize, GFP_DCU1_FIRST);
			linepixel = (KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc_specific(arraynum*sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T), GFP_DCU1_FIRST);
#endif
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "arraynum = %d\n",arraynum);
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "linebuffer = %lx\n",(unsigned long)linebuffer);

			if(linebuffer == NULL)
			{
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "rtk_hal_vsc_WriteVideoFrameBuffer:allocate memoty fail!!!!!\n");
				return FALSE;
			}
			for(p=0;p<pin->h;p++)
			{
				srclineptr = (unsigned int*)(capturebufferaddr+(pin->y+p)*linesize);
				//Do Swap start
				for(i=0; i<(linesize>>2);i++)
				{
					linebuffer[i] =( (srclineptr[i]&0x000000ff)<<24 )|( (srclineptr[i]&0x0000ff00)<<8 )| ( (srclineptr[i]&0x00ff0000)>>8 )|( (srclineptr[i]&0xff000000)>>24 );
				}
	    		for(i=0; i<(linesize>>2);i+=2)
				{
					tempvalue  = linebuffer[i];
					linebuffer[i] = linebuffer[i+1];
					linebuffer[i+1] = tempvalue;
				}
				//Do Swap end
				remainbit = 0;
				value4byte =0;
				i=0;
				j =0;
				colorindex = 0;
				for(i=0;i<arraynum;)
				{
					if(remainbit<10)
			       	{
			           	lowvalue = value4byte;
			        	value4byte = linebuffer[j++];
						highvalue = (value4byte&(0x000003ff>>remainbit))<<remainbit;
					    highvalue = highvalue|lowvalue;
						value4byte = value4byte >> (10-remainbit);
						remainbit = 32-(10-remainbit);
			        }
					else if((remainbit>=10)&&(remainbit<=32))
					{
						highvalue = value4byte&0x000003ff;
						value4byte = value4byte>>10;
						remainbit = remainbit - 10;
					}
					switch(colorindex)
					{
						case 0:
							linepixel[i].pixelStandardCr = highvalue;
							colorindex = 1;
							break;
						case 1:
							linepixel[i].pixelStandardCb = highvalue;
							colorindex = 2;
							break;
						case 2:
							linepixel[i].pixelStandardY= highvalue;
							colorindex = 0;
							i++;
							break;
					}
				}

				//write user's pixel to linepixel array
				memcpy((unsigned char *)(linepixel+pin->x),(unsigned char *)(writeaddr+p*pin->w), (pin->w)*sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T));
				//clear linebuffer
				memset((unsigned char *)linebuffer, 0,linesize);
				//linepixel is the new pixel line should be written in memory. so next do
				remainbit = 32;
				value4byte =0;
				i=0;
				j =0;
				colorindex = 0;
				for(i=0;i<arraynum;)
				{
					switch(colorindex)
					{
						case 0:
							value4byte = linepixel[i].pixelStandardCr;
							colorindex = 1;
							break;
						case 1:
							value4byte = linepixel[i].pixelStandardCb;
							colorindex = 2;
							break;
						case 2:
							value4byte = linepixel[i].pixelStandardY;
							colorindex = 0;
							i++;
							break;
					}

					if(remainbit==0)
			       	{
						//lowvalue = value4byte&(0x000003ff>>(10-remainbit));
						highvalue = (value4byte&0x000003ff);
						//linebuffer[j] = linebuffer[j];
						j++;
						linebuffer[j] = linebuffer[j] |highvalue;
						remainbit = 32-(10-remainbit);
			        }
					else if((remainbit<10)&&(remainbit>0))
			       	{
						lowvalue = value4byte&(0x000003ff>>(10-remainbit));
						highvalue = (value4byte&0x000003ff)>>remainbit;
						linebuffer[j] = linebuffer[j] |(lowvalue<<(32-remainbit));
						j++;
						linebuffer[j] = linebuffer[j] |highvalue;
						remainbit = 32-(10-remainbit);
			        }
					else if((remainbit>=10)&&(remainbit<=32))
					{
						linebuffer[j] =  linebuffer[j] |(value4byte&0x000003ff)<<(32-remainbit);
						remainbit = remainbit - 10;
					}
				}
				//Do Swap start
				for(i=0; i<(linesize>>2);i++)
				{
					srclineptr[i] =( (linebuffer[i]&0x000000ff)<<24 )|( (linebuffer[i]&0x0000ff00)<<8 )| ( (linebuffer[i]&0x00ff0000)>>8 )|( (linebuffer[i]&0xff000000)>>24 );
				}
	    			for(i=0; i<(linesize>>2);i+=2)
				{
					tempvalue  = srclineptr[i];
					srclineptr[i] = srclineptr[i+1];
					srclineptr[i+1] = tempvalue;
				}
				//Do Swap end
			}

			dvr_free((void *)linebuffer);
			dvr_free((void *)linepixel);
		}
#endif
	}
	else
	{
		unsigned int i,k;
		if(Scaler_DispGetStatus(channel, SLR_DISP_422CAP))//422 8bit fomat
		{
			for(i=pin->y;i<(pin->y + pin->h);i++)
			{
				for(k=pin->x;k<(pin->x + pin->w);k++)
				{
					capturebufferaddr[i*linesize+2*k] = writeaddr->pixelStandardY;
					capturebufferaddr[i*linesize+2*(k/2)*2+1] = writeaddr->pixelStandardCb;
					capturebufferaddr[i*linesize+2*(k/2)*2+3] = writeaddr->pixelStandardCr;
					writeaddr ++;
				}
			}
		}
		else//444 8bit format
		{
			for(i=pin->y;i<(pin->y + pin->h);i++)
			{
				for(k=pin->x;k<(pin->x + pin->w);k++)
				{
					capturebufferaddr[i*linesize+3*k+2] = writeaddr->pixelStandardY;
					capturebufferaddr[i*linesize+3*k+1] = writeaddr->pixelStandardCb;
					capturebufferaddr[i*linesize+3*k] = writeaddr->pixelStandardCr;
					writeaddr++;
				}
			}
		}
	}
	dmac_flush_range(capturebufferaddr, capturebufferaddr + capturebuffersize);
	outer_flush_range(capturebufferphyaddr, capturebufferphyaddr + capturebuffersize);
	return TRUE;
}

/*New HAL_VSC function*/
//add vsc pattern @Crixus 20170419
unsigned char rtk_hal_vsc_SetPattern(BOOLEAN on_off, VIDEO_WID_T winID, VSC_VIDEO_PATTERN_LOCATION_T pattern_location){
       vgip_vgip_chn1_ctrl_RBUS vgip_vgip_chn1_ctrl_reg;
       sub_vgip_vgip_chn2_ctrl_RBUS sub_vgip_vgip_chn2_ctrl_reg;
       scaleup_d_uzu_globle_ctrl_RBUS scaleup_d_uzu_globle_ctrl_reg;
       scaleup_ds_uzu_globle_ctrl_RBUS scaleup_ds_uzu_globle_ctrl_reg;
       sfg_sfg_force_bg_at_dif_RBUS sfg_sfg_force_bg_at_dif_reg;
	   di_di_ptg_ctrl_RBUS di_di_ptg_ctrl_reg;//ecn RL6543-594
	   di_di_ptg_act_window_RBUS di_di_ptg_act_window_reg;//ecn RL6543-594

#ifdef CONFIG_DUAL_CHANNEL
       if((winID < VIDEO_WID_MIN)||(winID > VIDEO_WID_MAX))
       {
               rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
               return FALSE;
       }
#else
       if(winID !=VIDEO_WID_0)
       {
               rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "wid id is not ok\n");
               return FALSE;
       }
#endif

       printk(KERN_EMERG"[%s]on_off = %d, winID = %d, pattern_location = %d\n", __FUNCTION__, on_off, winID, pattern_location);
       switch(pattern_location){
				case VSC_VIDEO_PATTERN_MUX:
					if(winID == VIDEO_WID_0){
						vgip_vgip_chn1_ctrl_reg.regValue = IoReg_Read32(VGIP_VGIP_CHN1_CTRL_reg);
						vgip_vgip_chn1_ctrl_reg.ch1_random_en = on_off;
						IoReg_Write32(VGIP_VGIP_CHN1_CTRL_reg, vgip_vgip_chn1_ctrl_reg.regValue);
					}
					else{
						sub_vgip_vgip_chn2_ctrl_reg.regValue = IoReg_Read32(SUB_VGIP_VGIP_CHN2_CTRL_reg);
						sub_vgip_vgip_chn2_ctrl_reg.ch2_random_en = on_off;
						IoReg_Write32(SUB_VGIP_VGIP_CHN2_CTRL_reg, sub_vgip_vgip_chn2_ctrl_reg.regValue);
					}
					break;

				case VSC_VIDEO_PATTERN_DI_NR:
					if(winID == VIDEO_WID_0){
						if(on_off && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE))
						{
							printk(KERN_ERR "[%s] scaler not ready\n", __FUNCTION__);
						}
						else
						{
							if(on_off)
							{
								//set PTG color bar
								di_di_ptg_ctrl_reg.regValue = IoReg_Read32(DI_DI_PTG_CTRL_reg);
								di_di_ptg_ctrl_reg.di_color_num = 2;//2'b00:2 color 2'b01:4 color 2'b10:8 color. set 8 color
								di_di_ptg_ctrl_reg.di_color_bar_vertical_mode = 1;//vertical
								IoReg_Write32(DI_DI_PTG_CTRL_reg, di_di_ptg_ctrl_reg.regValue);

								//set PTG size
								di_di_ptg_act_window_reg.regValue = IoReg_Read32(DI_DI_PTG_ACT_WINDOW_reg);
								// @willlin, 20180614
								if(Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE))
									di_di_ptg_act_window_reg.di_ptg_length =  Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) * 2;
								else
									di_di_ptg_act_window_reg.di_ptg_length =  Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE);
								di_di_ptg_act_window_reg.di_ptg_width = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE);
								IoReg_Write32(DI_DI_PTG_ACT_WINDOW_reg, di_di_ptg_act_window_reg.regValue);
							}
							di_di_ptg_ctrl_reg.regValue = IoReg_Read32(DI_DI_PTG_CTRL_reg);
							di_di_ptg_ctrl_reg.di_color_bar_mode_en = on_off ? 1 : 0;//enble or disable PTG
							IoReg_Write32(DI_DI_PTG_CTRL_reg, di_di_ptg_ctrl_reg.regValue);
						}
					}
					else{
						printk(KERN_ERR "[%s]Do not support sub PATTERN_DI_NR\n", __FUNCTION__);
					}



					break;

				case VSC_VIDEO_PATTERN_SCALER:
					if(winID == VIDEO_WID_0){
						scaleup_d_uzu_globle_ctrl_reg.regValue = IoReg_Read32(SCALEUP_D_UZU_Globle_Ctrl_reg);
						scaleup_d_uzu_globle_ctrl_reg.patgen_sel = on_off;
						scaleup_d_uzu_globle_ctrl_reg.patgen_mode = 2;
						IoReg_Write32(SCALEUP_D_UZU_Globle_Ctrl_reg, scaleup_d_uzu_globle_ctrl_reg.regValue);
					}
					else{
						scaleup_ds_uzu_globle_ctrl_reg.regValue = IoReg_Read32(SCALEUP_DS_UZU_Globle_Ctrl_reg);
						scaleup_ds_uzu_globle_ctrl_reg.patgen_sel = on_off;
						scaleup_ds_uzu_globle_ctrl_reg.patgen_mode = 2;
						IoReg_Write32(SCALEUP_DS_UZU_Globle_Ctrl_reg, scaleup_ds_uzu_globle_ctrl_reg.regValue);
					}
					break;

				case VSC_VIDEO_PATTERN_MEMC:
					if(on_off)
					{
						IoReg_Write32(PPOVERLAY_MEMC_MUX_OUT1_COLOR_VALUE_GB_reg, 0x08000800);//set color
						IoReg_Write32(PPOVERLAY_MEMC_MUX_OUT1_COLOR_VALUE_R_reg, 0x00000800);//set color
						IoReg_SetBits(PPOVERLAY_MEMC_MUX_CTRL_reg, _BIT12);//enable ptg
						IoReg_SetBits(PPOVERLAY_Double_Buffer_CTRL2_reg, _BIT16);//double buffer apply
						//IoReg_SetBits(IPPRE__IPPRE_20_ADDR, _BIT7);

					}
					else
					{
						IoReg_ClearBits(PPOVERLAY_MEMC_MUX_CTRL_reg, _BIT12);//clear color
						IoReg_SetBits(PPOVERLAY_Double_Buffer_CTRL2_reg, _BIT16);//double buffer apply
						IoReg_Write32(PPOVERLAY_MEMC_MUX_OUT1_COLOR_VALUE_GB_reg, 0);//clear color
						IoReg_Write32(PPOVERLAY_MEMC_MUX_OUT1_COLOR_VALUE_R_reg, 0);//clear color
						//IoReg_ClearBits(IPPRE__IPPRE_20_ADDR, _BIT7);
					}
					break;

				case VSC_VIDEO_PATTERN_DISPLAY:
					sfg_sfg_force_bg_at_dif_reg.regValue = IoReg_Read32(SFG_SFG_FORCE_BG_AT_DIF_reg);
					if(on_off)
						sfg_sfg_force_bg_at_dif_reg.bg_dif_blu = 0x3ff;
					else
						sfg_sfg_force_bg_at_dif_reg.bg_dif_blu = 0;
					sfg_sfg_force_bg_at_dif_reg.en_force_bg_dif = on_off;
					IoReg_Write32(SFG_SFG_FORCE_BG_AT_DIF_reg, sfg_sfg_force_bg_at_dif_reg.regValue);
					break;

				default:
					break;
       }
       return TRUE;
}


unsigned char rtk_hal_vsc_CaptureVideoFrame(KADP_VIDEO_DDI_CAPTURE_PLACE_T place, KADP_VIDEO_DDI_CAPTURE_INFO_T * pCaptureInfo)
{

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "have VT, V2G and VSCcapture not use,keep empty!!\n");
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;

}


unsigned char rtk_rerun_scaler(SCALER_DISP_CHANNEL channel)
{
	return TRUE;//No work
}

unsigned char rtk_hal_vsc_SetRGB444Mode(bool bonoff)
{
#ifdef ENABLE_FORCE_PC_MODE
	// Test Only, force set 444 mode
	bonoff = TRUE;
#endif
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC," function=%s, bonoff: %d\n", __FUNCTION__, bonoff);
	DbgSclrFlgTkr.RGB444Mode = bonoff;
	return TRUE;
}

bool rtk_hal_vsc_GetRGB444Mode(void)
{
	return DbgSclrFlgTkr.RGB444Mode;
}


unsigned char rtk_hal_vsc_setwinprop(VSC_SET_SUB_WINDOW_MODE_TYPE vsc_set_sub_win_mode)
{
   /*for testing
   vsc_set_sub_win_mode.mode = VSC_SUB_MODE_PIP;
   vsc_set_sub_win_mode.connectType = VSC_SUB_CONNECT_TYPE_MIRROR;
   vsc_set_sub_win_mode.memoryUse = VSC_SUB_MEMORY_USE_MULTI;

   printk(KERN_EMERG"[%s][crixus]@@VSC_IOC_SET_SetSubWinMode,mode = %d, connectType = %d, memoryUse = %d\n", __FUNCTION__, vsc_set_sub_win_mode.mode, vsc_set_sub_win_mode.connectType, vsc_set_sub_win_mode.memoryUse);
   */
   sub_mode_type = vsc_set_sub_win_mode.mode;//get sub mode
   sub_livezoom_type = vsc_set_sub_win_mode.connectType;

   //connect type is mirror => livezoom or magnifier
   if(vsc_set_sub_win_mode.connectType == KADP_VSC_SUB_CONNECT_TYPE_MIRROR){
		Set_Live_zoom_mode(LIVE_ZOOM_ON);
#if 1/*disable livezoom framsync flow*/
		DbgSclrFlgTkr.DataFramesynclivezoom = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC);
#else
		DataFramesynclivezoom = FALSE;
#endif

		//disable ST game mode timeout checking task when enter livezoom for quickly switching case @Crixus 20170726
		down(&GameMode_Check_Semaphore);
		if(drv_memory_get_game_mode() == _ENABLE){
			smooth_toggle_game_mode_timeout_trigger_flag = _DISABLE;
			//smooth_toggle_game_mode_check_cnt = 0;
			rtd_printk(KERN_NOTICE, TAG_NAME_NEW_GAME_MODE, "Disable ST game mode timeout tsk!!(before sub scaler)\n");
		}
		up(&GameMode_Check_Semaphore);
#if 1
		if(vsc_set_sub_win_mode.memoryUse == KADP_VSC_SUB_MEMORY_USE_MULTI){
			Set_Magnifier_LiveZoom_Mode(KADP_VSC_SUB_PURPOSE_LIVE_ZOOM);
		}
		else if(vsc_set_sub_win_mode.memoryUse == KADP_VSC_SUB_MEMORY_USE_SINGLE){
			Set_Magnifier_LiveZoom_Mode(KADP_VSC_SUB_PURPOSE_MAGNIFIER);
		}
		else{
			Set_Magnifier_LiveZoom_Mode(KADP_VSC_SUB_PURPOSE_NONE);
		}
#endif
   }
#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
   //connect type is non-mirror => multi-view or overlay miracast
   else if(vsc_set_sub_win_mode.connectType == KADP_VSC_SUB_CONNECT_TYPE_NON_MIRROR){
		   if((sub_mode_type == VSC_SUB_MODE_EX_PBP)){
				   //i2rnd_test_done = 1;
				   rtk_hal_vsc_i2rnd_enable(_ENABLE);
				   printk(KERN_EMERG"[%s][crixus]I2RND initial done\n", __FUNCTION__);
		   }else if((sub_mode_type == VSC_SUB_MODE_EX_PIP)){
				   //i2rnd_test_done = 0;
				   rtk_hal_vsc_i2rnd_enable(_DISABLE);
				   printk(KERN_EMERG"[%s][crixus]I2RND Uninitial done\n", __FUNCTION__);
		   }
   }
#endif
#endif

   else if((vsc_set_sub_win_mode.mode == VSC_SUB_MODE_EX_NONE) && (vsc_set_sub_win_mode.connectType == KADP_VSC_SUB_CONNECT_TYPE_NONE)
				   && (vsc_set_sub_win_mode.memoryUse == KADP_VSC_SUB_MEMORY_USE_NONE)){
		   //exit PIP or PBP app.
#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
		   if((Scaler_I2rnd_get_enable() == _ENABLE)){
				   //disable i2run mode
				   //i2rnd_test_done = 0;
				   i2rnd_send_table_idx(I2RND_TABLE_OFF);
				   rtk_hal_vsc_i2rnd_enable(_DISABLE);
				   //frank@I2run disable main VENC flag
				   VencModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){VSC_INPUTSRC_MAXN, 0, 0};
				   DbgSclrFlgTkr.OutputVencMode = FALSE;
				   vsc_i2rnd_sub_stage = I2RND_STAGE_DISABLE;
				   vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_DISABLE;
				   //apvr_request_run_main_path();
				   printk(KERN_EMERG"[%s][frank]I2RND close\n", __FUNCTION__);
		   }
#endif
#endif
   }
	return TRUE;
}


unsigned char LiveZoomPcmodeDiableRTNR;

void set_LiveZoomPcmodeDiableRTNR(unsigned char value)
{
	LiveZoomPcmodeDiableRTNR = value;
}

unsigned char get_LiveZoomPcmodeDiableRTNR(void)
{
	return LiveZoomPcmodeDiableRTNR;
}

unsigned char rtk_hal_vsc_Set3DForScaler(TRIDTV_SCALER_CTRL_T * p3DCfgInfo)
{
	unsigned char curmode;
	unsigned char support3Dinput[INPUT_TYPE_MAX]= {
		SLR_3DMODE_2D, SLR_3DMODE_3D_TB, SLR_3DMODE_3D_SBS, SLR_3DMODE_2D,
		SLR_3DMODE_2D, SLR_3DMODE_2D, SLR_3DMODE_2D, SLR_3DMODE_3D_FP,
		SLR_3DMODE_2D, SLR_3DMODE_2D, SLR_3DMODE_3D_SBS, SLR_3DMODE_3D_FP,
		SLR_3DMODE_2D_CVT_3D};

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"vsc_3d:%d=%d=%d=%d\n",p3DCfgInfo->mode, p3DCfgInfo->in_fmt, p3DCfgInfo->out_fmt, p3DCfgInfo->lr);
	if(p3DCfgInfo == NULL)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"scaler vsc Set3DForScaler paramter NULL!!!\n");
		return FALSE;
	}
	if(p3DCfgInfo->mode > TRIDTV_3DMODE_MAX || p3DCfgInfo->mode  < TRIDTV_3DMODE_OFF
		||p3DCfgInfo->in_fmt > INPUT_TYPE_MAX || p3DCfgInfo->in_fmt < INPUT_TYPE_3DOFF
		||p3DCfgInfo->out_fmt > SC_OUT_MAX || p3DCfgInfo->out_fmt < SC_OUT_SINGLE_2D
		||p3DCfgInfo->lr > INPUT_LR_MAX || p3DCfgInfo->lr  < INPUT_LR_SEQ)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"scaler vsc Set3DForScaler paramter error!!!\n");
		return FALSE;
	}

	set_field_alternative_3d_mode_enable(FALSE);
#if 1
	if(get_line_alternative_3d_mode_enable() == TRUE)
	{
		Scaler_DispSetInputInfo(SLR_INPUT_THROUGH_I3DDMA, false);
		set_line_alternative_3d_mode_enable(FALSE);
		DbgSclrFlgTkr.main_opensourceID =_UNKNOWN_INPUT;
	}
#endif
	if(p3DCfgInfo->mode == TRIDTV_3DMODE_OFF  || p3DCfgInfo->mode == TRIDTV_3DMODE_3DTO2D)
	{

		if(get_3D_mode_enable() == TRUE)
		{
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"scaler vsc Set3DForScaler OFF!change to 2D!\n");
			set_3D_mode_enable(FALSE);
			set_3D_overscan_enable(FALSE);
			Scaler_Set3DMode(SLR_MAIN_DISPLAY, SLR_3DMODE_2D, TRUE);
			down(&VSC_Semaphore);
			if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
  				rtk_output_connect(SLR_MAIN_DISPLAY);
   			up(&VSC_Semaphore);
		}
		return TRUE;
	}
	else if(p3DCfgInfo->mode == TRIDTV_3DMODE_MAX || p3DCfgInfo->in_fmt == INPUT_TYPE_MAX  ||p3DCfgInfo->out_fmt == SC_OUT_MAX ||p3DCfgInfo->lr == INPUT_LR_MAX)
	{

		if(get_3D_mode_enable() == TRUE)
		{
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"scaler vsc Set3DForScaler MAXNUM!change to 2D!\n");
			set_3D_mode_enable(FALSE);
			set_3D_overscan_enable(FALSE);
			Scaler_Set3DMode(SLR_MAIN_DISPLAY, SLR_3DMODE_2D, TRUE);
			down(&VSC_Semaphore);
			if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
  				rtk_output_connect(SLR_MAIN_DISPLAY);
   			up(&VSC_Semaphore);
		}
		return TRUE;
	}


	/*force set the out_fmt SC_OUT_SINGLE_FS*/
	if(p3DCfgInfo->out_fmt != SC_OUT_SINGLE_FS)
		p3DCfgInfo->out_fmt = SC_OUT_SINGLE_FS;

	if(p3DCfgInfo->out_fmt != SC_OUT_SINGLE_FS)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"scaler vsc Set3DForScaler out format no support!change to 2D!\n");
		if(get_3D_mode_enable() == TRUE)
		{
			set_3D_mode_enable(FALSE);
			set_3D_overscan_enable(FALSE);
			Scaler_Set3DMode(SLR_MAIN_DISPLAY, SLR_3DMODE_2D, TRUE);
			down(&VSC_Semaphore);
			if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
  				rtk_output_connect(SLR_MAIN_DISPLAY);
   			up(&VSC_Semaphore);
		}
		return TRUE;
	}

	if(p3DCfgInfo->in_fmt == INPUT_TYPE_DUALSTREAM)
	{
		set_3D_mode_enable(TRUE);
		set_3D_overscan_enable(FALSE);
		Scaler_Set3DMode(SLR_MAIN_DISPLAY, SLR_3DMODE_3D_FP, TRUE);
		down(&VSC_Semaphore);
		if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
			rtk_output_connect(SLR_MAIN_DISPLAY);
		up(&VSC_Semaphore);

		return TRUE;
	}

	if(p3DCfgInfo->in_fmt == INPUT_TYPE_LINE_ALTERNATIVE/*&& DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_HDMI*/)
	{
		vfe_hdmi_timing_info_t vfehdmitiminginfo;
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"input is line alternative\n");
		Scaler_Set3DMode(SLR_MAIN_DISPLAY, SLR_3DMODE_3D_LBL, TRUE);

		set_3D_mode_enable(TRUE);
		set_3D_overscan_enable(FALSE);

		 //DisplayModeInputInfo.type = VSC_INPUTSRC_VDEC;

		if(0!=vfe_hdmi_drv_get_display_timing_info(&vfehdmitiminginfo, SLR_MAIN_DISPLAY))
			return FALSE;
		Scaler_SET_VSCDispinfo_WithVFEHMDI(SLR_MAIN_DISPLAY, vfehdmitiminginfo);
		drvif_I3DDMA_Init();
		HDMI_set_detect_flag(FALSE);
		Scaler_DispSetInputInfo(SLR_INPUT_THROUGH_I3DDMA, true);
		set_line_alternative_3d_mode_enable(TRUE);
		drivf_I3DDMA_3D_config();

		Scaler_Set3DMode(SLR_MAIN_DISPLAY, SLR_3DMODE_3D_FP, TRUE);
		Scaler_Disp3dSetInfo(SLR_MAIN_DISPLAY, SLR_DISP_3D_3DTYPE,SLR_3D_FRAME_PACKING);
		Scaler_Set3DMode_Attr(SLR_MAIN_DISPLAY, SLR_3DMODE_3D_FP);
		set_vo_3d_mode(VO_2D_MODE);

		DbgSclrFlgTkr.main_opensourceID =_UNKNOWN_INPUT;
		down(&VSC_Semaphore);
		if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
  			rtk_output_connect(SLR_MAIN_DISPLAY);
   		up(&VSC_Semaphore);

		return TRUE;


	}
	else if(p3DCfgInfo->in_fmt == INPUT_TYPE_FIELD_ALTERNATIVE/*&& DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_HDMI*/)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"input is feild alternative\n");
		Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY),SLR_DISP_INTERLACE,true);
		set_3D_mode_enable(TRUE);
		set_3D_overscan_enable(FALSE);
		set_field_alternative_3d_mode_enable(TRUE);
		Scaler_Set3DMode(SLR_MAIN_DISPLAY, SLR_3DMODE_3D_FP, TRUE);
		down(&VSC_Semaphore);
		if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
			rtk_output_connect(SLR_MAIN_DISPLAY);
		up(&VSC_Semaphore);

		 return TRUE;

	}
	if(p3DCfgInfo->mode == TRIDTV_3DMODE_ON ||p3DCfgInfo->mode == TRIDTV_3DMODE_2DTO3D)
	{
		curmode = p3DCfgInfo->in_fmt;
		curmode = support3Dinput[(curmode < INPUT_TYPE_MAX? curmode: INPUT_TYPE_3DOFF)];

		if(curmode == SLR_3DMODE_2D)
		{
			if(get_3D_mode_enable() == TRUE)
			{
				set_3D_mode_enable(FALSE);
				set_3D_overscan_enable(FALSE);
				Scaler_Set3DMode(SLR_MAIN_DISPLAY, SLR_3DMODE_2D, TRUE);
				down(&VSC_Semaphore);
				if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
  					rtk_output_connect(SLR_MAIN_DISPLAY);
   				up(&VSC_Semaphore);
				return TRUE;
			}
			else
			{
				return TRUE;
			}
		}

		Scaler_Set3DMode(SLR_MAIN_DISPLAY, curmode, TRUE);
		 if (Get_PANEL_SCALER_2D_3D_CVT_HWSHIFT_ENABLE() && p3DCfgInfo->in_fmt == INPUT_TYPE_2DTO3D)
		{
			// [2D3D] default mode init
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"2d concvt 3d init\n");
			scaler_2Dcvt3D_init();
		}
		 if( drvif_scaler3d_decide_HDMI_framePacking_interlaced_status() && p3DCfgInfo->in_fmt == INPUT_TYPE_FRAMEPAC)
		 {
		 	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"Interlace Fp 3D, change progress to interlace!\n");
			Scaler_DispSetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY),SLR_DISP_INTERLACE,true);
		 }

		set_3D_mode_enable(TRUE);
		set_3D_overscan_enable(FALSE);
		down(&VSC_Semaphore);
		if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
  			rtk_output_connect(SLR_MAIN_DISPLAY);
   		up(&VSC_Semaphore);
		//Scaler_Set3DLRSwap(p3DCfgInfo->lr);
	}

	return TRUE;
}

unsigned char rtk_hal_vsc_Get3DAutoDetectmode(VIDEO_WID_T wid, KADP_VIDEO_DDI_3D_FORMAT_TYPE_T * pvideo3DType)
{
	unsigned char  curmode;

#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"wid id is not ok\n");
		return FALSE;
	}
#endif

	if(pvideo3DType == NULL)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"scaler vsc Get3DAutoDetectmode paramter is error!\n");
		return FALSE;
	}

	if (Scaler_InputSrcGetMainChType() == _SRC_VO)
	{
		if(get_vo_3d_mode() == VO_3D_SIDE_BY_SIDE_HALF)
			*pvideo3DType = KADP_VIDEO_DDI_3D_FORMAT_SIDEBYSIDE_HALF;
		else if(get_vo_3d_mode() == VO_3D_TOP_AND_BOTTOM)
			*pvideo3DType = KADP_VIDEO_DDI_3D_FORMAT_TOP_BOTTOM;
		else
			*pvideo3DType = KADP_VIDEO_DDI_3D_FORMAT_2D;
		return TRUE;
	}

	Scaler_Set3D_VoAutoDetect_Enable(true);

#ifdef CONFIG_DUAL_CHANNEL
	if(VIDEO_WID_1 == wid)
		check_vo3d_detect_result(SLR_SUB_DISPLAY);
	else// if(VIDEO_WID_0 == wid)
		check_vo3d_detect_result(SLR_MAIN_DISPLAY);
#else //#ifdef CONFIG_DUAL_CHANNEL
	check_vo3d_detect_result(SLR_MAIN_DISPLAY);
#endif //#ifdef CONFIG_DUAL_CHANNEL

	curmode = modestate_get_vo3d_detect_result();
	switch(curmode)
	{
		case VO_2D_MODE:
			*pvideo3DType = KADP_VIDEO_DDI_3D_FORMAT_2D;
			break;
		case VO_3D_SIDE_BY_SIDE_HALF:
			*pvideo3DType = KADP_VIDEO_DDI_3D_FORMAT_SIDEBYSIDE_HALF;
			break;
		case VO_3D_TOP_AND_BOTTOM:
			*pvideo3DType = KADP_VIDEO_DDI_3D_FORMAT_TOP_BOTTOM;
			break;
		default:
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"Can't detect 3D auto mode!\n");
			break;
	}


	return TRUE;
}

unsigned char rtk_hal_vsc_Set3Dpatternmode(VIDEO_WID_T wid, KADP_VIDEO_DDI_3D_PATTERN_TYPE_T video3DType)
{
	unsigned char curmode;
#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"wid id is not ok\n");
		return FALSE;
	}
#endif

	switch(video3DType)
	{
		case KADP_VIDEO_DDI_3D_PATTERN_TOP_BOTTOM:
			curmode = SLR_3DMODE_3D_TB;
			break;
		case KADP_VIDEO_DDI_3D_PATTERN_SIDEBYSIDE_HALF:
			curmode = SLR_3DMODE_3D_SBS;
			break;
		case KADP_VIDEO_DDI_3D_PATTERN_LINE_INTERLEAVE_HALF:
			curmode = SLR_3DMODE_3D_LBL;
			break;
		case KADP_VIDEO_DDI_3D_PATTERN_FRAME_PACKING:
			curmode = SLR_3DMODE_3D_FP;
			break;
		default:
			curmode = SLR_3DMODE_2D;
			break;
	}

	Scaler_Set3DMode(SLR_MAIN_DISPLAY, curmode, TRUE);
	rtk_rerun_scaler(SLR_MAIN_DISPLAY);
	return TRUE;
}

unsigned char rtk_hal_vsc_SetVENEMode(unsigned short framerate, unsigned short scantype)
{
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"VENEMode hal venc support framerate setting,but no scantype setting!!\n");
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;
}

unsigned char 	rtk_hal_vsc_OpenV2G(VIDEO_WID_T wid )
{
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"V2G not use,keep empty!!\n");
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;
}
unsigned char 	rtk_hal_vsc_CloseV2G(VIDEO_WID_T wid )
{
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"V2G not use,keep empty!!\n");
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;
}

unsigned char 	rtk_hal_vsc_GetV2GFramebuffer(VIDEO_WID_T wid , KADP_VIDEO_DDI_CAPTURE_INFO_T* pCaptureInfo)
{
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"have VT, V2G not use,keep empty!!\n");
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;
}

unsigned char	rtk_hal_vsc_SetUDInput(KADP_VIDEO_UD_MODE_T videoUDMode)
{
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"UD not use,keep empty!!\n");
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;
}

unsigned char 	rtk_hal_vsc_SetUDOutput(KADP_VIDEO_DDI_DIS_FMT_T disFmt)
{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"UD not use,keep empty!!\n");
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
		return TRUE;
}


unsigned char	rtk_hal_vsc_GetVideoDelayedTime (VIDEO_WID_T wid , unsigned short *pDelayedTime)
{

        unsigned short scaler_dispInfo = 0;

#ifdef CONFIG_DUAL_CHANNEL
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"wid id is not ok\n");
		return FALSE;
	}
#else
	if(wid !=VIDEO_WID_0)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"wid id is not ok\n");
		return FALSE;
	}
#endif

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);

        scaler_dispInfo = Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ);

        if(scaler_dispInfo != 0)
        {
	        *pDelayedTime = 10000/scaler_dispInfo;
		return TRUE;
        }
	else
	{
                rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"DispGetInputInfo is 0\n");
		return FALSE;
	}
}


unsigned char 	rtk_hal_vsc_SetTileMode(BOOLEAN bOnOff)
{
	//pip not support
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"pip pop mode not support!!\n");
	return TRUE;
}

unsigned char 	rtk_hal_vsc_SetTileMaxRowVal(unsigned char uMaxRow, unsigned char uMaxCol)
{
	//pip not support
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"pip pop mode not support!!\n");
	return TRUE;
}

unsigned char 	rtk_hal_vsc_SetTileID(unsigned char uTileID)
{
	//pip not support
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"pip pop mode not support!!\n");
	return TRUE;
}

unsigned char rtk_hal_vsc_SetAdaptiveStream(unsigned char bOnOff)
{
	int ret = -1;
		//this is vo smoothtoggle operation:when change timing,with qing_liu code
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"file=%s, function=%s, line=%d,bOnOff=%d,DbgSclrFlgTkr.adaptive_stream_pre=%d\n", __FILE__, __FUNCTION__, __LINE__, bOnOff,DbgSclrFlgTkr.adaptive_stream_pre);

	if(scaler_vsc_get_force_pst_lowdelay_mode() == TRUE){
		bOnOff = TRUE;
	}
	if((0 == bOnOff) && rtk_hal_vsc_Getdualdecoder())
	{
		rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"file=%s, function=%s, line=%d dual decoder case true, not set adaptive stream false, return\n",__FILE__, __FUNCTION__, __LINE__);
		return TRUE;
	}
	if(DbgSclrFlgTkr.adaptive_stream_pre != bOnOff) {
	#if 0
		unsigned int *pulTemp;
		unsigned int i = 0, ulItemCount = 0;
		SMOOTH_TOGGLE_UPDATE_FWINFO_PKG *sm_info_pkg = NULL;
		SMOOTH_TOGGLE_UPDATE_FWINFO_PKG update_info;
		sm_info_pkg = (SMOOTH_TOGGLE_UPDATE_FWINFO_PKG *)Scaler_GetShareMemVirAddr(SCALERIOC_SMOOTHTOGGLE_SHARE_INFO);
		if (sm_info_pkg)
			{
			memcpy(&update_info, sm_info_pkg, sizeof(SMOOTH_TOGGLE_UPDATE_FWINFO_PKG));
			ulItemCount = sizeof(SMOOTH_TOGGLE_UPDATE_FWINFO_PKG) /  sizeof(UINT32);
			pulTemp = (unsigned int *)&update_info;
			for (i = 0; i < ulItemCount; i++)
				pulTemp[i] = Scaler_ChangeUINT32Endian(pulTemp[i]);
			update_info.sm_info[SLR_MAIN_DISPLAY].vodma_plane = get_vo_plane_flag(SLR_MAIN_DISPLAY);
			}
	#endif
#if defined(CONFIG_REALTEK_2K_MODEL_ENABLED) && defined(ENABLE_IMD_PST_SMOOTHTOGGLE)//k5ap and enable force frame rate
		drvif_scaler_voFrameRateControl_set_bwSavingMode(_DISP_2D, (bOnOff? 0: 1));
#endif
		DbgSclrFlgTkr.adaptive_stream = bOnOff;
		DbgSclrFlgTkr.adaptive_stream_pre = bOnOff;
		if (0 != (ret = Scaler_SendRPC(SCALERIOC_ADAPTIVE_STREAM_FLAG, bOnOff, 1))){
			rtd_printk(KERN_ERR, TAG_NAME_VSC,"ret=%d, SCALERIOC_ADAPTIVE_STREAM_FLAG RPC fail !!!\n", ret);
				}
		}
		return TRUE;

}

unsigned char rtk_hal_vsc_SetAdaptiveStreamEX(VIDEO_WID_T wid,unsigned char bOnOff)
{
	int ret = -1;
	//this is vo smoothtoggle operation:when change timing,with qing_liu code
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"file=%s, function=%s, line=%d,bOnOff=%d,DbgSclrFlgTkr.adaptive_stream_pre=%d\n", __FILE__, __FUNCTION__, __LINE__, bOnOff,DbgSclrFlgTkr.adaptive_stream_pre);
	if((wid < VIDEO_WID_MIN)||(wid > VIDEO_WID_MAX))
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"wid id is not ok\n");
		return FALSE;
	}
	if (wid == VIDEO_WID_0) {

		if(scaler_vsc_get_force_pst_lowdelay_mode() == TRUE){
			bOnOff = TRUE;
		}

		if(DbgSclrFlgTkr.adaptive_stream_pre != bOnOff) {
		#if 0
			unsigned int *pulTemp;
			unsigned int i = 0, ulItemCount = 0;
			SMOOTH_TOGGLE_UPDATE_FWINFO_PKG *sm_info_pkg = NULL;
			SMOOTH_TOGGLE_UPDATE_FWINFO_PKG update_info;
			sm_info_pkg = (SMOOTH_TOGGLE_UPDATE_FWINFO_PKG *)Scaler_GetShareMemVirAddr(SCALERIOC_SMOOTHTOGGLE_SHARE_INFO);
			if (sm_info_pkg) {
				memcpy(&update_info, sm_info_pkg, sizeof(SMOOTH_TOGGLE_UPDATE_FWINFO_PKG));
				ulItemCount = sizeof(SMOOTH_TOGGLE_UPDATE_FWINFO_PKG) /  sizeof(UINT32);
				pulTemp = (unsigned int *)&update_info;
				for (i = 0; i < ulItemCount; i++)
					pulTemp[i] = Scaler_ChangeUINT32Endian(pulTemp[i]);
				update_info.sm_info[SLR_MAIN_DISPLAY].vodma_plane = get_vo_plane_flag(SLR_MAIN_DISPLAY);
			}
		#endif

#if defined(CONFIG_REALTEK_2K_MODEL_ENABLED) && defined(ENABLE_IMD_PST_SMOOTHTOGGLE)//k5ap and enable force frame rate
			drvif_scaler_voFrameRateControl_set_bwSavingMode(_DISP_2D, (bOnOff? 0: 1));
#endif

			DbgSclrFlgTkr.adaptive_stream = bOnOff;
			DbgSclrFlgTkr.adaptive_stream_pre = bOnOff;
			if (0 != (ret = Scaler_SendRPC(SCALERIOC_ADAPTIVE_STREAM_FLAG, bOnOff, 1))){
				rtd_printk(KERN_ERR, TAG_NAME_VSC,"ret=%d, SCALERIOC_ADAPTIVE_STREAM_FLAG RPC fail !!!\n", ret);
			}
		}
	}else if(wid == VIDEO_WID_1){
		if(DbgSclrFlgTkr.sub_adaptive_flag != bOnOff)
		{
			DbgSclrFlgTkr.sub_adaptive_flag = bOnOff;
			if (0 != (ret = Scaler_SendRPC(SCALERIOC_SUB_ADAPTIVE_STREAM_FLAG, bOnOff, 1))){
				rtd_printk(KERN_ERR, TAG_NAME_VSC,"ret=%d, SCALERIOC_SUB_ADAPTIVE_STREAM_FLAG RPC fail !!!\n", ret);
			}
		}
	}

	return TRUE;

}
EXPORT_SYMBOL(rtk_hal_vsc_SetAdaptiveStreamEX);

static bool is_adaptive_stream_source(unsigned char display)
{
	VSC_INPUT_TYPE_T srctype = Get_DisplayMode_Src(display);


#ifdef CONFIG_RTK_KDRV_DV_IDK_DUMP
	return 0;
#endif

	return srctype == VSC_INPUTSRC_VDEC;
}

unsigned char vsc_get_adaptivestream_flag(unsigned char display)
{
	bool had_adaptive_stream = is_adaptive_stream_source(display);

	if(display == SLR_MAIN_DISPLAY)
		return (had_adaptive_stream) ? DbgSclrFlgTkr.adaptive_stream : 0;
	else
		return (had_adaptive_stream) ? DbgSclrFlgTkr.sub_adaptive_flag : 0;
}

#ifdef SMOOTH_TOGGLE_DATAFRCFS_TEST
unsigned char vsc_decide_timingframesync(unsigned char display)
{
	if(display==SLR_MAIN_DISPLAY){
		if (Scaler_InputSrcGetType(display) == _SRC_VO){

			if (vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY)&& vbe_disp_get_adaptivestream_fs_mode())
			{
				return TRUE;
			}
			else
			{
				return FALSE;
			}
		}

		else {
			return FALSE;
		}
	}
	else if (display==SLR_SUB_DISPLAY){
			return FALSE;
	}

	return FALSE;


}
#endif

void Scaler_DualChannelRpc(unsigned char flag)
{
	int ret = 0;
	unsigned char *pulTemp = NULL;

	pulTemp = (unsigned char*)Scaler_GetShareMemVirAddr(SCALERIOC_DUAL_CHANNEL_FLAG);

	// copy to RPC share memory
	//memcpy(pulTemp, &DbgSclrFlgTkr.dvo_dual_decoder_flag, sizeof(unsigned char));

	//pulTemp[0] = htonl(pulTemp[0]);
	if (pulTemp) {
		*pulTemp = flag;
		if (0 != (ret = Scaler_SendRPC(SCALERIOC_DUAL_CHANNEL_FLAG,0,0)))
		{
			pr_debug( "ret=%d, set dual channel fail !!!\n", ret );
			return;
		}
	}
}

unsigned char dualdecoder_notchange_flag;
void scaler_Setdualdecoder_notchange(unsigned char flag)
{
	dualdecoder_notchange_flag = flag;
}
unsigned char scaler_Getdualdecoder_notchange(void)
{
	return dualdecoder_notchange_flag;
}

void rtk_hal_vsc_Setdualdecoder(unsigned char enable)
{
	rtd_printk(KERN_INFO, TAG_NAME_VSC,"file=%s, function=%s, enable=%d\n", __FILE__, __FUNCTION__, enable);

	DbgSclrFlgTkr.dvo_dual_decoder_flag = enable;
	if ( 0== enable) {
		if (0 ==scaler_Getdualdecoder_notchange()) {
			rtk_hal_vsc_Setdualdecoder_run(0);
			Scaler_DualChannelRpc(0);
		}
	} else {
		if (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) {
			rtk_hal_vsc_Setdualdecoder_run(1);
			Scaler_DualChannelRpc(1);
			rtd_printk(KERN_INFO, TAG_NAME_VSC, "dual decoder start to run 1\n");
		}
	}
}

unsigned char rtk_hal_vsc_Getdualdecoder(void)
{
	return DbgSclrFlgTkr.dvo_dual_decoder_flag;
}

void  rtk_hal_vsc_Setdualdecoder_run(unsigned char flag)
{
	DbgSclrFlgTkr.dvo_dual_decoder_run = flag;
}
unsigned char rtk_hal_vsc_Getdualdecoder_run(void)
{
	return DbgSclrFlgTkr.dvo_dual_decoder_run;
}

unsigned char 	rtk_hal_vsc_SetSOCOutputFMT(KADP_VIDEO_UD_MODE_T videoUDMode)
{
	//this is vo smoothtoggle operation:when change timing,with qing_liu code
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;

}

unsigned char 	rtk_hal_vsc_SetFRCType(unsigned char frcType)
{
	//this is vo smoothtoggle operation:when change timing,with qing_liu code
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;

}

unsigned char 	rtk_hal_vsc_GetFRCType(unsigned char frcType)
{
	//this is vo smoothtoggle operation:when change timing,with qing_liu code
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;

}

unsigned char	rtk_hal_vsc_GetMVOPStatus(VIDEO_WID_T wId, BOOLEAN *bMVOPEnable)
{
	//this is vo smoothtoggle operation:when change timing,with qing_liu code
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
	return TRUE;

}
/*api which have protect by forcebg_semaphore*/
void set_ATV_passthrought_output_flag(unsigned char display, unsigned char flag)
{
	if(display == SLR_MAIN_DISPLAY)
		DbgSclrFlgTkr.Main_ATV_PassThrought_output_flag = flag;
}

unsigned int osdsample_addr = 0;
#if 0
unsigned char rtk_hal_vsc_showosdsample(unsigned char bonoff)
{

	GRAPHIC_LAYERS_OBJECT grahpic_obj;
	GDMA_LAYER_OBJECT *picObj;

	memset(&grahpic_obj, 0, sizeof(GRAPHIC_LAYERS_OBJECT));
	picObj = &grahpic_obj.layer[0];
	grahpic_obj.layer_num = 1;

	picObj->src_type = SRC_NORMAL;
	picObj->format = VO_OSD_COLOR_FORMAT_ARGB8888_LITTLE;
	/*picObj->plane = VO_GRAPHIC_OSD1;*/
	picObj->colorkey = -1;
	picObj->alpha = 0;
	picObj->x = 0;
	picObj->y = 0;
	picObj->width = 260;				// image width
	picObj->height = 200;				// image height
	picObj->pitch = picObj->width*4;

	if(bonoff == TRUE)
	{
		osdsample_addr = (unsigned int)dvr_malloc(1024*1024*3);
	}

	//picObj->address = (unsigned int)virt_to_phys((void*)osdsample_addr);	// set image address
	picObj->address = (unsigned int)dvr_to_phys((void*)osdsample_addr);	// set image address
	picObj->dst_x = 0;
	picObj->dst_y = 0;
	picObj->dst_width = 260;	 // image width
	picObj->dst_height = 200; // image height
	picObj->plane_ar.value = 0xffffffff;
	picObj->plane_gb.value = 0xffffffff;
	picObj->clear_x.value = 0;
	picObj->clear_y.value = 0;
	picObj->syncstamp = 0;
	picObj->show = bonoff;	  // always show the picture by normal update pic flow
	picObj->compressed = 0;
	/*picObj->layer_used = 1;*/
	/*osd_comp_receive_picture(&com_picObj);*/
#ifdef CONFIG_RTK_KDRV_GDMA
	GDMA_ReceiveGraphicLayers(&grahpic_obj);
#endif

	if(bonoff == FALSE)
	{
		dvr_free((void *)osdsample_addr);
		osdsample_addr = 0;
	}
	return 0;
}
#endif

// Dolby Vision IDMA enable control

#ifdef CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT
// HDR10 IDMA enable control
unsigned char rtk_hal_vsc_SetHdr10IdmaEnable(unsigned char bEnable)
{
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"[HDR10] %s.%d\n", __FUNCTION__, __LINE__);
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"en=%d, type/idma=%d/%d\n", bEnable, DisplayModeInputInfo.type, Scaler_DispGetInputInfo(SLR_INPUT_THROUGH_I3DDMA));
	if(bEnable){
		if(DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_HDMI)
		{
			 vfe_hdmi_timing_info_t vfehdmitiminginfo;
			 DisplayModeInputInfo.type = VSC_INPUTSRC_VDEC;
			 DisplayModeInputInfo.resourceIndex = 0;
			if(0!=vfe_hdmi_drv_get_display_timing_info(&vfehdmitiminginfo, SLR_MAIN_DISPLAY))
				return FALSE;
			Scaler_SET_VSCDispinfo_WithVFEHMDI(SLR_MAIN_DISPLAY, vfehdmitiminginfo);

			set_HDMI_HDR_mode(HDR_HDR10_HDMI);
			drvif_I3DDMA_Init();
			Scaler_DispSetInputInfo(SLR_INPUT_THROUGH_I3DDMA, true);
			drivf_I3DDMA_3D_config();
			DbgSclrFlgTkr.main_opensourceID =_UNKNOWN_INPUT;

			if(Scaler_HDR10_Hdmi_Get_Detect_Status() == SLR_HDR10_HDMI_DETECT_OFF)
			down(&VSC_Semaphore);
	  		rtk_output_connect(SLR_MAIN_DISPLAY);
			if(Scaler_HDR10_Hdmi_Get_Detect_Status() == SLR_HDR10_HDMI_DETECT_OFF)
	   		up(&VSC_Semaphore);

			return TRUE;
		}else{
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"[WARN][HDR10][%d] Not in HDMI source\n", DisplayModeInputInfo.type);
		}
	}
	else if(DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_VDEC){
		if(Scaler_DispGetInputInfo(SLR_INPUT_THROUGH_I3DDMA) == true)
		{
			if(IoReg_Read32(H3DDMA_I3DDMA_enable_reg) & _BIT0){
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"[HDR10] Disable IDMA HW\n");
				I3DDMA_Setup3DDMA(&i3ddmaCtrl, I3DDMA_3D_OPMODE_DISABLE,SLR_MAIN_DISPLAY);
				msleep(40/*100*/); // wait DMA write done

				// [IDMA] allocate/release IDMA memory dynamic
				if(I3DDMA_Get3DAllocReleaseMemoryDynamic() == TRUE)
					drvif_I3DDMA_DeInit();
			}

			Scaler_DispSetInputInfo(SLR_INPUT_THROUGH_I3DDMA, false);
			DisplayModeInputInfo.type = KADP_VSC_INPUTSRC_HDMI;
			DbgSclrFlgTkr.main_opensourceID =_UNKNOWN_INPUT;
		}
		if(Scaler_HDR10_Hdmi_Get_Detect_Status() == SLR_HDR10_HDMI_DETECT_OFF)
		down(&VSC_Semaphore);
  		rtk_output_connect(SLR_MAIN_DISPLAY);
		if(Scaler_HDR10_Hdmi_Get_Detect_Status() == SLR_HDR10_HDMI_DETECT_OFF)
   		up(&VSC_Semaphore);
	}

	if(!bEnable)
		set_HDMI_HDR_mode(HDR_MODE_DISABLE);
	return 0;
}
#endif


unsigned char rtk_hal_vsc_SetZorder(VSC_SET_ZORDER_T zOrderMain,VSC_SET_ZORDER_T zOrderSub)//(unsigned char uZorder,unsigned char uAlpha)
{
	unsigned int main_blendingFactor = zOrderMain.uAlpha;
	unsigned int sub_blendingFactor = zOrderSub.uAlpha;

	//pr_err("[hal] zorder main:%d, sub:%d\n",zOrderMain.uZorder,zOrderSub.uZorder);
	//pr_err("[hal] alpha main:%d, sub:%d\n",main_blendingFactor,sub_blendingFactor);

	main_blendingFactor = zOrderMain.uAlpha * 256 / (zOrderMain.uAlpha + zOrderSub.uAlpha);
	sub_blendingFactor = zOrderSub.uAlpha * 256 / (zOrderMain.uAlpha + zOrderSub.uAlpha);

	pr_err("[vsc] blending factor main:%d, sub:%d\n",main_blendingFactor,sub_blendingFactor);

	if((sub_blendingFactor + main_blendingFactor) != 256){
		if((sub_blendingFactor + main_blendingFactor) > 256){
			pr_err("[ERROR]wrong blending factor(%d, %d) @func:%s, line:%d\n",main_blendingFactor,sub_blendingFactor,__FUNCTION__,__LINE__);
			return 0;
		}
		sub_blendingFactor = 256 - main_blendingFactor;
	}

	if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
		&&(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
	{
		//int ret = 0;
		//drvif_color_setpiprgbcontrastbrightness(zOrderMain.uAlpha);
		drvif_color_setBrightnessDualplayOverlay(main_blendingFactor,sub_blendingFactor);
		/*if (0 != (ret =Scaler_SendRPC(SCALERIOC_SENDZORDER, ((zOrderMain.uZorder<<8) + zOrderSub.uZorder), RPC_SEND_VALUE_ONLY))) {
			rtd_printk(KERN_EMERG, TAG_NAME_VSC,"ret=%d, rtk_hal_vsc_SetZorder SCALERIOC_SENDZORDER fail !!!\n", ret);
			return FALSE;
		}*/
	}
	return TRUE;
}

unsigned char rtk_hal_vsc_set_localDimmingCtrlDemoMode(unsigned char bType, unsigned char bCtrl)
{
	LocalDimmingDemoCtrlType = bType;
	LocalDimmingDemoCtrlMode = bCtrl;
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"rtk_hal_vsc_set_localDimmingCtrlDemoMode (type:%d. ctrl:%d) \n", bType,bCtrl);
	return _TRUE;
}


unsigned char rtk_hal_vsc_makeColoredVideo(KADP_VSC_VIDEO_COLOR_TYPE_T videoColor)
{
	osdovl_mixer_ctrl2_RBUS mixer_ctrl2_reg;
	ppoverlay_main_background_color1_RBUS main_background_color1_reg;
	ppoverlay_main_background_color2_RBUS main_background_color2_reg;
	ppoverlay_main_display_control_rsv_RBUS main_display_control_rsv_reg;
	ppoverlay_dispd_stage1_sm_ctrl_RBUS dispd_stage1_sm_ctrl_reg;
	ppoverlay_dispd_smooth_toggle1_RBUS	 dispd_smooth_toggle1_reg;
	ppoverlay_memc_mux_ctrl_RBUS memc_mux_ctrl_reg;
	ppoverlay_double_buffer_ctrl2_RBUS double_buffer_ctrl_reg;
	static unsigned char m_memc_bg_en = 0;

	static KADP_VIDEO_RECT_T originalSize={0,0,0,0};
	unsigned int timeout=0x3fffff;
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"rtk_hal_vsc_makeColoredVideo (%d) \n", videoColor);

	if(videoColor == KADP_VSC_VIDEO_COLOR_WHITE){

		rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"rtk_hal_vsc_makeColoredVideo KADP_VSC_VIDEO_COLOR_WHITE \n");
		if((originalSize.x==0)&&(originalSize.y==0)&&(originalSize.w==0)&&(originalSize.h==0)){
			rtk_hal_vsc_GetOutputRegion(VIDEO_WID_0, &originalSize);
			if((originalSize.x==0)&&(originalSize.y==0)&&(originalSize.w==0)&&(originalSize.h==0)){
				rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"no originalSize,reset to default.\n");
				originalSize.x = 0;
				originalSize.y = 0;
				originalSize.w = _DISP_WID;
				originalSize.h = _DISP_LEN;
			}
			rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"originalSize (%d.%d.%d.%d) \n", originalSize.x, originalSize.y, originalSize.w, originalSize.h);
		}
		down(&VPQ_ld_running_Semaphore);
		drvif_HAL_VPQ_LED_LDEnable(1);
		up(&VPQ_ld_running_Semaphore);
		OutpuLocalDimmingPatMode = TRUE;
		//set free run timing
		drivf_scaler_reset_freerun_60Hz();
		// turn off osd mixer
		mixer_ctrl2_reg.regValue = IoReg_Read32(OSDOVL_Mixer_CTRL2_reg);
		mixer_ctrl2_reg.mixer_en = 0;
		IoReg_Write32(OSDOVL_Mixer_CTRL2_reg, mixer_ctrl2_reg.regValue);
		IoReg_Write32(OSDOVL_OSD_Db_Ctrl_reg, 0);

		//frank@0220 check memc bg status and clear memc bg
		memc_mux_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_MEMC_MUX_CTRL_reg);
		m_memc_bg_en = memc_mux_ctrl_reg.memc_out_bg_en;
		if(m_memc_bg_en){
			//enable UZU DTG double buffer.
			double_buffer_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL2_reg);
			double_buffer_ctrl_reg.uzudtgreg_dbuf_en = 1;
			double_buffer_ctrl_reg.uzudtg_dbuf_vsync_sel = 3;//using uzudtg vsync
			IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL2_reg, double_buffer_ctrl_reg.regValue);
			memc_mux_ctrl_reg.memc_out_bg_en = 0;
			IoReg_Write32(PPOVERLAY_MEMC_MUX_CTRL_reg, memc_mux_ctrl_reg.regValue);
			//set apply
			double_buffer_ctrl_reg.uzudtgreg_dbuf_set = 1;
			IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL2_reg, double_buffer_ctrl_reg.regValue);
		}

		dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
		dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 1;
		IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);

		main_background_color1_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Background_Color1_reg);
		main_background_color2_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Background_Color2_reg);
		main_background_color1_reg.m_bg_b = 0x3fff;
		main_background_color1_reg.m_bg_g = 0x3fff;
		main_background_color2_reg.m_bg_r = 0x3fff;
		IoReg_Write32(PPOVERLAY_Main_Background_Color1_reg, main_background_color1_reg.regValue);
		IoReg_Write32(PPOVERLAY_Main_Background_Color2_reg, main_background_color2_reg.regValue);
		down(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
		main_display_control_rsv_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Display_Control_RSV_reg);
		main_display_control_rsv_reg.m_force_bg = 1;
		IoReg_Write32(PPOVERLAY_Main_Display_Control_RSV_reg, main_display_control_rsv_reg.regValue);
		up(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
		dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply=1;
		IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
		do{
			dispd_smooth_toggle1_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_smooth_toggle1_reg);
		}while((dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply==1) && (--timeout));

		if(timeout==0){
			rtd_printk(KERN_INFO, TAG_NAME_VSC, "[%s]WARNING! wait double buf timeout!\n", __FUNCTION__);
			dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply = 0;
			IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
			dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
			dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 0;
			IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
			dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply = 1;
			IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
		}else{
			dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
			dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 0;
			IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
		}
/*
		int x=0;
		VIDEO_RECT_T output_region;

		while(1){
			output_region.x= x;
			output_region.y = 0;
			output_region.w = 150;
			output_region.h = 2160;

			rtk_hal_vsc_SetOutputRegion(0, output_region);

			if(x<=3690){
				x+=20;
			}else
				x=0;
		}
*/
	}else{
		mixer_ctrl2_reg.regValue = IoReg_Read32(OSDOVL_Mixer_CTRL2_reg);
		mixer_ctrl2_reg.mixer_en = 1;
		IoReg_Write32(OSDOVL_Mixer_CTRL2_reg, mixer_ctrl2_reg.regValue);
		IoReg_Write32(OSDOVL_OSD_Db_Ctrl_reg, 0);

		dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
		dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 1;
		IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
		main_background_color1_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Background_Color1_reg);
		main_background_color2_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Background_Color2_reg);
		main_background_color1_reg.m_bg_b = 0;
		main_background_color1_reg.m_bg_g = 0;
		main_background_color2_reg.m_bg_r = 0;
		IoReg_Write32(PPOVERLAY_Main_Background_Color1_reg, main_background_color1_reg.regValue);
		IoReg_Write32(PPOVERLAY_Main_Background_Color2_reg, main_background_color2_reg.regValue);


		//frank@0220 revert memc bg
		if(m_memc_bg_en){
			//disable UZU DTG double buffer.
			double_buffer_ctrl_reg.regValue =  IoReg_Read32(PPOVERLAY_Double_Buffer_CTRL2_reg);
			double_buffer_ctrl_reg.uzudtgreg_dbuf_en = 0;
			IoReg_Write32(PPOVERLAY_Double_Buffer_CTRL2_reg, double_buffer_ctrl_reg.regValue);
			memc_mux_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_MEMC_MUX_CTRL_reg);
			memc_mux_ctrl_reg.memc_out_bg_en = m_memc_bg_en;
			m_memc_bg_en = 0;
			IoReg_Write32(PPOVERLAY_MEMC_MUX_CTRL_reg, memc_mux_ctrl_reg.regValue);
		}
		dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply=1;
		IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
		do{
			dispd_smooth_toggle1_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_smooth_toggle1_reg);
		}while((dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply==1) && (--timeout));

		if(timeout==0){
			rtd_printk(KERN_INFO, TAG_NAME_VSC, "[%s]WARNING! wait double buf timeout!\n", __FUNCTION__);
			dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply = 0;
			IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
			dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
			dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 0;
			IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
			dispd_smooth_toggle1_reg.dispd_stage1_smooth_toggle_apply = 1;
			IoReg_Write32(PPOVERLAY_dispd_smooth_toggle1_reg, dispd_smooth_toggle1_reg.regValue);
		}else{
			dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
			dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 0;
			IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
		}
		rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"recovery originalSize (%d.%d.%d.%d) \n", originalSize.x, originalSize.y, originalSize.w, originalSize.h);
		OutpuLocalDimmingPatMode = FALSE;

		if((originalSize.x==0)&&(originalSize.y==0)&&(originalSize.w==0)&&(originalSize.h==0)){
			//do nothing
		}else{
			rtk_hal_vsc_SetOutputRegion(VIDEO_WID_0, originalSize, 0, 0);
		}
		memset((void*)&originalSize, 0, sizeof(VIDEO_RECT_T));
		dispd_stage1_sm_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_dispd_stage1_sm_ctrl_reg);
		dispd_stage1_sm_ctrl_reg.dispd_stage1_smooth_toggle_protect = 0;
		IoReg_Write32(PPOVERLAY_dispd_stage1_sm_ctrl_reg, dispd_stage1_sm_ctrl_reg.regValue);
		scaler_disp_smooth_variable_settingByDisp(0);

        //frank@01062016 add below flow to avoid demo mode exit will have garbage
        if(!Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY)){
            if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
            {
                mute_control(SLR_MAIN_DISPLAY, FALSE);/*disable forcebg*/
            }
        }
	}
	return 1;
}

static KADP_VSC_HDR_TYPE_T last_hdmi_dm_type = KADP_VSC_HDR_MAXN;
unsigned char rtk_hal_vsc_dm_open(unsigned char display)
{
	if(display != SLR_MAIN_DISPLAY)
		return TRUE;//no sub case
	down(&DM_HDR_Semaphore);
	//printk(KERN_EMERG "pinyen======DM open\n");
	if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"rtk_hal_vsc_dm_open, It is OTT, so return true!");
		up(&DM_HDR_Semaphore);
		return TRUE;
	}
	else if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) != VSC_INPUTSRC_HDMI)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"rtk_hal_vsc_dm_open, It is not hdmi source, so can not call dm funciton!");
		up(&DM_HDR_Semaphore);
		return FALSE;
	}

#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
	Scaler_Hdmi_DM_Set_Status(SLR_HDMI_DM_OPEN);
#endif
	up(&DM_HDR_Semaphore);
	return TRUE;
}


unsigned char rtk_hal_vsc_dm_close(unsigned char display)
{
	if(display != SLR_MAIN_DISPLAY)
		return TRUE;//no sub case
	down(&DM_HDR_Semaphore);
	rtd_maskl(H3DDMA_I3DDMA_MDP_CR_reg,~(_BIT3|_BIT4), 0);
	if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"rtk_hal_vsc_dm_close, It is OTT, so return true!");
		up(&DM_HDR_Semaphore);
		return TRUE;
	}
	else if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) != VSC_INPUTSRC_HDMI)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"rtk_hal_vsc_dm_close, It is not hdmi source, so can not call dm funciton!");
		up(&DM_HDR_Semaphore);
		return FALSE;
	}
	DbgSclrFlgTkr.hdmi_dolby_vision_flag = FALSE;
#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
	Scaler_Hdmi_DM_Set_Status(SLR_HDMI_DM_CLOSE);
#endif
	up(&DM_HDR_Semaphore);
	return TRUE;
}

void Share_Memory_Set_DM_Connect_Flag(unsigned char enable)
{
	unsigned int *dm_connect_flag = NULL;
	unsigned int *pulTemp = NULL;
	unsigned int i = 0, ulItemCount = 0;

	dm_connect_flag = (unsigned int *)Scaler_GetShareMemVirAddr(SCALERIOC_DM_CONNECT_FLAG);
	*dm_connect_flag = enable;

	ulItemCount = sizeof(unsigned int) /  sizeof(UINT32);
	pulTemp = dm_connect_flag;
	for (i = 0; i < ulItemCount; i++)
		pulTemp[i] = Scaler_ChangeUINT32Endian(pulTemp[i]);
}

static bool is_dm_dolby_type(KADP_VSC_HDR_TYPE_T type)
{
	return type == KADP_VSC_HDR_DOLBY || type == KADP_VSC_HDR_DOLBY_LL;
}

unsigned char rtk_hal_vsc_dm_connect(unsigned char display, KADP_VSC_HDR_TYPE_T eHdrMode)
{
	if(display != SLR_MAIN_DISPLAY)
		return TRUE;//no sub case

	down(&DM_HDR_Semaphore);

	if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC)
	{
		last_hdmi_dm_type = KADP_VSC_HDR_MAXN;
#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
	#ifdef CONFIG_RTK_KDRV_DV
#ifdef	CONFIG_DOLBY_IDK_1_6_1_1
		dolby_adapter_Check_DV_Mode();
#else
		Check_DV_Mode();//Check dolby mode again. Dolby 64 patch
#endif
	#endif
#endif
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"rtk_hal_vsc_dm_connect, It is OTT, so so return true!");
		Share_Memory_Set_DM_Connect_Flag(true);
		up(&DM_HDR_Semaphore);

        if(get_OTT_HDR_mode() != HDR_DOLBY_COMPOSER)
        {
        	switch(eHdrMode)
        	{
				case KADP_VSC_HDR_DOLBY:
					break;
				case KADP_VSC_HDR_HDR10:
				case KADP_VSC_HDR_VP9:
				case KADP_VSC_HDR_HLG:
				case KADP_VSC_HDR_PRIME:
				case KADP_VSC_HDR_HDR10_PLUS:
				case KADP_VSC_HDR_AUTO://old dm connect parameter. decide dolby or hdr
            		set_OTT_HDR_mode(HDR_HDR10_VDEC);
					break;
				case KADP_VSC_HDR_DOLBY_LL:
					rtd_printk(KERN_ERR, TAG_NAME_VSC ,"rtk_hal_vsc_dm_connect, vdec mode hdrtype dolbyLL error");
					break;
				default:
					break;

        	}
        }
		MAIN_VSC_HDRTYPE = eHdrMode;
		return TRUE;
	}
	else if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) != VSC_INPUTSRC_HDMI)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"rtk_hal_vsc_dm_connect, It is not hdmi source, so can not call dm funciton!");
		up(&DM_HDR_Semaphore);
		return FALSE;
	}

	if(eHdrMode == KADP_VSC_HDR_AUTO)
	{//auto detetck hdrtype for demo board
#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
		if(Scaler_HDR_DolbyVision_Hdmi_Get_Detect_Result())
		{
			DbgSclrFlgTkr.hdmi_dolby_vision_flag = TRUE;
		}
		else
		{
#ifdef CONFIG_SUPPORT_DOLBY_VSIF
			/*HDR10 flow*/
			if(get_HDMI_Dolby_VSIF_mode() != DOLBY_HDMI_VSIF_DISABLE)
			{
				DbgSclrFlgTkr.hdmi_dolby_vision_flag = TRUE; // DOLBY VSIF STD OR LL also need to set as Dolby_Hdmi_mode
			}
			else
			{
		      	DbgSclrFlgTkr.hdmi_dolby_vision_flag = FALSE;//in HDR10 HDMI, disable Dolby version flag @Crixus 20160313
			}
#else
		     DbgSclrFlgTkr.hdmi_dolby_vision_flag = FALSE;//in HDR10 HDMI, disable Dolby version flag @Crixus 20160313
#endif
		}
#else
		DbgSclrFlgTkr.hdmi_dolby_vision_flag = FALSE;
#endif
	}
	else
	{
		if((eHdrMode == KADP_VSC_HDR_DOLBY) || (eHdrMode == KADP_VSC_HDR_DOLBY_LL))
			DbgSclrFlgTkr.hdmi_dolby_vision_flag = TRUE;
		else
			DbgSclrFlgTkr.hdmi_dolby_vision_flag = FALSE;
	}
	MAIN_VSC_HDRTYPE = eHdrMode;
#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
	if(Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CLOSE)//dm not open or not connect
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"hdmi hdr10 is not open\n");
		up(&DM_HDR_Semaphore);
		return FALSE;
	}

		Scaler_Hdmi_DM_Set_Status(SLR_HDMI_DM_CONNECT);

	if ((Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_HDMI) && (Get_Live_zoom_mode()==LIVE_ZOOM_OFF))
	{
		/*qiangzhou:livezoom case ,hdr will ng for here,so livezoom case not enter this code*/
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"sub hdmi hdr, so no enable hdr\n");
		Scaler_Hdmi_DM_Set_Status(SLR_HDMI_DM_CLOSE);
		up(&DM_HDR_Semaphore);
		return FALSE;
	}
#endif



	/*hdmi dolby detect ok, set dolby_vision_flag=true*/
	if(DbgSclrFlgTkr.hdmi_dolby_vision_flag)
	{
		/* reset HDMI CurHdmiMode state,TCL2851M-2254 */
		Scaler_HDR_DolbyVision_Hdmi_SetDisplaytEnable(_DISABLE);
		//set_HDMI_HDR_mode(HDR_DOLBY_HDMI);
	}
	else{
		/*HDR10 flow*/
		set_HDMI_HDR_mode(HDR_HDR10_HDMI);
	}


	if(!DbgSclrFlgTkr.hdmi_dolby_vision_flag)//HDMI HDR10 case. Wait OTT dolby run. should no wait
	{
#ifdef CONFIG_RTK_KDRV_DV
		unsigned char timeout = 10;
#ifdef	CONFIG_DOLBY_IDK_1_6_1_1
		while(dolby_adapter_check_ott_dolby_update_run() && timeout)
#else
		while(check_ott_dolby_update_run() && timeout)
#endif
		{
			msleep(1);
			timeout --;
		}
#endif
	}

#ifdef CONFIG_HDR_SDR_SEAMLESS
	if(get_HDMI_HDR_mode() == HDR_HDR10_HDMI)
	{
		unsigned char hdr_type = HDR_DM_MODE_NONE;//typedef enum PQ_HDR_TYPE
		switch(eHdrMode)
    	{
			case KADP_VSC_HDR_DOLBY:
			case KADP_VSC_HDR_DOLBY_LL:
				hdr_type = HDR_DM_DOLBY;
				break;
			case KADP_VSC_HDR_HDR10:
			case KADP_VSC_HDR_VP9:
			case KADP_VSC_HDR_PRIME:
				hdr_type = HDR_DM_HDR10;
				break;

			case KADP_VSC_HDR_HLG:
				hdr_type = HDR_DM_HLG;
				break;

			case KADP_VSC_HDR_HDR10_PLUS:
				hdr_type = HDR_DM_ST2094;
				break;

			case KADP_VSC_HDR_AUTO://old dm connect parameter. decide dolby or hdr
			default:
        		hdr_type = HDR_DM_HDR10;
				break;

    	}
		down(&HDR_Setting_Semaphore);
		if(get_hdr_semaless_active())
		{
			//set_target_i3ddma_color_format(decide_i3ddma_output_foramt(get_backup_hdmi_info()));
			trigger_seamless_flow(KADP_VSC_INPUTSRC_HDMI, TRUE, hdr_type);
			//recode current hdr mode for seamless change @Crixus 20170110
			set_ori_HDMI_HDR_mode(get_HDMI_HDR_mode());
		}
		up(&HDR_Setting_Semaphore);
	}
	else
	{
#ifdef CONFIG_RTK_KDRV_DV
		if(DbgSclrFlgTkr.hdmi_dolby_vision_flag) {
			reset_dolby_md_crc_error_cnt();
#ifdef	CONFIG_DOLBY_IDK_1_6_1_1
			dolby_adapter_DV_HDMI_Init();
#else
			DV_HDMI_Init();
#endif
		}
#endif
		increase_hdrtype_change_counter();
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
	}
#else
	Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_HDMI,255);

#ifdef CONFIG_RTK_KDRV_DV
	if(DbgSclrFlgTkr.hdmi_dolby_vision_flag) {
#ifdef	CONFIG_DOLBY_IDK_1_6_1_1
			dolby_adapter_DV_HDMI_Init();
#else
		DV_HDMI_Init();
#endif
	}
#endif
	//Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_THROUGH_I3DDMA, true);
	DbgSclrFlgTkr.main_opensourceID =_UNKNOWN_INPUT;
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
#endif
	if(DbgSclrFlgTkr.hdmi_dolby_vision_flag) {

		set_HDMI_HDR_mode(HDR_DOLBY_HDMI);
	}
	if ((last_hdmi_dm_type != eHdrMode) && (last_hdmi_dm_type != KADP_VSC_HDR_MAXN)
			&& (is_dm_dolby_type(last_hdmi_dm_type) || is_dm_dolby_type(eHdrMode))) {
		drvif_mode_onlinemeasure_setting(SLR_MAIN_DISPLAY, _SRC_HDMI, FALSE, FALSE);
		drvif_mode_disableonlinemeasure(SLR_MAIN_DISPLAY);//Disable online measure
	}
	last_hdmi_dm_type = eHdrMode;

	up(&DM_HDR_Semaphore);
	return TRUE;
}

extern void DI_freeze(int enable);

unsigned char rtk_hal_vsc_dm_disconnect(unsigned char display)
{
	if(display != SLR_MAIN_DISPLAY)
		return TRUE;//no sub case
	down(&DM_HDR_Semaphore);
	//reset Dolby HDR
	if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC) || get_HDMI_HDR_mode() == HDR_DOLBY_HDMI){
		//Scaler_Dolby_HDR_reset(); //Mark by will. Move to scaler
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"rtk_hal_vsc_dm_disconnect, reset Dolby HDR\n");
	}

	if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_VDEC)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"rtk_hal_vsc_dm_disconnect, It is OTT, so return true!");
		Share_Memory_Set_DM_Connect_Flag(false);
		up(&DM_HDR_Semaphore);
        if(get_OTT_HDR_mode() == HDR_HDR10_VDEC)
        {
            set_OTT_HDR_mode(HDR_MODE_DISABLE);
        }
		MAIN_VSC_HDRTYPE = KADP_VSC_HDR_MAXN;//reset hdr type
		return TRUE;
	}
	else if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) != VSC_INPUTSRC_HDMI)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"rtk_hal_vsc_dm_disconnect, It is not hdmi source, so can not call dm funciton!");
		up(&DM_HDR_Semaphore);
		return FALSE;
	}
	MAIN_VSC_HDRTYPE = KADP_VSC_HDR_MAXN;//reset hdr type
	//if(Scaler_DispGetInputInfo(SLR_INPUT_THROUGH_I3DDMA) == true)
	if(DbgSclrFlgTkr.hdmi_dolby_vision_flag)
	{
		//DV_Stop(void)
#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
		Scaler_HDR_DolbyVision_Hdmi_SetDisplaytEnable(_DISABLE);
#endif
	}

#ifdef CONFIG_HDR_SDR_SEAMLESS
	if(get_HDMI_HDR_mode() == HDR_DOLBY_HDMI)
	{
		increase_hdrtype_change_counter();

		if(Get_DisplayMode_Src(SLR_SUB_DISPLAY) ==VSC_INPUTSRC_HDMI)
			Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
		if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)
			Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
		//willychou add WOSQRTK-8674/WOSQRTK-9024,HDMI clock change -> _MODE_STATE_SEARCH -> stop rtk_check_signal and HDMI_set_detect_flag(TRUE)
		//-> no signal happen -> util HDMI_set_detect_flag(TRUE) again
		down(get_hdmi_detectsemaphore());
		if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
		up(get_hdmi_detectsemaphore());
	}

#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
	Scaler_Hdmi_DM_Set_Status(SLR_HDMI_DM_OPEN);
#endif

	if(get_HDMI_HDR_mode() == HDR_DOLBY_HDMI)
	{
		set_HDMI_HDR_mode(HDR_MODE_DISABLE);
	}
	else
	{
		set_HDMI_HDR_mode(HDR_MODE_DISABLE);
		down(&HDR_Setting_Semaphore);
		if(get_hdr_semaless_active())
		{
			set_target_i3ddma_color_format(decide_i3ddma_output_foramt(get_backup_hdmi_info()));
			trigger_seamless_flow(KADP_VSC_INPUTSRC_HDMI, FALSE, HDR_DM_MODE_NONE);
			//recode current hdr mode for seamless change @Crixus 20170110
			set_ori_HDMI_HDR_mode(get_HDMI_HDR_mode());
		}
		up(&HDR_Setting_Semaphore);
	}


#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
	Scaler_HDR_DolbyVision_Hdmi_SetDetectEnable(_ENABLE, _DISABLE);
#endif


#else
	if(Get_DisplayMode_Src(SLR_SUB_DISPLAY) == KADP_VSC_INPUTSRC_HDMI)
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);

	if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == KADP_VSC_INPUTSRC_HDMI)
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);

	//willychou add WOSQRTK-8674/WOSQRTK-9024,HDMI clock change -> _MODE_STATE_SEARCH -> stop rtk_check_signal and HDMI_set_detect_flag(TRUE)
	//-> no signal happen -> util HDMI_set_detect_flag(TRUE) again
	down(get_hdmi_detectsemaphore());
	if(get_HDMI_Global_Status() == SRC_CONNECT_DONE) HDMI_set_detect_flag(TRUE);
	up(get_hdmi_detectsemaphore());

#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
	Scaler_Hdmi_DM_Set_Status(SLR_HDMI_DM_CLOSE);
#endif
	drvif_mode_onlinemeasure_setting(SLR_MAIN_DISPLAY, _SRC_HDMI, FALSE, FALSE);
	drvif_mode_disableonlinemeasure(SLR_MAIN_DISPLAY);//Disable online measure
	last_hdmi_dm_type = KADP_VSC_HDR_MAXN;

    Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_THROUGH_I3DDMA, false);
	DbgSclrFlgTkr.main_opensourceID =_UNKNOWN_INPUT;
	set_HDMI_HDR_mode(HDR_MODE_DISABLE);
	Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_HDMI, 255);

#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
	Scaler_HDR_DolbyVision_Hdmi_SetDetectEnable(_ENABLE, _DISABLE);
#endif

#endif
	DI_freeze(false);
	up(&DM_HDR_Semaphore);
	return TRUE;
}

void scaler_dolby_hdmi_smooth_toggle(UINT8 isSDRtoEDR)/*1==SDR->EDR   0==EDR->SDR*/
{
#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
	if(isSDRtoEDR)
	{
		Scaler_Hdmi_DM_Set_Status(SLR_HDMI_DM_CONNECT);
	}
	else
	{
		Scaler_Hdmi_DM_Set_Status(SLR_HDMI_DM_CLOSE);
	}
#endif

	DbgSclrFlgTkr.Main_Scaler_Stop_flag = FALSE;
	DbgSclrFlgTkr.Main_Run_Scaler_flag =TRUE;
	Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
}

extern void I3DDMA_Set_Metadata_Vgip(void);

#ifdef CONFIG_FORCE_RUN_I3DDMA
unsigned char scaler_force_run_idma(unsigned char display, VSC_INPUT_TYPE_T inputSrctype)
{
	if(DbgSclrFlgTkr.Main_Scaler_Stop_flag)
		return FALSE;

	set_force_change_vo_flag(0, TRUE);//force update vo info

#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
	if(Scaler_Hdmi_DM_Get_Status() == SLR_HDMI_DM_CONNECT)
		Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_HDMI,  255);
	else
#endif
	{
		Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_HDMI,  0xfa);
	}

	down(&VSC_Semaphore);
	drvif_mode_resetmode(display);
	drvif_I3DDMA_Init();

	if((inputSrctype == VSC_INPUTSRC_VDEC) || (inputSrctype == VSC_INPUTSRC_JPEG))
	{
		rtd_printk(KERN_EMERG, TAG_NAME_VSC,"vo source,return\n");
		up(&VSC_Semaphore);
		return TRUE;
	}
	else if(inputSrctype == VSC_INPUTSRC_ADC)//ypp,VGA
	{
		down(get_adc_detectsemaphore());
		Scaler_SET_VSCDispinfo_WithVFEDispinfo(display, Get_ADC_Dispinfo());//now for test, only for ypp timing info
		if(vsc_timinginfo_check() == FALSE)
		{
			up(get_adc_detectsemaphore());
			up(&VSC_Semaphore);
			rtd_printk(KERN_ERR, TAG_NAME_VSC,"adc vsc_timinginfo_check error\n");
			return FALSE;
		}
		if(Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) > 2000)//mean 4095 no support
		{
			up(get_adc_detectsemaphore());
			up(&VSC_Semaphore);
			rtd_printk(KERN_ERR, TAG_NAME_VSC,"scaler_force_run_idma adc vsc_timinginfo_check no support error\n");
			return FALSE;
		}
		ADC_set_detect_flag(FALSE);
		up(get_adc_detectsemaphore());

		// Scart RGB
		if(get_ADC_Input_Source() == _SRC_SCART_RGB)
		{
			if(!drivf_i3ddma_config(display, VGIP_SRC_ATV))
			{
				up(&VSC_Semaphore);
				rtd_printk(KERN_EMERG, TAG_NAME_VSC,"adc drivf_i3ddma_config error\n");
				return FALSE;
			}
		}
		// YPP and VGA
		else
		{
			if(!drivf_i3ddma_config(display, VGIP_SRC_ADC))
			{
				up(&VSC_Semaphore);
				rtd_printk(KERN_EMERG, TAG_NAME_VSC,"adc drivf_i3ddma_config error\n");
				return FALSE;
			}
			fw_scaler_set_sample(display, _ENABLE);
		}
		if(!check_verify_mode_enable()){
			rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"#####[%s(%d)] call ADC_VSC_Setting\n",__func__,__LINE__);
			ADC_VSC_Setting(get_ADC_Input_Source());//if ADC verify mode no need this
		}
		fw_scaler_adc_nolock_wdg_ctrl(display, FALSE);//Disable adc_nolock_wdg
		drvif_mode_enable_dma_onlinemeasure();//Enable dma online measure
	}
	else if(inputSrctype == VSC_INPUTSRC_AVD)
	{
		down(get_vdc_detectsemaphore());
		Scaler_SET_VSCDispinfo_WithVFEDispinfo(display, Get_AVD_ScalerDispinfo());
		if(vsc_timinginfo_check() == FALSE)
		{
			up(get_vdc_detectsemaphore());
			up(&VSC_Semaphore);
			rtd_printk(KERN_EMERG, TAG_NAME_VSC,"avd vsc_timinginfo_check error\n");
			return FALSE;
		}
		up(get_vdc_detectsemaphore());
		if(!drivf_i3ddma_config(display, VGIP_SRC_ATV))
		{
			up(&VSC_Semaphore);
			rtd_printk(KERN_EMERG, TAG_NAME_VSC,"avd drivf_i3ddma_config error\n");
			return FALSE;
		}
		drvif_mode_enable_dma_onlinemeasure();//Enable dma online measure
	}
	else if(inputSrctype == VSC_INPUTSRC_HDMI)
	{

		vfe_hdmi_timing_info_t vfehdmitiminginfo;
		down(get_hdmi_detectsemaphore());
		if(0 != vfe_hdmi_drv_get_display_timing_info(&vfehdmitiminginfo, display))
		{
			up(get_hdmi_detectsemaphore());
			up(&VSC_Semaphore);
			rtd_printk(KERN_EMERG, TAG_NAME_VSC,"vfe_hdmi_drv_get_display_timing_info error\n");
			return FALSE;
		}
		Scaler_SET_VSCDispinfo_WithVFEHMDI(display, vfehdmitiminginfo);
		#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
		Scaler_HDR10_Hdmi_Set_Input_ACT_WID_info(vfehdmitiminginfo.active.w);
		#endif

		if(vsc_timinginfo_check() == FALSE)
		{
			up(get_hdmi_detectsemaphore());
			up(&VSC_Semaphore);
			rtd_printk(KERN_EMERG, TAG_NAME_VSC,"hdmi vsc_timinginfo_check error\n");
			return FALSE;
		}

		HDMI_set_detect_flag(FALSE);
		up(get_hdmi_detectsemaphore());
		if((drvif_Hdmi_GetRawColorSpace() == COLOR_YUV420) && (drvif_Hdmi_GetFrlMode() == 0))
		{//hdmi2.0 and color yuv420
			if(get_hdmi_4k_hfr_mode() == HDMI_4K120_2_0)
			{
				drvif_Hdmi_EnableBypassYUV420Engine(1);//bypass hmdi yuv420 to yuv444
			}
			else
			{
				drvif_Hdmi_EnableBypassYUV420Engine(0);//orignal hmdi yuv420 to yuv444
			}
		}
		if(!drivf_i3ddma_config(display, VGIP_SRC_TMDS))
		{
			up(&VSC_Semaphore);
			rtd_printk(KERN_EMERG, TAG_NAME_VSC,"hdmi drivf_i3ddma_config error\n");
			return FALSE;
		}

		#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
		if(DbgSclrFlgTkr.hdmi_dolby_vision_flag)
		{
			Scaler_HDR_DolbyVision_Hdmi_SetDisplaytEnable(_ENABLE);
		}
		#endif

		drvif_mode_enable_dma_onlinemeasure();//Enable dma online measure
	}
	up(&VSC_Semaphore);
#ifdef _PRINT_AVD_COST_TIME
	rtd_printk(KERN_INFO, TAG_NAME_VSC,"_PRINT_AVD_COST_TIME:  %s(%d) time = %d\n",__FUNCTION__,__LINE__,IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90);
#endif
	return TRUE;
}

unsigned char scaler_atv_force_run_idma(void)
{
	if (ATV_forcei3ddma == 1)
		;	//	ATV will force i3ddma scaler flow
#ifndef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
	else if(DbgSclrFlgTkr.Main_Output_Set_flag || DbgSclrFlgTkr.Main_Scaler_Stop_flag || DbgSclrFlgTkr.Main_Run_Scaler_flag)
		return FALSE;
#endif
	set_force_change_vo_flag(0, TRUE);//force update vo info
	Scaler_Send_VoType_VOMDA(KADP_VO_VSC_SRC_HDMI,  0xfa);
	down(&VSC_Semaphore);
	drvif_mode_resetmode(SLR_MAIN_DISPLAY);
	drvif_I3DDMA_Init();

	down(get_vdc_detectsemaphore());
	Scaler_SET_VSCDispinfo_WithVFEDispinfo(SLR_MAIN_DISPLAY, Get_AVD_ScalerDispinfo());
	if(vsc_timinginfo_check() == FALSE)
	{
		up(get_vdc_detectsemaphore());
		up(&VSC_Semaphore);
		pr_emerg("avd vsc_timinginfo_check error\n");
		return FALSE;
	}
	up(get_vdc_detectsemaphore());
	if(!drivf_i3ddma_config(SLR_MAIN_DISPLAY, VGIP_SRC_ATV))
	{
		up(&VSC_Semaphore);
		rtd_printk(KERN_EMERG, TAG_NAME_VSC,"atv drivf_i3ddma_config error\n");
		return FALSE;
	}
	drvif_mode_enable_dma_onlinemeasure();//Enable online measure

	up(&VSC_Semaphore);

	return TRUE;
}
#endif


#ifdef CONFIG_I2RND_ENABLE
void rtk_hal_vsc_i2rnd_enable(unsigned char enable){
	return;
	if(enable == _ENABLE){
		//Eric@20170904 move i2rnd initial to vsc initial
		if(vsc_i2rnd_initial_done == _DISABLE){
			//Eric@0809 Dual VO i2rnd case use this flag to default run i2rnd flow fill s0 cmd table, but not enable i2rnd timing.
			//Scaler_I2rnd_set_force_cmd(_ENABLE);
			//Scaler_I2rnd_set_force_cmd(_DISABLE);
			Scaler_I2rnd_set_enable(_ENABLE);
			i2rnd_default_register_setting();
		}
		else{
			//Scaler_I2rnd_set_force_cmd(_ENABLE);
			Scaler_I2rnd_set_enable(_ENABLE);
			i2rnd_default_register_setting();
		}
	}
	else{
		Scaler_I2rnd_set_enable(_DISABLE);//uninitial i2rnd  to disable I2rnd flag @Crixus 20160801
		Scaler_I2rnd_set_force_cmd(_DISABLE);
	}
}
#endif

#ifdef CONFIG_PST_ENABLE
extern unsigned char Scaler_sub_md_pst_get_enable(void);
void rtk_hal_vsc_pst_enable(unsigned char enable){
	//Eric@20170904 move pst initial to vsc initial
	if(enable == _ENABLE){
		//enable main pst
		Scaler_main_md_pst_set_enable(_ENABLE);
		//enable sub pst
		Scaler_sub_md_pst_set_enable(_ENABLE);
	}
	else{
		//disable main pst
		Scaler_main_md_pst_set_enable(_DISABLE);
		//disable sub pst
		Scaler_sub_md_pst_set_enable(_DISABLE);
	}
}
#endif


#ifdef CONFIG_I2RND_B05_ENABLE
unsigned char rtk_hal_vsc_i2rnd_b05_enable(unsigned char enable)
{
	if(enable == _ENABLE) {
	//               printk("in_b05_initial\n");
		drvif_scaler_i2rnd_b05_initial();
		Scaler_I2rnd_b05_set_enable(_ENABLE);
	//                drvif_scaler_i2rnd_b05_vodma_setting(SLR_MAIN_DISPLAY);
	} else {
		drvif_scaler_i2rnd_b05_uninitial();
		Scaler_I2rnd_b05_set_enable(_DISABLE);//uninitial i2rnd_b05  to disable I2rnd flag
		//printk("in_b05_uninitial\n");
	}
	return TRUE;
}
#endif


unsigned char rtk_hal_vsc_SetDelayBuffer(VIDEO_WID_T wId, UINT8 buffer)
{
#ifdef CONFIG_REALTEK_2K_MODEL_ENABLED
	if(wId == VIDEO_WID_0){
		if(buffer >=3 && buffer <=7)
		{
			Check_smooth_toggle_update_flag(wId);
			drv_memory_Set_multibuffer_number(buffer);
			drv_memory_Set_multibuffer_flag(_ENABLE);

		}
		else
		{
			drv_memory_Set_multibuffer_flag(_DISABLE);
			drv_memory_Set_multibuffer_number(0);
		}
		drv_memory_send_multibuffer_number_to_smoothtoogh();
		pr_emerg("function=%s,buffernub=%d\n",__FUNCTION__,buffer);
	}
#endif
	return TRUE;
}


SMOOTH_TOGGLE_INFO temp_info_main;
void scaler_save_main_info(void)
{
	temp_info_main.IMD_SMOOTH_H_ACT_WID_PRE= Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_WID_PRE);
	temp_info_main.IMD_SMOOTH_H_ACT_STA_PRE= Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_STA_PRE);
	temp_info_main.IMD_SMOOTH_V_ACT_LEN_PRE= Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_LEN_PRE);
	temp_info_main.IMD_SMOOTH_V_ACT_STA_PRE= Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_STA_PRE);
	temp_info_main.IMD_SMOOTH_H_ACT_WID = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_WID);
	temp_info_main.IMD_SMOOTH_H_ACT_STA= Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_STA);
	temp_info_main.IMD_SMOOTH_V_ACT_LEN= Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_LEN);
	temp_info_main.IMD_SMOOTH_V_ACT_STA= Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_STA);
	temp_info_main.IMD_SMOOTH_FRAMESYNC = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_FRAMESYNC);
	temp_info_main.IMD_SMOOTH_DI_WID= Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DI_WID);

#ifdef CONFIG_SDNR_CROP
	temp_info_main.IMD_SMOOTH_SDNRH_ACT_STA_PRE = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_STA_PRE);
	temp_info_main.IMD_SMOOTH_SDNRV_ACT_STA_PRE = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_STA_PRE);
	temp_info_main.IMD_SMOOTH_SDNRH_ACT_WID_PRE = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_WID_PRE);
	temp_info_main.IMD_SMOOTH_SDNRV_ACT_LEN_PRE = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_LEN_PRE);
	temp_info_main.IMD_SMOOTH_SDNRH_ACT_STA = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_STA);
	temp_info_main.IMD_SMOOTH_SDNRV_ACT_STA = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_STA);
	temp_info_main.IMD_SMOOTH_SDNRH_ACT_WID = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_WID);
	temp_info_main.IMD_SMOOTH_SDNRV_ACT_LEN = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_LEN);
#endif
	temp_info_main.IMD_SMOOTH_CapWid = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_CAP_WID);
	temp_info_main.IMD_SMOOTH_CapLen = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_CAP_LEN);
	temp_info_main.IMD_SMOOTH_MEM_ACT_HSTA = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_HSTA);
	temp_info_main.IMD_SMOOTH_MEM_ACT_VSTA = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_VSTA);
	temp_info_main.IMD_SMOOTH_MEM_ACT_LEN = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_LEN);
	temp_info_main.IMD_SMOOTH_MEM_ACT_WID = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_WID);
	temp_info_main.IMD_SMOOTH_DispLen = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DISP_LEN);
	temp_info_main.IMD_SMOOTH_DispWid = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DISP_WID);
	temp_info_main.IMD_SMOOTH_DISP_RTNR =Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR);
	temp_info_main.IMD_SMOOTH_DISP_10BIT = Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_10BIT);
	temp_info_main.IMD_SMOOTH_DISP_THRIP = Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_THRIP);
	temp_info_main.IMD_SMOOTH_DISP_MA3A = Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_MA3A);
	temp_info_main.IMD_SMOOTH_DISP_422CAP= Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422CAP);
	temp_info_main.IMD_SMOOTH_DISP_422= Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422);
}
void scaler_update_struct_info(unsigned char display)
{
	if (display == SLR_MAIN_DISPLAY) {
		pr_emerg("update main scaler struct info\n");
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_WID_PRE, temp_info_main.IMD_SMOOTH_H_ACT_WID_PRE);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_STA_PRE, temp_info_main.IMD_SMOOTH_H_ACT_STA_PRE);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_LEN_PRE, temp_info_main.IMD_SMOOTH_V_ACT_LEN_PRE);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_STA_PRE, temp_info_main.IMD_SMOOTH_V_ACT_STA_PRE);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_WID, temp_info_main.IMD_SMOOTH_H_ACT_WID);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_STA, temp_info_main.IMD_SMOOTH_H_ACT_STA);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_LEN, temp_info_main.IMD_SMOOTH_V_ACT_LEN);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_STA, temp_info_main.IMD_SMOOTH_V_ACT_STA);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_FRAMESYNC, temp_info_main.IMD_SMOOTH_FRAMESYNC);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DI_WID, temp_info_main.IMD_SMOOTH_DI_WID);

#ifdef CONFIG_SDNR_CROP
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_STA_PRE, temp_info_main.IMD_SMOOTH_SDNRH_ACT_STA_PRE);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_STA_PRE, temp_info_main.IMD_SMOOTH_SDNRV_ACT_STA_PRE);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_WID_PRE, temp_info_main.IMD_SMOOTH_SDNRH_ACT_WID_PRE);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_LEN_PRE, temp_info_main.IMD_SMOOTH_SDNRV_ACT_LEN_PRE);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_STA, temp_info_main.IMD_SMOOTH_SDNRH_ACT_STA);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_STA, temp_info_main.IMD_SMOOTH_SDNRV_ACT_STA);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_WID, temp_info_main.IMD_SMOOTH_SDNRH_ACT_WID);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_LEN, temp_info_main.IMD_SMOOTH_SDNRV_ACT_LEN);
#endif
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_CAP_WID, temp_info_main.IMD_SMOOTH_CapWid);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_CAP_LEN, temp_info_main.IMD_SMOOTH_CapLen);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_HSTA, temp_info_main.IMD_SMOOTH_MEM_ACT_HSTA);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_VSTA, temp_info_main.IMD_SMOOTH_MEM_ACT_VSTA);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_LEN, temp_info_main.IMD_SMOOTH_MEM_ACT_LEN );
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_WID, temp_info_main.IMD_SMOOTH_MEM_ACT_WID);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DISP_LEN, temp_info_main.IMD_SMOOTH_DispLen);
		Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DISP_WID, temp_info_main.IMD_SMOOTH_DispWid);
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR, temp_info_main.IMD_SMOOTH_DISP_RTNR);
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_10BIT, temp_info_main.IMD_SMOOTH_DISP_10BIT);
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_THRIP, temp_info_main.IMD_SMOOTH_DISP_THRIP);
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_MA3A, temp_info_main.IMD_SMOOTH_DISP_MA3A);
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422CAP, temp_info_main.IMD_SMOOTH_DISP_422CAP);
		Scaler_DispSetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422, temp_info_main.IMD_SMOOTH_DISP_422);
	} else {
		pr_emerg("update sub scaler struct info\n");
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_IPH_ACT_WID_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_WID_PRE));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_IPH_ACT_STA_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_STA_PRE));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_IPV_ACT_LEN_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_LEN_PRE));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_IPV_ACT_STA_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_STA_PRE));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_IPH_ACT_WID,  Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_WID));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_IPH_ACT_STA, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPH_ACT_STA));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_IPV_ACT_LEN, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_LEN));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_IPV_ACT_STA, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_IPV_ACT_STA));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_FRAMESYNC, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_FRAMESYNC));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_DI_WID, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DI_WID));

#ifdef CONFIG_SDNR_CROP
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_SDNRH_ACT_STA_PRE,  Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_STA_PRE));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_SDNRV_ACT_STA_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_STA_PRE));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_SDNRH_ACT_WID_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_WID_PRE));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_SDNRV_ACT_LEN_PRE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_LEN_PRE));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_SDNRH_ACT_STA, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_STA));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_SDNRV_ACT_STA, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_STA));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_SDNRH_ACT_WID, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRH_ACT_WID));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_SDNRV_ACT_LEN, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_SDNRV_ACT_LEN));
#endif
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_CAP_WID, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_CAP_WID));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_CAP_LEN,  Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_CAP_LEN));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_MEM_ACT_HSTA, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_HSTA));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_MEM_ACT_VSTA, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_VSTA));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_MEM_ACT_LEN, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_LEN));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_MEM_ACT_WID, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MEM_ACT_WID));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_DISP_LEN, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DISP_LEN));
		Scaler_DispSetInputInfoByDisp(SLR_SUB_DISPLAY,SLR_INPUT_DISP_WID, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_DISP_WID));
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_RTNR, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_RTNR));
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_10BIT, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_10BIT));
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_THRIP, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_THRIP));
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_MA3A, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_MA3A));
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_422CAP, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422CAP));
		Scaler_DispSetStatus(SLR_SUB_DISPLAY, SLR_DISP_422, Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_422));
	}
}

/*//no used
unsigned int VSC_PM_REGISTER_DATA[][2]
=
{
	//VGIP
	{SUB_VGIP_VGIP_CHN2_DELAY_reg, 0},
	{SUB_VGIP_VGIP_CHN2_ACT_HSTA_Width_reg, 0},
	{SUB_VGIP_VGIP_CHN2_ACT_VSTA_Length_reg, 0},
	{SUB_VGIP_VGIP_CHN2_CTRL_reg, 0},

	{VGIP_VGIP_CHN1_MISC_reg, 0},
	{VGIP_Data_Path_Select_reg, 0},
	{VGIP_VGIP_CHN1_DELAY_reg, 0},
	{VGIP_VGIP_CHN1_ACT_HSTA_Width_reg, 0},
	{VGIP_VGIP_CHN1_ACT_VSTA_Length_reg, 0},
	{VGIP_FRAMEPACKING_INTERLACE_CTRL1_reg, 0},
	{VGIP_FRAMEPACKING_INTERLACE_CTRL2_reg, 0},
	{VGIP_FRAMEPACKING_INTERLACE_CTRL3_reg, 0},
	{VGIP_FRAMEPACKING_INTERLACE_CTRL4_reg, 0},
	{VGIP_FRAMEPACKING_CTRL1_reg, 0},
	{VGIP_FRAMEPACKING_CTRL2_reg, 0},
	{VGIP_VGIP_CHN1_CTRL_reg, 0},
	{VGIP_INT_CTL_reg, 0},

	//RGB2YUV
	{RGB2YUV_Tab1_M11_M12_reg, 0},
	{RGB2YUV_Tab1_M13_M21_reg, 0},
	{RGB2YUV_Tab1_M22_M23_reg, 0},
	{RGB2YUV_Tab1_M31_M32_reg, 0},
	{RGB2YUV_Tab1_M33_YGain_reg,0},
	{RGB2YUV_Tab1_Yo_reg, 0},
	{RGB2YUV_ICH1_422to444_CTRL_reg, 0},
	{RGB2YUV_ICH1_RGB2YUV_CTRL_reg, 0},

	{RGB2YUV_Tab2_M11_M12_reg, 0},
	{RGB2YUV_Tab2_M13_M21_reg, 0},
	{RGB2YUV_Tab2_M22_M23_reg, 0},
	{RGB2YUV_Tab2_M31_M32_reg, 0},
	{RGB2YUV_Tab2_M33_Y_Gain_reg, 0},
	{RGB2YUV_Tab2_Yo_reg, 0},
	{RGB2YUV_ICH2_422to444_CTRL_reg, 0},
	{RGB2YUV_ICH2_RGB2YUV_CTRL_reg, 0},
	//UZD
	{SCALEDOWN_ICH1_sdnr_444to422_CTRL_reg, 0},
	{SCALEDOWN_ICH1_IBUFF_CTRLI_BUFF_CTRL_reg, 0},
	{SCALEDOWN_ICH1_UZD_FIR_Coef_Tab1_C0_reg, 0},
	{SCALEDOWN_ICH1_UZD_FIR_Coef_Tab2_C0_reg, 0},
	{SCALEDOWN_ICH1_hsd_3d_boundary_reg, 0},
	{SCALEDOWN_ICH1_UZD_Scale_Hor_Factor_reg, 0},
	{SCALEDOWN_ICH1_UZD_Scale_Ver_Factor_reg, 0},
	{SCALEDOWN_ICH1_UZD_Initial_Value_reg, 0},
	{SCALEDOWN_ICH1_UZD_Hor_Segment_reg, 0},
	{SCALEDOWN_ICH1_UZD_Hor_Delta1_reg, 0},
	{SCALEDOWN_ICH1_UZD_Ctrl0_reg, 0},
	{SCALEDOWN_ICH1_UZD_Ctrl1_reg, 0},

	{HSD_DITHER_DI_UZD_FIR_Coef_Tab1_C0_reg, 0},
	{HSD_DITHER_DI_HSD_Scale_Hor_Factor_reg, 0},
	{HSD_DITHER_DI_HSD_Initial_Value_reg, 0},
	{HSD_DITHER_DI_HSD_Hor_Delta1_reg, 0},
	{HSD_DITHER_DI_HSD_Hor_Segment_reg, 0},
	{HSD_DITHER_DI_HSD_Ctrl0_reg, 0},

	{SCALEDOWN_ICH2_UZD_H_Output_Size_reg, 0},
	{SCALEDOWN_ICH2_UZD_Scale_Hor_Factor_reg, 0},
	{SCALEDOWN_ICH2_UZD_Scale_Ver_Factor_reg, 0},
	{SCALEDOWN_ICH2_UZD_Initial_Value_reg, 0},
	{SCALEDOWN_ICH2_UZD_Ctrl0_reg, 0},
	{SCALEDOWN_ICH2_UZD_Ctrl1_reg, 0},
	//DI
	//{EXSRAM_CTRL_reg, 0},
	{DI_Color_Recovery_Option_reg, 0},
	{DI_DI_DMA_Multi_Req_Num_reg, 0},
	{DI_IM_DI_WEAVE_WINDOW_CONTROL_reg, 0},
	{DI_db_reg_ctl_reg, 0},
	{DI_IM_DI_DMA_reg, 0},
	{DI_DDR_RDATDMA_WTLENNUM_reg, 0},
	{DI_DDR_RINFDMA_WTLENNUM_reg, 0},
	{DI_DDR_WDATDMA_WTLENNUM_reg, 0},
	{DI_DDR_DATDMA_RM_reg, 0},
	{DI_DDR_WINFDMA_WTLENNUM_reg, 0},
	{DI_DDR_INFDMA_RM_reg, 0},
	{DI_DI_DATMemoryStartAdd1_reg, 0},
	{DI_DI_DATMemoryStartAdd2_reg, 0},
	{DI_DI_DATMemoryStartAdd3_reg, 0},
	{DI_DI_DATMemoryStartAdd4_reg, 0},
	{DI_DI_INFMemoryStartAdd1_reg, 0},
	{DI_DI_INFMemoryStartAdd2_reg, 0},
	{DI_DI_DATMemoryStartAdd1_3D_reg, 0},
	{DI_DI_DATMemoryStartAdd2_3D_reg, 0},
	{DI_DI_DATMemoryStartAdd3_3D_reg, 0},
	{DI_DI_DATMemoryStartAdd4_3D_reg, 0},
	{DI_DI_INFMemoryStartAdd1_3D_reg, 0},
	{DI_DI_INFMemoryStartAdd2_3D_reg, 0},
	{DI_IM_DI_ACTIVE_WINDOW_CONTROL_reg, 0},
	{DI_IM_DI_BTR_CONTROL_reg, 0},
	{DI_IM_DI_MPEG_SEQUENCE_APP_reg, 0},
	{DI_IM_DI_FRAMESOBEL_STATISTIC_reg, 0},
	{DI_IM_DI_CONTROL_reg, 0},
	//MTG:
	{PPOVERLAY_MAIN_DEN_H_Start_End_reg, 0},
	{PPOVERLAY_MAIN_DEN_V_Start_End_reg, 0},
	{PPOVERLAY_MAIN_Background_H_Start_End_reg, 0},
	{PPOVERLAY_MAIN_Background_V_Start_End_reg, 0},
	{PPOVERLAY_Main_Background_Color1_reg, 0},
	{PPOVERLAY_Main_Background_Color2_reg, 0},
	{PPOVERLAY_Main_Border_Highlight_Border_Color1_reg, 0},
	{PPOVERLAY_Main_Border_Highlight_Border_Color2_reg, 0},
	{PPOVERLAY_Main_Border_Highlight_Border_Color3_reg, 0},
	{PPOVERLAY_MAIN_Active_H_Start_End_reg, 0},
	{PPOVERLAY_MAIN_Active_V_Start_End_reg, 0},

	{PPOVERLAY_SUB_DEN_H_Start_Width_reg, 0},
	{PPOVERLAY_SUB_DEN_V_Start_Length_reg, 0},
	{PPOVERLAY_SUB_Background_H_Start_End_reg, 0},
	{PPOVERLAY_SUB_Background_V_Start_End_reg, 0},
	{PPOVERLAY_SUB_Background_Color1_reg, 0},
	{PPOVERLAY_SUB_Background_Color2_reg, 0},
	{PPOVERLAY_SUB_Border_Highlight_Border_Color1_reg, 0},
	{PPOVERLAY_SUB_Border_Highlight_Border_Color2_reg, 0},
	{PPOVERLAY_SUB_Border_Highlight_Border_Color3_reg, 0},
	{PPOVERLAY_SUB_Active_H_Start_End_reg, 0},
	{PPOVERLAY_SUB_Active_V_Start_End_reg, 0},

	//UZU
	{SCALEUP_DM_UZUMAIN_H_PARTIAL_DROP_reg, 0},
	{SCALEUP_DM_UZUMAIN_V_PARTIAL_DROP_reg, 0},
	//{SCALEUP_DM_UZUMAIN_Adapt12tap_reg, 0},
	{SCALEUP_DM_UZU_8tap_deringv_reg, 0},
	{SCALEUP_DM_UZU_V8CTRL_reg, 0},
	//{SCALEUP_DM_UZU_AdaptV8CTRL_reg, 0},
	{SCALEUP_DM_UZU_Scale_Hor_Factor_reg, 0},
	{SCALEUP_DM_UZU_Scale_Ver_Factor_reg, 0},
	{SCALEUP_DM_UZU_Hor_Delta1_reg, 0},
	{SCALEUP_DM_UZU_Hor_Delta2_reg, 0},
	{SCALEUP_DM_UZU_Hor_Segment1_reg, 0},
	{SCALEUP_DM_UZU_Hor_Segment2_reg, 0},
	{SCALEUP_DM_UZU_Hor_Segment3_reg, 0},
	{SCALEUP_DM_UZU_Initial_Value_reg, 0},
	{SCALEUP_DM_UZU_Input_Size_reg, 0},
	{SCALEUP_D_UZU_Globle_Ctrl_reg, 0},
	{SCALEUP_DM_UZU_Ctrl_reg, 0},

	{SCALEUP_DS_UZU_Scale_Ver_Factor_reg, 0},
	{SCALEUP_DS_UZU_Scale_Hor_Factor_reg, 0},
	{SCALEUP_DS_UZU_Initial_Value_reg, 0},
	{SCALEUP_DS_UZU_Input_Size_reg, 0},
	{SCALEUP_DS_UZU_Ctrl_reg, 0},
	//Data FRC:m cap
	{MDOMAIN_CAP_Main_SDNR_cxxto64_reg, 0},
	{MDOMAIN_CAP_DDR_In1WTLVL_Num_reg, 0},
	{MDOMAIN_CAP_DDR_In1WrLen_Rem_reg, 0},
	{MDOMAIN_CAP_DDR_In1Addr_reg, 0},
	{MDOMAIN_CAP_DDR_In1LineStep_reg, 0},
	{MDOMAIN_CAP_DDR_In1BlkStep_reg, 0},
	{MDOMAIN_CAP_DDR_In1_2ndAddr_reg, 0},
	{MDOMAIN_CAP_DDR_In1_3rdAddr_reg, 0},
	{MDOMAIN_CAP_DDR_In1LineNum_reg, 0},
	{MDOMAIN_CAP_DDR_In1Ctrl_reg, 0},
	{MDOMAIN_CAP_CapMain_BoundaryAddr1_reg, 0},
	{MDOMAIN_CAP_CapMain_BoundaryAddr2_reg, 0},
	{MDOMAIN_CAP_CapMain_SBS_VSD_CAP_CTRL_reg, 0},
	{MDOMAIN_CAP_CapMain_SBS_VSD_CAP_OFFSET_reg, 0},
	{MDOMAIN_CAP_Capture1_byte_swap_reg, 0},
	{MDOMAIN_CAP_Cap_In1_enable_reg, 0},

	{MDOMAIN_CAP_Sub_SDNR_cxxto64_reg, 0},
	{MDOMAIN_CAP_DDR_In2WTLVL_reg, 0},
	{MDOMAIN_CAP_DDR_In2WrLen_Rem_reg, 0},
	{MDOMAIN_CAP_DDR_In2Addr_reg, 0},
	{MDOMAIN_CAP_DDR_In2LineStep_reg, 0},
	{MDOMAIN_CAP_DDR_In2BlkStep_reg, 0},
	{MDOMAIN_CAP_DDR_In2_2ndAddr_reg, 0},
	{MDOMAIN_CAP_DDR_In2LineNum_reg, 0},
	{MDOMAIN_CAP_DDR_In2Ctrl_reg, 0},
	{MDOMAIN_CAP_CapSub_BoundaryAddr1_reg, 0},
	{MDOMAIN_CAP_CapSub_BoundaryAddr2_reg, 0},
	{MDOMAIN_CAP_Cap_In2_enable_reg, 0},
	//m disp
	{MDOMAIN_DISP_DDR_MainPreVStart_reg, 0},
	{MDOMAIN_DISP_DDR_MainNumWTL_reg, 0},
	{MDOMAIN_DISP_DDR_MainRdNumLenRem_reg, 0},
	{MDOMAIN_DISP_DDR_MainAddr_reg, 0},
	{MDOMAIN_DISP_DDR_MainAddrDropBits_reg, 0},
	{MDOMAIN_DISP_DDR_MainLineStep_reg, 0},
	{MDOMAIN_DISP_DDR_MainBlkStep_reg, 0},
	{MDOMAIN_DISP_DDR_MainLineNum_reg, 0},
	{MDOMAIN_DISP_DDR_MainCtrl_reg, 0},
	{MDOMAIN_DISP_DDR_Main2ndAddr_reg, 0},
	{MDOMAIN_DISP_DDR_Main3rdAddr_reg, 0},
	{MDOMAIN_DISP_DDR_Main_R_1ST_Addr_reg, 0},
	{MDOMAIN_DISP_DDR_Main_R_2ND_Addr_reg, 0},
	{MDOMAIN_DISP_DDR_Main_R_3RD_Addr_reg, 0},
	{MDOMAIN_DISP_Display_byte_channel_swap_reg, 0},
	{MDOMAIN_DISP_Disp_main_enable_reg, 0},

	{MDOMAIN_DISP_DDR_SubPreVStart_reg, 0},
	{MDOMAIN_DISP_DDR_SubPixNumWTL_reg, 0},
	{MDOMAIN_DISP_DDR_SubRdNumLenRem_reg, 0},
	{MDOMAIN_DISP_DDR_SubAddr_reg, 0},
	{MDOMAIN_DISP_DDR_SubAddrDropBits_reg, 0},
	{MDOMAIN_DISP_DDR_SubLineStep_reg, 0},
	{MDOMAIN_DISP_DDR_SubBlkStep_reg, 0},
	{MDOMAIN_DISP_DDR_SubLineNum_reg, 0},
	{MDOMAIN_DISP_DDR_SubCtrl_reg, 0},
	{MDOMAIN_DISP_DDR_Sub2ndAddr_reg, 0},
	{MDOMAIN_DISP_Disp_sub_enable_reg, 0},

};
*/

#ifdef CONFIG_PM
static int vsc_suspend (struct device *p_dev)
{
#if 0//No need vsc suspend
	int i,size;

	/*rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"func=%s line=%d \n", __FUNCTION__, __LINE__);*/

	size = (sizeof(VSC_PM_REGISTER_DATA)/4)/2;
	for(i = 0; i < size; i++)
	{
		VSC_PM_REGISTER_DATA[i][1] = rtd_inl(VSC_PM_REGISTER_DATA[i][0]);
		/*rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"func=%s line=%d VSC_PM_REGISTER_DATA[i][0]=%x\n", __FUNCTION__, __LINE__, VSC_PM_REGISTER_DATA[i][0]);*/
		/*rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"func=%s line=%d VSC_PM_REGISTER_DATA[i][1]=%x\n", __FUNCTION__, __LINE__, VSC_PM_REGISTER_DATA[i][1]);*/
	}
#endif
//Eric@20171127 Disable i2rnd & pst when DC off
#ifdef CONFIG_I2RND_ENABLE
	//Initial Main path & Sub path stage
	vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_DISABLE;
	vsc_i2rnd_sub_stage = I2RND_STAGE_DISABLE;
	vsc_i2rnd_dualvo_sub_stage = I2RND_DUALVO_STAGE_SUB_DISABLE;
	printk(KERN_EMERG"[%s]I2RND close\n", __FUNCTION__);
#endif
#ifdef ENABLE_IMD_PST_SMOOTHTOGGLE
	scaler_pst_suspend();
#endif
	return 0;
}

static int vsc_resume (struct device *p_dev)
{
#if 0//No need vsc resume
	int i, size;
	size = (sizeof(VSC_PM_REGISTER_DATA)/4)/2;
	for(i = 0; i < size; i++)
	{
		IoReg_Write32(VSC_PM_REGISTER_DATA[i][0],VSC_PM_REGISTER_DATA[i][1]);
		/*rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"func=%s line=%d VSC_PM_REGISTER_DATA[i][0]=%x\n", __FUNCTION__, __LINE__, VSC_PM_REGISTER_DATA[i][0]);*/
		/*rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"func=%s line=%d VSC_PM_REGISTER_DATA[i][1]=%x\n", __FUNCTION__, __LINE__, VSC_PM_REGISTER_DATA[i][1]);*/
	}
#endif
#ifdef CONFIG_I2RND_ENABLE
	//Eric@20171127I2rnd & pst init
	drvif_scaler_i2rnd_initial();
	drvif_scaler_pst_initial(_MAIN_MD);
	drvif_scaler_pst_initial(_SUB_MD);
#endif
#ifdef ENABLE_IMD_PST_SMOOTHTOGGLE
	scaler_pst_resume();
#endif
	reset_any_srcrect(&main_dispwin_for_only_xy);
	reset_any_srcrect(&main_dispwin_pre);
#ifdef CONFIG_DUAL_CHANNEL
	reset_any_srcrect(&sub_dispwin_pre);
#endif
	set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_LIVEZOOM, FALSE);
	set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_GameMode, FALSE);
#ifdef CONFIG_DUAL_CHANNEL
	set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_LIVEZOOM, FALSE);
	set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_GameMode, FALSE);
#endif
	//update game_mode_cmd_pre and st_game_mode_cmd_pre flag
	game_mode_cmd_pre = game_mode_cmd_check;
	st_game_mode_cmd_pre = smooth_toggle_game_mode_check_cnt;
	DbgSclrFlgTkr.adaptive_stream_pre = ADAPTIVE_STREAM_INIT;
	vpq_ld_running_flag = FALSE;
	DbgSclrFlgTkr.vpq_ld_first_boot = TRUE;
	sub_mode_type = KADP_VSC_SUB_MODE_PIP;//reset sub mode.
	//ECN item new mode. will add for MAC6-566
	enable_clock_mux_new_mode();

	return 0;
}

#ifdef CONFIG_ENABLE_HDMI_NN
static void vsc_chcek_nn_cap_status(void)
{
	int ret =0;

	if((Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE) &&
		(get_hdmi_4k_hfr_mode() != HDMI_4K120_2_1) && (DbgSclrFlgTkr.Sub_OutputVencMode != TRUE))
	{
		h3ddma_nn_set_sub_path_enable(ALL_CAP_ENABLE);
	}
	else if(get_hdmi_4k_hfr_mode() == HDMI_4K120_2_1)
	{
		h3ddma_nn_set_sub_path_enable(NN_ALL_CAP_DISABLE);
	}
	else
	{
		h3ddma_nn_set_sub_path_enable(H3DDMA_CAP_ENABLE_ONLY);
	}
#if defined(CONFIG_RTK_AI_DRV)
        if (0 != (ret = Scaler_SendRPC(SCALERIOC_NN_CAP_MODE_SWITCH_EABLE,h3ddma_nn_get_sub_path_enable(),1)))//
        {
                rtd_printk(KERN_ERR, TAG_NAME_VSC,"ret=%d, SCALERIOC_NN_CAP_MODE_SWITCH_EABLE RPC fail !!!\n", ret);
        }
#else
        if (0 != (ret = Scaler_SendRPC(SCALERIOC_NN_CAP_MODE_SWITCH_EABLE,NN_ALL_CAP_DISABLE,1)))//
        {
                rtd_printk(KERN_ERR, TAG_NAME_VSC,"ret=%d, SCALERIOC_NN_CAP_MODE_SWITCH_EABLE RPC fail !!!\n", ret);
        }
#endif
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"[NN]sub NN enable condition(%d.%d.%d) \n", Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE),
							get_hdmi_4k_hfr_mode(), DbgSclrFlgTkr.Sub_OutputVencMode);
}
#endif

#ifdef CONFIG_HIBERNATION
static int vsc_resume_std (struct device *p_dev)
{
#if 0//No need vsc resume
	int i, size;
	size = (sizeof(VSC_PM_REGISTER_DATA)/4)/2;
	for(i = 0; i < size; i++)
	{
		IoReg_Write32(VSC_PM_REGISTER_DATA[i][0],VSC_PM_REGISTER_DATA[i][1]);
		/*rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"func=%s line=%d VSC_PM_REGISTER_DATA[i][0]=%x\n", __FUNCTION__, __LINE__, VSC_PM_REGISTER_DATA[i][0]);*/
		/*rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"func=%s line=%d VSC_PM_REGISTER_DATA[i][1]=%x\n", __FUNCTION__, __LINE__, VSC_PM_REGISTER_DATA[i][1]);*/
	}
#endif
	ResetShareMem();//reset share memory to 0
	Set_send_panel_para_flag(TRUE);//Need to send panel parameter
	set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_LIVEZOOM, FALSE);
	set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_GameMode, FALSE);
#ifdef CONFIG_DUAL_CHANNEL
	set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_LIVEZOOM, FALSE);
	set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_GameMode, FALSE);
#endif
	game_mode_cmd_pre = game_mode_cmd_check;	//Update game_mode_cmd_pre to avoid fll task break.
	st_game_mode_cmd_pre = smooth_toggle_game_mode_check_cnt;
	DbgSclrFlgTkr.adaptive_stream_pre = ADAPTIVE_STREAM_INIT;
	vpq_ld_running_flag = FALSE;
	DbgSclrFlgTkr.vpq_ld_first_boot = TRUE;
	sub_mode_type = KADP_VSC_SUB_MODE_PIP;//reset sub mode.
	//ECN item new mode. will add for MAC6-566
	enable_clock_mux_new_mode();
	return 0;
}
#endif
#endif
int vsc_open(struct inode *inode, struct file *filp) {
	return 0;
}

ssize_t  vsc_read(struct file *filep, char *buffer, size_t count, loff_t *offp)
{
	return 0;

}

ssize_t vsc_write(struct file *filep, const char *buffer, size_t count, loff_t *offp)
{
	long ret = count;
	char cmd_buf[100] = {0};

	#ifndef CONFIG_ARM64
	pr_notice("%s(): count=%d, buf=0x%08lx\n", __func__, count, (long)buffer);
	#endif

	if (count >= 100)
		return -EFAULT;

	if (copy_from_user(cmd_buf, buffer, count)) {
		ret = -EFAULT;
	}

	if(count > 0) {
	   cmd_buf[count] = '\0';
	}

#ifdef ENABLE_SCALER_DUMP_FRAME_INFO
	if ((cmd_buf[0] == 't') && (cmd_buf[1] == 'e') && (cmd_buf[2] == 's') && (cmd_buf[3] == 't') && (cmd_buf[4] == 'm')
            && (cmd_buf[5] == 'o') && (cmd_buf[6] == 'd') && (cmd_buf[7] == 'e') && (cmd_buf[8] == '='))

    {
            // shell command as: echo testmode=1 testresult=/tmp/var/log/xxxxx > /dev/vodev
            if((cmd_buf[9] == '1') && (cmd_buf[11] == 't') && (cmd_buf[20] == 't') && (cmd_buf[21] == '=')){
			pr_notice("\n=== rtkscaler: enable dump CRC =============\n");
                   rtkscaler_dumpCRC_enable(&cmd_buf[22], (count-22)-1);
			pr_notice("\n=======================================\n");
            } // shell command as: echo testmode=1 /tmp/var/log/xxxxx > /dev/vodev
		else if ((cmd_buf[9] == '1') && (cmd_buf[11] == '/')) {
			pr_notice("\n=== rtkvo: enable dump CRC =============\n");
                   rtkscaler_dumpCRC_enable(&cmd_buf[11], (count-11)-1);
			pr_notice("\n=======================================\n");
            } // shell command as: echo testmode=0 > /dev/vodev
		else if (cmd_buf[9] == '0') {
			pr_notice("\n=== rtkvo: disable dump CRC =============\n");
			rtkscaler_dumpCRC_disable();
			pr_notice("\n=======================================\n");
		}
		else {
			pr_notice("%s\n", cmd_buf);
		}
	}
        else {
		pr_notice("%s\n", cmd_buf);
	}
#endif

	// shell command : echo test_videolatency=1 > /dev/vscdev
	if(strcmp(cmd_buf, "test_videolatency=1\n") == 0){
		set_latency_pattern_self_test(1);
		printk(KERN_EMERG "enable test_videolatency \n");
	}else if(strcmp(cmd_buf, "test_videolatency=0\n") == 0){
		set_latency_pattern_self_test(0);
		printk(KERN_EMERG "disable test_videolatency \n");
	}

	return ret;
}

int vsc_release(struct inode *inode, struct file *filep)
{
	return 0;
}

unsigned char vsc_set_vd_ptg(unsigned char bOnOff)
{
	//rtd_printk(KERN_EMERG, TAG_NAME_VSC, "function=%s, line=%d\n", __FUNCTION__, __LINE__);

	if(bOnOff == _ENABLE) {
		//Set VD PatternGen
		IoReg_SetBits(VDTOP_PATTERN_CONTROL_reg,_BIT0);
		IoReg_Write32(VDTOP_AD_SW_CTRL0_reg, 0x0);
		//Set VGIP PatternGen
		IoReg_SetBits(SUB_VGIP_VGIP_CHN2_CTRL_reg,_BIT27);
	}
	else {
		//Clear VD PatternGen
		IoReg_ClearBits(VDTOP_PATTERN_CONTROL_reg,_BIT0);
		IoReg_Write32(VDTOP_AD_SW_CTRL0_reg, 0xc9);
		//Clear VGIP PatternGen
		IoReg_ClearBits(SUB_VGIP_VGIP_CHN2_CTRL_reg,_BIT27);
	}
	return TRUE;
}

unsigned char vsc_get_uzu_crc(VIDEO_WID_T wid, unsigned int *CRC_Rsult)
{
	//rtd_printk(KERN_EMERG, TAG_NAME_VSC, "function=%s, line=%d\n", __FUNCTION__, __LINE__);
	unsigned int iResult = 0x00;
	unsigned int golden = 0x3d8e33a2;

	//Set M-Domain CRC Bits
	if(wid == VIDEO_WID_0) {
		IoReg_SetBits(SCALEUP_DM_MEM_CRC_CTRL_reg,_BIT1|_BIT0);
	}
	else if(wid == VIDEO_WID_1) {
		IoReg_SetBits(SCALEUP_DS_MEM_CRC_CTRL_reg,_BIT1|_BIT0);
	}
	msleep(1000);
	//Get M-Domain CRC Result
	if(wid == VIDEO_WID_0) {
		iResult = IoReg_Read32(SCALEUP_DM_MEM_CRC_Result_reg);
	}
	else if(wid == VIDEO_WID_1) {
		iResult = IoReg_Read32(SCALEUP_DS_MEM_CRC_Result_reg);
	}

	if(iResult == golden)
		*CRC_Rsult = TRUE;
	else
		*CRC_Rsult = FALSE;

	return TRUE;
}

unsigned char i3dma_uzd_flag=1;
void set_i3dma_uzd(unsigned char i3dma_uzd)
{
	i3dma_uzd_flag=i3dma_uzd;
}

unsigned char get_i3dma_uzd(void)
{
	return i3dma_uzd_flag;
}

unsigned char vsc_set_uzd_path(unsigned char i3dma_uzd)
{
	//rtd_printk(KERN_EMERG, TAG_NAME_VSC, "function=%s, line=%d\n", __FUNCTION__, __LINE__);

	set_i3dma_uzd(i3dma_uzd);

	return TRUE;
}

extern void scalerVIP_Set_BlackDetection_EN(unsigned char bEnable_main, unsigned char bEnable_sub);
long vsc_ioctl(struct file *file, unsigned int cmd,  unsigned long arg)
{
	extern KADP_VFE_AVD_TIMING_INFO_T *Get_AVD_LGETiminginfo(void);
	unsigned int before_time = 0;
	unsigned int after_time = 0;
	KADP_VFE_AVD_TIMING_INFO_T *ptLGETimingInfo = NULL;
	StructDisplayInfo * p_adc_dispinfo = NULL;
	//HDMI_TIMING_T hdmi_timing_info = {0, COLOR_RGB, HDMI_COLORIMETRY_NOSPECIFIED, 0 ,HDMI3D_2D_ONLY, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	vfe_hdmi_timing_info_t hdmi_timing_info;

	int retval = 0;
	//rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC: vsc_ioctl, %x;;agr:%x\n", cmd, *((unsigned int *)arg));

	if (_IOC_TYPE(cmd) != VSC_IOC_MAGIC || _IOC_NR(cmd) > VSC_IOC_MAXNR) return -ENOTTY ;

	switch (cmd)
	{
		case VSC_IOC_INITIALIZE:
		{
			before_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
			if(rtk_hal_vsc_initialize()==FALSE)
				retval =  -1;
			after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC intial time=%d ms", (after_time-before_time));
			break;
		}
		case VSC_IOC_UNINITIALIZE:
		{
			if(rtk_hal_vsc_uninitialize()==FALSE)
				return -1;
			break;
		}
		case VSC_IOC_OPEN:
		{
			VIDEO_WID_T widid;
			before_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
			if(copy_from_user((void *)&widid, (const void __user *)arg, sizeof(VIDEO_WID_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_OPEN copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_open(widid) == FALSE)
					retval =  -1;
				after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC open time=%d ms", (after_time-before_time));
			}
			break;
		}
		case VSC_IOC_CLOSE:
		{
			VIDEO_WID_T widid;
			if(copy_from_user((void *)&widid, (const void __user *)arg, sizeof(VIDEO_WID_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_CLOSE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_close(widid)==FALSE)
					retval =  -1;
			}
			break;

		}
		case VSC_IOC_CONNECT:
		{
			VSC_CONNECT_PARA_T connectPara;
			before_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
			if(copy_from_user((void *)&connectPara, (const void __user *)arg, sizeof(VSC_CONNECT_PARA_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_CONNECT copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				down(&Magnifier_Semaphore);/*added by qiangzhou, can not remove*/
#ifdef VDO_CONNECT_NEW_FLOW_ENABLE
                                if(connectPara.vsc_input.type == KADP_VSC_INPUTSRC_VDEC)
                                {
                                    if(connectPara.connectwid == KADP_VIDEO_WID_0)//current sub always live zoom case. Need to add livezoom condition later
                                    {
                                        if(!vdo0_connect)//means no call vdo connect
                                        {
                                            vdo_connect(connectPara.connectwid, connectPara.vsc_input.resourceIndex);
                                        }
                                    } else {
                                        if(Get_Live_zoom_mode() != LIVE_ZOOM_ON)
                                        {
                                            if(!vdo1_connect)//means no call vdo connect
                                            {
                                                vdo_connect(connectPara.connectwid, connectPara.vsc_input.resourceIndex);
                                            }
                                        }
                                    }
                                }
#endif
				if(rtk_hal_vsc_Connect(connectPara.connectwid, connectPara.vsc_input, connectPara.outputmode)==FALSE)
				{
					retval =  -1;
				}
				up(&Magnifier_Semaphore);
				after_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC connect time=%d ms",(after_time-before_time));

			}
			break;
		}
		case VSC_IOC_DISCONNECT:
		{
			VSC_CONNECT_PARA_T disconnectPara;
			if(copy_from_user((void *)&disconnectPara, (const void __user *)arg, sizeof(VSC_CONNECT_PARA_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_DISCONNECT copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				down(&Magnifier_Semaphore);/*added by qiangzhou, can not remove*/
				if(rtk_hal_vsc_Disconnect(disconnectPara.connectwid, disconnectPara.vsc_input, disconnectPara.outputmode) == FALSE)
				{
					retval =  -1;
				}
#ifdef VDO_CONNECT_NEW_FLOW_ENABLE
                                if(disconnectPara.vsc_input.type == KADP_VSC_INPUTSRC_VDEC)
                                {
                                    if(disconnectPara.connectwid == KADP_VIDEO_WID_0)//current sub always live zoom case. Need to add livezoom condition later
                                    {
                                        if(vdo0_connect)//means no call vdo connect
                                        {
                                            vdo_disconnect(disconnectPara.connectwid, disconnectPara.vsc_input.resourceIndex);
                                        }
                                    } else {
                                        if(Get_Live_zoom_mode() != LIVE_ZOOM_ON)
                                        {
                                            if(vdo1_connect)//means no call vdo connect
                                            {
                                                vdo_disconnect(disconnectPara.connectwid, disconnectPara.vsc_input.resourceIndex);
                                            }
                                        }
                                    }
                                }
#endif
				up(&Magnifier_Semaphore);
			}
			break;
		}
		case VSC_IOC_SET_WINBLANK:
		{
			VSC_WINBLANK_PARA_T winblankpara;
			if(copy_from_user((void *)&winblankpara, (const void __user *)arg, sizeof(VSC_WINBLANK_PARA_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_WINBLANK copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				rtd_printk(KERN_INFO, TAG_NAME_VSC, "VSC_IOC_SET_WINBLANK: winblankpara.winblankwid=%d,winblankpara.winblankbonoff=%d,winblankpara.winblankcolor=%d\n", winblankpara.winblankwid, winblankpara.winblankbonoff, winblankpara.winblankcolor);
				if(rtk_hal_vsc_SetWinBlank(winblankpara.winblankwid, winblankpara.winblankbonoff, winblankpara.winblankcolor) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_GET_ADAPTIVE_INPUTREGION:
		{
			VSC_GET_FRAME_REGION_T  pframeregion;
			VIDEO_DDI_RECT_T inregion = {0, 0, 0 , 0};
			if(copy_from_user((void *)&pframeregion, (const void __user *)arg, sizeof(VSC_GET_FRAME_REGION_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_GET_ADAPTIVE_INPUTREGION copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_GetInputRegion_ForAdaptive(pframeregion.setframewid, &inregion) == FALSE) {
					retval =  -1;
				}
				else
				{
					if (copy_to_user(to_user_ptr(pframeregion.pinregion) , &inregion, sizeof(VIDEO_DDI_RECT_T)) )
					{
	                			rtd_printk(KERN_ERR, TAG_NAME_VSC,  "[ERR] VSC_IOC_GET_INPUTREGION copy_to_user error \n");
						retval = EFAULT;
	            			}
				}

			}
			break;
		}
		case VSC_IOC_SET_ADAPTIVE_INPUTREGION:
		{
			VSC_SET_FRAME_REGION_T frameregion;
			if(copy_from_user((void *)&frameregion, (const void __user *)arg, sizeof(VSC_SET_FRAME_REGION_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_ADAPTIVE_INPUTREGION copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetInputRegion_ForAdaptive(frameregion.setframewid, frameregion.inregion) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_GET_INPUTREGION:
		{
			VSC_GET_FRAME_REGION_T  pframeregion;
			KADP_VIDEO_RECT_T inregion = {0, 0, 0 , 0};
			if(copy_from_user((void *)&pframeregion, (const void __user *)arg, sizeof(KADP_VIDEO_RECT_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_GET_INPUTREGION copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_GetInputRegion(pframeregion.setframewid, &inregion) == FALSE) {
					retval =  -1;
				}
				else
				{
					if (copy_to_user(to_user_ptr(pframeregion.pinregion) , &inregion, sizeof(KADP_VIDEO_RECT_T)) )
					{
	                	rtd_printk(KERN_ERR, TAG_NAME_VSC,  "[ERR] VSC_IOC_GET_INPUTREGION copy_to_user error \n");
						retval = EFAULT;
	            	}
				}

			}
			break;
		}
		case VSC_IOC_SET_INPUTREGION:
		{
			VSC_SET_FRAME_REGION_T frameregion;
			rtd_printk(KERN_INFO, TAG_NAME_VSC, "[VSC] VSC_IOC_SET_INPUTREGION calls\n");
			if(copy_from_user((void *)&frameregion, (const void __user *)arg, sizeof(VSC_SET_FRAME_REGION_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_INPUTREGION copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetInputRegion(frameregion.setframewid, frameregion.inregion) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_GET_OUTPUTREGION:
		{
			VSC_GET_FRAME_REGION_T  pframeregion;
			KADP_VIDEO_RECT_T outregion = {0, 0, 0 , 0};
			if(copy_from_user((void *)&pframeregion, (const void __user *)arg, sizeof(VSC_GET_FRAME_REGION_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_GET_OUTPUTREGION copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_GetOutputRegion(pframeregion.setframewid, &outregion) == FALSE) {
					retval =  -1;
				}
				else
				{
					if (copy_to_user(to_user_ptr(pframeregion.pinregion) , &outregion, sizeof(VIDEO_DDI_RECT_T)) )
					{
	                	rtd_printk(KERN_ERR, TAG_NAME_VSC,  "[ERR] VSC_IOC_GET_OUTPUTREGION copy_to_user error \n");
						retval = EFAULT;
	            	}
				}
			}
			break;
		}
		case VSC_IOC_SET_OUTPUTREGION:
		{
			VSC_SET_FRAME_REGION_T frameregion;
			rtd_printk(KERN_INFO, TAG_NAME_VSC, "[VSC] VSC_IOC_SET_INPUTREGION calls\n");
			if(copy_from_user((void *)&frameregion, (const void __user *)arg, sizeof(VSC_SET_FRAME_REGION_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_OUTPUTREGION copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				virtual_w = true_wide;
				virtual_h = true_high;

				if(rtk_hal_vsc_SetOutputRegion(frameregion.setframewid, frameregion.inregion, virtual_w, virtual_h)==FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_WINFREEZE:
		{
			VSC_FREEZE_ACTION_T freezeact;
			if(copy_from_user((void *)&freezeact, (const void __user *)arg, sizeof(VSC_FREEZE_ACTION_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_WINFREEZE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "freezeact.freezewid=%d,freezeact.freezeonoff=%d\n", freezeact.freezewid, freezeact.freezeonoff);
				if(rtk_hal_vsc_SetWinFreeze(freezeact.freezewid, freezeact.freezeonoff)==FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_FREEZE_VIDEOFRAMEBUFFER:
		{
			VSC_FREEZE_ACTION_T freezeact;
			if(copy_from_user((void *)&freezeact, (const void __user *)arg, sizeof(VSC_FREEZE_ACTION_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_FREEZE_VIDEOFRAMEBUFFER copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				Factory_SelfDiagnosis_Mode = TRUE;
				if(rtk_hal_vsc_FreezeVideoFrameBuffer(freezeact.freezewid, freezeact.freezeonoff)==FALSE)
					retval =  -1;
				Factory_SelfDiagnosis_Mode = FALSE;
			}
			break;
		}
		case VSC_IOC_READ_VIDEOFRAMEBUFFER:
		{
			VSC_READ_BUFFER_ACTION_T readaction;
			if(copy_from_user((void *)&readaction, (const void *)arg, sizeof(VSC_READ_BUFFER_ACTION_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_READ_VIDEOFRAMEBUFFER copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				VIDEO_RECT_T kernelInregion;
				KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *kernelPRead;
				KADP_VIDEO_DDI_COLOR_STANDARD_T Color_standard ;
				KADP_VIDEO_DDI_PIXEL_COLOR_FORMAT_T PixelColorFormat;
				Factory_SelfDiagnosis_Mode = TRUE;

				if(copy_from_user((void *)&kernelInregion, (const void *)to_user_ptr(readaction.pinregion), sizeof(VIDEO_DDI_RECT_T)))
				{
					retval = -EFAULT;
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_READ_VIDEOFRAMEBUFFER kernelInregion copy_from_user failed!!!!!!!!!!!!!!!\n");
				}

				kernelPRead = (KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc_specific(kernelInregion.w * kernelInregion.h * sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T), GFP_DCU1_FIRST);

				Color_standard = KADP_VIDEO_DDI_COLOR_STANDARD_YUV;
				PixelColorFormat = KADP_VIDEO_DDI_PIXEL_8BIT;
				if(rtk_hal_vsc_ReadVideoFrameBuffer(readaction.bufferwid, &kernelInregion, kernelPRead, &Color_standard, &PixelColorFormat) == FALSE)
					retval =  -1;

				if(copy_to_user(to_user_ptr(readaction.pcolor_standard), (void *)&Color_standard, sizeof(KADP_VIDEO_DDI_COLOR_STANDARD_T)))
				{
					retval = -EFAULT;
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_READ_VIDEOFRAMEBUFFER pcolor_standard copy_to_user failed!!!!!!!!!!!!!!!\n");
				}

				if(copy_to_user(to_user_ptr(readaction.ppixelcolorformat), (void *)&PixelColorFormat, sizeof(KADP_VIDEO_DDI_PIXEL_COLOR_FORMAT_T)))
				{
					retval = -EFAULT;
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_READ_VIDEOFRAMEBUFFER ppixelcolorformat copy_to_user failed!!!!!!!!!!!!!!!\n");
				}

				if(copy_to_user(to_user_ptr(readaction.pRead), (void *)kernelPRead, kernelInregion.w * kernelInregion.h * sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T)))
				{
					retval = -EFAULT;
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_READ_VIDEOFRAMEBUFFER pRead copy_to_user failed!!!!!!!!!!!!!!!\n");
				}
				dvr_free((void *)kernelPRead);
				Factory_SelfDiagnosis_Mode = FALSE;
			}
			break;
		}
		case VSC_IOC_WRITE_VIDEOFRAMEBUFFER:
		{
			VSC_WRITE_BUFFER_ACTION_T writeaction;
			if(copy_from_user((void *)&writeaction, (const void *)arg, sizeof(VSC_WRITE_BUFFER_ACTION_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_WRITE_VIDEOFRAMEBUFFER copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				KADP_VIDEO_RECT_T kernelInregion;
				KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *kernelPWrite;
				Factory_SelfDiagnosis_Mode = TRUE;
				if(copy_from_user((void *)&kernelInregion, (const void __user *)to_user_ptr(writeaction.pinregion), sizeof(VIDEO_DDI_RECT_T)))
				{
					retval = -EFAULT;
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_WRITE_VIDEOFRAMEBUFFER kernelInregion copy_from_user failed!!!!!!!!!!!!!!!\n");
				}

				kernelPWrite = (KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T *)dvr_malloc_specific(kernelInregion.w * kernelInregion.h * sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T), GFP_DCU1_FIRST);

				if(copy_from_user((void *)kernelPWrite, (const void __user *)to_user_ptr(writeaction.pWrite), kernelInregion.w * kernelInregion.h * sizeof(KADP_VIDEO_DDI_PIXEL_STANDARD_COLOR_T)))
				{
					retval = -EFAULT;
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_WRITE_VIDEOFRAMEBUFFER kernelPWrite copy_from_user failed!!!!!!!!!!!!!!!\n");
				}

				if(rtk_hal_vsc_WriteVideoFrameBuffer(writeaction.bufferwid, &kernelInregion, kernelPWrite) == FALSE)
					retval =  -1;

				dvr_free((void *)kernelPWrite);
				Factory_SelfDiagnosis_Mode = FALSE;
			}

			break;
		}
		case VSC_IOC_CAPTURE_VIDEOFRAME:
		{
			VSC_CAPTURE_FRAME_ACTION_T capaction;
			if(copy_from_user((void *)&capaction, (const void __user *)arg, sizeof(VSC_CAPTURE_FRAME_ACTION_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_CAPTURE_VIDEOFRAME copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
#if 0//now have VT,no use vsc capture,but these code must keep:qiang_zhou
				if(rtk_hal_vsc_CaptureVideoFrame(capaction.place, capaction.pcaptureinfo) == FALSE)
					retval =  -1;
#endif
			}
			break;
		}
		case VSC_IOC_SET_RGB444MODE:
		{
			bool boffon;
			if(copy_from_user((void *)&boffon, (const void __user *)arg, sizeof(bool)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_RGB444MODE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "VSC_IOC_SET_RGB444MODE=%x\n", boffon);
				if( (0 != HAL_VPQ_MEMC_SetRGBYUVMode(boffon)) || (rtk_hal_vsc_SetRGB444Mode(boffon)==FALSE) )
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_3DFORSCALER:
		{

			TRIDTV_SCALER_CTRL_T p3dcfginfo;
			if(copy_from_user((void *)&p3dcfginfo, (const void __user *)arg, sizeof(TRIDTV_SCALER_CTRL_T )))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_3DFORSCALER copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_Set3DForScaler(&p3dcfginfo) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_GET_3DAUTODETECTMODE:
		{
			VSC_3DAUTODET_ACTION_T autodet;
			KADP_VIDEO_DDI_3D_FORMAT_TYPE_T threedtype = KADP_VIDEO_DDI_3D_FORMAT_MAX;
			if(copy_from_user((void *)&autodet, (const void __user *)arg, sizeof(VSC_3DAUTODET_ACTION_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_GET_3DAUTODETECTMODE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_Get3DAutoDetectmode(autodet.wid, &threedtype) == FALSE)
				{
					retval =  -1;
				}
				if (copy_to_user(to_user_ptr(autodet.pvideo3dtype), (void *)&threedtype, sizeof(KADP_VIDEO_DDI_3D_FORMAT_TYPE_T)) )
				{
                	rtd_printk(KERN_ERR, TAG_NAME_VSC,  "[ERR] VSC_IOC_GET_3DAUTODETECTMODE copy_to_user error \n");
					retval = EFAULT;
            	}
			}
			break;
		}
		case VSC_IOC_SET_3DPATTERNMODE:
		{
			VSC_3DPATTERNMODE_ACTION_T patternaction;
			if(copy_from_user((void *)&patternaction, (const void __user *)arg, sizeof(VSC_3DPATTERNMODE_ACTION_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_3DPATTERNMODE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_Set3Dpatternmode(patternaction.wid, patternaction.video3dtype) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_VENCMODE:
		{
			VSC_SET_VENCMODE_ACTION_T venc;
			if(copy_from_user((void *)&venc, (const void __user *)arg, sizeof(VSC_SET_VENCMODE_ACTION_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_VENCMODE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetVENEMode(venc.framerate,venc.scantype)==FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_OPENV2G:
		{
			VIDEO_WID_T widid;
			if(copy_from_user((void *)&widid, (const void __user *)arg, sizeof(VIDEO_WID_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_OPENV2G copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_OpenV2G(widid)==FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_CLOSEV2G:
		{
			VIDEO_WID_T widid;
			if(copy_from_user((void *)&widid, (const void __user *)arg, sizeof(VIDEO_WID_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_CLOSEV2G copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_CloseV2G(widid)==FALSE)
					retval =  -1;
			}

			break;
		}
		case VSC_IOC_GET_V2GFRAMEBUFFER:
		{
			VSC_GET_V2GFRAMEBUFFER_T v2gbf;
			if(copy_from_user((void *)&v2gbf, (const void __user *)arg, sizeof(VSC_GET_V2GFRAMEBUFFER_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_GET_V2GFRAMEBUFFER copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
#if 0//now have VT,no use V2G,but these code must keep:qiang_zhou
				if(rtk_hal_vsc_GetV2GFramebuffer(v2gbf.wid,v2gbf.pCaptureInfo) == FALSE)
					retval =  -1;
#endif
			}
			break;
		}
		case VSC_IOC_SET_UDINPUT:
		{
			KADP_VIDEO_UD_MODE_T udmode;
			if(copy_from_user((void *)&udmode, (const void __user *)arg, sizeof(udmode)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_UDINPUT copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetUDInput(udmode)==FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_UDOUTPUT:
		{
			KADP_VIDEO_DDI_DIS_FMT_T disfmt;
			if(copy_from_user((void *)&disfmt, (const void __user *)arg, sizeof(KADP_VIDEO_DDI_DIS_FMT_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_UDOUTPUT copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetUDOutput(disfmt)==FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_GET_VIDEODELAYEDTIME:
		{
			VSC_GET_VIDEODELAYEDTIME_T vddelaytime;
			unsigned short delaytime = 0;
			if(copy_from_user((void *)&vddelaytime, (const void __user *)arg, sizeof(VSC_GET_VIDEODELAYEDTIME_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_GET_VIDEODELAYEDTIME copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_GetVideoDelayedTime(vddelaytime.wid, &delaytime) == FALSE)
				{
					retval =  -1;
				}
				else
				{
					if (copy_to_user(to_user_ptr(vddelaytime.pDelayedTime) , (void *)&delaytime, sizeof(unsigned short)) )
					{
	                	rtd_printk(KERN_ERR, TAG_NAME_VSC,  "[ERR] VSC_IOC_GET_VIDEODELAYEDTIME copy_to_user error \n");
						retval = EFAULT;
	            	}
				}
			}
			break;
		}
		case VSC_IOC_SET_TITLEMODE:
		{
			bool bonoff;
			if(copy_from_user((void *)&bonoff, (const void __user *)arg, sizeof(bool)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_TITLEMODE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetTileMode(bonoff)==FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_TILEMAXROWVAL:
		{
			VSC_SET_TILEMAXROWVAL_T titlerowval;
			if(copy_from_user((void *)&titlerowval, (const void __user *)arg, sizeof(VSC_SET_TILEMAXROWVAL_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_TILEMAXROWVAL copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetTileMaxRowVal(titlerowval.uMaxRow,titlerowval.uMaxCol)==FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_TILEID:
		{
			unsigned char titleid;
			if(copy_from_user((void *)&titleid, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_TILEID copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetTileID(titleid)==FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_ADAPTIVESTREAM:
		{
			bool bonoff;
			if(copy_from_user((void *)&bonoff, (const void __user *)arg, sizeof(bool)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_ADAPTIVESTREAM copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetAdaptiveStream(bonoff) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_ADAPTIVESTREAMEX:
		{
			VSC_ADAPTIVESTREAM_PARA_T adpstream;

			if(copy_from_user((void *)&adpstream, (const void __user *)arg, sizeof(VSC_ADAPTIVESTREAM_PARA_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_ADAPTIVESTREAMEX copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetAdaptiveStreamEX(adpstream.adaptivestreamwid,adpstream.adaptivestreambonoff) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_SOCOUTPUTFMT:
		{
			KADP_VIDEO_UD_MODE_T socoutputfmt;
			if(copy_from_user((void *)&socoutputfmt, (const void __user *)arg, sizeof(KADP_VIDEO_UD_MODE_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_SOCOUTPUTFMT copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetSOCOutputFMT(socoutputfmt) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_FRCTYPE:
		{
			unsigned char  frctype;
			if(copy_from_user((void *)&frctype, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_FRCTYPE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetFRCType(frctype) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_GET_FRCTYPE:
		{
			unsigned char frctypeget;
			if(copy_from_user((void *)&frctypeget, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_GET_FRCTYPE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_GetFRCType(frctypeget) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_GET_GETMVOPSTATUS:
		{
			VSC_GET_GETMVOPSTATUS_T mvopstatus;
			BOOLEAN MVOPEnable = FALSE;
			if(copy_from_user((void *)&mvopstatus, (const void __user *)arg, sizeof(VSC_GET_GETMVOPSTATUS_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_GET_GETMVOPSTATUS copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_GetMVOPStatus(mvopstatus.wid, &MVOPEnable) == FALSE)//Current not use
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_SET_VENCI3DDMA:
		{
			IDMA_DISPD_CAPTURE_INFO capInfo;
			if(copy_from_user((void *)&capInfo, (const void __user *)arg, sizeof(IDMA_DISPD_CAPTURE_INFO)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_VENCI3DDMA copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				drvif_I3DDMA_dispD_to_IdmaVI_idmaConfig(capInfo);
			}
			break;
		}
		case VSC_IOC_STOPVO:
		{
			/*
			down(get_vo_infosemaphore());
			set_vo_change_flag(TRUE);
   			memset(Get_VO_Dispinfo(), 0, sizeof(StructDisplayInfo));
			up(get_vo_infosemaphore());
			*/
			break;
		}
		case VSC_IOC_GETINPUTINFO:
		{
			VSC_GET_INPUT_INFO info;
			SCALER_INPUT_INFO input_info = {0, 0, 0, 0, 0, 0};
			if(copy_from_user((void *)&info, (const void __user *)arg, sizeof(VSC_GET_INPUT_INFO )))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_GETINPUTINFO copy_from_user failed!!!!!!!!!!!!!!!\n");
			}

			rtd_printk(KERN_ERR, TAG_NAME_VSC,  "[FRANK]iINFO1 VSC_IOC_GETINPUTINFO %x \n",info.wid);
			if (info.wid == KADP_VIDEO_WID_0) {
				state_update_disp3d_info();
				I3DDMA_Parse_HDMI3D_pattern();
				switch(Get_DisplayMode_Src(SLR_MAIN_DISPLAY))
				{
					case KADP_VSC_INPUTSRC_ADC:
						down(get_adc_detectsemaphore());
						p_adc_dispinfo = Get_ADC_Dispinfo();
						input_info.inputWid = p_adc_dispinfo->IPH_ACT_WID_PRE;
						input_info.inputLen = p_adc_dispinfo->IPV_ACT_LEN_PRE;
		           		input_info.capWid = p_adc_dispinfo->IPH_ACT_WID_PRE;
		           		input_info.capLen = p_adc_dispinfo->IPV_ACT_LEN_PRE;
						input_info.inputFramerate = p_adc_dispinfo->IVFreq;
						input_info.interlace = (p_adc_dispinfo->disp_status&_BIT8)>>8;
						up(get_adc_detectsemaphore());
						break;

					case KADP_VSC_INPUTSRC_HDMI:
/*
						newbase_hdmi_get_timing(newbase_hdmi_get_current_display_port(), &hdmi_timing_info);
						input_info.inputWid = hdmi_timing_info.h_act_len;
						input_info.inputLen = hdmi_timing_info.v_act_len;
		           		input_info.capWid = hdmi_timing_info.h_act_len;
		           		input_info.capLen = hdmi_timing_info.v_act_len;
						input_info.inputFramerate = hdmi_timing_info.v_freq;
*/
						hdmi_timing_info.port = drvif_Hdmi_GetCurrentPhysicalPort();
						vfe_hdmi_drv_get_port_timing_info(&hdmi_timing_info);
						input_info.inputWid = hdmi_timing_info.active.w;
						input_info.inputLen = hdmi_timing_info.active.h;
				           	input_info.capWid = hdmi_timing_info.active.w;
				           	input_info.capLen = hdmi_timing_info.active.h;
						input_info.inputFramerate = hdmi_timing_info.v_freq;
						input_info.interlace = !hdmi_timing_info.scan_type;
						break;

					case KADP_VSC_INPUTSRC_AVD:
						ptLGETimingInfo = Get_AVD_LGETiminginfo();
						input_info.inputWid = ptLGETimingInfo->active.w;
						input_info.inputLen = ptLGETimingInfo->active.h/2;
						input_info.capWid = ptLGETimingInfo->active.w;
						input_info.capLen = ptLGETimingInfo->active.h/2;
						input_info.inputFramerate = ptLGETimingInfo->vFreq;
						input_info.interlace = !ptLGETimingInfo->scanType;
						break;

					default:
						rtd_printk(KERN_ERR, TAG_NAME_VSC,  "[FRANK]iINFO2 VSC_IOC_GETINPUTINFO \n");
						input_info.inputWid = 0;
						input_info.inputLen = 0;
		           		input_info.capWid = 0;
		           		input_info.capLen = 0;
						input_info.inputFramerate = 0;
						input_info.interlace = 0;
						break;
				}
				if (copy_to_user(to_user_ptr(info.inputInfo), (void *)&input_info, sizeof(SCALER_INPUT_INFO)) )
				{
	                rtd_printk(KERN_ERR, TAG_NAME_VSC,  "[ERR] VSC_IOC_GETINPUTINFO main copy_to_user error \n");
					retval = EFAULT;
	            }
			} else {
				if(DbgSclrFlgTkr.Sub_OutputVencMode && (Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_AVD)) {
					ptLGETimingInfo = Get_AVD_LGETiminginfo();
					input_info.inputWid = ptLGETimingInfo->active.w;
					input_info.inputLen = ptLGETimingInfo->active.h/2;
					input_info.capWid = sub_dispwin.src_wid;
					input_info.capLen = sub_dispwin.src_height;
					input_info.inputFramerate = ptLGETimingInfo->vFreq;
					input_info.interlace = !ptLGETimingInfo->scanType;
				} else {
					rtd_printk(KERN_ERR, TAG_NAME_VSC,  "[FRANK]iINFO3 VSC_IOC_GETINPUTINFO %x, %x\n",DbgSclrFlgTkr.Sub_OutputVencMode, (Get_DisplayMode_Src(SLR_SUB_DISPLAY)));
					input_info.inputWid = 0;
					input_info.inputLen = 0;
					input_info.capWid = 0;
					input_info.capLen = 0;
					input_info.inputFramerate = 0;
					input_info.interlace = 0;
				}
				if (copy_to_user(to_user_ptr(info.inputInfo), (void *)&input_info, sizeof(SCALER_INPUT_INFO)) )
				{
	                rtd_printk(KERN_ERR, TAG_NAME_VSC,  "[ERR] VSC_IOC_GETINPUTINFO sub copy_to_user error \n");
					retval = EFAULT;
	            }
			}
			break;
		}
		case VSC_IOC_SHOWOSDSAMPLE:
		{
			// Sync from Demo version.
#if 0
			unsigned char bonoff;
			if(copy_from_user((void *)&bonoff, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SHOWOSDSAMPLE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_showosdsample(bonoff) == FALSE)
					retval =  -1;
			}
#endif
			retval =  -1;
			break;
		}
		case VSC_IOC_GETPANELSIZE:
		{
			VSC_PANEL_SIZE_T  panel_size;
			panel_size.display_wid = _DISP_WID;
			panel_size.display_len = _DISP_LEN;
			if(copy_to_user((void __user *)arg, (void *)&panel_size, sizeof(VSC_PANEL_SIZE_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_GETPANELSIZE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			break;
		}
		case VSC_IOC_SET_DOLBYVISION_IDMA_ENABLE:
		{

			break;
		}
		case VSC_IOC_SETZORDER:
		{
			VSC_SET_ZORDER_T zorderNO[2];
			if(copy_from_user((void *)zorderNO, (const void __user *)arg, 2*sizeof(VSC_SET_ZORDER_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_GET_OUTPUTREGION copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetZorder(zorderNO[0],zorderNO[1]) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_MAKECOLOREDVIDEO:
		{
			KADP_VSC_VIDEO_COLOR_TYPE_T colorType;

			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Scaler vsc disp: Get VSC_IOC_MAKECOLOREDVIDEO!!!!!!!\n");

			if(copy_from_user((void *) &colorType, (const void __user *)arg, sizeof(KADP_VSC_VIDEO_COLOR_TYPE_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_MAKECOLOREDVIDEO copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_makeColoredVideo(colorType) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_DM_OPEN:
		{
			if(rtk_hal_vsc_dm_open(SLR_MAIN_DISPLAY)==FALSE)
				return -1;
			break;
		}
		case VSC_IOC_DM_CLOSE:
		{
			if(rtk_hal_vsc_dm_close(SLR_MAIN_DISPLAY)==FALSE)
				return -1;
			break;
		}
		case VSC_IOC_DM_CONNECT:
		{
			rtd_printk(KERN_INFO, TAG_NAME_VSC, "[VSC] VSC_IOC_DM_CONNECT calls\n");
			if(rtk_hal_vsc_dm_connect(SLR_MAIN_DISPLAY, KADP_VSC_HDR_AUTO) == FALSE)
				return -1;
			break;
		}
		case VSC_IOC_DM_DISCONNECT:
		{
			rtd_printk(KERN_INFO, TAG_NAME_VSC, "[VSC] VSC_IOC_DM_DISCONNECT calls\n");
			if(rtk_hal_vsc_dm_disconnect(SLR_MAIN_DISPLAY)==FALSE)
				return -1;
			break;
		}
		case VSC_IOC_ISDOLBYHDR:
		{

			unsigned char isdolbyHdr = 0;
#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
			if(Scaler_HDR_DolbyVision_Hdmi_Get_Detect_Result())
				isdolbyHdr = 1;
			else
				isdolbyHdr = 0;
#endif

			if(copy_to_user((void __user *)arg, (void *)&isdolbyHdr, sizeof(unsigned char)))
        		{
           			retval = -EFAULT;
            			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler hdcp2 ioctl code=VSC_IOC_ISDOBLYHDR copy_to_user failed!!!!!!!!!!!!!!!\n");
            			break;
        		}

			break;
		}

		case VSC_IOC_UPDATE_ADAPTIVE_STREAMING_INFO:
		{//no use
			break;
		}

		case VSC_IOC_NOTICE_GST_VO_UPDATE:
		{
			VSC_NOTICE_GST_VO_UPDATE_INFO temp_vsc_notice_gst_vo_update;
			unsigned char update_flag = TRUE;
			if(copy_from_user((void *)&temp_vsc_notice_gst_vo_update, (const void __user *)arg, sizeof(VSC_NOTICE_GST_VO_UPDATE_INFO)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_ERR, TAG_NAME_VSC, "scaler vsc ioctl VSC_IOC_NOTICE_GST_VO_UPDATE copy_from_user failed!!!!!!!!!!!!!!!\n");
				return retval;
			}
			update_flag = TRUE;
			if(temp_vsc_notice_gst_vo_update.update_flag)
			{
				if (copy_to_user(to_user_ptr(temp_vsc_notice_gst_vo_update.update_flag), (void *)&update_flag, sizeof(unsigned char)) )
				{
	                rtd_printk(KERN_ERR, TAG_NAME_VSC,  "[ERR] VSC_IOC_NOTICE_GST_VO_UPDATE copy_to_user error 1 \n");
					retval = EFAULT;
	            }
			}


			break;
		}

		case VSC_IOC_APP_CONTRO_FORCEBG:
		{//no used
			break;
		}

		case VSC_IOC_HDR_OPEN:
		{
			unsigned char wid;
			if(copy_from_user((void *)&wid, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_ERR, TAG_NAME_VSC, "scaler vsc ioctl VSC_IOC_HDR_OPEN copy_from_user failed!!!!!!!!!!!!!!!\n");
				return retval;
			}
			if(wid == KADP_VIDEO_WID_0)
			{
				if(rtk_hal_vsc_dm_open(SLR_MAIN_DISPLAY) == FALSE)
					return -1;
			}
			else
			{
				if(rtk_hal_vsc_dm_open(SLR_SUB_DISPLAY) == FALSE)
					return -1;
			}
			break;

		}
		case VSC_IOC_HDR_CLOSE:
		{
			unsigned char wid;
			if(copy_from_user((void *)&wid, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_ERR, TAG_NAME_VSC, "scaler vsc ioctl VSC_IOC_HDR_CLOSE copy_from_user failed!!!!!!!!!!!!!!!\n");
				return retval;
			}

			if(wid == KADP_VIDEO_WID_0)
			{
				if(rtk_hal_vsc_dm_close(SLR_MAIN_DISPLAY) == FALSE)
					return -1;
			}
			else
			{
				if(rtk_hal_vsc_dm_close(SLR_SUB_DISPLAY) == FALSE)
					return -1;
			}
			break;
		}
		case VSC_IOC_HDR_CONNECT:
		{
			KADP_VSC_HDR_INFO_T VSC_HDR_INFO;
			rtd_printk(KERN_INFO, TAG_NAME_VSC, "[VSC] VSC_IOC_HDR_CONNECT calls\n");
			if(copy_from_user((void *)&VSC_HDR_INFO, (const void __user *)arg, sizeof(KADP_VSC_HDR_INFO_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_HDR_CONNECT copy_from_user failed!!!!!!!!!!!!!!!\n");
				return retval;
			}

			if(VSC_HDR_INFO.winid == KADP_VIDEO_WID_0)
			{
				if(rtk_hal_vsc_dm_connect(SLR_MAIN_DISPLAY, VSC_HDR_INFO.hdrtype) == FALSE)
					return -1;
			}
			else
			{
				if(rtk_hal_vsc_dm_connect(SLR_SUB_DISPLAY, VSC_HDR_INFO.hdrtype) == FALSE)
					return -1;
			}

			break;
		}
		case VSC_IOC_HDR_DISCONNECT:
		{
			unsigned char wid;
			rtd_printk(KERN_INFO, TAG_NAME_VSC, "[VSC] VSC_IOC_HDR_DISCONNECT calls\n");
			if(copy_from_user((void *)&wid, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_ERR, TAG_NAME_VSC, "scaler vsc ioctl VSC_IOC_HDR_DISCONNECT copy_from_user failed!!!!!!!!!!!!!!!\n");
				return retval;
			}


			if(wid == KADP_VIDEO_WID_0)
			{
				if(rtk_hal_vsc_dm_disconnect(SLR_MAIN_DISPLAY) == FALSE)
					return -1;
			}
			else
			{
				if(rtk_hal_vsc_dm_disconnect(SLR_SUB_DISPLAY) == FALSE)
					return -1;
			}
			break;
		}

		case VSC_IOC_SET_SubWinShape:
		{
			//Evance->VSC_SUB_SHAPE_INFO_T
			KADP_VSC_SUB_SHAPE_INFO_T shape_info;
	//		VIDEO_RECT_T  shape_region;
	//		int shape_type;
			if(copy_from_user((void *)&shape_info, (const void __user *)arg, sizeof(KADP_VSC_SUB_SHAPE_INFO_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=KADP_VSC_SUB_SHAPE_INFO_T copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				{
					//virtual_x =shape_info.rect.x;
					//virtual_y =shape_info.rect.y;
					true_wide =shape_info.rect.w;
					true_high=shape_info.rect.h;
				if (shape_info.shapeinfo == 0)
					sub_shape_type = VSC_MGF_TYPE_CIRCLE;
				else if (shape_info.shapeinfo == 1)
					sub_shape_type = VSC_MGF_TYPE_RECTANGLE;
				else
					sub_shape_type = VSC_MGF_TYPE_RECTANGLE;
//				subWin_LGowner =1;
#if 0
				printk("\n ***************************virtual_x = %d", virtual_x);
				printk("\n ***************************virtual_y = %d", virtual_y);
				printk("\n ***************************virtual_w = %d", virtual_w);
				printk("\n ***************************virtual_h = %d", virtual_h);
				printk("\n ***************************sub_shape_type = %d", sub_shape_type);
#endif
			}
			}

			break;
		}

		case  VSC_IOC_SET_SetSubWinModeEx:
          	{
                       VSC_SET_SUB_WINDOW_MODE_TYPE vsc_set_sub_win_mode;
  //                     int mode_type = 0;
                       //if(copy_from_user((void *)&mode_type, (const void __user *)arg, sizeof(VSC_SUB_MODE_T)))
                       if(copy_from_user((void *)&vsc_set_sub_win_mode, (const void __user *)arg, sizeof(VSC_SET_SUB_WINDOW_MODE_TYPE)))
                       {
                               retval = -EFAULT;
                               rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_SetSubWinMode copy_from_user failed!!!!!!!!!!!!!!!\n");
                       }
                       else
                       {
                               /*for testing
                               vsc_set_sub_win_mode.mode = VSC_SUB_MODE_PIP;
                               vsc_set_sub_win_mode.connectType = VSC_SUB_CONNECT_TYPE_MIRROR;
                               vsc_set_sub_win_mode.memoryUse = VSC_SUB_MEMORY_USE_MULTI;

                               printk(KERN_EMERG"[%s][crixus]@@VSC_IOC_SET_SetSubWinMode,mode = %d, connectType = %d, memoryUse = %d\n", __FUNCTION__, vsc_set_sub_win_mode.mode, vsc_set_sub_win_mode.connectType, vsc_set_sub_win_mode.memoryUse);
                               */
                               sub_mode_type = vsc_set_sub_win_mode.mode;//get sub mode
                               sub_livezoom_type = vsc_set_sub_win_mode.connectType;

                               //connect type is mirror => livezoom or magnifier
                               if(vsc_set_sub_win_mode.connectType == KADP_VSC_SUB_CONNECT_TYPE_MIRROR){
									Set_Live_zoom_mode(LIVE_ZOOM_ON);
#if 1/*disable livezoom framsync flow*/
									DbgSclrFlgTkr.DataFramesynclivezoom = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC);
#else
									DataFramesynclivezoom = FALSE;
#endif

									//disable ST game mode timeout checking task when enter livezoom for quickly switching case @Crixus 20170726
									down(&GameMode_Check_Semaphore);
									if(drv_memory_get_game_mode() == _ENABLE){
										smooth_toggle_game_mode_timeout_trigger_flag = _DISABLE;
										//smooth_toggle_game_mode_check_cnt = 0;
										rtd_printk(KERN_NOTICE, TAG_NAME_NEW_GAME_MODE, "Disable ST game mode timeout tsk!!(before sub scaler)\n");
									}
									up(&GameMode_Check_Semaphore);
#if 1
									if(vsc_set_sub_win_mode.memoryUse == KADP_VSC_SUB_MEMORY_USE_MULTI){
										Set_Magnifier_LiveZoom_Mode(KADP_VSC_SUB_PURPOSE_LIVE_ZOOM);
									}
									else if(vsc_set_sub_win_mode.memoryUse == KADP_VSC_SUB_MEMORY_USE_SINGLE){
										Set_Magnifier_LiveZoom_Mode(KADP_VSC_SUB_PURPOSE_MAGNIFIER);
									}
									else{
										Set_Magnifier_LiveZoom_Mode(KADP_VSC_SUB_PURPOSE_NONE);
									}
#endif
                               }
#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
                               //connect type is non-mirror => multi-view or overlay miracast
                               else if(vsc_set_sub_win_mode.connectType == KADP_VSC_SUB_CONNECT_TYPE_NON_MIRROR){
                                       if((sub_mode_type == VSC_SUB_MODE_EX_PBP)){
                                               //i2rnd_test_done = 1;
                                               rtk_hal_vsc_i2rnd_enable(_ENABLE);
                                               printk(KERN_EMERG"[%s][crixus]I2RND initial done\n", __FUNCTION__);
                                       }else if((sub_mode_type == VSC_SUB_MODE_EX_PIP)){
                                               //i2rnd_test_done = 0;
                                               rtk_hal_vsc_i2rnd_enable(_DISABLE);
                                               printk(KERN_EMERG"[%s][crixus]I2RND Uninitial done\n", __FUNCTION__);
                                       }
                               }
#endif
#endif

                               else if((vsc_set_sub_win_mode.mode == VSC_SUB_MODE_EX_NONE) && (vsc_set_sub_win_mode.connectType == KADP_VSC_SUB_CONNECT_TYPE_NONE)
                                               && (vsc_set_sub_win_mode.memoryUse == KADP_VSC_SUB_MEMORY_USE_NONE)){
                                       //exit PIP or PBP app.
#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
                                       if((Scaler_I2rnd_get_enable() == _ENABLE)){
                                               //disable i2run mode
                                               //i2rnd_test_done = 0;
                                               i2rnd_send_table_idx(I2RND_TABLE_OFF);
                                               rtk_hal_vsc_i2rnd_enable(_DISABLE);
                                               //frank@I2run disable main VENC flag
                                               VencModeInputInfo = (KADP_VSC_INPUT_SRC_INFO_T){VSC_INPUTSRC_MAXN, 0, 0};
                                               DbgSclrFlgTkr.OutputVencMode = FALSE;
                                               vsc_i2rnd_sub_stage = I2RND_STAGE_DISABLE;
                                               vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_DISABLE;
                                               //apvr_request_run_main_path();
                                               printk(KERN_EMERG"[%s][frank]I2RND close\n", __FUNCTION__);
                                       }
#endif
#endif
                               }
                       }
                       break;
               }

		case  VSC_IOC_SET_SetSubWinMode:
		{
			int mode_type = 0;


			if(copy_from_user((void *)&mode_type, (const void __user *)arg, sizeof(KADP_VSC_SUB_MODE_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_SetSubWinMode copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				printk(KERN_EMERG"[%s][crixus]@@VSC_IOC_SET_SetSubWinMode, mode_type = %d\n", __FUNCTION__, (unsigned int)mode_type);
				sub_mode_type = mode_type;//get sub mode
#if 0//def CONFIG_I2RND_ENABLE
				if((i2rnd_test_done == 0) && (sub_mode_type == VSC_SUB_MODE_PBP)){
					i2rnd_test_done = 1;
					rtk_hal_vsc_i2rnd_enable(_ENABLE);
					printk(KERN_EMERG"[%s][crixus]I2RND initial done\n", __FUNCTION__);
				}else if((i2rnd_test_done == 1) && (sub_mode_type == VSC_SUB_MODE_PIP)){
					i2rnd_test_done = 0;
					rtk_hal_vsc_i2rnd_enable(_DISABLE);
					printk(KERN_EMERG"[%s][crixus]I2RND Uninitial done\n", __FUNCTION__);
				}
#endif
			}
			break;
		}

		case  VSC_IOC_SET_SetSubWinPurpose:
		{
			KADP_VSC_SUB_PURPOSE_T purpose_type;


			if(copy_from_user((void *)&purpose_type, (const void __user *)arg, sizeof(KADP_VSC_SUB_PURPOSE_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_SetSubWinPurpose copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				//Set_Magnifier_LiveZoom_Mode(purpose_type);
				printk(KERN_EMERG"[qiangzhou]@@VSC_IOC_SET_SetSubWinPurpose, purpose_type = %d\n", (unsigned int)purpose_type);

			}
			break;
		}

		case  VSC_IOC_SET_SetDelayBuffer:
		{
			VSC_SET_DELAY_BUFFER_TYPE delay_buffer_type;


			if(copy_from_user((void *)&delay_buffer_type, (const void __user *)arg, sizeof(VSC_SET_DELAY_BUFFER_TYPE)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_SET_DELAY_BUFFER_TYPE copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				rtk_hal_vsc_SetDelayBuffer(delay_buffer_type.window, delay_buffer_type.buffer);
				printk("VSC_SET_DELAY_BUFFER_TYPE, delay_buffer_type.window = %d\n", (unsigned int)delay_buffer_type.window);
				printk("VSC_SET_DELAY_BUFFER_TYPE, delay_buffer_type.buffer = %d\n", (unsigned int)delay_buffer_type.buffer);

			}
			break;
		}

		case VSC_IOC_GET_BLACDETECTION_INFO_T:
		{
			//static unsigned int cnt;
			//printk("Enter VSC_IOC_GET_BLACDETECTION_INFO_T\n");
			VSC_GET_BLACDETECTION_INFO_T BLACKDETECTION_INFO;
			VIP_BlackDetectionInfo vip_info;

			BLACKDETECTION_INFO.ready_flag = fwif_color_get_black_detection_info_tv006(&vip_info);

			memcpy(&(BLACKDETECTION_INFO.window.original), &(vip_info.OriRegion), sizeof(VIDEO_RECT_T));
			memcpy(&(BLACKDETECTION_INFO.window.active), &(vip_info.ActRegion), sizeof(VIDEO_RECT_T));
			BLACKDETECTION_INFO.connectwid = BLK_WID;//Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL);

			if (copy_to_user((void __user *)arg, (void *)&BLACKDETECTION_INFO, sizeof(VSC_GET_BLACDETECTION_INFO_T))) {
				retval = -EFAULT;
				pr_err( "kernel VSC_IOC_GET_BLACDETECTION_INFO_T fail\n");
			}
			#if 0
			if (cnt % 600 == 0)
				printk("BLACKDETECTION_INFO.window = %d, %d %d %d, %d %d %d %d\n", BLACKDETECTION_INFO.window.original.x,BLACKDETECTION_INFO.window.original.y,BLACKDETECTION_INFO.window.original.w,BLACKDETECTION_INFO.window.original.h,BLACKDETECTION_INFO.window.active.x,BLACKDETECTION_INFO.window.active.y,BLACKDETECTION_INFO.window.active.w,BLACKDETECTION_INFO.window.active.h);
			cnt ++;
			#endif
			break;

		}
		case VSC_IOC_SET_BLACDETECTION_EN:
		{
			VSC_SET_BLACDETECTION_INFO_T BLK_Info;
			unsigned char bEnable_main = 0;
			unsigned char bEnable_sub = 0;
			if(copy_from_user((void *)&BLK_Info, (const void __user *)arg, sizeof(VSC_SET_BLACDETECTION_INFO_T))) {
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_BLACDETECTION_EN copy_from_user failed!!!!!!!!!!!!!!!\n");
			} else {
				printk("1. wId=%d, EN=%d, bEnable_main=%d, bEnable_sub=%d",BLK_Info.connectwid,BLK_Info.enable,bEnable_main,bEnable_sub);
				if (BLK_Info.enable == TRUE) {
					if (BLK_Info.connectwid == VIDEO_WID_0) {
						bEnable_main = 1;
						BLK_WID = VIDEO_WID_0;
					}
					else if (BLK_Info.connectwid == VIDEO_WID_1) {
						BLK_WID = VIDEO_WID_1;
						bEnable_sub = 1;
					}
					else
						retval = -EFAULT;
				} else {

					if (BLK_Info.connectwid == VIDEO_WID_0)
						bEnable_main = 0;
					else if (BLK_Info.connectwid == VIDEO_WID_1)
						bEnable_sub = 0;
					else
						retval = -EFAULT;

				}
				printk("2. wId=%d, EN=%d, bEnable_main=%d, bEnable_sub=%d",BLK_Info.connectwid,BLK_Info.enable,bEnable_main,bEnable_sub);
				scalerVIP_Set_BlackDetection_EN(bEnable_main, bEnable_sub);

			}
			break;

		}
		case VSC_IOC_RotateVideo:
		{
			KADP_VSC_ROTATE_T rotate_type;
			if(copy_from_user((void *)&rotate_type, (const void __user *)arg, sizeof(KADP_VSC_ROTATE_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_RotateVideo copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{

#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
				down(&SetMainOutPutRegion_Semaphore);
				rotate_mode_pre = rotate_mode;
				rotate_mode = rotate_type;
				up(&SetMainOutPutRegion_Semaphore);
#endif
			}
			break;
		}

		case VSC_IOC_SetVideoPattern:
        	{
         		VSC_VIDEO_PATTERN_LOCATION_TYPE vsc_pattern_type;
         		if(copy_from_user((void *)&vsc_pattern_type, (const void __user *)arg, sizeof(VSC_VIDEO_PATTERN_LOCATION_TYPE))) {
                 		retval = -EFAULT;
                 		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SetVideoPattern copy_from_user failed!!!!!!!!!!!!!!!\n");
         		} else {
                 		rtk_hal_vsc_SetPattern(vsc_pattern_type.on_off, vsc_pattern_type.window, vsc_pattern_type.pattern_location);
         		}
         		break;
		}

		case VSC_IOC_GetLimitedWindow:
		{
			VSC_GET_LIMIT_WINDOW_T info;
			KADP_VSC_SCALER_RATIO_T input_info = {0, 0, 0, 0};

			if(copy_from_user((void *)&info, (const void __user *)arg, sizeof(VSC_GET_LIMIT_WINDOW_T )))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_GetLimitedWindow copy_from_user failed!!!!!!!!!!!!!!!\n");
			}

			input_info.h_scaledown_ratio = 32;
			input_info.v_scaledown_ratio = 32;
			input_info.h_scaleup_ratio = 256;
			input_info.v_scaleup_ratio = 256;

			if (copy_to_user(to_user_ptr(info.limit_window), (void *)&input_info, sizeof(KADP_VSC_SCALER_RATIO_T)) )
			{
	                	rtd_printk(KERN_ERR, TAG_NAME_VSC,  "[ERR] VSC_IOC_GetLimitedWindow main copy_to_user error \n");
				retval = EFAULT;
	            }
			break;
		}

		case VSC_IOC_SET_INPUTREGION_EX:
		{
			VSC_SET_FRAME_REGION_EX_T frameregion;
			if(copy_from_user((void *)&frameregion, (const void __user *)arg, sizeof(VSC_SET_FRAME_REGION_EX_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_INPUTREGION_EX copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetInputRegionEx(frameregion.setframewid, frameregion.inregion, frameregion.originalInput) == FALSE)
					retval =  -1;
			}
			break;
		}

		case VSC_IOC_SET_UZD_PATH:
		{
			unsigned char i3dma_uzd = 0;
			if(copy_from_user((void *)&i3dma_uzd, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_EMERG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_UZD_PATH copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else{
				if(vsc_set_uzd_path(i3dma_uzd) == FALSE)
					retval =  -1;
			}
			break;
		}

		case VSC_IOC_WAIT_MUTEOFF_QUEUE:
		{
			unsigned char winid = 0;
			wait_event_freezable(MUTEOFF_CB_WAIT_QUEUE, sub_muteoff_cb_trigger || main_muteoff_cb_trigger);
			if(main_muteoff_cb_trigger)
			{
				down(&muteoff_cb_sem);
				main_muteoff_cb_trigger = FALSE;
				up(&muteoff_cb_sem);
				winid |= WIN_MAIN_ONLY;//main path mute off
			}
			if(sub_muteoff_cb_trigger)
			{
				down(&muteoff_cb_sem);
				sub_muteoff_cb_trigger = FALSE;
				up(&muteoff_cb_sem);
				winid |= WIN_SUB_ONLY;//sub path mute off
			}
			if(copy_to_user((void __user *)arg, (void *)&winid, sizeof(unsigned char)))
			{
				rtd_printk(KERN_ERR, TAG_NAME_VSC,  "[ERR] VSC_IOC_WAIT_MUTEOFF_QUEUE copy_to_user error \n");
				retval = EFAULT;
			}
			break;
		}
		case VSC_IOC_VDO_CONNECT:
		{
#ifdef VDO_CONNECT_NEW_FLOW_ENABLE
            VSC_CONNECT_PARA_T connectPara;
            rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\033[10;32m [%s:%d]:VSC_IOC_VDO_CONNECT \033[0m \n", __FUNCTION__, __LINE__);
            if(copy_from_user((void *)&connectPara, (const void __user *)arg, sizeof(VSC_CONNECT_PARA_T)))
            {
                retval = -EFAULT;
                rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_VDO_CONNECT copy_from_user failed!!!!!!!!!!!!!!!\n");
            }
            else
            {
                down(&Magnifier_Semaphore);/*added by qiangzhou, can not remove*/

				if(!vdo_connect((unsigned char)connectPara.connectwid, (unsigned char)connectPara.vsc_input.resourceIndex))
				{
					retval =  -1;
				}
                up(&Magnifier_Semaphore);

            }
#endif
            break;
		}
		case VSC_IOC_VDO_DISCONNECT:
		{
#ifdef VDO_CONNECT_NEW_FLOW_ENABLE
                VSC_CONNECT_PARA_T disconnectPara;
                rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\033[10;32m [%s:%d]:VSC_IOC_VDO_DISCONNECT \033[0m \n", __FUNCTION__, __LINE__);
                if(copy_from_user((void *)&disconnectPara, (const void __user *)arg, sizeof(VSC_CONNECT_PARA_T)))
                {
                    retval = -EFAULT;
                    rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_VDO_DISCONNECT copy_from_user failed!!!!!!!!!!!!!!!\n");
                }
                else
                {
                    down(&Magnifier_Semaphore);/*added by qiangzhou, can not remove*/
					vdo_disconnect(disconnectPara.connectwid, disconnectPara.vsc_input.resourceIndex);
                    up(&Magnifier_Semaphore);
                }
#endif
                break;
		}

		case VSC_IOC_SetVideoLatencyPattern:
		{
			VSC_VIDEO_LATENCY_PATTERN_T set_video_latency_pattern;

			if(copy_from_user((void *)&set_video_latency_pattern, (const void __user *)arg, sizeof(VSC_VIDEO_LATENCY_PATTERN_T )))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SetVideoLatencyPattern copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else{
				set_latency_pattern_info(set_video_latency_pattern);
			}
			break;
		}

		case VSC_IOC_Set_VD_PTG:
		{
			unsigned char bOnOff = 0;
			if(copy_from_user((void *)&bOnOff, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_EMERG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_Set_VD_PTG copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else{
				if(vsc_set_vd_ptg(bOnOff) == FALSE)
					retval =  -1;
			}
			break;
		}
		case VSC_IOC_GET_UZD_CRC:
		{
			VSC_UZD_CRC pUZD_CRC;
			unsigned int iCRC_Result = 0;
			if(copy_from_user((void *)&pUZD_CRC, (const void __user *)arg, sizeof(VSC_UZD_CRC)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_EMERG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_GET_UZD_CRC copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else{
				if(vsc_get_uzu_crc(pUZD_CRC.wid,&iCRC_Result) == FALSE)
					retval =  -1;
				else{
					pUZD_CRC.CRC_Result= iCRC_Result;
					if(copy_to_user((void __user *)arg, &pUZD_CRC, sizeof(VSC_UZD_CRC)))
					{
						retval = -EFAULT;
						rtd_printk(KERN_EMERG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_GET_UZD_CRC copy_to_user failed!!!!!!!!!!!!!!!\n");
					}
				}
			}
			break;
		}
		case VSC_IOC_SET_DRIVER_PATTERN:
		{
			break;

		}
		case VSC_IOC_SET_DRIVER_TABLE:
		{
			break;

		}

		case VSC_IOC_SET_WINBLANK_SYNC_MEMC:
		{//this is for mute on to sync memc ready
			VSC_WINBLANK_PARA_T winblankpara;
			if(copy_from_user((void *)&winblankpara, (const void __user *)arg, sizeof(VSC_WINBLANK_PARA_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_WINBLANK_SYNC_MEMC copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "winblankpara.winblankwid=%d,winblankpara.winblankbonoff=%d,winblankpara.winblankcolor=%d\n", winblankpara.winblankwid, winblankpara.winblankbonoff, winblankpara.winblankcolor);

				//These are for mute on to wait memc already blck video
				sync_memc_ready = TRUE;//if TRUE. when mute on to wait memc buffer

				if(rtk_hal_vsc_SetWinBlank(winblankpara.winblankwid, winblankpara.winblankbonoff, winblankpara.winblankcolor) == FALSE)
					retval =  -1;
				//These are for mute on to wait memc already blck video
				sync_memc_ready = FALSE;//if TRUE. when mute on to wait memc buffer
			}
			break;
		}



		case VSC_IOC_SET_INPUT_OUTPUT:
		{//this is for new input output hal
			KADP_ARC_INFO_T ARC_info;
			if(copy_from_user((void *)&ARC_info, (const void __user *)arg, sizeof(KADP_ARC_INFO_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_ERR, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_INPUT_OUTPUT copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{

				if(rtk_hal_vsc_SetInputRegion_OutputRegion(ARC_info.wid, ARC_info.rotation, ARC_info.input, ARC_info.original_input, ARC_info.ouput, ARC_info.null_input, ARC_info.null_output) == FALSE)
					retval =  -1;
			}
			break;
		}


		case VSC_IOC_SetSplitInfoForHDMI:
		{
			KADP_HAL_VSC_SPLIT_INFO_T splitInfo;
			if(copy_from_user((void *)&splitInfo, (const void __user *)arg, sizeof(KADP_HAL_VSC_SPLIT_INFO_T)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_ERR, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SetSplitInfoForHDMI copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				if(rtk_hal_vsc_SetSplitInfoForHDMI() == FALSE)
					retval =  -1;
			}
			break;

		}
		case VSC_IOC_WAIT_NOTIFY_WIN_DELAY:
		{
			KADP_SCALER_WIN_CALLBACK_DELAY_INFO scaler_win_delay_cb_info = {0};
			unsigned long flags;
			wait_event_freezable(WIN_DELAY_CB_WAIT_QUEUE, delay_info_cb_trigger);
			if(delay_info_cb_trigger)
			{
				spin_lock_irqsave(get_delay_info_cb_spin_lock(), flags);
				delay_info_cb_trigger = FALSE;
				spin_unlock_irqrestore(get_delay_info_cb_spin_lock(), flags);
				update_win_apply_delay_info_for_cb(SLR_MAIN_DISPLAY, &scaler_win_delay_cb_info);
			}
			if(copy_to_user((void __user *)arg, (void *)&scaler_win_delay_cb_info, sizeof(KADP_SCALER_WIN_CALLBACK_DELAY_INFO)))
			{
				rtd_printk(KERN_ERR, TAG_NAME_VSC,  "[ERR] VSC_IOC_WAIT_NOTIFY_WIN_DELAY copy_to_user error \n");
				retval = EFAULT;
			}

			break;
		}

		case VSC_IOC_SET_HFRMode:
		{
			unsigned char bOnOff;
			if(copy_from_user((void *)&bOnOff, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_HFRMode copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else
			{
				set_HFR_mode(bOnOff);
			}
			break;
		}
		case VSC_IOC_SET_DUALDECODER:
		{
			unsigned char dual_decoder_flag = 0;
			if(copy_from_user((void *)&dual_decoder_flag, (const void __user *)arg, sizeof(unsigned char)))
			{
				retval = -EFAULT;
				rtd_printk(KERN_EMERG, TAG_NAME_VSC, "scaler vsc ioctl code=VSC_IOC_SET_DUALDECODER copy_from_user failed!!!!!!!!!!!!!!!\n");
			}
			else{
				rtk_hal_vsc_Setdualdecoder(dual_decoder_flag);
			}
			break;
		}

		default:
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Scaler vsc disp: ioctl code = %d is invalid!!!!!!!!!!!!!!!1\n", cmd);
			break ;
		}
	return retval;


}

#if defined(CONFIG_COMPAT) && defined(CONFIG_ARM64)
long vsc_compat_ioctl(struct file *file, unsigned int cmd,  unsigned long arg)
{
	return vsc_ioctl(file,cmd,arg);
}
#endif

#define REGULAR_PST_VIDEO_DELAY 1

void Scaler_ForceUpdate_Callback_Delay_Info_by_InputOutput_Region(KADP_VIDEO_RECT_T  OutputRegion)
{
	UINT32 framePeriod = 0;
	framePeriod =16;

	g_scaler_win_delay_cb_info.wid = 0;
	g_scaler_win_delay_cb_info.delayTime = framePeriod;
	g_scaler_win_delay_cb_info.OutputRegion.x = OutputRegion.x;
	g_scaler_win_delay_cb_info.OutputRegion.y = OutputRegion.y;
	g_scaler_win_delay_cb_info.OutputRegion.w = OutputRegion.w;
	g_scaler_win_delay_cb_info.OutputRegion.h = OutputRegion.h;
	g_scalerForceUpdate_CB_by_InputOutput_Region_Flag = 1;

	printk(KERN_NOTICE "[Scaler_ForceUpdate_Callback_Delay_Info_by_InputOutput_Region] (%x.%x.%x.%x.%d)\n", g_scaler_win_delay_cb_info.OutputRegion.x,g_scaler_win_delay_cb_info.OutputRegion.y,
		g_scaler_win_delay_cb_info.OutputRegion.w, g_scaler_win_delay_cb_info.OutputRegion.h, framePeriod);

	wakeup_window_delay_info_callback(SLR_MAIN_DISPLAY,FALSE);
}

void Scaler_Reset_ForceUpdate_Callback_Delay_Info(void)
{
	g_scalerForceUpdate_CB_by_InputOutput_Region_Flag = 0;
	memset((void*) &g_scaler_win_delay_cb_info, 0, sizeof(KADP_SCALER_WIN_CALLBACK_DELAY_INFO));
}


void Scaler_Fulfill_Callback_Delay_Info(KADP_SCALER_WIN_CALLBACK_DELAY_INFO *pCallBack_info)
{
	SCALER_WIN_CALLBACK_DELAY_INFO* pPstDelaySetting = NULL;
	UINT32 framePeriod = 0;
	SLR_VOINFO* pVOInfo = Scaler_VOInfoPointer(Scaler_Get_CurVoInfo_plane());
	extern SCALER_WIN_CALLBACK_DELAY_INFO* Scaler_Get_Pst_Window_Delay_Setting(void);
	extern void Scaler_Reset_Pst_Window_Delay_Setting(void);

	pPstDelaySetting = Scaler_Get_Pst_Window_Delay_Setting();

	if((pPstDelaySetting)&&(pPstDelaySetting->validinfo)){
		Scaler_Reset_Pst_Window_Delay_Setting();

		//printk(KERN_NOTICE "pVOInfo->v_freq=%d \n", pVOInfo->v_freq);

		framePeriod = ((100000/pVOInfo->v_freq)*REGULAR_PST_VIDEO_DELAY)/10;

		if(pCallBack_info){
			pCallBack_info->wid = 0;
			pCallBack_info->delayTime = framePeriod;
			pCallBack_info->OutputRegion.x = pPstDelaySetting->region_x;
			pCallBack_info->OutputRegion.y = pPstDelaySetting->region_y;
			pCallBack_info->OutputRegion.w = pPstDelaySetting->region_w;
			pCallBack_info->OutputRegion.h = pPstDelaySetting->region_h;
		}
		#if 0
		printk(KERN_NOTICE "[Scaler_Fulfill_Callback_Delay_Info] (%x.%x.%x.%x.%d)\n", pPstDelaySetting->region_x,pPstDelaySetting->region_y,
			pPstDelaySetting->region_w, pPstDelaySetting->region_h, framePeriod);
		#endif
	}
}


#define CONFIG_MAGNIFIER_MESSAGE_QUEUE_SIZE 	6 // Define the size of message queue

static VSC_MAGNIGIER_PARA_T MAGNIFIER_MESSAGEQUEUES_BUF[CONFIG_MAGNIFIER_MESSAGE_QUEUE_SIZE]; // message queue
static unsigned char  InMagnifierQueue, OutMagnifierQueue; // in/out index of message queue


void magnifier_message_push(VSC_MAGNIGIER_PARA_T message)
{
	down(&MagMsg_Semaphore);
	MAGNIFIER_MESSAGEQUEUES_BUF[InMagnifierQueue] = message;
	InMagnifierQueue = (InMagnifierQueue + 1) % CONFIG_MAGNIFIER_MESSAGE_QUEUE_SIZE;
	//frank@0506 add avoid message queue full and can not be pop
	if(InMagnifierQueue == OutMagnifierQueue){//Queue is full
		if(InMagnifierQueue == 0)
			InMagnifierQueue = CONFIG_MAGNIFIER_MESSAGE_QUEUE_SIZE-1;
		else
			InMagnifierQueue = InMagnifierQueue-1;
	}
	up(&MagMsg_Semaphore);
}

VSC_MAGNIGIER_PARA_T ManifierNULLmsg = {VIDEO_WID_MAXN, {0,0,0,0}, {0,0,0,0}};

VSC_MAGNIGIER_PARA_T magnifier_message_pop(void)
{
	VSC_MAGNIGIER_PARA_T msg;
	down(&MagMsg_Semaphore);
	if(OutMagnifierQueue == InMagnifierQueue) {
		up(&MagMsg_Semaphore);
		return ManifierNULLmsg;
	}
	msg = MAGNIFIER_MESSAGEQUEUES_BUF[OutMagnifierQueue];
	MAGNIFIER_MESSAGEQUEUES_BUF[OutMagnifierQueue] = ManifierNULLmsg;
	OutMagnifierQueue = (OutMagnifierQueue + 1) % CONFIG_MAGNIFIER_MESSAGE_QUEUE_SIZE;
	up(&MagMsg_Semaphore);

	return msg;
}


static bool magnifier_tsk_running_flag = FALSE;//Record vsc_connet_apply_tsk status. True: Task is running
static struct task_struct *p_magnifier_tsk = NULL;


static int vsc_magnifier_tsk(void *p)//This task run rtk_check_signal to check signal stable or not
{
    rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "vsc_magnifier_tsk()\n");
	current->flags &= ~PF_NOFREEZE;
    while (1)
    {
		VSC_MAGNIGIER_PARA_T msg;
		msg = magnifier_message_pop();
		if(msg.magnifierWid == VIDEO_WID_MAXN) {
			msleep(10);
		} else {
			if(msg.magnifierWid != VIDEO_WID_MAXN) {
				down(&Magnifier_Semaphore);
				down(&VSC_Semaphore);
				shape_wide=msg.W;
				shape_high=msg.H;
				if(Get_Live_zoom_mode() != LIVE_ZOOM_OFF){
					if(msg.magnifierWid == VIDEO_WID_0) {
						Scaler_DispWindowZoomin(SLR_MAIN_DISPLAY, msg.magnifierinregion, msg.magnifieroutregion,0,0,FALSE);
#if 0
						/*zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, msg.magnifierinregion.x, msg.magnifierinregion.y, msg.magnifierinregion.w, msg.magnifierinregion.h, ZOOM_CROP);
						zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, msg.magnifierinputTiming.x, msg.magnifierinputTiming.y, msg.magnifierinputTiming.w, msg.magnifierinputTiming.h, ZOOM_CROP_TIMING);
						zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, msg.magnifieroutregion.x, msg.magnifieroutregion.y, msg.magnifieroutregion.w, msg.magnifieroutregion.h, ZOOM_DISP);*/
						StructSrcRect main_inputRegion = { 0, 0, 0, 0};
						StructSrcRect main_inputTiming = { 0, 0, 0, 0};
						StructSrcRect main_outputRegion = { 0, 0, 0, 0};
						main_inputRegion.srcx = msg.magnifierinregion.x;
						main_inputRegion.srcy = msg.magnifierinregion.y;
						main_inputRegion.src_wid = msg.magnifierinregion.w;
						main_inputRegion.src_height = msg.magnifierinregion.h;

						main_inputTiming.srcx = msg.magnifierinputTiming.x;
						main_inputTiming.srcy = msg.magnifierinputTiming.y;
						main_inputTiming.src_wid = msg.magnifierinputTiming.w;
						main_inputTiming.src_height = msg.magnifierinputTiming.h;

						main_outputRegion.srcx = msg.magnifieroutregion.x;
						main_outputRegion.srcy = msg.magnifieroutregion.y;
						main_outputRegion.src_wid = msg.magnifieroutregion.w;
						main_outputRegion.src_height = msg.magnifieroutregion.h;

						zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, msg.inputType, main_inputRegion,main_inputTiming,main_outputRegion);
#endif
					}else if(msg.magnifierWid == VIDEO_WID_1) {
						if (Get_Magnifier_LiveZoom_Mode()==KADP_VSC_SUB_PURPOSE_LIVE_ZOOM)
							Scaler_DispWindowZoomin(SLR_SUB_DISPLAY, msg.magnifierinregion, msg.magnifieroutregion,msg.W,msg.H,FALSE);
						else if (Get_Magnifier_LiveZoom_Mode()==KADP_VSC_SUB_PURPOSE_MAGNIFIER)
							Scaler_DispWindowZoomin(SLR_SUB_DISPLAY, msg.magnifierinregion, msg.magnifieroutregion,msg.W,msg.H,TRUE);
#if 0
						/*zoom_imd_smooth_toggle_config(SLR_SUB_DISPLAY, msg.magnifierinregion.x, msg.magnifierinregion.y, msg.magnifierinregion.w, msg.magnifierinregion.h, ZOOM_CROP);
						zoom_imd_smooth_toggle_config(SLR_SUB_DISPLAY, msg.magnifierinputTiming.x, msg.magnifierinputTiming.y, msg.magnifierinputTiming.w, msg.magnifierinputTiming.h, ZOOM_CROP_TIMING);
						zoom_imd_smooth_toggle_config(SLR_SUB_DISPLAY, msg.magnifieroutregion.x, msg.magnifieroutregion.y, msg.magnifieroutregion.w, msg.magnifieroutregion.h, ZOOM_DISP);*/
						StructSrcRect sub_inputRegion = { 0, 0, 0, 0};
						StructSrcRect sub_inputTiming = { 0, 0, 0, 0};
						StructSrcRect sub_outputRegion = { 0, 0, 0, 0};
						sub_inputRegion.srcx = msg.magnifierinregion.x;
						sub_inputRegion.srcy = msg.magnifierinregion.y;
						sub_inputRegion.src_wid = msg.magnifierinregion.w;
						sub_inputRegion.src_height = msg.magnifierinregion.h;

						sub_inputTiming.srcx = msg.magnifierinputTiming.x;
						sub_inputTiming.srcy = msg.magnifierinputTiming.y;
						sub_inputTiming.src_wid = msg.magnifierinputTiming.w;
						sub_inputTiming.src_height = msg.magnifierinputTiming.h;

						sub_outputRegion.srcx = msg.magnifieroutregion.x;
						sub_outputRegion.srcy = msg.magnifieroutregion.y;
						sub_outputRegion.src_wid = msg.magnifieroutregion.w;
						sub_outputRegion.src_height = msg.magnifieroutregion.h;

						zoom_imd_smooth_toggle_config(SLR_SUB_DISPLAY, msg.inputType, sub_inputRegion,sub_inputTiming,sub_outputRegion);
#endif
					}
				}
				up(&VSC_Semaphore);
				up(&Magnifier_Semaphore);

			}else {
				msleep(5);
			}
		}
		if (freezing(current))
        	{
			try_to_freeze();
        	}

		if (kthread_should_stop()) {
         	break;
      	}
    }
    rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####vsc_magnifier_tsk: exit...####\n");
    do_exit(0);
    return 0;
}

static void create_magnifier_tsk(void)
{
	int i;
	int err;
	for(i=0; i<CONFIG_MAGNIFIER_MESSAGE_QUEUE_SIZE; i++)
		MAGNIFIER_MESSAGEQUEUES_BUF[i] = ManifierNULLmsg;

	if (magnifier_tsk_running_flag == FALSE) {
		p_magnifier_tsk = kthread_create(vsc_magnifier_tsk, NULL, "magnifier_tsk");

	    if (p_magnifier_tsk) {
			wake_up_process(p_magnifier_tsk);
			magnifier_tsk_running_flag = TRUE;
	    } else {
	    	err = PTR_ERR(p_magnifier_tsk);
	    	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Unable to start p_magnifier_tsk (err_id = %d)./n", err);
	    }
	}
}

static void delete_magnifier_tsk(void)
{
	int ret;
	if (magnifier_tsk_running_flag) {
 		ret = kthread_stop(p_magnifier_tsk);
 		if (!ret) {
 			p_magnifier_tsk = NULL;
 			magnifier_tsk_running_flag = FALSE;
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "p_magnifier_tsk thread stopped\n");
 		}
	}
}
void Convert_Timing_To_fs_Depend_datafs(unsigned char display)
{
	if (display == SLR_MAIN_DISPLAY) {
		if ((drvif_scaler_get_display_mode() != DISPLAY_MODE_FRAME_SYNC)
			&& (1==Scaler_get_data_framesync(SLR_MAIN_DISPLAY)))
		{ //data frc change to data fs,display timing need change
			modestate_set_fll_running_flag(_DISABLE);
                    drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
			Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_FRAMESYNC,TRUE);
			rtd_printk(KERN_INFO, TAG_NAME_VSC, "Convert_Timing_To_fs_Depend_datafs:framesync\n");
		}
	}
}

extern void i2rnd_debug(void);
static bool vsc_tsk_running_flag = FALSE;//Record vsc_scaler_tsk status. True: Task is running
static struct task_struct *p_vsc_tsk = NULL;
static int vsc_scaler_tsk(void *p)//This task run scaler or check signal stable or not
{

    unsigned short vsc_task_alive_print = 150;//6 second

	StructSrcRect winSrcRect;
	VSC_INPUT_TYPE_T srctype;
    struct cpumask vsc_cpumask;
	int timeout, filmDetect_timeout;
	unsigned char port;
#ifdef CONFIG_ENABLE_HDMI_NN
	unsigned ulNNYAddr = 0, ulNNCAddr = 0, ulCropYAddr = 0, ulCropCAddr = 0;
#endif

#ifdef CONFIG_RTK_KDRV_PWM
	static int ld_debug_cnt=0;
#endif
	current->flags &= ~PF_NOFREEZE;
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "vsc_scaler_tsk()\n");
    set_freezable();
    cpumask_clear(&vsc_cpumask);
    cpumask_set_cpu(0, &vsc_cpumask); // run task in core 0
    cpumask_set_cpu(2, &vsc_cpumask); // run task in core 2
    cpumask_set_cpu(3, &vsc_cpumask); // run task in core 3
    sched_setaffinity(0, &vsc_cpumask);

    while (1)
    {
		//msleep(10);
		wait_for_completion_timeout(&vsc_scaler_tsk_completion, (HZ * 10) / 1000);

		if (freezing(current))
        {//for some continue case
        	update_vsc_task_status(1, VSC_FREEZE_DISABLE_MAIN_IP);
			fw_scalerip_disable_onlyip(SLR_MAIN_DISPLAY);
			update_vsc_task_status(0, VSC_FREEZE_DISABLE_MAIN_IP);
#ifdef CONFIG_DUAL_CHANNEL
			update_vsc_task_status(1, VSC_FREEZE_DISABLE_SUB_IP);
			fw_scalerip_disable_onlyip(SLR_SUB_DISPLAY);
			update_vsc_task_status(0, VSC_FREEZE_DISABLE_SUB_IP);
#endif
			try_to_freeze();
        }

		if(vsc_task_alive_print == 0)
		{
			rtd_printk(KERN_INFO, TAG_NAME_VSC, " vsc_scaler_tsk alive \n");
			vsc_task_alive_print = 150;//print alive 6 second
		}
		else
		{
			vsc_task_alive_print--;
		}

		if(vbe_disp_orbit_get_vo_overscan()==1 ){

			vbe_disp_orbit_set_vo_overscan(0);
			if(!(IoReg_Read32(0xb8022288)&_BIT26)){

				if((Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
				{
					vbe_disp_orbit_sub_overscan();
				}
                else
				{
					vbe_disp_orbit_set_sub_overscan(0);
				}

				if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
					&& !(SCALEUP_D_UZU_Globle_Ctrl_get_patgen_sel(IoReg_Read32(SCALEUP_D_UZU_Globle_Ctrl_reg)))
					&&(rotate_mode == DIRECT_VO_FRAME_ORIENTATION_ROTATE_0)
					)
				{
					if(ScalerCheckOrbitFinish())
						vbe_disp_orbit_vo_overscan();
				}
				else
				{
					SCALER_ORBIT_SHIFT_INFO *orbit_shift_info = NULL;
					orbit_shift_info = (SCALER_ORBIT_SHIFT_INFO*)Scaler_GetShareMemVirAddr(SCALERIOC_ORBIT_SHIFT_INFO);
					orbit_shift_info->orbit_enable = 0;
					orbit_shift_info->active_state = 0;
				}

				vbe_disp_orbit_set_osd_overscan(1);

				if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ORBIT_READY))
				{
					unsigned int counter  = 5;
					while(counter && !(ScalerCheckOrbitFinish()))
					{
						msleep(10);
						counter--;
					}
					rtd_printk(KERN_INFO, TAG_NAME_VSC, "wait orbit ready counter:%d\n", counter);
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ORBIT_READY, FALSE);//Set orbit mask
					trigger_mute_off(SLR_MAIN_DISPLAY, 1);
				}
				if(Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ORBIT_READY))
				{
					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ORBIT_READY, FALSE);//Set orbit mask
					trigger_mute_off(SLR_SUB_DISPLAY, 1);
				}
			}
		}
		else if(vbe_disp_orbit_get_frc_overscan()==1  ){

			vbe_disp_orbit_set_frc_overscan(0);

			if((Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
			{
				vbe_disp_orbit_sub_overscan();
			}
            else
			{
				vbe_disp_orbit_set_sub_overscan(0);
			}

			if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
				&& !(SCALEUP_D_UZU_Globle_Ctrl_get_patgen_sel(IoReg_Read32(SCALEUP_D_UZU_Globle_Ctrl_reg)))
				&&(rotate_mode == DIRECT_VO_FRAME_ORIENTATION_ROTATE_0)
				)
			{
				if(ScalerCheckOrbitFinish())
					vbe_disp_orbit_frc_overscan();
			}
			else{
				SCALER_ORBIT_SHIFT_INFO *orbit_shift_info = NULL;
				orbit_shift_info = (SCALER_ORBIT_SHIFT_INFO*)Scaler_GetShareMemVirAddr(SCALERIOC_ORBIT_SHIFT_INFO);
				orbit_shift_info->orbit_enable = 0;
				orbit_shift_info->active_state = 0;
			}

			vbe_disp_orbit_OSD_overscan();
			if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ORBIT_READY))
			{
				unsigned int counter  = 5;
				while(counter && !(ScalerCheckOrbitFinish()))
				{
					msleep(10);
					counter--;
				}
				rtd_printk(KERN_INFO, TAG_NAME_VSC, "wait orbit ready counter:%d\n", counter);

				set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ORBIT_READY, FALSE);//Set orbit mask
				trigger_mute_off(SLR_MAIN_DISPLAY, 1);
			}
			if(Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ORBIT_READY))
			{
				set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_ORBIT_READY, FALSE);//Set orbit mask
				trigger_mute_off(SLR_SUB_DISPLAY, 1);
			}
		}
		else if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ORBIT_READY))
		{
			set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ORBIT_READY, FALSE);//Set orbit mask
			trigger_mute_off(SLR_MAIN_DISPLAY, 1);
		}
		else
		{
			if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE) || (SCALEUP_D_UZU_Globle_Ctrl_get_patgen_sel(IoReg_Read32(SCALEUP_D_UZU_Globle_Ctrl_reg))))
			{
				SCALER_ORBIT_SHIFT_INFO *orbit_shift_info = NULL;
				orbit_shift_info = (SCALER_ORBIT_SHIFT_INFO*)Scaler_GetShareMemVirAddr(SCALERIOC_ORBIT_SHIFT_INFO);
				orbit_shift_info->orbit_enable = 0;
				orbit_shift_info->active_state = 0;
			}
		}

#ifdef CONFIG_ENABLE_HDMI_NN
			// Test NN read buffer, check 0xB8025800[27]=1 ?
			if(get_i3ddma_NN_flag())
			{
				update_vsc_task_status(1, VSC_I3DDMA_NN);
				if ((IoReg_Read32(H3DDMA_LR_Separate_CTRL1_reg)) & _BIT27)
				{
					h3ddma_get_NN_read_buffer(&ulNNYAddr, &ulNNCAddr, &ulCropYAddr, &ulCropCAddr);

					pr_emerg("NNYAddr=%x, NNCAddr=%x, ulCropYAddr=%x, ulCropCAddr=%x\n", ulNNYAddr, ulNNCAddr, ulCropYAddr, ulCropCAddr);

					//h3ddma_get_NN_read_buffer_test(&ulNNYAddr, &ulNNCAddr);

					//pr_emerg("test NNYAddr=%x, NNCAddr=%x\n", ulNNYAddr, ulNNCAddr);
				}

				// Dump NN data once, 0xB8025800[28]=1
				if ((IoReg_Read32(H3DDMA_LR_Separate_CTRL1_reg)) & _BIT28)
				{
#ifdef CONFIG_FORCE_RUN_I3DDMA
					i3ddma_dump_data_to_file();
#endif
					IoReg_ClearBits(H3DDMA_LR_Separate_CTRL1_reg, _BIT28);
				}

				update_vsc_task_status(0, VSC_I3DDMA_NN);
			}
#endif


#ifdef MSPG_AUTO_TEST
		if(MSPG_AUTO_TEST_START == IoReg_Read32(MSPG_AUTO_TEST_REGISTER))
		{
            update_vsc_task_status(1, VSC_MESPG_AUTO_TEST);
			if(TRUE == Check_DisplayFrame_isRightColorbar())
			{
				IoReg_Write32(MSPG_AUTO_TEST_REGISTER, MSPG_AUTO_TEST_SUCCESS);
			}else{
				IoReg_Write32(MSPG_AUTO_TEST_REGISTER, MSPG_AUTO_TEST_FAIL);
			}

            update_vsc_task_status(0, VSC_MESPG_AUTO_TEST);
		}
#endif

		if(OutpuLocalDimmingPatMode == TRUE){
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "#Enter LocalDimming debug mode#\n");
			continue;
		}

		if(TV006_WB_Pattern_En == TRUE){
			if(DbgSclrFlgTkr.Main_Reset_Mode_flag)	//WOSQRTK-7881 should go reset after close in WB background
			{
                update_vsc_task_status(1, VSC_MAIN_RESET_MODE);
				down(&Main_ResetMode_Semaphore);
				DbgSclrFlgTkr.Main_Reset_Mode_flag = FALSE;
				up(&Main_ResetMode_Semaphore);
				rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n#####func:%s DO Main reset mode during WB#####\r\n", __FUNCTION__);
				down(&VSC_Semaphore);
				drvif_mode_resetmode(SLR_MAIN_DISPLAY);//Reset Mode for Main
				up(&VSC_Semaphore);
                update_vsc_task_status(0, VSC_MAIN_RESET_MODE);
			}
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "#Enter WB Pattern debug mode#\n");	//WOSQRTK-7731
			continue;
		}

		if(vpq_ld_running_flag == TRUE){
#ifdef CONFIG_RTK_KDRV_PWM
			if((DbgSclrFlgTkr.vpq_ld_first_boot==FALSE)||(((IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)-ld_time_tick)/90) > 1100)){
                update_vsc_task_status(1, VSC_VPQ_LD);
				if((DbgSclrFlgTkr.vpq_ld_first_boot==TRUE)){ // protect first enter after resume 1.1sec, otherwise no need to check time
					rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "[%s] ld tick time = %d (cnt:%d)\n", __FUNCTION__, (IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)-ld_time_tick)/90,
						ld_debug_cnt);
				}
				DbgSclrFlgTkr.vpq_ld_first_boot = FALSE;
				down(&VPQ_ld_running_Semaphore);
				drvif_HAL_VPQ_LED_LDEnable(vpq_led_LDEnable);
				vpq_ld_running_flag = FALSE;
				up(&VPQ_ld_running_Semaphore);
				ld_debug_cnt = 0;
                update_vsc_task_status(0, VSC_VPQ_LD);
			}else{
				ld_debug_cnt++;
			}
#endif
		}

#ifdef BRING_UP_I2RND
		//Eric@20180518 for i2rnd bring up HW verify
		if((IoReg_Read32(0xb8022288) & _BIT9) && (i2rnd_brungup_setting_done == 0)){
			i2rnd_bring_up_verify();
			i2rnd_brungup_setting_done = 1;
		}
#endif

		#if 1
		if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE){
#ifdef CONFIG_I2RND_ENABLE
			if(Scaler_I2rnd_get_timing_enable() && (Scaler_main_md_pst_get_enable() == _DISABLE)){
				DbgSclrFlgTkr.Main_smooth_toggle_set_flag = _DISABLE;
				DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = _DISABLE;
			}
#endif
			zoom_update_scaler_info_from_vo_smooth_toggle(SLR_MAIN_DISPLAY);//update vo smooth toggle info
			if (rtk_hal_vsc_Getdualdecoder() && (0 == rtk_hal_vsc_Getdualdecoder_run()))
			{
				rtk_hal_vsc_Setdualdecoder_run(1);
				Scaler_DualChannelRpc(1);
				rtd_printk(KERN_INFO, TAG_NAME_VSC, "dual decoder start to run\n");
			}
			if(DbgSclrFlgTkr.Main_smooth_toggle_set_flag || DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off) {
				unsigned char Main_smoothtoggle_forcebg_flag=0;
				unsigned char Main_smoothtoggle_from_mute_off = FALSE;//if TRUE, means mute off trigger smooth toggle
				srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
                update_vsc_task_status(1, VSC_MAIN_SMOOTHTOGGLE);
				down(&SetMainOutPutRegion_Semaphore);
				if(DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off)
					Main_smoothtoggle_from_mute_off = TRUE;//if TRUE, means mute off trigger smooth toggle
				DbgSclrFlgTkr.smoothtoggle_start_flag = TRUE;
				DbgSclrFlgTkr.Main_smooth_toggle_set_flag = false;
				DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off = FALSE;
				if (DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag) {
					Main_smoothtoggle_forcebg_flag=TRUE;
					DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag =false;
				}

				Scaler_DispWindowSet(main_dispwin);
				//Scaler_InputRegionType_Set(SLR_MAIN_DISPLAY,hal_main_InputRegionType);
				/*if(srctype != KADP_VSC_INPUTSRC_AVD) {
					zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height, ZOOM_CROP);
					zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, main_input_timing.srcx, main_input_timing.srcy, main_input_timing.src_wid, main_input_timing.src_height, ZOOM_CROP_TIMING);
				}*/
				up(&SetMainOutPutRegion_Semaphore);
				if(Check_AP_Set_Enable_ForceBG(SLR_MAIN_DISPLAY)) {
					ppoverlay_main_display_control_rsv_RBUS main_display_control_rsv_reg;
					main_display_control_rsv_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Display_Control_RSV_reg);
					timeout = 30;
					while(!main_display_control_rsv_reg.m_force_bg && timeout) {
						timeout -- ;
						msleep(10);
						main_display_control_rsv_reg.regValue = IoReg_Read32(PPOVERLAY_Main_Display_Control_RSV_reg);
					}
					pr_info("before smoothtoggle,need wait forcebg ok timeout=%d\n",timeout);
				}
				//when change to data fs,need change timing to fs
				Convert_Timing_To_fs_Depend_datafs(SLR_MAIN_DISPLAY);
				if(srctype == VSC_INPUTSRC_AVD)
				{
#ifdef SPEEDUP_NEW_SCALER_FLOW
					if(get_AVD_Input_Source() != _SRC_TV)
					{//do h v start compensation
						avd_start_compensation();//compensation h v start
					}
#endif
#ifdef CONFIG_ENABLE_VD_27MHZ_MODE
					down(&VSC_Semaphore);
					Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
					winSrcRect = Scaler_DispWindowGet();
					//zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, winSrcRect.srcx, winSrcRect.srcy, winSrcRect.src_wid, winSrcRect.src_height, ZOOM_DISP);
					zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, getInputRegionType(SLR_MAIN_DISPLAY), main_input_size, main_input_timing, winSrcRect);
					up(&VSC_Semaphore);
#endif

				}
				else
				{
					down(&VSC_Semaphore);
					Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
					winSrcRect = Scaler_DispWindowGet();
					//zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, winSrcRect.srcx, winSrcRect.srcy, winSrcRect.src_wid, winSrcRect.src_height, ZOOM_DISP);
					zoom_imd_smooth_toggle_config(SLR_MAIN_DISPLAY, getInputRegionType(SLR_MAIN_DISPLAY), main_input_size, main_input_timing, winSrcRect);
					up(&VSC_Semaphore);
				}

				if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY))
				{
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, FALSE);//display arc ready mask, becasue we already apply ARC
					Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);//wait smooth toggle ready to avoid to see ARC change
#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG
					down(&SetMainOutPutRegion_Semaphore);
					if(!DbgSclrFlgTkr.Main_Scaler_Stop_flag && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE))
					{
						down(&new_input_output_main_sem);
						reset_pst_sharemem_buffer(SLR_MAIN_DISPLAY);//reset pst buffer data
						set_pst_active_state(SLR_MAIN_DISPLAY, TRUE);//update to enable PST
						up(&new_input_output_main_sem);
					}
					up(&SetMainOutPutRegion_Semaphore);
#endif

				}
				if((DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off == FALSE) && (DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag == FALSE)){
					rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n#####open forcebg after smoothtoggle\r\n");
					if((Main_smoothtoggle_forcebg_flag==TRUE)/*&&(srctype == VSC_INPUTSRC_VDEC)*/&&(!Get_display_forcebg_mask(SLR_MAIN_DISPLAY,SLR_FORCE_BG_TYPE_VSC)))
					{
						Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
						if (srctype == VSC_INPUTSRC_ADC) {//componet 5A wait at least two frame in case of shaking
							int timingMode = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_MODE_CURR);
							if((Scaler_DispGetStatus(SLR_MAIN_DISPLAY,SLR_DISP_INTERLACE)) && (Scaler_InputSrcGetType(SLR_MAIN_DISPLAY) == _SRC_YPBPR)&&((timingMode == _MODE_480I)||(timingMode == _MODE_576I)))
							{
								unsigned int waitsec = 3*10000/(int)Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_V_FREQ);
								msleep(waitsec);
							}
						}
					}

					if(srctype == VSC_INPUTSRC_VDEC)
					{
						// [K5LG-828] wait for VO film mode detect done
						unsigned int stc = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
						filmDetect_timeout = FILM_DETECT_TO;
						port = Get_DisplayMode_Port(SLR_MAIN_DISPLAY);
						timeout = 30;
						while((((get_vo_avsync_flag(port) == FALSE) && timeout)|| ((get_film_detect_done_flag(port) == FALSE) && filmDetect_timeout)) && Main_smoothtoggle_from_mute_off)
						{
							timeout -- ;
							filmDetect_timeout--;
							if(DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off || DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag || DbgSclrFlgTkr.Main_Scaler_Stop_flag)
								break;
							if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
								break;
							msleep(1);
						}
						if(filmDetect_timeout != FILM_DETECT_TO)
						    rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "[FILM] P[%d] Wait Detect Done[%d]=%d ms\n",  port, filmDetect_timeout, (IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg) - stc)/90);

						rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "\r\n### smooth toggle vo wait sync & film detect done timeout:%d, %d####\r\n", timeout, filmDetect_timeout);

						//Set FLL flag when DTV channel changing
						if(vbe_disp_get_adaptivestream_fs_mode() == 1){
							//drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
							modestate_set_fll_running_flag(_DISABLE);
							//rtd_printk(KERN_EMERG, TAG_NAME_VSC,"@@@@@@@@@@@FLL disable for adaptive stream\n");
						}else{
							if (Main_smoothtoggle_forcebg_flag && DbgSclrFlgTkr.check_only_xy_shift_same_region) {//only the same timing DTV exchange need reset_freerun
								#ifdef CONFIG_I2RND_ENABLE
								if(Scaler_I2rnd_get_timing_enable() == _DISABLE)
								#endif

#ifdef ENABLE_VR360_DATA_FS_FLOW
								if(get_vt_EnableFRCMode() != FALSE)	//VR360 cannot set freerun
#endif
								{
									if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_FRAMESYNC)==FALSE) {
										//for enter fixlastline condition, reset timing to freerun
										drivf_scaler_reset_freerun();
									}
								}
								if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_FRAMESYNC)==FALSE) {
									if((Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_HDMI) || (Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_LVDS_TO_HDMI))
										modestate_set_fll_running_flag(_DISABLE);
									else
										modestate_set_fll_running_flag(_ENABLE);
								}
							}
						}
					}
					DbgSclrFlgTkr.smoothtoggle_start_flag = FALSE;
					if((DbgSclrFlgTkr.Main_run_smooth_toggle_from_mute_off == FALSE) && (DbgSclrFlgTkr.Main_SetOutput_request_muteoff_smooth_toggle_set_flag == FALSE) &&
						(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)) {

                        if(vbe_disp_oled_orbit_enable)
                        {
                            ScalerForceUpdateOrbit(1);

                            rtd_printk(KERN_INFO, TAG_NAME_VSC, "####[%s(%d)] enable orbit mask\n",__func__, __LINE__);
                            set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ORBIT_READY, TRUE);//Set orbit mask
                        }

                        if (!Get_display_forcebg_mask(SLR_MAIN_DISPLAY,SLR_FORCE_BG_TYPE_VSC)) {
							trigger_mute_off(SLR_MAIN_DISPLAY, 1);
						}
					}
				}

                update_vsc_task_status(0, VSC_MAIN_SMOOTHTOGGLE);
			} else {
			#if 0
				if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_FRAMESYNC)&& (Get_DisplayMode_Src(SLR_MAIN_DISPLAY)==VSC_INPUTSRC_VDEC)) {
					onms_onms1_ctrl_RBUS onms_onms1_ctrl_reg;
					onms_onms1_ctrl_reg.regValue =  IoReg_Read32(ONMS_onms1_ctrl_reg);
					if(!onms_onms1_ctrl_reg.on1_start_ms) {
						Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
						drvif_mode_enableonlinemeasure(SLR_MAIN_DISPLAY);
						drvif_mode_onlinemeasure_setting(SLR_MAIN_DISPLAY, _SRC_VO, TRUE, FALSE);
					}
				}
			#endif
			}
		}else{
			if(DbgSclrFlgTkr.Main_smooth_toggle_set_flag) {
               pr_info(" not active clear Main_smooth_toggle_set_flag start\n");
				down(&SetMainOutPutRegion_Semaphore);
				DbgSclrFlgTkr.Main_smooth_toggle_set_flag=FALSE;
				up(&SetMainOutPutRegion_Semaphore);
                pr_info(" not active clear Main_smooth_toggle_set_flag end\n");
			}
		}

		#endif

		if(DbgSclrFlgTkr.run_iv2dv_slow_tuning_flag)
		{
			if(drv_memory_get_game_mode_iv2dv_slow_enable() == TRUE){
				rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "\r\n#drv_run_GameMode_iv2dv_slow_tuning#\r\n");
                update_vsc_task_status(1, VSC_IV2DV_TUNING);
                down(&Iv2dv_Slow_Tuning_Semaphore);
				drv_run_GameMode_iv2dv_slow_tuning();
				up(&Iv2dv_Slow_Tuning_Semaphore);
                update_vsc_task_status(0, VSC_IV2DV_TUNING);
			}
		}

		if(DbgSclrFlgTkr.Main_Reset_Mode_flag)
		{
            update_vsc_task_status(1, VSC_MAIN_RESET_MODE);
			down(&Main_ResetMode_Semaphore);
#ifdef CONFIG_I2RND_ENABLE
			Scaler_I2rnd_set_display(I2RND_TABLE_OFF);
			printk(KERN_EMERG"[%s]I2RND_TABLE_OFF in main reset mode!!!!\n",__FUNCTION__);
#endif
			DbgSclrFlgTkr.Main_Reset_Mode_flag = FALSE;
			up(&Main_ResetMode_Semaphore);
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n#####func:%s DO Main reset mode#####\r\n", __FUNCTION__);
			down(&VSC_Semaphore);
			drvif_mode_resetmode(SLR_MAIN_DISPLAY);//Reset Mode for Main
			if(PPOVERLAY_uzudtg_control1_get_uzu_4k_120_mode(IoReg_Read32(PPOVERLAY_uzudtg_control1_reg))){
				pr_notice("resetmode: 2step enable, cannot enter memc mux.\n");
			}else{
				vbe_disp_game_mode_memc_bypass(0);
			}
			fw_set_vsc_GameMode(0);
			up(&VSC_Semaphore);
            update_vsc_task_status(0, VSC_MAIN_RESET_MODE);
		}
		else
		{
            update_vsc_task_status(1, VSC_MAIN_BBD_VGIP);
			check_bdb_vgip_driver_request(SLR_MAIN_DISPLAY);
            update_vsc_task_status(0, VSC_MAIN_BBD_VGIP);
		}
#ifdef CONFIG_RTK_KDRV_DV
		if(
#ifdef	CONFIG_DOLBY_IDK_1_6_1_1
				dolby_adapter_get_request_letter_dtg_change()
#else
				request_letter_dtg_change
#endif
				&& (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) && ((rtd_inl(VGIP_Smooth_tog_ctrl_reg)&_BIT0)==0))

		{
			ppoverlay_main_background_h_start_end_RBUS main_background_h_start_end_reg;
			ppoverlay_main_background_v_start_end_RBUS main_background_v_start_end_reg;
			unsigned char dolby_dtg_black_flag;
			unsigned long flags;//for spin_lock_irqsave
			update_vsc_task_status(1, VSC_DOLBY_LB);
#ifdef	CONFIG_DOLBY_IDK_1_6_1_1
			dolby_adapter_dolby_letter_box_spin_lock_irq_save(&flags);
			main_background_h_start_end_reg.regValue = dolby_adapter_get_dolby_proverlay_background_h_start_end();
			main_background_v_start_end_reg.regValue = dolby_adapter_get_dolby_proverlay_background_v_start_end();
			dolby_dtg_black_flag = dolby_adapter_get_letter_box_black_flag();
			dolby_adapter_set_request_letter_dtg_change(FALSE);
			dolby_adapter_dolby_letter_box_spin_unlock_irqrestore(&flags);
#else
			spin_lock_irqsave(dolby_letter_box_spinlock(), flags);
			main_background_h_start_end_reg.regValue = dolby_proverlay_background_h_start_end;
			main_background_v_start_end_reg.regValue = dolby_proverlay_background_v_start_end;
			dolby_dtg_black_flag = letter_box_black_flag;
			request_letter_dtg_change = FALSE;
			spin_unlock_irqrestore(dolby_letter_box_spinlock(), flags);
#endif
			IoReg_Write32(PPOVERLAY_MAIN_Background_H_Start_End_reg, main_background_h_start_end_reg.regValue);
			IoReg_Write32(PPOVERLAY_MAIN_Background_V_Start_End_reg, main_background_v_start_end_reg.regValue);
			down(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
			if(dolby_dtg_black_flag)
				IoReg_SetBits(PPOVERLAY_Main_Display_Control_RSV_reg, _BIT2);
			else
				IoReg_ClearBits(PPOVERLAY_Main_Display_Control_RSV_reg, _BIT2);
			spin_lock_irqsave(get_DBreg_spinlock(SLR_MAIN_DISPLAY), flags);//lock double buffer spinlock
			IoReg_SetBits(PPOVERLAY_Double_Buffer_CTRL_reg, _BIT0);//Aplly double buffer
			spin_unlock_irqrestore(get_DBreg_spinlock(SLR_MAIN_DISPLAY), flags);//unlock double buffer spinlock
			up(get_forcebg_semaphore());/*semaphore must added for not effect mute function when setting b8028300*/
            update_vsc_task_status(0, VSC_DOLBY_LB);
}
#endif

		if((DbgSclrFlgTkr.memc_realcinema_run_flag)&&((rtd_inl(VGIP_Smooth_tog_ctrl_reg)&_BIT0)==0)) //wait smooth toggle finish
		{
            update_vsc_task_status(1, VSC_MEMC_REALCINEMA);
            Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
			down(&Memc_Realcinema_Semaphore);
			DbgSclrFlgTkr.memc_realcinema_run_flag=FALSE;
			up(&Memc_Realcinema_Semaphore);


			down(&VSC_Semaphore);
#ifdef ENABLE_IMD_PST_SMOOTHTOGGLE
			if((scaler_vsc_get_adaptive_pst_lowdelay_mode()==1)&&((vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY))||scaler_vsc_get_force_pst_lowdelay_mode()==1)){
				scaler_vsc_set_adaptive_pst_lowdelay_mode(1);
			}else{
				memc_realcinema_framerate();
			}
#else
			memc_realcinema_framerate();
#endif
			up(&VSC_Semaphore);
			update_vsc_task_status(0, VSC_MEMC_REALCINEMA);
		}

#ifdef CONFIG_I2RND_ENABLE
		//trigger I2rnd sub => vo => main flow
		if(/*(Scaler_I2rnd_get_timing_enable() == _ENABLE) && */(vsc_i2rnd_sub_stage == I2RND_STAGE_TRIGGER_RUN_MAIN)){
				vsc_i2rnd_sub_stage = I2RND_STAGE_MAIN_GET_RPC;
				printk(KERN_EMERG"[I2RND]@@@@@@@@@@@@I2RND_STAGE_MAIN_GET_RPC\n");
				printk(KERN_EMERG"[I2RND]Scaler_I2rnd_get_display = %d\n", Scaler_I2rnd_get_display());
				//check timing enable
				Scaler_I2rnd_wait_timing_enable();
				//run main patch
				down(&VSC_Semaphore);
				//disable s0 db_en when i2r timing enable @Crixus 20171219
				Scaler_I2rnd_set_display(I2RND_MAIN_S0_TABLE);
				set_zoom_reset_double_state(_DISABLE, SLR_MAIN_DISPLAY);//always disable double buffer
				//check di setting
				i2rnd_default_register_setting();
				//printk(KERN_EMERG"[%s][sub connect]I2RND default setting done\n", __FUNCTION__);
				Scaler_I2rnd_set_display(I2RND_SUB_S1_TABLE);
				scaler_i2rnd_run_main();
				if ((vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY)) && (vo_timing_change_for_adaptive == 1)) {
					//Eric@20170922 update main structure info for adaptive stream
					Scaler_SET_VSCDispinfo_WithVFEDispinfo(SLR_MAIN_DISPLAY, Get_VO_Dispinfo(DisplayModeInputInfo.resourceIndex));
					vo_timing_change_for_adaptive = 0;
				}
				vsc_i2rnd_sub_stage = I2RND_STAGE_MAIN_I2RND_FINISH;
				printk(KERN_EMERG"[I2RND]@@@@@@@@@@@@I2RND_STAGE_MAIN_I2RND_FINISH\n");
				printk(KERN_EMERG"[I2RND]DbgSclrFlgTkr.Sub_Run_Scaler_flag = %d\n", DbgSclrFlgTkr.Sub_Run_Scaler_flag);

				//Disable main force cmd buffer flag after sub done because i2r enable at vo. @Crixus 20171128
				down(&I2RND_Semaphore);
				Scaler_I2rnd_set_force_cmd(_DISABLE);
				up(&I2RND_Semaphore);
				printk(KERN_EMERG"[I2RND]Disable main force cmd buffer flag after sub done.\n");

				if(DbgSclrFlgTkr.Sub_Run_Scaler_flag == TRUE){
					printk(KERN_EMERG"[I2RND]run sub scaler again, do not disable sub fbg\n");

				}
				else{
					//Disable sub fbg after sub=>vo=>mcap2 done @Crixus 20160728
					//down(get_forcebg_semaphore());
					//scalerdisplay_force_bg_enable(SLR_SUB_DISPLAY, FALSE);
					//up(get_forcebg_semaphore());

					set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, FALSE);//disable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
					trigger_mute_off(SLR_SUB_DISPLAY, 1);
					printk(KERN_EMERG"[I2RND]Disable fbg after sub => vo => main mcap2 done.\n");
				}

				up(&VSC_Semaphore);
		}

		//move APVR run scaler to tsk @Crixus 20160824
		if((Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_TRIGGER_RUN_MAIN)){
			vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_TRIGGER_RUN_MAIN;
//			apvr_request_run_main_path();
		}
#endif
#if 0
		if (LiveZoom_MEMCClose_Flag == TRUE) {
			down(&VSC_Semaphore);
			if (LiveZoom_MEMCClose_Flag == TRUE) {
				down(get_livezoom_memcclose_Semaphore());
				LiveZoom_MEMCClose_Flag = FALSE;
				up(get_livezoom_memcclose_Semaphore());
				memc_setting_displayDtiming_framerate();
			}
			up(&VSC_Semaphore);
		}
#endif
		if ((DbgSclrFlgTkr.rotate_run_scaler_flag || DbgSclrFlgTkr.Main_Run_Scaler_flag || decide_auto_scaler_run(SLR_MAIN_DISPLAY)) && (DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE) && (DbgSclrFlgTkr.Main_Reset_Mode_flag == FALSE)//wait vsc close reset mode ready
#ifdef CONFIG_I2RND_ENABLE
			&& (((vsc_i2rnd_sub_input_type != VSC_INPUTSRC_VDEC) && ((vsc_i2rnd_sub_stage == I2RND_STAGE_DISABLE) ||(vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_I2RND_FINISH)))
				|| ((vsc_i2rnd_sub_input_type == VSC_INPUTSRC_VDEC) && ((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_SUB_DISABLE) || (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FINISH))))
#endif
			) {
			update_vsc_task_status(1, VSC_MAIN_PRE_CHECK);
			set_current_scaler_source_num(SLR_MAIN_DISPLAY);//record current vsc source num
			srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
#ifdef SPEEDUP_NEW_SCALER_FLOW
			if((srctype == VSC_INPUTSRC_ADC) || (srctype == VSC_INPUTSRC_HDMI) || (srctype == VSC_INPUTSRC_VDEC) || (srctype == VSC_INPUTSRC_JPEG) || ((srctype == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() != _SRC_TV)))
			{
				set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, TRUE);
				rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "######[%s(%d)] run scaler start:%d %d#####\n", __func__, __LINE__, DbgSclrFlgTkr.Main_Run_Scaler_flag, decide_auto_scaler_run(SLR_MAIN_DISPLAY));

				down(&SetMainOutPutRegion_Semaphore);
				DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = TRUE;
				set_ori_rotate_mode(get_rotate_mode());
				set_rotate_mode(rotate_mode);
				up(&SetMainOutPutRegion_Semaphore);
				if(srctype == VSC_INPUTSRC_AVD)
					set_avd_start_need_compensation(TRUE);
			}
			else
			{//Need to remove
#ifndef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
				set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, FALSE);
				down(&SetMainOutPutRegion_Semaphore);
				DbgSclrFlgTkr.Main_Run_Scaler_flag = FALSE;
				DbgSclrFlgTkr.Main_Output_Set_flag = FALSE;
				DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = TRUE;
				DbgSclrFlgTkr.rotate_run_scaler_flag = FALSE;
				DbgSclrFlgTkr.rotate_muteoff_request_flag = FALSE;
				set_input_for_vgip(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
				set_input_for_crop(SLR_MAIN_DISPLAY, main_input_size);
				set_input_timing_for_crop(SLR_MAIN_DISPLAY, main_input_timing);
				Scaler_InputRegionType_Set(SLR_MAIN_DISPLAY,getInputRegionType(SLR_MAIN_DISPLAY));
				Scaler_DispWindowSet(main_dispwin);
				//Fixed ATV all direction zoom non-working issue. @Crixus 20160829
				if(!((srctype == KADP_VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))){
					//printk(KERN_EMERG"[%s][%d]\n", __FUNCTION__, __LINE__);
					zoom_record_input_output_pre_size(SLR_MAIN_DISPLAY,main_input_size,main_input_timing,main_dispwin);
				}
				set_ori_rotate_mode(get_rotate_mode());
				set_rotate_mode(rotate_mode);
				up(&SetMainOutPutRegion_Semaphore);
#endif
			}

#else
			down(&SetMainOutPutRegion_Semaphore);
			DbgSclrFlgTkr.Main_Run_Scaler_flag = FALSE;
			DbgSclrFlgTkr.Main_Output_Set_flag = FALSE;
			DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = TRUE;
			DbgSclrFlgTkr.rotate_run_scaler_flag = FALSE;
			DbgSclrFlgTkr.rotate_muteoff_request_flag = FALSE;
			set_input_for_vgip(SLR_MAIN_DISPLAY, main_input_size.srcx, main_input_size.srcy, main_input_size.src_wid, main_input_size.src_height);
			set_input_for_crop(SLR_MAIN_DISPLAY, main_input_size);
			set_input_timing_for_crop(SLR_MAIN_DISPLAY, main_input_timing);
			Scaler_InputRegionType_Set(SLR_MAIN_DISPLAY,getInputRegionType(SLR_MAIN_DISPLAY));
			Scaler_DispWindowSet(main_dispwin);
			//Fixed ATV all direction zoom non-working issue. @Crixus 20160829
			if(srctype != VSC_INPUTSRC_AVD){
				//printk(KERN_EMERG"[%s][%d]\n", __FUNCTION__, __LINE__);
				zoom_record_input_output_pre_size(SLR_MAIN_DISPLAY,main_input_size,main_input_timing,main_dispwin);
			}
			set_ori_rotate_mode(get_rotate_mode());
			set_rotate_mode(rotate_mode);
			up(&SetMainOutPutRegion_Semaphore);
#endif
			port = Get_DisplayMode_Port(SLR_MAIN_DISPLAY);
#ifdef CONFIG_I2RND_ENABLE
			Scaler_I2rnd_set_display(I2RND_MAIN_S0_TABLE);
			printk(KERN_EMERG"[%s]I2RND_MAIN_S0_TABLE!!!!\n",__FUNCTION__);
#endif
#ifdef CONFIG_HDR_SDR_SEAMLESS
			reset_seamless_trigger_flag();//reset trigger flag when run scaler flow. avoid keep previous source trigger flag
#endif
#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG
			set_pst_active_state(SLR_MAIN_DISPLAY, FALSE);//reste activer state
#endif
            update_vsc_task_status(0, VSC_MAIN_PRE_CHECK);
			switch(srctype)
			{
				case KADP_VSC_INPUTSRC_AVD:
					if(get_AVD_Input_Source() != _SRC_TV)
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "####Main path VSC_Src:KADP_VSC_INPUTSRC_AVD(AV)#####\r\n");
				break;

				case KADP_VSC_INPUTSRC_ADC:
					rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "####Main path VSC_Src:KADP_VSC_INPUTSRC_ADC#####\r\n");
				break;

				case KADP_VSC_INPUTSRC_HDMI:
					set_ori_HDMI_HDR_mode(get_HDMI_HDR_mode());//recode current hdr mode
					rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "####Main path VSC_Src:KADP_VSC_INPUTSRC_HDMI#####\r\n");
				break;

				case VSC_INPUTSRC_VDEC:
					rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "####Main path VSC_Src:VSC_INPUTSRC_VDEC#####\r\n");
				break;

				case VSC_INPUTSRC_JPEG:
					rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "####Main path VSC_Src:VSC_INPUTSRC_JPEG#####\r\n");
				break;

				default:
					break;
			}
#if 0 //remove in k4lp
			//game mode search status checking:ex:change input source
			if(drv_memory_get_game_mode_dynamic() != drv_memory_get_game_mode_flag()){
				if(drv_memory_get_game_mode_dynamic() == _ENABLE){
					drv_memory_set_game_mode(_ENABLE);
				} else {
					drv_memory_set_game_mode(_DISABLE);
				}
			}
#endif
            update_vsc_task_status(1, VSC_WAIT_GAME_MODE);
			wait_game_mode_finish();//wait game mode finish
			update_vsc_task_status(0, VSC_WAIT_GAME_MODE);
#ifdef CONFIG_FORCE_RUN_I3DDMA
			if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_SEARCH)
			{
				//rtd_printk(KERN_EMERG, TAG_NAME_VSC,"######fw_set_vsc_GameMode(0) Line=%d #######\n", __LINE__);
				fw_set_vsc_GameMode(0);
                set_vsc_run_pc_mode(rtk_hal_vsc_GetRGB444Mode());//save vsc run pc mode or not
				/*main path always run i3ddma->vodma->scaler*/
				if(((srctype == VSC_INPUTSRC_HDMI) && (get_hdmi_4k_hfr_mode() != HDMI_4K120_2_1))
				|| (srctype == VSC_INPUTSRC_ADC) || ((srctype == VSC_INPUTSRC_AVD)  && (get_AVD_Input_Source() != _SRC_TV)))
				{
					#ifdef CONFIG_ENABLE_HDMI_NN
					unsigned char ver = get_ic_version();
                    set_i3ddma_NN_flag(1);
					#else
					set_i3ddma_NN_flag(0);
					#endif
					update_vsc_task_status(1, VSC_I3DDMA_DRIVE);
				    down(&Force_Run_Idma_Semaphore);
					#ifdef CONFIG_ENABLE_HDMI_NN
					if(ver < VERSION_C)
						set_force_i3ddma_enable(FALSE);
					else
						set_force_i3ddma_enable(TRUE);
					#else
					set_force_i3ddma_enable(TRUE);
					#endif
					if(get_hdmi_4k_hfr_mode() == HDMI_4K120_2_0)
					{
						set_i3ddma_4k120_flag(1);//hdmi2.0 4k120 case
						#ifdef CONFIG_ENABLE_HDMI_NN
						set_i3ddma_NN_flag(0); //hdmi2.0 4k120 disable NN
						#endif
					}
					else
					{
						set_i3ddma_4k120_flag(0);//not hdmi2.0 4k120 case
						#ifdef CONFIG_ENABLE_HDMI_NN
						set_i3ddma_NN_flag(1);
						#endif
					}

#ifdef CONFIG_ENABLE_HDMI_NN
					vsc_chcek_nn_cap_status();

#endif
					if(scaler_force_run_idma(SLR_MAIN_DISPLAY, srctype) == FALSE)
					{
						set_force_i3ddma_enable(false);
						Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_HDMI, 0xfa);
						up(&Force_Run_Idma_Semaphore);
						pr_err("######scaler_force_run_idma fail fail fail!!!#######\n");
						reset_ARC_cmd(SLR_MAIN_DISPLAY);
						down(&SetMainOutPutRegion_Semaphore);
						reset_any_srcrect(&main_dispwin_pre);
						up(&SetMainOutPutRegion_Semaphore);
						if(srctype  == VSC_INPUTSRC_ADC)
						{//Need to rerun scaler
							StructDisplayInfo  *p_timing = NULL;
							down(get_adc_detectsemaphore());
							reset_adc_timing_ready();
							p_timing = Get_ADC_Dispinfo();
							if(p_timing!=NULL)
							{
								p_timing->IPH_ACT_WID_PRE = 0;
								p_timing->IPV_ACT_LEN_PRE = 0;
								p_timing->IVFreq = 0;
								p_timing->IHFreq = 0;
								p_timing->IHTotal = 0;
								p_timing->IVTotal = 0;
								p_timing->ucMode_Table_Index = Mode_Table_Init_Index;
							}
							if (get_ADC_Global_Status() == SRC_CONNECT_DONE) {
								ADC_OnlineMeasureError_Handler(get_ADC_Input_Source());
								Set_Reply_Zero_Timing_Flag(VSC_INPUTSRC_ADC, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/
								ADC_set_detect_flag(TRUE);
							}
							up(get_adc_detectsemaphore());
						}
						else if(srctype  == VSC_INPUTSRC_HDMI)
						{//Need to rerun scaler
							reset_hdmi_timing_ready();
							vfe_hdmi_drv_handle_on_line_measure_error(0);
							down(get_hdmi_detectsemaphore());
							if (get_HDMI_Global_Status() == SRC_CONNECT_DONE) {
								Set_Reply_Zero_Timing_Flag(VSC_INPUTSRC_HDMI, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/
								HDMI_set_detect_flag(TRUE);
							}
							up(get_hdmi_detectsemaphore());
						}
						else if(srctype  == VSC_INPUTSRC_AVD)
						{//Need to rerun scaler
							/*//no need because AVD don't stop detect task
							down(get_vdc_detectsemaphore());
							if (get_AVD_Global_Status() == SRC_CONNECT_DONE) {
								VDC_set_detect_flag(TRUE);
							}
							up(get_vdc_detectsemaphore());
							*/
							reset_avd_timing_ready();
							Set_Reply_Zero_Timing_Flag(KADP_VSC_INPUTSRC_AVD, REPORT_ZERO_TIMING);/*Let Webos get zero timing*/
						}
						I3DDMA_Setup3DDMA(&i3ddmaCtrl, I3DDMA_3D_OPMODE_DISABLE,SLR_MAIN_DISPLAY);
                        update_vsc_task_status(0, VSC_I3DDMA_DRIVE);
                        continue;
					}
					else
					{
						/*stored for iv2pv delay(i3ddma and vodma) setting at gamemode*/
						//printk("[qiangzhou22]SLR_INPUT_MODE_CURR = %d\n",Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR));
						Set_GamemodeSaveI3ddmaGetcurMode(Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR));
					    up(&Force_Run_Idma_Semaphore);
						pr_notice("\r\n########func:%s force i3ddma_success (modeidx: %d)##########\r\n", __FUNCTION__, Scaler_DispGetInputInfo(SLR_INPUT_MODE_CURR));
						port = 0;
                        update_vsc_task_status(0, VSC_I3DDMA_DRIVE);
					}
				}
				else
				{
					if(srctype != VSC_INPUTSRC_AVD)	//for vdec, jpeg case
						set_force_i3ddma_enable(false);
					set_i3ddma_4k120_flag(0);//not hdmi2.0 4k120 case
				}
			}
			sync_pc_mode_info();//this position  scaler info is from input source

			if(srctype == VSC_INPUTSRC_HDMI)
			{
				down(&SetMainOutPutRegion_Semaphore);
				DbgSclrFlgTkr.main_opensourceID = _UNKNOWN_INPUT;
				set_source_info_forPQ(SLR_MAIN_DISPLAY);
				up(&SetMainOutPutRegion_Semaphore);
			}
#endif

#ifdef CONFIG_FORCE_RUN_I3DDMA
			if(((srctype == VSC_INPUTSRC_VDEC || srctype == VSC_INPUTSRC_JPEG) && ((DbgSclrFlgTkr.Main_force_frc_flag == FALSE)&&(DbgSclrFlgTkr.Main_force_frc_fs_flag==FALSE)))
				|| (((srctype == VSC_INPUTSRC_ADC) || (srctype == VSC_INPUTSRC_HDMI) || (srctype == VSC_INPUTSRC_AVD && (get_AVD_Input_Source() != _SRC_TV))) && get_force_i3ddma_enable(SLR_MAIN_DISPLAY))
				)
#else
			if ((srctype == VSC_INPUTSRC_VDEC || srctype == VSC_INPUTSRC_JPEG) && ((DbgSclrFlgTkr.Main_force_frc_flag == FALSE)&&(DbgSclrFlgTkr.Main_force_frc_fs_flag==FALSE)))
#endif
			{
                update_vsc_task_status(1, VSC_WAIT_VO_INFO);
				if(vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY))
					timeout = 300;
                else if(srctype == VSC_INPUTSRC_JPEG)
					timeout = 500;
				else
					timeout = 200;
				while (timeout--) {
					if(DbgSclrFlgTkr.Main_Scaler_Stop_flag) {
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "\r\n####VO already disconnet#####\r\n");
						break;
					}
					if(get_vo_change_flag(port)) {
						break;
					}
					if((get_ori_rotate_mode() != get_rotate_mode() || rotate_mode != rotate_mode_pre)&&(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE)==_MODE_STATE_ACTIVE)){
						break;
					}
					msleep(10);
				}
#if 0	//Eric@20180315 APVR do not go i2rnd flow
#ifdef CONFIG_I2RND_ENABLE
				//for APVR and ATV channel changing stage, avoid the race condition issue. @Crixus 20160823
				if((Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_TRIGGER_RUN_MAIN)){
					vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_I3DDMA_RPC;
					//printk(KERN_EMERG"[%s][%d]vsc_i2rnd_main_rerun_stage = %d!!!!\n",__FUNCTION__, __LINE__, vsc_i2rnd_atv_main_rerun_stage);
				}
#endif
#endif
				vsc_adaptivestream_calc_outregion(SLR_MAIN_DISPLAY);

				if((srctype == VSC_INPUTSRC_VDEC) || (srctype == VSC_INPUTSRC_JPEG))
					rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "####Go VO case. timeout:%d#####\r\n", timeout);
				else if(timeout <= 0)
					rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "####Go i3ddma case. timeout err#####\r\n");


				if((srctype == VSC_INPUTSRC_VDEC) && !DbgSclrFlgTkr.Main_Scaler_Stop_flag)
				{
					DbgSclrFlgTkr.Main_during_scalerflow_flag = TRUE;//WOSQRTK-7524 patch. Avoid webos call mute off during scaler flow
				}

                update_vsc_task_status(0, VSC_WAIT_VO_INFO);
			}
#if 0
            if(DbgSclrFlgTkr.Main_force_frc_fs_flag) {
				down(&SetMainOutPutRegion_Semaphore);
				DbgSclrFlgTkr.Main_force_frc_fs_flag=FALSE;
				up(&SetMainOutPutRegion_Semaphore);
			}
#endif
#ifdef SPEEDUP_NEW_SCALER_FLOW
			if((srctype == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
#else
			if(srctype ==VSC_INPUTSRC_AVD)
#endif
			{
				// If signal is locked, needs to wait VDC_DETECT_STAGE_FINAL
				if((Scaler_AVD_GetDetectStage() == VDC_DETECT_STAGE_FINAL) || (drvif_video_status_reg(VDC_no_signal)==1)
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
					|| 	decide_auto_scaler_run(SLR_MAIN_DISPLAY)
#endif
					) // Need wait detect ready. (0 == vdc_LockStatus) means snow screen

				{
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
					if(!DbgSclrFlgTkr.Main_Scaler_Stop_flag)
#else
					if(!DbgSclrFlgTkr.Main_Output_Set_flag && !DbgSclrFlgTkr.Main_Scaler_Stop_flag && !DbgSclrFlgTkr.Main_Run_Scaler_flag)
#endif
					{
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
						if(get_AVD_Input_Source() == _SRC_TV)
							rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "####[%s(%d)] Main path VSC_Src:KADP_VSC_INPUTSRC_AVD(ATV)####\n",__func__,__LINE__);
#endif
                        update_vsc_task_status(1, VSC_ATV_WAIT_STABLE);
						if (0 == drvif_video_status_reg(VDC_no_signal))
						{
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
							if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
							{
								if(check_atv_mode_id_change()||Scaler_AVD_CheckATVTimingChange(SLR_MAIN_DISPLAY)) {
									Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
									if(get_AVD_Input_Source() == _SRC_TV)
										rtd_printk(KERN_INFO, TAG_NAME_VSC, "#######[%s(%d)] Switch ATV different format##########\n",__func__,__LINE__);
								} else {
									if(get_AVD_Input_Source() == _SRC_TV)
										rtd_printk(KERN_INFO, TAG_NAME_VSC, "#######[%s(%d)] Switch ATV same format########## \n",__func__,__LINE__);

									modestate_set_fll_running_flag(_ENABLE);
								}
							}
#else
							if(Scaler_AVD_CheckATVTimingChange(SLR_MAIN_DISPLAY)) {
								Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
								if(get_AVD_Input_Source() == _SRC_TV)
									rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "#######Switch ATV different format##########\r\n");
							} else {
								if(get_AVD_Input_Source() == _SRC_TV)
									rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "#######Switch ATV same format##########\r\n");
								modestate_set_fll_running_flag(_ENABLE);
							}
#endif
						}
						else
						{
							rtd_printk(KERN_INFO, TAG_NAME_VSC, "####[%s(%d)] vsc_scaler_tsk  ATV no-signal,SLR_INPUT_STATE=%d\n",__func__,__LINE__,Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE));

							if(drvif_module_vdc_read_scan_flag()&&Scaler_AVD_GetAutoTuneCheck()){
								rtd_printk(KERN_INFO, TAG_NAME_VSC, "####[%s(%d)] search mode\n",__func__,__LINE__);
								Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);
							}
						}
                        update_vsc_task_status(0, VSC_ATV_WAIT_STABLE);
						if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_SEARCH) {
							rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "####[%s(%d)] _MODE_STATE_SEARCH #####\n",__func__,__LINE__);
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
							if(!DbgSclrFlgTkr.Main_Scaler_Stop_flag)
#else
							if(!DbgSclrFlgTkr.Main_Output_Set_flag && !DbgSclrFlgTkr.Main_Scaler_Stop_flag && !DbgSclrFlgTkr.Main_Run_Scaler_flag)
#endif
							{
#ifdef CONFIG_FORCE_RUN_I3DDMA
								if(get_AVD_Input_Source() == _SRC_TV)
								{
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
									rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "####[%s(%d)] Main path VSC_Src:VSC_INPUTSRC_AVD(ATV)#####\n",__func__,__LINE__);
#endif
                                    if(drvif_module_vdc_read_scan_flag()&&Scaler_AVD_GetAutoTuneCheck()){
                                        rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "####[%s(%d)] reset Scaler_AVD_SetAutoTuneCheck #####\n",__func__,__LINE__);
                                        Scaler_AVD_SetAutoTuneCheck(false);
                                    }

                                    update_vsc_task_status(1, VSC_I3DDMA_DRIVE);
                                    set_vsc_run_pc_mode(0);//save vsc run pc mode or not
								    down(&Force_Run_Idma_Semaphore);
									set_force_i3ddma_enable(TRUE);
                                    #ifdef CONFIG_ENABLE_HDMI_NN
									set_i3ddma_NN_flag(1);
									#endif

									#ifdef CONFIG_ENABLE_HDMI_NN
									vsc_chcek_nn_cap_status();
									#endif
									if(scaler_atv_force_run_idma()) {
										up(&Force_Run_Idma_Semaphore);
										port = 0;
										timeout = 200;
										while (timeout--) {
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
											if(DbgSclrFlgTkr.Main_Scaler_Stop_flag)
#else
											if(DbgSclrFlgTkr.Main_Scaler_Stop_flag || DbgSclrFlgTkr.Main_Output_Set_flag || DbgSclrFlgTkr.Main_Run_Scaler_flag)
#endif
											{
												rtd_printk(KERN_INFO, TAG_NAME_VSC, "####[%s(%d)]avd already disconnet#####\r\n",__func__,__LINE__);
												break;
											}
											if(get_vo_change_flag(port)) {
												rtd_printk(KERN_INFO, TAG_NAME_VSC, "####[%s(%d)]vo change flag#####\r\n",__func__,__LINE__);
												break;
											}
											msleep(1);
										}
#ifdef CONFIG_I2RND_ENABLE
										//for APVR and ATV channel changing stage, avoid the race condition issue. @Crixus 20160823
										if((Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_TRIGGER_RUN_MAIN)){
											vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_I3DDMA_RPC;
											//printk(KERN_EMERG"[%s][%d]vsc_i2rnd_main_rerun_stage = %d!!!!\n",__FUNCTION__, __LINE__, vsc_i2rnd_atv_main_rerun_stage);
										}
#endif
                                        update_vsc_task_status(0, VSC_I3DDMA_DRIVE);
										if(timeout <= 0)
											rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "#####[%s(%d)]Go ATV VO case. timeout err#####\r\n",__func__,__LINE__);

									} else {
										if(!DbgSclrFlgTkr.Main_Scaler_Stop_flag) {	//if not disconnected
											set_force_i3ddma_enable(FALSE);
											Scaler_Send_VoDisconnect_VOMDA(KADP_VO_VSC_SRC_HDMI, 0xfa);
											rtd_printk(KERN_INFO, TAG_NAME_VSC, "####[%s(%d)]Main_Scaler_Stop_flag is false.#####\r\n",__func__,__LINE__);
										}
										up(&Force_Run_Idma_Semaphore);
                                        update_vsc_task_status(0, VSC_I3DDMA_DRIVE);
									}
									//if(DbgSclrFlgTkr.Main_Scaler_Stop_flag)
										//set_force_i3ddma_enable(FALSE);
								}
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
								if(!DbgSclrFlgTkr.Main_Scaler_Stop_flag && get_force_i3ddma_enable(SLR_MAIN_DISPLAY))
#else
								if(!DbgSclrFlgTkr.Main_Output_Set_flag && !DbgSclrFlgTkr.Main_Scaler_Stop_flag && !DbgSclrFlgTkr.Main_Run_Scaler_flag)
#endif
								{
                                    update_vsc_task_status(1, VSC_ATV_SCALER);
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
									set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, TRUE);
									rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "#####[%s(%d)] run scaler start:%d %d#####\n", __func__, __LINE__, DbgSclrFlgTkr.Main_Run_Scaler_flag, decide_auto_scaler_run(SLR_MAIN_DISPLAY));

									down(&SetMainOutPutRegion_Semaphore);
									DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = TRUE;
									up(&SetMainOutPutRegion_Semaphore);
									set_avd_start_need_compensation(TRUE);
#endif
									down(&VSC_Semaphore);
									pr_debug("\r\n####atv run scaler flow#####\r\n");

									rtk_output_connect(SLR_MAIN_DISPLAY); // different format to go normal scaler
#ifdef CONFIG_I2RND_ENABLE
									//for APVR and ATV channel changing stage, avoid the race condition issue. @Crixus 20160823
									if((Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_I3DDMA_RPC)){
										vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_RERUN_MAIN_DONE;
										//printk(KERN_EMERG"[%s][%d]vsc_i2rnd_main_rerun_stage = %d!!!!\n",__FUNCTION__, __LINE__, vsc_i2rnd_atv_main_rerun_stage);
									}

									//send RPC let video fw do not write to memory after i2rnd donw @Crixus 20160808
									//i2rnd_send_table_idx(I2RND_TABLE_OFF);
#endif
									up(&VSC_Semaphore);
                                    update_vsc_task_status(0, VSC_ATV_SCALER);

								}
								else if((DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE) && DbgSclrFlgTkr.Main_Output_Set_flag) {
									DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;// Set output again, switch channel
								}
#else//#ifdef CONFIG_FORCE_RUN_I3DDMA
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
								if(get_AVD_Input_Source() == _SRC_TV)
									rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "####[%s(%d)] Main path VSC_Src:VSC_INPUTSRC_AVD(ATV)#####\n",__func__,__LINE__);
								set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, TRUE);
								rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "###[%s(%d)] run scaler start:%d %d#####\r\n",__func__,__LINE__, DbgSclrFlgTkr.Main_Run_Scaler_flag, decide_auto_scaler_run(SLR_MAIN_DISPLAY));
								down(&SetMainOutPutRegion_Semaphore);
								DbgSclrFlgTkr.main_VO_smoothtoggle_need_presetting = TRUE;
								up(&SetMainOutPutRegion_Semaphore);
								set_avd_start_need_compensation(TRUE);
#endif
								down(&VSC_Semaphore);
								rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "####atv run scaler flow#####\r\n");
								rtk_output_connect(SLR_MAIN_DISPLAY); // different format to go normal scaler
								up(&VSC_Semaphore);
#endif//#ifdef CONFIG_FORCE_RUN_I3DDMA
							} else if((DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE) && DbgSclrFlgTkr.Main_Output_Set_flag) {
								DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;// Set output again, switch channel
							}
						} else {
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
							if(((Scaler_AVD_GetDetectStage() == VDC_DETECT_STAGE_FINAL) || (drvif_video_status_reg(VDC_no_signal) == 1)) && !DbgSclrFlgTkr.Main_Scaler_Stop_flag)
#endif
							{
                                update_vsc_task_status(1, VSC_ATV_SMOOTHTOGGLE);
#ifdef SPEEDUP_NEW_SCALER_FLOW_FOR_ATV
								set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, TRUE);
								down(&SetMainOutPutRegion_Semaphore);
								DbgSclrFlgTkr.Main_Run_Scaler_flag = FALSE;
								DbgSclrFlgTkr.Main_Output_Set_flag = FALSE;
								Scaler_DispWindowSet(main_dispwin);
								up(&SetMainOutPutRegion_Semaphore);
								set_avd_start_need_compensation(TRUE);
								avd_start_compensation();

#endif
								if(!DbgSclrFlgTkr.Main_Output_Set_flag && !DbgSclrFlgTkr.Main_Scaler_Stop_flag && !DbgSclrFlgTkr.Main_Run_Scaler_flag){
									rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "####atv run smooth toggle flow#####\r\n");
									down(&VSC_Semaphore);
									Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
									//before ATV smooth toggle flow, sync start address. @Crixus 20161019
									//send_memory_mapping_for_adaptive_streaming();
#ifdef CONFIG_ENABLE_VD_27MHZ_MODE
									//Scaler_InputRegionType_Set(SLR_MAIN_DISPLAY,hal_main_InputRegionType);
									//zoom_imd_smooth_toggle_config(VIDEO_WID_0, main_dispwin.srcx, main_dispwin.srcy,
										//main_dispwin.src_wid, main_dispwin.src_height, ZOOM_DISP);
									zoom_imd_smooth_toggle_config(VIDEO_WID_0, getInputRegionType(VIDEO_WID_0), main_input_size, main_input_timing, main_dispwin);
#else
									//zoom_imd_smooth_toggle_config(VIDEO_WID_0, main_dispwin.srcx, main_dispwin.srcy,
									//	main_dispwin.src_wid, main_dispwin.src_height, ZOOM_DISP);
									zoom_imd_smooth_toggle_config(VIDEO_WID_0, getInputRegionType(VIDEO_WID_0), main_input_size, main_input_timing, main_dispwin);
#endif
									up(&VSC_Semaphore);


									if (FALSE == CheckAVDandWebOSInfo(SLR_MAIN_DISPLAY))
									{
										rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
										rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "CheckAVDandWebOSInfo() fail\n");

										if (0xff == DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount)
										{
											rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Set DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount = 0\n");
											DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount = 0;
										}

										DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount++;

										if(DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE && DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount < CHECK_AVD_WEBOS_INFO_TIMEOUT){
											DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;// Set output again, switch channel
										}
										else
										{
											rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount timeout\n");
											DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount = 0xff;
										}
									}
									else
									{
										rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
										rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "CheckAVDandWebOSInfo ok, DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount=%d\n", DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount);
										DbgSclrFlgTkr.g_ucCheckAVDandWebOSInfoCount = 0xff;
									}


									if(!DbgSclrFlgTkr.Main_Scaler_Stop_flag && !DbgSclrFlgTkr.Main_Output_Set_flag && !DbgSclrFlgTkr.Main_Run_Scaler_flag)
									{
										if(wait_atv_stable_for_bg(SLR_MAIN_DISPLAY,__func__,__LINE__) == FALSE)
										{
											if((DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE) && DbgSclrFlgTkr.Main_Output_Set_flag){
												rtd_printk(KERN_INFO, TAG_NAME_VSC, "####[%s(%d)] #####\r\n",__FUNCTION__, __LINE__);
												DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE; // Set output again, switch channel
											}

											if((DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE)
												&&(get_AVD_Input_Source() == _SRC_TV)
												&&((drvif_module_vdc_GetLockStatus() == 0)||(drvif_module_vdc_OutputStable()==FALSE)||(Scaler_AVD_GetDetectStage() != VDC_DETECT_STAGE_FINAL))
												&&(0 == drvif_video_status_reg(VDC_no_signal))){
												rtd_printk(KERN_INFO, TAG_NAME_VSC, "####[%s(%d)] #####\r\n",__FUNCTION__, __LINE__);
												DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;
											}
										} else {
											if(!DbgSclrFlgTkr.Main_Scaler_Stop_flag) {
												Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);

												if ((get_AVD_Input_Source() == _SRC_TV)
													&&(DbgSclrFlgTkr.g_ucVSCCheckATVChanelChange == TRUE)
													&&(Scaler_AVD_GetVDPreMode() != _MODE_UNKNOWN)
													&&(drvif_module_vdc_OutputStable() == FALSE)
													&&(1 == drvif_module_vdc_GetLockStatus())){
													rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"#####[%s(%d)]set output again\n", __func__, __LINE__);
													DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE; // Set output again, switch channel
												}else{
													wait_DI_ready();//wait DI ready
													if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY))
													{
														rtd_printk(KERN_INFO, TAG_NAME_VSC, "####[%s(%d)] disable arc mask\r\n",__func__, __LINE__);
														set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_SIG_ARC_READY, FALSE);//display arc ready mask, becasue we already apply ARC
													}

                                                    if(vbe_disp_oled_orbit_enable)
													{
														ScalerForceUpdateOrbit(1);

														rtd_printk(KERN_INFO, TAG_NAME_VSC, "####[%s(%d)] enable orbit mask\n",__func__, __LINE__);
														set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_ORBIT_READY, TRUE);//Set orbit mask
													}
													trigger_mute_off(SLR_MAIN_DISPLAY, 1);
												}
											}

#ifdef _PRINT_VSC_COST_TIME_AFTER_MUTE_OFF
											cost_time = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg)/90 - cost_time;
											rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####vsc cost time:%d ms after mute off atv smooth toggle####\r\n", cost_time);
#endif
										}
									} else if((DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE) && DbgSclrFlgTkr.Main_Output_Set_flag) {
										DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;// Set output again, switch channel
									}

								}
								else if((DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE) && DbgSclrFlgTkr.Main_Output_Set_flag) {
									DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;// Set output again, switch channel
								}

                                update_vsc_task_status(0, VSC_ATV_SMOOTHTOGGLE);

							}


						}
					} else {
						if((DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE) && DbgSclrFlgTkr.Main_Output_Set_flag)
							DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;// Set output again, switch channel
					}
				} else {

					if(DbgSclrFlgTkr.Main_Scaler_Stop_flag == FALSE)
						DbgSclrFlgTkr.Main_Run_Scaler_flag = TRUE;// Set output again, switch channel
				}

			} else {
				if(!DbgSclrFlgTkr.Main_Scaler_Stop_flag) {
                    update_vsc_task_status(1, VSC_NON_ATV_MAIN_SCALER);
					down(&VSC_Semaphore);
					rtk_output_connect(SLR_MAIN_DISPLAY);
#ifdef CONFIG_I2RND_ENABLE
					//for APVR and ATV channel changing stage, avoid the race condition issue. @Crixus 20160823
					if((Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_I3DDMA_RPC)){
						vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_RERUN_MAIN_DONE;
						//printk(KERN_EMERG"[%s][%d]vsc_i2rnd_main_rerun_stage = %d!!!!\n",__FUNCTION__, __LINE__, vsc_i2rnd_atv_main_rerun_stage);
					}

					//send RPC let video fw do not write to memory after i2rnd donw @Crixus 20160808
					//i2rnd_send_table_idx(I2RND_TABLE_OFF);
#endif
					up(&VSC_Semaphore);
                    update_vsc_task_status(0, VSC_NON_ATV_MAIN_SCALER);

				}
			}
			if (DbgSclrFlgTkr.main_winfreeze) {
				Scaler_SetFreeze(SLR_MAIN_DISPLAY, DbgSclrFlgTkr.main_winfreeze);
			}
			DbgSclrFlgTkr.main_winfreeze=0;
		} else if ((DbgSclrFlgTkr.OuputDisplayMode == TRUE)  && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)) {
#ifndef BRING_UP_AUTO_FLOW
			update_vsc_task_status(1, VSC_MAIN_CHECK_MODE);
			rtk_check_signal(SLR_MAIN_DISPLAY);
			update_vsc_task_status(0, VSC_MAIN_CHECK_MODE);
#endif
		}
		if (freezing(current))
        {
            update_vsc_task_status(1, VSC_FREEZE_DISABLE_MAIN_IP);
			fw_scalerip_disable_onlyip(SLR_MAIN_DISPLAY);
            update_vsc_task_status(0, VSC_FREEZE_DISABLE_MAIN_IP);
#ifdef CONFIG_DUAL_CHANNEL
            update_vsc_task_status(1, VSC_FREEZE_DISABLE_SUB_IP);
			fw_scalerip_disable_onlyip(SLR_SUB_DISPLAY);
            update_vsc_task_status(0, VSC_FREEZE_DISABLE_SUB_IP);
#endif
			try_to_freeze();
        }

#ifdef CONFIG_DUAL_CHANNEL
		if(DbgSclrFlgTkr.Sub_Reset_Mode_flag)
		{
            update_vsc_task_status(1, VSC_SUB_RESET_MODE);
			down(&Sub_ResetMode_Semaphore);
			DbgSclrFlgTkr.Sub_Reset_Mode_flag = FALSE;
			up(&Sub_ResetMode_Semaphore);
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n#####func:%s DO Sub reset mode#####\r\n", __FUNCTION__);
			down(&VSC_Semaphore);
#ifdef CONFIG_I2RND_ENABLE
			Scaler_I2rnd_set_display(I2RND_TABLE_OFF);
			printk(KERN_EMERG"[%s]I2RND_TABLE_OFF in sub reset mode!!!!\n",__FUNCTION__);
#endif
			drvif_mode_resetmode(SLR_SUB_DISPLAY);//Reset Mode for sub
			up(&VSC_Semaphore);
            update_vsc_task_status(0, VSC_SUB_RESET_MODE);
		}
		else
		{
            update_vsc_task_status(1, VSC_SUB_BBD_VGIP);
			check_bdb_vgip_driver_request(SLR_SUB_DISPLAY);
            update_vsc_task_status(0, VSC_SUB_BBD_VGIP);
		}

		if(Get_DisplayMode_Src(SLR_SUB_DISPLAY) != VSC_INPUTSRC_MAXN)
		{
			msleep(10);
		#if 1//sub
			// for sub smooth toggle test
			if(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE){
				if(DbgSclrFlgTkr.Sub_smooth_toggle_set_flag) {
                    update_vsc_task_status(1, VSC_SUB_SMOOTHTOGGLE);
					down(&SetSubOutPutRegion_Semaphore);
					Scaler_SetCurrentDispInfo(SLR_SUB_DISPLAY);
					DbgSclrFlgTkr.Sub_smooth_toggle_set_flag = FALSE;
					//DbgSclrFlgTkr.Sub_Scaler_Stop_flag = FALSE;
					//DbgSclrFlgTkr.Sub_Run_Scaler_flag = FALSE;
					up(&SetSubOutPutRegion_Semaphore);

					down(&VSC_Semaphore);
					set_input_for_vgip(SLR_SUB_DISPLAY, sub_input_size.srcx, sub_input_size.srcy, sub_input_size.src_wid, sub_input_size.src_height);
					Scaler_SubDispWindowSet(sub_dispwin);
					zoom_imd_smooth_toggle_config(SLR_SUB_DISPLAY, getInputRegionType(SLR_SUB_DISPLAY), sub_input_size, sub_input_timing, sub_dispwin);
					up(&VSC_Semaphore);
					if(!DbgSclrFlgTkr.Sub_OutputVencMode)
					{
						drvif_color_setpiprgbcontrastbrightness(0);//disable hidden
						trigger_mute_off(SLR_SUB_DISPLAY, 1);//trigger mute off. because previous is mute on from arc
					}
                    update_vsc_task_status(0, VSC_SUB_SMOOTHTOGGLE);
				}
			}
		#endif
			if (DbgSclrFlgTkr.Sub_Run_Scaler_flag && (DbgSclrFlgTkr.Sub_Scaler_Stop_flag == FALSE) && (DbgSclrFlgTkr.Sub_Reset_Mode_flag == FALSE)//wait vsc close reset mode ready
#ifdef CONFIG_I2RND_ENABLE
				&& ((((vsc_i2rnd_sub_stage == I2RND_STAGE_DISABLE) || (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_I2RND_FINISH))	//[K3LG-1721]Eric@0413 Fix sub not rerun scaler when NTSC switch to PAL
				//for APVR and ATV channel changing stage, avoid the race condition issue. @Crixus 20160823
				&& ((Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_AVD)/* && (get_AVD_Input_Source() == _SRC_TV)*/ && (Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_RERUN_MAIN_DONE)))
				//Eric@0606 Dual VDEC Needs to Run Sub Path
				|| ((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_SUB_DISABLE) || (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_FINISH))
				//PIP run sub-scaler path
				|| ((vsc_i2rnd_sub_stage == I2RND_STAGE_DISABLE) || (vsc_i2rnd_sub_stage == I2RND_STAGE_MAIN_I2RND_FINISH)))
#endif
				) {

				KADP_VIDEO_RECT_T tOutRegion, tInputRegion;
                update_vsc_task_status(1, VSC_SUB_PRE_CHECK);
                set_current_scaler_source_num(SLR_SUB_DISPLAY);//record current vsc source num
				down(&SetSubOutPutRegion_Semaphore);
				DbgSclrFlgTkr.Sub_Run_Scaler_flag = FALSE;
				DbgSclrFlgTkr.Sub_Output_Set_flag = FALSE;


#ifdef CONFIG_I2RND_ENABLE
				Scaler_I2rnd_set_display(I2RND_SUB_S1_TABLE);
				printk(KERN_EMERG"[%s]I2RND_SUB_S1_TABLE!!!!\n",__FUNCTION__);
#endif
				set_input_for_vgip(SLR_SUB_DISPLAY, sub_input_size.srcx, sub_input_size.srcy, sub_input_size.src_wid, sub_input_size.src_height);
				set_input_for_crop(SLR_SUB_DISPLAY, sub_input_size);
				set_input_timing_for_crop(SLR_SUB_DISPLAY, sub_input_timing);
				Scaler_InputRegionType_Set(SLR_SUB_DISPLAY,getInputRegionType(SLR_SUB_DISPLAY));
				Scaler_SubDispWindowSet(sub_dispwin);

				rtk_hal_vsc_GetInputRegion(SLR_SUB_DISPLAY, &tInputRegion);
				rtk_hal_vsc_GetOutputRegion(SLR_SUB_DISPLAY, &tOutRegion);

				up(&SetSubOutPutRegion_Semaphore);
                update_vsc_task_status(0, VSC_SUB_PRE_CHECK);
				srctype = Get_DisplayMode_Src(SLR_SUB_DISPLAY);

				switch(srctype)
				{
					case VSC_INPUTSRC_AVD:
						if(get_AVD_Input_Source() != _SRC_TV)
							rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "####Sub path VSC_Src:VSC_INPUTSRC_AVD(AV)#####\r\n");
					break;

					case VSC_INPUTSRC_ADC:
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "####Sub path VSC_Src:VSC_INPUTSRC_ADC#####\r\n");
					break;

					case VSC_INPUTSRC_HDMI:
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "####Sub path VSC_Src:VSC_INPUTSRC_HDMI#####\r\n");
					break;

					case VSC_INPUTSRC_VDEC:
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "####Sub path VSC_Src:VSC_INPUTSRC_VDEC#####\r\n");
					break;

					case VSC_INPUTSRC_JPEG:
						rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "####Sub path VSC_Src:VSC_INPUTSRC_JPEG#####\r\n");
					break;

					default:
						break;
				}

				if((srctype == VSC_INPUTSRC_AVD) && (get_AVD_Input_Source() == _SRC_TV))
				{
					if((Scaler_AVD_GetDetectStage() == VDC_DETECT_STAGE_FINAL) || (0 == vdc_LockStatus))
					{//If APVR, need to wait main ready
						if(!DbgSclrFlgTkr.Sub_Output_Set_flag && !DbgSclrFlgTkr.Sub_Scaler_Stop_flag && !DbgSclrFlgTkr.Sub_Run_Scaler_flag) {
							rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "####Sub path VSC_Src:VSC_INPUTSRC_AVD(ATV)#####\r\n");
							#if 0
							rtd_printk(KERN_EMERG, TAG_NAME_VSC, "file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
							rtd_printk(KERN_EMERG, TAG_NAME_VSC, "rtk_hal_vsc_GetInputRegion InputRegion_x=%d, y=%d, w=%d, h=%d\n", tInputRegion.x, tInputRegion.y, tInputRegion.w, tInputRegion.h);
							rtd_printk(KERN_EMERG, TAG_NAME_VSC, "rtk_hal_vsc_GetOutputRegion OutputRegion_x=%d, y=%d, w=%d, h=%d\n", tOutRegion.x, tOutRegion.y, tOutRegion.w, tOutRegion.h);

							rtd_printk(KERN_EMERG, TAG_NAME_VSC, "Pre InputRegion_x=%d, y=%d, w=%d, h=%d\n", DbgSclrFlgTkr.Sub_ATV_InputRegion_x_pre, DbgSclrFlgTkr.Sub_ATV_InputRegion_y_pre, DbgSclrFlgTkr.Sub_ATV_InputRegion_w_pre, DbgSclrFlgTkr.Sub_ATV_InputRegion_h_pre);
							rtd_printk(KERN_EMERG, TAG_NAME_VSC, "Pre OutputRegion_x=%d, y=%d, w=%d, h=%d\n", DbgSclrFlgTkr.Sub_ATV_OutputRegion_x_pre, DbgSclrFlgTkr.Sub_ATV_OutputRegion_y_pre, DbgSclrFlgTkr.Sub_ATV_OutputRegion_w_pre, DbgSclrFlgTkr.Sub_ATV_OutputRegion_h_pre);

							rtd_printk(KERN_EMERG, TAG_NAME_VSC, "DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag=%x\n", DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag);
							rtd_printk(KERN_EMERG, TAG_NAME_VSC, "CompareATVInputOutputRegion()=%x\n", CompareATVInputOutputRegion(SLR_SUB_DISPLAY, &tOutRegion, &tInputRegion));
							#endif

							rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "file=%s, function=%s, line=%d\n", __FILE__, __FUNCTION__, __LINE__);
							rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag=%x\n", DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag);
							rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "CompareATVInputOutputRegion()=%x\n", CompareATVInputOutputRegion(SLR_SUB_DISPLAY, &tOutRegion, &tInputRegion));

                            update_vsc_task_status(1, VSC_ATV_SCALER);
							if (DbgSclrFlgTkr.Sub_ATV_Go_Smooth_Toggle_flag && CompareATVInputOutputRegion(SLR_SUB_DISPLAY, &tOutRegion, &tInputRegion))
							{
								rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "vsc_scaler_task ATV sub path don't run scaler flow\n");
								//rtd_printk(KERN_EMERG, TAG_NAME_VSC, "vsc_scaler_task ATV sub path don't run scaler flow\n");
							}
							else
							{
								rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Set ATV output/input pre\n");
								//rtd_printk(KERN_EMERG, TAG_NAME_VSC, "Set ATV output/input pre\n");

								DbgSclrFlgTkr.Sub_ATV_OutputRegion_x_pre = tOutRegion.x;
								DbgSclrFlgTkr.Sub_ATV_OutputRegion_y_pre = tOutRegion.y;
								DbgSclrFlgTkr.Sub_ATV_OutputRegion_w_pre = tOutRegion.w;
								DbgSclrFlgTkr.Sub_ATV_OutputRegion_h_pre = tOutRegion.h;

								DbgSclrFlgTkr.Sub_ATV_InputRegion_x_pre = tInputRegion.x;
								DbgSclrFlgTkr.Sub_ATV_InputRegion_y_pre = tInputRegion.y;
								DbgSclrFlgTkr.Sub_ATV_InputRegion_w_pre = tInputRegion.w;
								DbgSclrFlgTkr.Sub_ATV_InputRegion_h_pre = tInputRegion.h;


								rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####atv run sub scaler flow#####\r\n");
								down(&VSC_Semaphore);
								rtk_output_connect(SLR_SUB_DISPLAY); // different format to go normal scaler
								if(!DbgSclrFlgTkr.Sub_OutputVencMode)
									drvif_color_setpiprgbcontrastbrightness(0);//disable hidden
								Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
#ifdef CONFIG_I2RND_ENABLE
								//I2rnd sub=>vo RPC
								if(vsc_i2rnd_sub_stage == I2RND_STAGE_DETECT_SOURCE){
									vsc_i2rnd_sub_stage = I2RND_STAGE_SUB_VO_RPC;
									printk(KERN_EMERG"[I2RND]@@@@@@@@@@@@I2RND_STAGE_SUB_VO_RPC\n");
									//Scaler_I2rnd_set_display(I2RND_SUB_S1_TABLE);
									//i2rnd_send_table_idx(I2RND_SUB_S1_TABLE);
									//drvif_scaler_i2rnd_vodma_setting(SLR_SUB_DISPLAY, srctype);
									drivf_Sub_I2rnd_SetupVODMA();
									//i2rnd_debug();
									printk(KERN_EMERG"[I2RND]@@@@@@@@@@@@I2RND_STAGE_SUB_VO_RPC OK!!!!!\n");
								}
#endif
								up(&VSC_Semaphore);
#ifdef CONFIG_I2RND_ENABLE
								//for APVR and ATV channel changing stage, avoid the race condition issue. @Crixus 20160823
								if((Scaler_I2rnd_get_enable() == _ENABLE) && (vsc_i2rnd_atv_main_rerun_stage == I2RND_ATV_STAGE_RERUN_MAIN_DONE)){
									vsc_i2rnd_atv_main_rerun_stage = I2RND_ATV_STAGE_DISABLE;
								}
#endif
							}
                            update_vsc_task_status(0, VSC_ATV_SCALER);
						} else if((DbgSclrFlgTkr.Sub_Scaler_Stop_flag == FALSE) && DbgSclrFlgTkr.Sub_Output_Set_flag) {
							DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;// Set output again, switch channel
						}
					} else {

						if(DbgSclrFlgTkr.Sub_Scaler_Stop_flag == FALSE)
							DbgSclrFlgTkr.Sub_Run_Scaler_flag = TRUE;// Set output again, switch channel
					}
				} else {
					if(!DbgSclrFlgTkr.Sub_Scaler_Stop_flag) {
                        update_vsc_task_status(1, VSC_NON_ATV_SUB_SCALER);
						down(&VSC_Semaphore);
						rtk_output_connect(SLR_SUB_DISPLAY);
						if(!DbgSclrFlgTkr.Sub_OutputVencMode)
							drvif_color_setpiprgbcontrastbrightness(0);//disable hidden
						Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
#ifdef CONFIG_I2RND_ENABLE
						if((Scaler_I2rnd_get_timing_enable() == _ENABLE) && ((vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_SUB_CONNECT)) && (DbgSclrFlgTkr.Sub_Run_Scaler_flag == FALSE)){
							vsc_i2rnd_dualvo_sub_stage = I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1;
							printk(KERN_EMERG"[I2RND]@@@@@@@@@@@@I2RND_DUALVO_STAGE_RERUN_MAIN_FOR_S1@@@@@@@@@@\n");
							//check timing enable
							Scaler_I2rnd_wait_timing_enable();
							//disable s0 db_en when i2r timing enable @Crixus 20171219
							Scaler_I2rnd_set_display(I2RND_MAIN_S0_TABLE);
							set_zoom_reset_double_state(_DISABLE, SLR_MAIN_DISPLAY);//always disable double buffer
							//check di setting
							i2rnd_default_register_setting();
							//printk(KERN_EMERG"[%s][sub connect]I2RND default setting done\n", __FUNCTION__);
							scaler_i2rnd_run_main();

							//before disable sub fbg, need to check sub disconnect or not @Crixus 20180110
							if(DbgSclrFlgTkr.Sub_Scaler_Stop_flag){
								printk(KERN_EMERG"[I2RND]sub already disconnect, do not disable fbg!!\n");
							}
							else{
								//Disable main force cmd buffer flag after sub done because i2r enable at vo. @Crixus 20171128
								down(&I2RND_Semaphore);
								Scaler_I2rnd_set_force_cmd(_DISABLE);
								up(&I2RND_Semaphore);
								printk(KERN_EMERG"[I2RND]Disable main force cmd buffer flag after sub done.\n");
								if((Scaler_I2rnd_get_timing_enable() == _ENABLE) && (vsc_i2rnd_dualvo_sub_stage == I2RND_DUALVO_STAGE_RERUN_MAIN_DONE)){
									vsc_i2rnd_dualvo_sub_stage = I2RND_DUALVO_STAGE_RERUN_MAIN_FINISH;
									printk(KERN_EMERG"[I2RND]@@@@@@@@@@@@I2RND_DUALVO_STAGE_RERUN_MAIN_FINISH@@@@@@@@@@\n");
								}

								set_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_SIG_UNSTABLE, FALSE);//disable SLR_FORCE_BG_TYPE_SIG_UNSTABLE mask
								trigger_mute_off(SLR_SUB_DISPLAY, 1);

								//down(get_forcebg_semaphore());
								//scalerdisplay_force_bg_enable(SLR_SUB_DISPLAY, FALSE);
								//up(get_forcebg_semaphore());
								printk(KERN_EMERG"[I2RND] DualVO rerun main path done, disable fbg!!\n");
							}

							if ((vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY)) && (vo_timing_change_for_adaptive == 1)) {
								//Eric@20170922 update main structure info for adaptive stream
								Scaler_SET_VSCDispinfo_WithVFEDispinfo(SLR_MAIN_DISPLAY, Get_VO_Dispinfo(DisplayModeInputInfo.resourceIndex));
								vo_timing_change_for_adaptive = 0;
							}
						}

						//I2rnd sub=>vo RPC
						if(vsc_i2rnd_sub_stage == I2RND_STAGE_DETECT_SOURCE){
							vsc_i2rnd_sub_stage = I2RND_STAGE_SUB_VO_RPC;
							printk(KERN_EMERG"[I2RND]@@@@@@@@@@@@I2RND_STAGE_SUB_VO_RPC\n");
							//Scaler_I2rnd_set_display(I2RND_SUB_S1_TABLE);
							//i2rnd_send_table_idx(I2RND_SUB_S1_TABLE);
							//drvif_scaler_i2rnd_vodma_setting(SLR_SUB_DISPLAY, srctype);
							drivf_Sub_I2rnd_SetupVODMA();
							//i2rnd_debug();
							printk(KERN_EMERG"[I2RND]@@@@@@@@@@@@I2RND_STAGE_SUB_VO_RPC OK!!!!!\n");
						}
#endif
						up(&VSC_Semaphore);
                        update_vsc_task_status(0, VSC_NON_ATV_SUB_SCALER);

					}
				}
			} else if ((DbgSclrFlgTkr.Sub_OuputDisplayMode == TRUE) && (Get_Live_zoom_mode() == LIVE_ZOOM_OFF )
				&& (Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)) {
#ifndef BRING_UP_AUTO_FLOW

				update_vsc_task_status(1, VSC_SUB_CHECK_MODE);
				rtk_check_signal(SLR_SUB_DISPLAY);
				update_vsc_task_status(0, VSC_SUB_CHECK_MODE);
#endif
			}
		}
		if (freezing(current))
       	{
            update_vsc_task_status(1, VSC_FREEZE_DISABLE_MAIN_IP);
			fw_scalerip_disable_onlyip(SLR_MAIN_DISPLAY);
            update_vsc_task_status(0, VSC_FREEZE_DISABLE_MAIN_IP);
#ifdef CONFIG_DUAL_CHANNEL
            update_vsc_task_status(1, VSC_FREEZE_DISABLE_SUB_IP);
			fw_scalerip_disable_onlyip(SLR_SUB_DISPLAY);
            update_vsc_task_status(0, VSC_FREEZE_DISABLE_SUB_IP);
#endif
			try_to_freeze();
        }
#endif
		if (kthread_should_stop()) {
         	break;
      	}
    }
    rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####vsc_scaler_tsk: exit...####\n");
    do_exit(0);
    return 0;
}

/* Start
20170524 pinyen create new game mode tsk
*/
#ifdef BRING_UP_K4L_TEST
static bool new_game_mode_tsk_flag = FALSE;//Record new_game_mode_tsk status. True: Task is running
static struct task_struct *p_new_game_mode_tsk = NULL;

unsigned char get_new_game_mode_vdec_memc_bypass_condition(void){

	if( is_DTV_flag_get() && (!vsc_get_adaptivestream_flag(SLR_MAIN_DISPLAY))){
		// non vdec source need exclusive vdec_direct, so add  !adaptive stream flag
		return TRUE;
	}
	else
		return FALSE;
}

//to check the condition which can enter game mode or not
unsigned char get_new_game_mode_condition(void){
	 VSC_INPUT_TYPE_T srctype = Get_DisplayMode_Src(SLR_MAIN_DISPLAY);
	 mdomain_disp_ddr_mainctrl_RBUS ddr_mainctrl_reg;
	 ppoverlay_main_active_v_start_end_RBUS main_active_v_start_end_reg;
	 ddr_mainctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainCtrl_reg);
	 main_active_v_start_end_reg.regValue = IoReg_Read32(PPOVERLAY_MAIN_Active_V_Start_End_reg);
	if (((srctype == VSC_INPUTSRC_ADC) || (srctype == VSC_INPUTSRC_HDMI) ||((srctype == VSC_INPUTSRC_AVD)  && (get_AVD_Input_Source() != _SRC_TV)))
		/*Only support HDMI and Component and AV*/
		&& (Get_Live_zoom_mode()==LIVE_ZOOM_OFF)/*livezoom and magnifier not support single buffer mode*/
		&& !(vbe_disp_get_adaptivestream_fs_mode() && (ddr_mainctrl_reg.main_source_sel == 0x3))/*Adaptive stream & Data frame sync case do not set game mode!!*/
		&& !Get_Factory_SelfDiagnosis_Mode()/*factory self diagnosis grab pixel from third buffer,so not support single buffer mode*/
		/*&& !Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC)*//*Data frame sync do not set game mode*/
		&& (get_HDMI_HDR_mode() != HDR_DOLBY_HDMI)/*20170908, pinyen add dolby hdmi case should set iv2pv delay default value*/
		&& !((main_active_v_start_end_reg.mv_act_end - main_active_v_start_end_reg.mv_act_sta) < _DISP_LEN)
	){
		return TRUE;
	}
	else{
		return FALSE;
	}
}

//gamemode case, when bypass memc and timing framerate < 50, let vo output 50/60,for this we need rerun scaler
unsigned char scaler_vsc_need_rerun_for_gamemode(void)
{
	unsigned char result = FALSE;
#ifdef CONFIG_MEMC_BYPASS
	unsigned int source_freq = scaler_vsc_get_external_src_vfreq();
	if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && (source_freq <= 310) && drv_memory_get_game_mode()) {
	       result = TRUE;
	}
#endif
	return result;
}

// FixMe, 20190925
extern void MEMC_LibBlueScreen(unsigned char is_BlueScreen);
static int new_game_mode_tsk(void *p)//This task run new_game_mode_tsk
{
//    int ret = 0;
    rtd_printk(KERN_DEBUG, TAG_NAME_NEW_GAME_MODE, "new_game_mode_tsk()\n");
    //printk(KERN_EMERG "new_game_mode_tsk()\n");
	current->flags &= ~PF_NOFREEZE;
    while (1)
    {
    		msleep(10);//need to switch

		if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE && (get_scaler_stop_flag(SLR_MAIN_DISPLAY)==FALSE)){
#if 0
			if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && (vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag())){
				drv_memory_set_game_mode_dynamic(_DISABLE);
				game_mode_cmd_pre = game_mode_cmd_check;	//Update game_mode_cmd_pre to avoid fll task break.
				st_game_mode_cmd_pre = smooth_toggle_game_mode_check_cnt;
			}
#endif
			if(smooth_toggle_game_mode_timeout_trigger_flag == _ENABLE)
			{
				pr_debug("gamemode task break for scaler trigger smooth toggle\n");
				continue;
			}

			//game mode dynamic checking
			if(drv_memory_get_game_mode_dynamic() != drv_memory_get_game_mode_flag())
			{
				if(drv_memory_get_game_mode_dynamic() == _ENABLE){
					drv_memory_set_game_mode(_ENABLE);
				} else {
					drv_memory_set_game_mode(_DISABLE);
				}

				if (get_new_game_mode_condition())
				{/*qiangzhou:only need run av hdmi ypp, DTV ATV Playback,CP no need run these*/
					/*
						New Game Mode Flow: Seprate the game mode setting with scaler flow.
						Enter game mode:
							change to timing frame sync => Iv2dv delay done => change to 1-buffer.

						Exit game mode:
							change to timing free run => change to 3-buffer => Iv2dv delay => change to timing FLL
					*/

					rtd_printk(KERN_EMERG, TAG_NAME_NEW_GAME_MODE,"[Started]New game mode flow!!\n");
                    if(scaler_vsc_check_gamemode_force_framerate_condition() || scaler_vsc_need_rerun_for_gamemode()){
                        unsigned int scaler_freq = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ);
                        rtd_printk(KERN_EMERG, TAG_NAME_NEW_GAME_MODE,"gamemode_force_framerate_condition++\n");
                        if(((scaler_freq>1195)&&(scaler_freq<1205))||
                           ((scaler_freq>995)&&(scaler_freq<1005)))
                        {
                            if(drv_memory_get_game_mode_dynamic()==TRUE){
                                //game mode timing correct, no act and reset counter
                                scaler_vsc_reset_gamemode_rerun_count();
                            }else{
                                //exit game mode, need re-run
                                scaler_vsc_reset_gamemode_rerun_count();
                                down(&GameMode_Check_Semaphore);
								DbgSclrFlgTkr.game_mode_dynamic_flag = TRUE;
								DbgSclrFlgTkr.game_mode_rerun_scaler_flag = TRUE;
                                set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_GameMode, TRUE);
                                down(get_forcebg_semaphore());
                                scalerdisplay_force_bg_enable(SLR_MAIN_DISPLAY, TRUE);
                                up(get_forcebg_semaphore());
                                up(&GameMode_Check_Semaphore);
                                down(&VSC_Semaphore);
                                rtd_printk(KERN_EMERG, TAG_NAME_NEW_GAME_MODE,"exit re-run flow++++\n");
                                Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
                                drvif_mode_dma_onlinemeasure_setting(FALSE, FALSE);//Disable online measure watchdog and interrupt
                                drvif_mode_disable_dma_onlinemeasure();//Disable online measure
                                Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);//Let main path to search state. In order to request VO
                                DbgSclrFlgTkr.Main_Run_Scaler_flag = 1;
                                up(&VSC_Semaphore);

                                down(&GameMode_Check_Semaphore);
								DbgSclrFlgTkr.game_mode_dynamic_flag = FALSE;
								up(&GameMode_Check_Semaphore);
                                continue;
                            }
                        }else{
                            if(drv_memory_get_game_mode_dynamic()==TRUE){
                                if(scaler_vsc_get_gamemode_rerun_count()>0){
                                    rtd_printk(KERN_ERR, TAG_NAME_NEW_GAME_MODE,"gamemode_rerun_count(%d),ingore.\n",scaler_vsc_get_gamemode_rerun_count());
                                }else{
                                    //enter game mode, need re-run
                                    down(&GameMode_Check_Semaphore);
									//prevent gamemode unmute task disable forcebg
									//KTASKWBS-13911, forcebg by gamemode=>vsc_semaphore+ =>scaler done=>gamemode unmute disable bg=>
									//vsc_semaphore- => scaler re-runflow show garbage
									DbgSclrFlgTkr.game_mode_dynamic_flag = TRUE;
									DbgSclrFlgTkr.game_mode_rerun_scaler_flag = TRUE;
                                    set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_GameMode, TRUE);
                                    down(get_forcebg_semaphore());
                                    scalerdisplay_force_bg_enable(SLR_MAIN_DISPLAY, TRUE);
                                    up(get_forcebg_semaphore());
                                    up(&GameMode_Check_Semaphore);
                                    //check smooth toggle already done
									Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
                                    down(&VSC_Semaphore);
                                    rtd_printk(KERN_EMERG, TAG_NAME_NEW_GAME_MODE,"enter re-run flow++++\n");
                                    drvif_mode_dma_onlinemeasure_setting(FALSE, FALSE);//Disable online measure watchdog and interrupt
                                    drvif_mode_disable_dma_onlinemeasure();//Disable online measure
                                    Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE, _MODE_STATE_SEARCH);//Let main path to search state. In order to request VO
                                    DbgSclrFlgTkr.Main_Run_Scaler_flag = 1;
                                    scaler_vsc_increase_gamemode_rerun_count();
                                    up(&VSC_Semaphore);
                                    down(&GameMode_Check_Semaphore);
									DbgSclrFlgTkr.game_mode_dynamic_flag = FALSE;
									up(&GameMode_Check_Semaphore);
                                    continue;
                                }
                            }else{
                                //exit game mode timing correct, no act
                                scaler_vsc_reset_gamemode_rerun_count();
                            }
                        }
                        rtd_printk(KERN_EMERG, TAG_NAME_NEW_GAME_MODE,"gamemode_force_framerate_condition--\n");
                    }
                    else{
                        scaler_vsc_reset_gamemode_rerun_count();
                    }

					down(&GameMode_Check_Semaphore);

					//check smooth toggle already done
					Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);

					//re-enter game mode flow, need to disable timeout tsk.
					smooth_toggle_game_mode_timeout_trigger_flag = _DISABLE;
					//smooth_toggle_game_mode_check_cnt = 0;

										//set the game mode dynamic flag.
					down(&GameMode_SCALER_SYNC_Semaphore);
					if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
					{
						DbgSclrFlgTkr.game_mode_dynamic_flag = TRUE;
					}
					else
					{
						up(&GameMode_SCALER_SYNC_Semaphore);
						up(&GameMode_Check_Semaphore);
						continue;
					}
					up(&GameMode_SCALER_SYNC_Semaphore);



					//mute on
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_GameMode, TRUE);
					down(get_forcebg_semaphore());
					scalerdisplay_force_bg_enable(SLR_MAIN_DISPLAY, TRUE);
					up(get_forcebg_semaphore());
					//rtd_printk(KERN_EMERG, TAG_NAME_NEW_GAME_MODE,"Mute on\n");
#if 1/*config for game mode*/
					//timing free run
					if(!(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC)))
					{
						if((vbe_disp_get_dynamic_memc_bypass_flag() == TRUE)
							&& ((Scaler_DispGetInputInfo(SLR_INPUT_FRAC_FS_REMOVE_RATIO) == 1)
							&& (Scaler_DispGetInputInfo(SLR_INPUT_FRAC_FS_MULTIPLE_RATIO) == 1))
							&& (drvif_scaler_get_display_mode() == DISPLAY_MODE_FRAME_SYNC)
							&& (Get_DISPLAY_REFRESH_RATE() != 120)){
							//IoReg_ClearBits(VODMA_VODMA_CLKGEN_reg,VODMA_VODMA_CLKGEN_en_fifo_full_gate_mask);
							scaler_set_full_gatting_rpc(false);
							drivf_scaler_reset_freerun();
						}
					}
					//DI game mode
					fw_scalerip_set_di_gamemode_setting(fw_scalerip_get_di_gamemode());
					//game mode use line mode, other use frame mode for compression setting
					if(drv_memory_get_game_mode() == _ENABLE){
						dvrif_memory_set_compression_mode(SLR_MAIN_DISPLAY, COMPRESSION_LINE_MODE);
						//printk(KERN_EMERG"[crixus]compression line mode\n");
					}
					else{
						dvrif_memory_set_compression_mode(SLR_MAIN_DISPLAY, COMPRESSION_FRAME_MODE);
						//printk(KERN_EMERG"[crixus]compression frame mode\n");
					}
					//send RPC to video fw
					//drvif_memory_compression_rpc();//no need send rpc to video fw, keep 3-buffer when smooth toggle.
					//down(&VSC_Semaphore);
					//check smooth toggle already done
					Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
					zoom_update_scaler_info_from_vo_smooth_toggle(SLR_MAIN_DISPLAY);//sync smooth toggle timing info
					//up(&VSC_Semaphore);
					//change line or frame mode for PQC
					if(!(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC)))
						dvrif_memory_handler();
					//I3DDMA and M-domain game mode
					if(drv_memory_get_game_mode() == _ENABLE){
						if(drvif_i3ddma_triplebuf_flag()){
							drv_I3ddmaVodma_SingleBuffer_GameMode(_DISABLE); //Input fast case use 3-buffer
						}
						else if(scaler_vsc_get_gamemode_force_framerate_lowdelay_mode()){
							drv_I3ddmaVodma_SingleBuffer_GameMode(_DISABLE); //I3DDMA 3-buffer
						}
						else{
							drv_I3ddmaVodma_SingleBuffer_GameMode(_ENABLE); //I3DDMA 1-buffer
						}

						//change M-domain to 1-buffer after iv2dv delay done
					} else {
						//I3DDMA 3 buffer
						drv_I3ddmaVodma_SingleBuffer_GameMode(_DISABLE);
						//change M-domain to 3-buffer
						drv_memory_GameMode_Switch_TripleBuffer();
					}
					//D-domain game mode
					if(drv_memory_get_game_mode() == _ENABLE){
						drv_game_mode_timing_Dynamic(_ENABLE);
						//after timing fs lock, switch to 1-buffer
						if((vbe_disp_gamemode_use_fixlastline()==FALSE) &&
							!(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC))){
							//if use game fll, switches to single buffer at fll tsk done.
							if(!((Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_HDMI) || (Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_LVDS_TO_HDMI)))
								drv_memory_GameMode_Switch_SingleBuffer();
						}
						else if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && (vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag())){
							//VRR Game mode change to single buffer directly
							if(!((Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_HDMI) || (Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_LVDS_TO_HDMI)))
								drv_memory_GameMode_Switch_SingleBuffer();
						}
						//printk(KERN_EMERG"[crixus]Enter D-domain game mode!!!\n");
					} else {
						drv_game_mode_timing_Dynamic(_DISABLE);
						//printk(KERN_EMERG"[crixus]Exit D-domain game mode!!!\n");
					}
					//MEMC game mode
					if((vbe_disp_get_dynamic_memc_bypass_flag() == TRUE) && (Get_DISPLAY_REFRESH_RATE() != 120)){
						if(drv_memory_get_game_mode_dynamic_flag()==TRUE){
							if(fw_get_vsc_GameMode() == FALSE){
								vbe_disp_game_mode_memc_bypass(1);
								//drv_GameMode_adjust_dtgM2GoldenVsync_delay(_ENABLE);
								fw_set_vsc_GameMode(1);
							}
						}else{
							if(fw_get_vsc_GameMode() == TRUE){
								//drv_GameMode_adjust_dtgM2GoldenVsync_delay(_DISABLE);
								// FixMe, 20190925
								MEMC_LibBlueScreen(1);//20180710, MEMC Jerry provide memc internal ptg to avoid frame blending switch from memc bypass to enable.
								vbe_disp_game_mode_memc_bypass(0);
								fw_set_vsc_GameMode(0);
							}
						}
					}
					//[WOSQRTK-12780] call MEMC low delay after force bg, to avoid video shake issue
					//need MEMC control bg to make sure bg is enable when memc index changing.
					MEMC_LibBlueScreen(1);
					if(drv_memory_get_game_mode() == _ENABLE){
				pr_notice("[%s][%d][LowDelayMode]", __FUNCTION__, __LINE__);
						vpq_memc_set_lowDelayMode(_ENABLE);
					}
					else{
				pr_notice("[%s][%d][LowDelayMode]", __FUNCTION__, __LINE__);
						vpq_memc_set_lowDelayMode(_DISABLE);
					}
					//switch between line mode and frame mode need to wait frame delay done
					//20171018 pinyen add to fix ML3RTANDN-418
					if(!(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC)))
						wait_game_mode_frame_delay_done();

#endif
					//Disable the game mode dynamic flag.
					DbgSclrFlgTkr.game_mode_dynamic_flag = FALSE;
					up(&GameMode_Check_Semaphore);

					rtd_printk(KERN_EMERG, TAG_NAME_NEW_GAME_MODE,"[End]New game mode flow!!\n");
				}
				else if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) != VSC_INPUTSRC_JPEG){
					rtd_printk(KERN_EMERG, TAG_NAME_NEW_GAME_MODE,"[Started]New game mode flow - VDEC!!\n");

					down(&GameMode_Check_Semaphore);

                    scaler_vsc_reset_gamemode_rerun_count();

					//reset timeout tsk.
					smooth_toggle_game_mode_timeout_trigger_flag = _DISABLE;
					//smooth_toggle_game_mode_check_cnt = 0;

					//set the game mode dynamic flag.
					down(&GameMode_SCALER_SYNC_Semaphore);
					if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
					{
						DbgSclrFlgTkr.game_mode_dynamic_flag = TRUE;
					}
					else
					{
						up(&GameMode_SCALER_SYNC_Semaphore);
						up(&GameMode_Check_Semaphore);
						printk(KERN_ERR "\r\n### func:%s line:%d break####\r\n",__FUNCTION__,__LINE__);
						continue;
					}
					up(&GameMode_SCALER_SYNC_Semaphore);
#if 1
					//mute on
					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_GameMode, TRUE);
					down(get_forcebg_semaphore());
					scalerdisplay_force_bg_enable(SLR_MAIN_DISPLAY, TRUE);
					up(get_forcebg_semaphore());
#endif
                    //Set timing free run
                    if(!(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC)))
                    {
						if((vbe_disp_get_dynamic_memc_bypass_flag() == TRUE)
							&& (get_new_game_mode_vdec_memc_bypass_condition() == TRUE)
							&& ((Scaler_DispGetInputInfo(SLR_INPUT_FRAC_FS_REMOVE_RATIO) == 1)
							&& (Scaler_DispGetInputInfo(SLR_INPUT_FRAC_FS_MULTIPLE_RATIO) == 1))
							&& (drvif_scaler_get_display_mode() == DISPLAY_MODE_FRAME_SYNC)
							&& (Get_DISPLAY_REFRESH_RATE() != 120))
						{
							//IoReg_ClearBits(VODMA_VODMA_CLKGEN_reg,VODMA_VODMA_CLKGEN_en_fifo_full_gate_mask);
							scaler_set_full_gatting_rpc(false);
							drivf_scaler_reset_freerun();
						}
                    }

					Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
					//MEMC bypass
					zoom_update_scaler_info_from_vo_smooth_toggle(SLR_MAIN_DISPLAY);//sync smooth toggle timing info
					if(get_new_game_mode_vdec_memc_bypass_condition() == TRUE){
					if((vbe_disp_get_dynamic_memc_bypass_flag() == TRUE) && (Get_DISPLAY_REFRESH_RATE() != 120)){
						if(drv_memory_get_game_mode_dynamic_flag()==TRUE){
							if(fw_get_vsc_GameMode() == FALSE){
									rtd_printk(KERN_NOTICE, TAG_NAME_NEW_GAME_MODE,"[GameMode]VDEC condition: MEMC_BYPASS 1\n");
									vbe_disp_game_mode_memc_bypass(1);//no need control
									//drv_GameMode_adjust_dtgM2GoldenVsync_delay(_ENABLE);
								fw_set_vsc_GameMode(1);
							}
						}else{
							if(fw_get_vsc_GameMode() == TRUE){
									rtd_printk(KERN_NOTICE, TAG_NAME_NEW_GAME_MODE,"[GameMode]VDEC condition: MEMC_BYPASS 0\n");
									//drv_GameMode_adjust_dtgM2GoldenVsync_delay(_DISABLE);
									// FixMe, 20190925
									MEMC_LibBlueScreen(1);
									vbe_disp_game_mode_memc_bypass(0);//no need control
									fw_set_vsc_GameMode(0);
								}
							}
						}
					}

					//[WOSQRTK-12780] call MEMC low delay after force bg, to avoid video shake issue
					//need MEMC control bg to make sure bg is enable when memc index changing.
					MEMC_LibBlueScreen(1);
					if(drv_memory_get_game_mode() == _ENABLE){
				pr_notice("[%s][%d][LowDelayMode]", __FUNCTION__, __LINE__);
						vpq_memc_set_lowDelayMode(_ENABLE);
					}
					else{
				pr_notice("[%s][%d][LowDelayMode]", __FUNCTION__, __LINE__);
						vpq_memc_set_lowDelayMode(_DISABLE);
					}
					//Disable the game mode dynamic flag.
					DbgSclrFlgTkr.game_mode_dynamic_flag = FALSE;

					up(&GameMode_Check_Semaphore);

					rtd_printk(KERN_EMERG, TAG_NAME_NEW_GAME_MODE,"[End]New game mode flow-VDEC!!\n");
				}

			}

		}

		if (freezing(current))
	    {
			try_to_freeze();
	    }

		if (kthread_should_stop())
	   		break;
	   	}

    rtd_printk(KERN_DEBUG, TAG_NAME_NEW_GAME_MODE, "\r\n####new_game_mode_tsk: exit...####\n");
    //printk(KERN_EMERG "\r\n####new_game_mode_tsk: exit...####\n");
    do_exit(0);
    return 0;
}


static void create_new_game_mode_tsk(void)
{
    int err;
	if (new_game_mode_tsk_flag == FALSE) {
		p_new_game_mode_tsk = kthread_create(new_game_mode_tsk, NULL, "new_game_mode_tsk");

	    if (p_new_game_mode_tsk) {
			wake_up_process(p_new_game_mode_tsk);
			new_game_mode_tsk_flag = TRUE;
	    } else {
	    	err = PTR_ERR(p_new_game_mode_tsk);
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Unable to start new_game_mode_tsk (err_id = %d)./n", err);
	    }
	}
}
#endif
/* End
20170524 pinyen create new game mode tsk
*/

static void create_vsc_tsk(void)
{
	int err;
	if (vsc_tsk_running_flag == FALSE) {
		p_vsc_tsk = kthread_create(vsc_scaler_tsk, NULL, "vsc_tsk");

	    if (p_vsc_tsk) {
			wake_up_process(p_vsc_tsk);
			vsc_tsk_running_flag = TRUE;
	    } else {
	    	err = PTR_ERR(p_vsc_tsk);
	    	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Unable to start create_vsc_tsk (err_id = %d)./n", err);
	    }
	}
}

static void delete_vsc_tsk(void)
{
	int ret;
	if (vsc_tsk_running_flag) {
 		ret = kthread_stop(p_vsc_tsk);
 		if (!ret) {
 			p_vsc_tsk = NULL;
 			vsc_tsk_running_flag = FALSE;
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "vsc_scaler_tsk thread stopped\n");
 		}
	}
}
static UINT8 enable_VRR_mode_dynamic = _DISABLE;
void drv_set_vrr_mode_dynamic(unsigned char enable){
    enable_VRR_mode_dynamic = enable;
}

unsigned char drv_get_vrr_mode_dynamic(void){
    return enable_VRR_mode_dynamic;
}

static UINT8 enable_freesync_mode_dynamic = _DISABLE;
void drv_set_freesync_mode_dynamic(unsigned char enable){
    enable_freesync_mode_dynamic = enable;
}

unsigned char drv_get_freesync_mode_dynamic(void){
    return enable_freesync_mode_dynamic;
}

static UINT8 enable_vrr_low_delay_mode_Dynamic = _DISABLE;
void drv_set_vrr_low_delay_mode_dynamic(unsigned char enable){
    enable_vrr_low_delay_mode_Dynamic = enable;
}

unsigned char drv_get_vrr_low_delay_mode_dynamic(void){
    return enable_vrr_low_delay_mode_Dynamic;
}

static int variable_refresh_rate_tsk(void *p)//This task run variable_refresh_rate_tsk
{
//    int ret = 0;
    rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "variable_refresh_rate_tsk()\n");
    //printk(KERN_EMERG "variable_refresh_rate_tsk()\n");
    current->flags &= ~PF_NOFREEZE;
    while (1)
    {
            msleep(10);//need to switch

        if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE && (get_scaler_stop_flag(SLR_MAIN_DISPLAY)==FALSE)){

           if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)
			{
#if 0
                //vrr dynamic checking
				if(vbe_disp_get_VRR_timingMode_flag() == drvif_Hdmi_GetVRREnable())
				{

					//VRR low delay flow
					if(vbe_disp_get_VRR_ALLM_flag() != drv_get_vrr_low_delay_mode_dynamic()){
						drv_set_vrr_low_delay_mode_dynamic(_ENABLE);
						if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI){
							if(vbe_disp_get_VRR_ALLM_flag()){
								//VRR low delay mode
								if(!((Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_HDMI) || (Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_LVDS_TO_HDMI))){
									//check smooth toggle already done
									Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
									dvrif_LowDelay_memory_handler(_ENABLE);
									rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "###[VRR] enter VRR low delay mode, set to M-domain single buffer###\n");
								}
							}
							/*
							else{
								drv_set_vrr_low_delay_mode_dynamic(_DISABLE);
								dvrif_LowDelay_memory_handler(_DISABLE);
								rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "###[VRR] exit VRR low delay mode, set to M-domain triple buffer###\n");
							}
							*/
						}
					}
				}
#endif
				if(vbe_disp_get_freesync_mode_flag() == drvif_Hdmi_GetAMDFreeSyncEnable())
				{
					//Freesync flow
					if(vbe_disp_get_freesync_mode_flag() != drv_get_freesync_mode_dynamic()){
						drv_set_freesync_mode_dynamic(_ENABLE);
						if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI){
							if(vbe_disp_get_freesync_mode_flag()){
								drv_set_vrr_low_delay_mode_dynamic(_ENABLE);
								if(!((Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_HDMI) || (Get_DISPLAY_PANEL_TYPE() == P_VBY1_TO_LVDS_TO_HDMI))){
									Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);
									dvrif_LowDelay_memory_handler(_ENABLE);
									rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "###[VRR] enter freesync_mode mode, set to M-domain single buffer###\n");
								}
							}
						}
					}
				}
			}
        }

        if (freezing(current))
        {
            try_to_freeze();
        }

        if (kthread_should_stop())
            break;
        }

    rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####variable_refresh_rate_tsk: exit...####\n");
    //printk(KERN_EMERG "\r\n####variable_refresh_rate_tsk: exit...####\n");
    do_exit(0);
    return 0;
}

static bool variable_refresh_rate_flag = FALSE;//Record variable_refresh_rate_tsk status. True: Task is running
static struct task_struct *p_variable_refresh_rate_tsk = NULL;

static void create_variable_refresh_rate_tsk(void)
{
    int err;
    if (variable_refresh_rate_flag == FALSE) {
        p_variable_refresh_rate_tsk = kthread_create(variable_refresh_rate_tsk, NULL, "variable_refresh_rate_tsk");

        if (p_variable_refresh_rate_tsk) {
            wake_up_process(p_variable_refresh_rate_tsk);
            variable_refresh_rate_flag = TRUE;
        } else {
            err = PTR_ERR(p_variable_refresh_rate_tsk);
        rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Unable to start variable_refresh_rate_tsk (err_id = %d)./n", err);
        }
    }
}

void trigger_mute_on_by_isr(unsigned char display)
{//use spin lock for ISR
	if(display == SLR_MAIN_DISPLAY)
	{
		spin_lock(&muteoff_main_ctrl_flag_Spinlock);
		DbgSclrFlgTkr.Main_Request_ForceBG_ctrl = TRUE;
		spin_unlock(&muteoff_main_ctrl_flag_Spinlock);
		wake_up(&FORCEBG_WAIT_QUEUE);
		//printk(KERN_NOTICE "\r\n#### func:%s line:%d trigger mute off####\r\n",__FUNCTION__,__LINE__);
	}
#ifdef CONFIG_DUAL_CHANNEL
	else
	{
		spin_lock(&muteoff_sub_ctrl_flag_Spinlock);
		DbgSclrFlgTkr.Sub_Request_ForceBG_ctrl = TRUE;
		spin_unlock(&muteoff_sub_ctrl_flag_Spinlock);
		wake_up(&FORCEBG_WAIT_QUEUE);
	}
#endif
}

void trigger_mute_off_by_isr(unsigned char display, unsigned char no_delay)
{//use spin lock for ISR
	if(display == SLR_MAIN_DISPLAY)
	{
		spin_lock(&muteoff_main_ctrl_flag_Spinlock);
		DbgSclrFlgTkr.Main_Request_ForceBG_ctrl = TRUE;
		spin_unlock(&muteoff_main_ctrl_flag_Spinlock);
		if(no_delay)//trigger now
			wake_up(&FORCEBG_WAIT_QUEUE);
		//printk(KERN_NOTICE "\r\n#### func:%s line:%d trigger mute off####\r\n",__FUNCTION__,__LINE__);
	}
#ifdef CONFIG_DUAL_CHANNEL
	else
	{
		spin_lock(&muteoff_sub_ctrl_flag_Spinlock);
		DbgSclrFlgTkr.Sub_Request_ForceBG_ctrl = TRUE;
		spin_unlock(&muteoff_sub_ctrl_flag_Spinlock);
		if(no_delay)//trigger now
			wake_up(&FORCEBG_WAIT_QUEUE);
	}
#endif
}



void trigger_mute_off(unsigned char display, unsigned char no_delay)
{//trigger to call mute off flow at video_muteoff_tsk
	unsigned long flags;//for spin_lock_irqsave
	if(display == SLR_MAIN_DISPLAY)
	{
		spin_lock_irqsave(&muteoff_main_ctrl_flag_Spinlock, flags);
		DbgSclrFlgTkr.Main_Request_ForceBG_ctrl = TRUE;
		spin_unlock_irqrestore(&muteoff_main_ctrl_flag_Spinlock, flags);
		if(no_delay)//trigger now
			wake_up(&FORCEBG_WAIT_QUEUE);
	}
#ifdef CONFIG_DUAL_CHANNEL
	else
	{
		spin_lock_irqsave(&muteoff_sub_ctrl_flag_Spinlock, flags);
		DbgSclrFlgTkr.Sub_Request_ForceBG_ctrl = TRUE;
		spin_unlock_irqrestore(&muteoff_sub_ctrl_flag_Spinlock, flags);
		if(no_delay)//trigger now
			wake_up(&FORCEBG_WAIT_QUEUE);
	}
#endif
}

unsigned char get_request_ForceBG_ctrl(unsigned char display)
{
	unsigned long flags;//for spin_lock_irqsave
	unsigned char result = FALSE;
	if(display == SLR_MAIN_DISPLAY)
	{
		spin_lock_irqsave(&muteoff_main_ctrl_flag_Spinlock, flags);
		result = DbgSclrFlgTkr.Main_Request_ForceBG_ctrl;
		spin_unlock_irqrestore(&muteoff_main_ctrl_flag_Spinlock, flags);
	}
#ifdef CONFIG_DUAL_CHANNEL
	else
	{
		spin_lock_irqsave(&muteoff_sub_ctrl_flag_Spinlock, flags);
		result = DbgSclrFlgTkr.Sub_Request_ForceBG_ctrl;
		spin_unlock_irqrestore(&muteoff_sub_ctrl_flag_Spinlock, flags);
	}
#endif
	return result;
}

static bool forcebg_tsk_running_flag = FALSE;//Record forcebg_scaler_tsk status. True: Task is running
static struct task_struct *p_forcebg_tsk = NULL;

static int video_muteoff_tsk(void *p)
{//for disable forcebg
#define DEBUG_PRINT_CONTER 20
    unsigned int wait_av_sync_timeout;
    unsigned char vdec_mute_off_check = TRUE;//TRUE can mute off. FALSE can not mute off

	unsigned long flags;//for spin_lock_irqsave
	struct cpumask vsc_cpumask;
	char main_debug_counter = DEBUG_PRINT_CONTER;//when the value is 0. print error message
	char sub_debug_counter = DEBUG_PRINT_CONTER;//when the value is 0. print error message
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,  "video_muteoff_tsk()\n");
    cpumask_clear(&vsc_cpumask);
    cpumask_set_cpu(0, &vsc_cpumask); // run task in core 0
    cpumask_set_cpu(2, &vsc_cpumask); // run task in core 2
    cpumask_set_cpu(3, &vsc_cpumask); // run task in core 3
    sched_setaffinity(0, &vsc_cpumask);
	current->flags &= ~PF_NOFREEZE;
	while (1)
	{
#ifdef CONFIG_DUAL_CHANNEL
		wait_event_freezable_timeout(FORCEBG_WAIT_QUEUE, get_request_ForceBG_ctrl(SLR_MAIN_DISPLAY) || get_request_ForceBG_ctrl(SLR_SUB_DISPLAY), 30);//Timeout is 300ms
#else
		wait_event_freezable_timeout(FORCEBG_WAIT_QUEUE, get_request_ForceBG_ctrl(SLR_MAIN_DISPLAY), 30);//Timeout is 300ms
#endif

#ifdef CONFIG_DUAL_CHANNEL
		if(get_request_ForceBG_ctrl(SLR_MAIN_DISPLAY) || get_request_ForceBG_ctrl(SLR_SUB_DISPLAY))
#else
		if(get_request_ForceBG_ctrl(SLR_MAIN_DISPLAY))
#endif
		{
			if(get_request_ForceBG_ctrl(SLR_MAIN_DISPLAY)) {
				spin_lock_irqsave(&muteoff_main_ctrl_flag_Spinlock, flags);
				DbgSclrFlgTkr.Main_Request_ForceBG_ctrl = FALSE;
				spin_unlock_irqrestore(&muteoff_main_ctrl_flag_Spinlock, flags);
				if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_HDMI_AVMUTE_MASK))
				{
					mute_control(SLR_MAIN_DISPLAY, TRUE);//mute on
				}
				else if(Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_DOLBY_MD_CRC))
				{
					mute_control(SLR_MAIN_DISPLAY, TRUE);//mute on for hdmi sink-led crc error
				}
				else if(Check_ForceBG_Mask_Enable(SLR_MAIN_DISPLAY, TRUE) == FALSE)
				{
					if(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) ==  VSC_INPUTSRC_VDEC)
					{
						vdec_mute_off_check = TRUE;
						for(wait_av_sync_timeout = 30; wait_av_sync_timeout > 0 ; wait_av_sync_timeout--)
						{//wait av sync ready
							if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) !=  VSC_INPUTSRC_VDEC) || (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
								|| (Check_ForceBG_Mask_Enable(SLR_MAIN_DISPLAY, FALSE) == TRUE))
							{
								vdec_mute_off_check = FALSE;
								break;
							}
							else if(get_vo_avsync_flag(0))
							{//av sync ready
								break;
							}
							msleep(10);
						}
						if(vdec_mute_off_check)
							mute_control(SLR_MAIN_DISPLAY, FALSE);
						else
						{
							rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"#####[%s(%d)]vdec change, so can not mute off \n", __func__, __LINE__);
						}
					}
					else
						mute_control(SLR_MAIN_DISPLAY, FALSE);
				}
			}
#ifdef CONFIG_DUAL_CHANNEL
			if(get_request_ForceBG_ctrl(SLR_SUB_DISPLAY)) {
				spin_lock_irqsave(&muteoff_sub_ctrl_flag_Spinlock, flags);
				DbgSclrFlgTkr.Sub_Request_ForceBG_ctrl = FALSE;
				spin_unlock_irqrestore(&muteoff_sub_ctrl_flag_Spinlock, flags);
				if(Get_display_forcebg_mask(SLR_SUB_DISPLAY, SLR_FORCE_BG_TYPE_HDMI_AVMUTE_MASK))
				{
					mute_control(SLR_SUB_DISPLAY, TRUE);//mute on
				}
				else if(Check_ForceBG_Mask_Enable(SLR_SUB_DISPLAY, TRUE) == FALSE)
				{
					mute_control(SLR_SUB_DISPLAY, FALSE);
				}
			}

#endif
		}
		if(!DbgSclrFlgTkr.Main_Request_ForceBG_ctrl && !Check_ForceBG_Mask_Enable(SLR_MAIN_DISPLAY, FALSE))
		{
			if(!main_debug_counter)
			{
				main_debug_counter = DEBUG_PRINT_CONTER;
				check_abnormal_mute_on_condition(SLR_MAIN_DISPLAY);//check and print abnormal condition
			}
			else
				main_debug_counter --;
		}
		else
		{
			main_debug_counter = DEBUG_PRINT_CONTER;
		}
#ifdef CONFIG_DUAL_CHANNEL
		if(!DbgSclrFlgTkr.Sub_Request_ForceBG_ctrl && !Check_ForceBG_Mask_Enable(SLR_SUB_DISPLAY, FALSE))
		{
			if(!sub_debug_counter)
			{
				sub_debug_counter = DEBUG_PRINT_CONTER;
				check_abnormal_mute_on_condition(SLR_SUB_DISPLAY);//check and print abnormal condition
			}
			else
				sub_debug_counter --;
		}
		else
		{
			sub_debug_counter = DEBUG_PRINT_CONTER;
		}
#endif
		if (freezing(current))
		{
			try_to_freeze();
		}
		if (kthread_should_stop()) {
			break;
		}
	}

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,  "\r\n####video_muteoff_tsk: exit...####\n");
	do_exit(0);
	return 0;
}



static void create_forcebg_tsk(void)
{
	int err;
	if (forcebg_tsk_running_flag == FALSE) {
		p_forcebg_tsk = kthread_create(video_muteoff_tsk, NULL, "forcebg_tsk");

	    if (p_forcebg_tsk) {
			wake_up_process(p_forcebg_tsk);
			forcebg_tsk_running_flag = TRUE;
	    } else {
	    	err = PTR_ERR(p_forcebg_tsk);
	    	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Unable to start video_muteoff_tsk (err_id = %d)./n", err);
	    }
	}
}

static void delete_forcebg_tsk(void)
{
	int ret;
	if (forcebg_tsk_running_flag) {
 		ret = kthread_stop(p_forcebg_tsk);
 		if (!ret) {
 			p_forcebg_tsk = NULL;
 			forcebg_tsk_running_flag = FALSE;
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "video_forcebg_tsk thread stopped\n");
 		}
	}
}


#if FREEZE_MUTE_IMPLEMENT_STATE == H5X_MDOMAIN && defined(CONFIG_RTK_8KCODEC_INTERFACE)
extern void create_merlin5DolbyCRCCallH5X_task(void);
extern void delete_merlin5DolbyCRCCallH5X_task(void);
#endif

void isr_control_hdmi_avmute(unsigned char display)
{//hdmi av mute flow use
	unsigned char av_mute_status;
	if(Get_DisplayMode_Src(display) == VSC_INPUTSRC_HDMI)
	{
		av_mute_status = drvif_Hdmi_IsAvmute();
		if(av_mute_status)
		{
			if(!Get_display_forcebg_mask(display, SLR_FORCE_BG_TYPE_HDMI_AVMUTE_MASK))
			{
				set_display_forcebg_mask_by_isr(display, SLR_FORCE_BG_TYPE_HDMI_AVMUTE_MASK, TRUE);
				trigger_mute_on_by_isr(display);
				//mute on
			}
		}
		else
		{
			if(Get_display_forcebg_mask(display, SLR_FORCE_BG_TYPE_HDMI_AVMUTE_MASK))
			{
				set_display_forcebg_mask_by_isr(display, SLR_FORCE_BG_TYPE_HDMI_AVMUTE_MASK, FALSE);
				trigger_mute_off_by_isr(display, 1);//mute off
			}
		}
	}
}

#define FLL_UZUDTG_VSYNC_LINE_DELAY 63
#define FLL_UZUDTG_WAIT_LINE_RANGE 20
#define FLL_LOWER_DOUNDARY_PERCENT 22//lower boundary is total line * 2.2%
#define FLL_UPPER_DOUNDARY_PERCENT 44 //upper boundary is total line * 4.4%

static bool fix_lastline_tsk_running_flag = FALSE;//Record fixlastline_scaler_tsk status. True: Task is running
static struct task_struct *p_fix_lastline_tsk = NULL;
static bool localDimmingDemoCtrl_tsk_running_flag = FALSE;
static struct task_struct *p_localDimmingDemoCtrl_tsk	= NULL;

extern void drvif_scaler_set_frc2fsync_vtotal_protect_on_without_den_shift(void);
extern void drvif_scaler_set_fixlastline_vtotal_speedup_protect_on(void);
extern void drvif_scaler_set_frc2fsync_vtotal_protect_off(void);
extern void drvif_scaler_set_frc2fsync_recovery_vtotal(unsigned int u32_vtotal);


unsigned char vsc_decide_fixlastline_speedup_enable(void)
{
	unsigned char b_enable = 1;

	if(drvif_scaler_get_display_mode() == DISPLAY_MODE_FRAME_SYNC){
		b_enable = 0;
	}
	//if(Scaler_DispGetInputInfo(SLR_INPUT_FRAC_FS_REMOVE_RATIO) != 1){
	//	b_enable = 0;
	//}
	return b_enable;
}
/*
typedef struct{
	int  x;
	int  y;
}ORBIT_PIXEL_SHIFT_STRUCT;
*/
extern ORBIT_PIXEL_SHIFT_STRUCT vbe_disp_calculate_orbit_position(unsigned int MaxPixelShift, unsigned int MaxLineShift, unsigned int index);

static int localDimmingDemoCtrl_tsk(void *p)
{

	KADP_VIDEO_RECT_T outputRegion;

	outputRegion.x = 0;
	outputRegion.y = 0;
	outputRegion.w = 768;
	outputRegion.h = 2160;

	current->flags &= ~PF_NOFREEZE;

	while(1){

			latency_pattern_self_test_run();
/*
			if(vbe_disp_orbit_get_vo_overscan()==1 && !main_arc_change_flag){
				//vbe_disp_orbit_set_vo_overscan(0);
				if(!(IoReg_Read32(0xb8022288)&_BIT26)){
					vbe_disp_orbit_vo_overscan();
					vbe_disp_orbit_sub_overscan();
				}
			}
			if(vbe_disp_orbit_get_frc_overscan()==1 && !main_arc_change_flag){
				vbe_disp_orbit_set_frc_overscan(0);
				vbe_disp_orbit_frc_overscan();
				vbe_disp_orbit_sub_overscan();
			}
*/
			if(LocalDimmingDemoCtrlMode){
				rtk_hal_vsc_makeColoredVideo(1);

				do{
					outputRegion.x +=20;
					rtk_hal_vsc_SetOutputRegion(0, outputRegion, 0,0);
					if(outputRegion.x+outputRegion.w >= 3840){
						outputRegion.x=0;
					}
				}while(LocalDimmingDemoCtrlMode);

				rtk_hal_vsc_makeColoredVideo(0);
				outputRegion.x = 0;
				outputRegion.y = 0;
				outputRegion.w = 768;
				outputRegion.h = 2160;
			}

			if (freezing(current))
			{
				try_to_freeze();
			}
			if (kthread_should_stop()) {
				break;
			}
			msleep(10);

	}

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,  "\r\n####localDimmingDemoCtrl_tsk: exit...####\n");
	do_exit(0);
	return 0;

}
unsigned char b_gamemode_force_framerate_lowdelay_mode = 0;
unsigned int u32_external_src_vfreq = 0;
unsigned int u32_external_src_backproch = 0;
unsigned int u32_gamemode_rerun_count = 0;

unsigned int scaler_vsc_get_gamemode_rerun_count(void)
{
    return u32_gamemode_rerun_count;
}

void scaler_vsc_reset_gamemode_rerun_count(void)
{
    u32_gamemode_rerun_count = 0;
}

void scaler_vsc_increase_gamemode_rerun_count(void)
{
    u32_gamemode_rerun_count++;
}


void scaler_vsc_set_external_src_vfreq(unsigned char display,   unsigned short vfreq)
{
    if(display == SLR_MAIN_DISPLAY)
        u32_external_src_vfreq = vfreq;
}

void scaler_vsc_set_external_src_backporch(unsigned char display, unsigned int backporch)
{
    if(display == SLR_MAIN_DISPLAY)
        u32_external_src_backproch = backporch;
}

unsigned int scaler_vsc_get_external_src_vfreq(void)
{
    return u32_external_src_vfreq;
}

unsigned int scaler_vsc_get_external_src_backporch(void)
{
    return u32_external_src_backproch;
}

UINT8 scaler_vsc_check_gamemode_force_framerate_condition(void)
{
    unsigned int source_freq = scaler_vsc_get_external_src_vfreq();
    unsigned char result = FALSE;

    if((Get_DISPLAY_REFRESH_RATE()==120)      &&
        (get_new_game_mode_condition()==TRUE) &&
        (Scaler_DispGetStatus(SLR_MAIN_DISPLAY, SLR_DISP_INTERLACE)==0) &&  //ingore interlaced
        (((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) &&  // ingore VRR
        (vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag()))==0) &&
        (((source_freq>495) && (source_freq<505))||
        ((source_freq>595) && (source_freq<605)))
      )
      {
        if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPH_ACT_WID_PRE) > 1280)&&
            (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_IPV_ACT_LEN_PRE) > 720)){
            result = TRUE;
        }
        else{
            result = FALSE;
        }
     }
    else{
        result = FALSE;
    }
    rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"function=%s, result = %d. \n", __FUNCTION__,result);

    return result;
}



void scaler_vsc_set_gamemode_force_framerate_lowdelay_mode(UINT8 bOnOff)
{
    int ret = -1;

    rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"function=%s, bOnOff=%d \n", __FUNCTION__, bOnOff);
    b_gamemode_force_framerate_lowdelay_mode = bOnOff;

    if (0 != (ret = Scaler_SendRPC(SCALERIOC_GAMEMODE_FORCE_VO_FRAMERATE_FLAG, bOnOff, 1))){
        rtd_printk(KERN_ERR, TAG_NAME_VSC,"ret=%d, SCALERIOC_GAMEMODE_FORCE_VO_FRAMERATE_FLAG RPC fail !!!\n", ret);
    }
}

UINT8 scaler_vsc_get_gamemode_force_framerate_lowdelay_mode(void)
{
    return b_gamemode_force_framerate_lowdelay_mode;
}

unsigned char b_adaptive_pst_lowdelay_mode = 0;
extern void drivf_scaler_reset_fraction_ratio(void);

void scaler_vsc_set_adaptive_pst_lowdelay_mode(UINT8 bOnOff)
{
	int ret = -1;
	unsigned int targetLowBound = 0;
	extern unsigned int drvif_scaler_voFrameRateControl_get_lowBound(DISP_MODE flag_3d);
    SLR_VOINFO *pVOInfo = Scaler_VOInfoPointer(Scaler_Get_CurVoInfo_plane());

#ifdef CONFIG_MEMC_BYPASS
        rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"function=%s, memc by pass not to run\n", __FUNCTION__);
        return;
#endif

	rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"function=%s, bOnOff=%d \n", __FUNCTION__, bOnOff);

	if((Get_DISPLAY_REFRESH_RATE() != 120)&&Scaler_get_realcinema_mode_condition()){ //tru-motion off + real cinema
		targetLowBound = DEFAULT_LOW_BOUND;
	}else{
		if ((get_vt_EnableFRCMode() != FALSE) &&(Get_DISPLAY_REFRESH_RATE() == 120) && (pVOInfo->is2KCP == 1)) {
			targetLowBound = 99500;
		} else {
			targetLowBound = 49000;
		}
	}

	if((drvif_scaler_voFrameRateControl_get_lowBound(0)== targetLowBound) && (b_adaptive_pst_lowdelay_mode == bOnOff)
		&& !(bOnOff == 0 && scaler_vsc_get_keep_vo_framerate_control() == 0)){
		rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"function=%s, no need update, return. \n", __FUNCTION__);
		return;
	}
	b_adaptive_pst_lowdelay_mode = bOnOff;

	drvif_scaler_voFrameRateControl_set_bwSavingMode(_DISP_2D, (bOnOff? 0: 1));

#if 0	//[KTASKWBS-11949] This will cause Youtube 24Hz video garbage at playback start, mark it.
	if(bOnOff){
        down(&VBE_LowDelay_Semaphore);
		drivf_scaler_reset_fraction_ratio();
        up(&VBE_LowDelay_Semaphore);
	}
#endif
	if (0 != (ret = Scaler_SendRPC(SCALERIOC_PST_RERUN_VO_FLAG, bOnOff, 1))){
		rtd_printk(KERN_ERR, TAG_NAME_VSC,"ret=%d, SCALERIOC_PST_RERUN_VO_FLAG RPC fail !!!\n", ret);
	}
}
EXPORT_SYMBOL(scaler_vsc_set_adaptive_pst_lowdelay_mode);

UINT8 scaler_vsc_get_adaptive_pst_lowdelay_mode(void)
{
	return b_adaptive_pst_lowdelay_mode;
}

unsigned char b_force_pst_lowdelay_mode = 0;

void scaler_vsc_set_force_pst_lowdelay_mode(UINT8 bOnOff)
{
	rtd_printk(KERN_ERR, TAG_NAME_VSC,"scaler_vsc_set_force_pst_lowdelay_mode = %d\n", bOnOff);
	b_force_pst_lowdelay_mode = bOnOff;
}
EXPORT_SYMBOL(scaler_vsc_set_force_pst_lowdelay_mode);

UINT8 scaler_vsc_get_force_pst_lowdelay_mode(void)
{
	return b_force_pst_lowdelay_mode;
}
unsigned char b_keep_vo_framerate_control = 0;

void scaler_vsc_set_keep_vo_framerate_control(UINT8 bOnOff)
{
    rtd_printk(KERN_ERR, TAG_NAME_VSC,"scaler_vsc_set_keep_vo_framerate_control = %d\n", bOnOff);
    b_keep_vo_framerate_control = bOnOff;
}
EXPORT_SYMBOL(scaler_vsc_set_keep_vo_framerate_control);

UINT8 scaler_vsc_get_keep_vo_framerate_control(void)
{
    return b_keep_vo_framerate_control;
}

static UINT8 stVR360_block_mdomain_db_flag = 0;

void scaler_vsc_set_vr360_block_mdomain_doublebuffer(UINT8 bEnable)
{
	stVR360_block_mdomain_db_flag = bEnable;

}

UINT8 scaler_vsc_get_vr360_block_mdomain_doublebuffer(void)
{
	return stVR360_block_mdomain_db_flag;
}


void scaler_vsc_vr360_enter_datafs_proc(void)
{
	mdomain_disp_ddr_mainsubctrl_RBUS ddr_mainsubctrl_reg;
	mdomain_cap_cap_reg_doublbuffer_RBUS cap_reg_doublbuffer_reg;
	vodma_vodma_clkgen_RBUS vodma_vodma_clkgen_reg;
	mdomain_cap_cap_pq_cmp_RBUS mdomain_cap_cap_pq_cmp_reg;
	mdomain_disp_dispm_main_pq_decmp_RBUS mdomain_disp_dispm_main_pq_decmp_reg;
	mdomain_disp_ddr_mainctrl_RBUS mdomain_disp_ddr_mainctrl_reg;
	mdomain_cap_main_sdnr_cxxto64_RBUS mdomain_cap_main_sdnr_cxxto64_reg;
	UINT32 count = 0x3ffffff;
	UINT8 record_422CAP_flag = 0;

	pr_notice("[%s] [line %d] \n", __FUNCTION__, __LINE__);

	record_422CAP_flag = Scaler_DispGetStatus(_MAIN_DISPLAY, SLR_DISP_422CAP);

	scaler_vsc_set_vr360_block_mdomain_doublebuffer(TRUE);

	//timing free run
	drivf_scaler_reset_freerun();
	modestate_set_fll_running_flag(FALSE);
	Scaler_DispSetInputInfo(SLR_INPUT_FRAMESYNC, TRUE);

	Scaler_DispSetStatus(_MAIN_DISPLAY, SLR_DISP_422CAP, FALSE);
    drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
	IoReg_ClearBits(PPOVERLAY_Main_Display_Control_RSV_reg,_BIT14);  //close watch dog for data framesync flow
	vbe_disp_set_dtgM2uzu_lowdelay_mode(1);

	//enable full gating
	vodma_vodma_clkgen_reg.regValue = IoReg_Read32(VODMA_VODMA_CLKGEN_reg);
	vodma_vodma_clkgen_reg.en_fifo_full_gate = 1;
	IoReg_Write32(VODMA_VODMA_CLKGEN_reg, vodma_vodma_clkgen_reg.regValue);

	//enable m-domain double buffer
	cap_reg_doublbuffer_reg.regValue =IoReg_Read32(MDOMAIN_CAP_cap_reg_doublbuffer_reg);
	cap_reg_doublbuffer_reg.cap1_db_en=1;
	IoReg_Write32(MDOMAIN_CAP_cap_reg_doublbuffer_reg, cap_reg_doublbuffer_reg.regValue);
	ddr_mainsubctrl_reg.regValue =IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
	ddr_mainsubctrl_reg.disp1_double_enable=1;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, ddr_mainsubctrl_reg.regValue);


	fw_scalerdisplay_handler(Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY));
	drvif_color_ultrazoom_config_scaling_up(Scaler_DispCheckRatio(SLR_RATIO_PANORAMA));
	dvrif_memory_setting_for_data_fs();
	drvif_memory_set_fs_display_fifo();
	dvrif_memory_comp_setting(FALSE, Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_CAP_WID), Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_CAP_LEN), dvrif_memory_get_compression_bits(SLR_MAIN_DISPLAY));

	//disable compression
	mdomain_cap_cap_pq_cmp_reg.regValue = IoReg_Read32(MDOMAIN_CAP_CAP_PQ_CMP_reg);
	mdomain_cap_cap_pq_cmp_reg.cmp_en = 0;
	IoReg_Write32(MDOMAIN_CAP_CAP_PQ_CMP_reg, mdomain_cap_cap_pq_cmp_reg.regValue);
	mdomain_disp_dispm_main_pq_decmp_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DISPM_MAIN_PQ_DECMP_reg);
	mdomain_disp_dispm_main_pq_decmp_reg.decmp_en = 0;
	IoReg_Write32(MDOMAIN_DISP_DISPM_MAIN_PQ_DECMP_reg, mdomain_disp_dispm_main_pq_decmp_reg.regValue);


	mdomain_disp_ddr_mainctrl_reg.regValue = 0;
	mdomain_disp_ddr_mainctrl_reg.main_source_sel = 3;
	mdomain_disp_ddr_mainctrl_reg.main_decompression_clk_en = 1;
	mdomain_disp_ddr_mainctrl_reg.main_in_format = 1;
	mdomain_disp_ddr_mainctrl_reg.main_bit_num = (Scaler_DispGetStatus((SCALER_DISP_CHANNEL)Scaler_DispGetInputInfo(SLR_INPUT_DISPLAY),SLR_DISP_10BIT)?1:0);
	IoReg_Write32(MDOMAIN_DISP_DDR_MainCtrl_reg, mdomain_disp_ddr_mainctrl_reg.regValue);
	mdomain_cap_main_sdnr_cxxto64_reg.regValue = IoReg_Read32(MDOMAIN_CAP_Main_SDNR_cxxto64_reg);
	mdomain_cap_main_sdnr_cxxto64_reg.out_bit = Scaler_DispGetStatus(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_10BIT);
	mdomain_cap_main_sdnr_cxxto64_reg.sort_fmt = Scaler_DispGetStatus(Scaler_DispGetInputInfo(SLR_INPUT_CHANNEL), SLR_DISP_422CAP) ? 0 : 1;
	IoReg_Write32(MDOMAIN_CAP_Main_SDNR_cxxto64_reg, mdomain_cap_main_sdnr_cxxto64_reg.regValue);
	IoReg_ClearBits(MDOMAIN_CAP_Cap_In1_enable_reg, MDOMAIN_CAP_Cap_In1_enable_in1_cap_enable_mask);
	IoReg_ClearBits(MDOMAIN_DISP_Disp_main_enable_reg,	MDOMAIN_DISP_Disp_main_enable_main_disp_en_mask);

	//M-domain DB_apply
	cap_reg_doublbuffer_reg.cap1_db_apply=1;
	IoReg_Write32(MDOMAIN_CAP_cap_reg_doublbuffer_reg, cap_reg_doublbuffer_reg.regValue);
	ddr_mainsubctrl_reg.disp1_double_apply = 1;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, ddr_mainsubctrl_reg.regValue);
	count = 0x3ffffff;
	while((ddr_mainsubctrl_reg.disp1_double_apply)&&--count){
		ddr_mainsubctrl_reg.regValue =IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
	}

	// restore flags
	Scaler_DispSetStatus(_MAIN_DISPLAY, SLR_DISP_422CAP, record_422CAP_flag);
	scaler_vsc_set_vr360_block_mdomain_doublebuffer(FALSE);
}

#define APPLY_DOUBLE_BUFFER_PROTECT_VGIP_AREA 400

void scaler_vsc_vr360_enter_datafrc_proc(void)
{
	mdomain_disp_ddr_mainsubctrl_RBUS ddr_mainsubctrl_reg;
	mdomain_cap_cap_reg_doublbuffer_RBUS cap_reg_doublbuffer_reg;
	mdomain_cap_ddr_in1status_RBUS mdomain_cap_ddr_in1status_reg;
	mdomain_disp_ddr_mainprevstart_RBUS mdomain_ddr_mainprevstart_reg;
	mdomain_cap_ddr_in1ctrl_RBUS mdomain_cap_ddr_in1ctrl_reg;
//	mdomain_cap_cap_ddr_fifostatus_RBUS mdomain_cap_cap_ddr_fifostatus_reg;
	mdomain_disp_ddr_mainstatus_RBUS mdomain_disp_ddr_mainstatus_reg;
	mdomain_disp_ddr_mainctrl_RBUS mdomain_disp_ddr_mainctrl_reg;
	vgip_vgip_chn1_lc_RBUS vgip_vgip_chn1_lc_reg;
	UINT32 count = 0x3ffffff;

	pr_notice("[%s] [line %d] \n", __FUNCTION__, __LINE__);

	scaler_vsc_set_vr360_block_mdomain_doublebuffer(TRUE);

	Scaler_DispSetInputInfo(SLR_INPUT_FRAMESYNC, FALSE);

	//enable m-cap double buffer
	cap_reg_doublbuffer_reg.regValue = IoReg_Read32(MDOMAIN_CAP_cap_reg_doublbuffer_reg);
	cap_reg_doublbuffer_reg.cap1_db_en = 1;
	IoReg_Write32(MDOMAIN_CAP_cap_reg_doublbuffer_reg,cap_reg_doublbuffer_reg.regValue);
	//enable m-disp double buffer
	ddr_mainsubctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
	ddr_mainsubctrl_reg.disp1_double_enable = 1;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg,ddr_mainsubctrl_reg.regValue);

	IoReg_ClearBits(PPOVERLAY_Main_Display_Control_RSV_reg,_BIT14);  //close watch dog for data framesync flow

	dvrif_memory_set_compression_mode(SLR_MAIN_DISPLAY, COMPRESSION_LINE_MODE);

	dvrif_memory_handler();

	mdomain_ddr_mainprevstart_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainPreVStart_reg);
	mdomain_ddr_mainprevstart_reg.main_pre_rd_v_start = 17;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainPreVStart_reg, mdomain_ddr_mainprevstart_reg.regValue);

	mdomain_disp_ddr_mainctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainCtrl_reg);
	mdomain_disp_ddr_mainctrl_reg.main_double_en = 0;
	mdomain_disp_ddr_mainctrl_reg.main_v_flip_3buf_en = 0;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainCtrl_reg, mdomain_disp_ddr_mainctrl_reg.regValue);

	mdomain_cap_ddr_in1ctrl_reg.regValue = IoReg_Read32(MDOMAIN_CAP_DDR_In1Ctrl_reg);
	mdomain_cap_ddr_in1ctrl_reg.in1_double_enable = 0;
	mdomain_cap_ddr_in1ctrl_reg.in1_v_flip_3buf_en = 0;
	IoReg_Write32(MDOMAIN_CAP_DDR_In1Ctrl_reg, mdomain_cap_ddr_in1ctrl_reg.regValue);

	IoReg_SetBits(MDOMAIN_CAP_Cap_In1_enable_reg, MDOMAIN_CAP_Cap_In1_enable_in1_cap_enable_mask);


	//apply m-cap double buffer
	cap_reg_doublbuffer_reg.cap1_db_apply = 1;
	IoReg_Write32(MDOMAIN_CAP_cap_reg_doublbuffer_reg,cap_reg_doublbuffer_reg.regValue);
	//apply m-disp double buffer
	ddr_mainsubctrl_reg.disp1_double_apply = 1;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg, ddr_mainsubctrl_reg.regValue);

	//wait above settings apply
	count = 0x3ffffff;
	while(count--){
		cap_reg_doublbuffer_reg.regValue = IoReg_Read32(MDOMAIN_CAP_cap_reg_doublbuffer_reg);
		ddr_mainsubctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
		if((cap_reg_doublbuffer_reg.cap1_db_apply == 0) && (ddr_mainsubctrl_reg.disp1_double_apply == 0))
			break;
	}

	// <<<====================	single buffer , compressio line mode //////////////////////////

	dvrif_memory_set_compression_mode(SLR_MAIN_DISPLAY, COMPRESSION_FRAME_MODE);

	count = 0x3ffffff;
	while(--count){
		vgip_vgip_chn1_lc_reg.regValue = IoReg_Read32(VGIP_VGIP_CHN1_LC_reg);
		if((vgip_vgip_chn1_lc_reg.ch1_line_cnt) < APPLY_DOUBLE_BUFFER_PROTECT_VGIP_AREA)
			break;
	}

	dvrif_memory_handler();

	//switch to 3 buffers
	mdomain_cap_ddr_in1ctrl_reg.regValue = IoReg_Read32(MDOMAIN_CAP_DDR_In1Ctrl_reg);
	mdomain_cap_ddr_in1ctrl_reg.in1_v_flip_3buf_en = 1;
	mdomain_cap_ddr_in1ctrl_reg.in1_double_enable = 1;
	IoReg_Write32(MDOMAIN_CAP_DDR_In1Ctrl_reg,mdomain_cap_ddr_in1ctrl_reg.regValue);

	cap_reg_doublbuffer_reg.regValue =IoReg_Read32(MDOMAIN_CAP_cap_reg_doublbuffer_reg);
	cap_reg_doublbuffer_reg.cap1_db_apply = 1;
	IoReg_Write32(MDOMAIN_CAP_cap_reg_doublbuffer_reg,cap_reg_doublbuffer_reg.regValue);

	mdomain_cap_ddr_in1status_reg.regValue = IoReg_Read32(MDOMAIN_CAP_DDR_In1Status_reg);
	mdomain_disp_ddr_mainstatus_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainStatus_reg);
//	pr_notice("[line:%d] cap/disp = (%d.%d)\n", __LINE__, mdomain_cap_ddr_in1status_reg.in1_block_select, mdomain_disp_ddr_mainstatus_reg.main_block_select);

	count = 0x3ffffff;
	while((cap_reg_doublbuffer_reg.cap1_db_apply == 1) && (--count)){
		cap_reg_doublbuffer_reg.regValue = rtd_inl(MDOMAIN_CAP_cap_reg_doublbuffer_reg);
//		if((count&0xfff)==0)
//			pr_notice("[%d] line check (%x.%d.%d) \n", __LINE__, count, ((IoReg_Read32(0xb8022234)&0xfff0000)>>16), ((IoReg_Read32(0xb8028258)&0xfff0000)>>16));
	}
	mdomain_cap_ddr_in1status_reg.regValue = IoReg_Read32(MDOMAIN_CAP_DDR_In1Status_reg);
	mdomain_disp_ddr_mainstatus_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainStatus_reg);
//	pr_notice("[line:%d] cap/disp = (%d.%d) (count:%x)--- apply cap 3 buf done (%d.%d)\n", __LINE__, mdomain_cap_ddr_in1status_reg.in1_block_select,
//																						mdomain_disp_ddr_mainstatus_reg.main_block_select,
//																						count,
//																						((IoReg_Read32(0xb8022234)&0xfff0000)>>16),
//																						((IoReg_Read32(0xb8028258)&0xfff0000)>>16));

	count = 0x3ffffff;
	while(--count){
		vgip_vgip_chn1_lc_reg.regValue = IoReg_Read32(VGIP_VGIP_CHN1_LC_reg);
		if((vgip_vgip_chn1_lc_reg.ch1_line_cnt) > APPLY_DOUBLE_BUFFER_PROTECT_VGIP_AREA)
			break;
	}
//	pr_notice("[line:%d] cap/disp = (%d.%d) (count:%x)--- check vgip protect (%d.%d)\n", __LINE__, mdomain_cap_ddr_in1status_reg.in1_block_select,
//																						mdomain_disp_ddr_mainstatus_reg.main_block_select,
//																						count,
//																						((IoReg_Read32(0xb8022234)&0xfff0000)>>16),
//																						((IoReg_Read32(0xb8028258)&0xfff0000)>>16));


	//change M-disp.
	mdomain_disp_ddr_mainctrl_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainCtrl_reg);
	mdomain_disp_ddr_mainctrl_reg.main_double_en = 1;
	mdomain_disp_ddr_mainctrl_reg.main_v_flip_3buf_en = 1;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainCtrl_reg,mdomain_disp_ddr_mainctrl_reg.regValue);
	ddr_mainsubctrl_reg.disp1_double_apply = 1;
	IoReg_Write32(MDOMAIN_DISP_DDR_MainSubCtrl_reg,ddr_mainsubctrl_reg.regValue);

	mdomain_cap_ddr_in1status_reg.regValue = IoReg_Read32(MDOMAIN_CAP_DDR_In1Status_reg);
	mdomain_disp_ddr_mainstatus_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainStatus_reg);

	count = 0x3ffffff;
	while((ddr_mainsubctrl_reg.disp1_double_apply == 1) && (count--)){
		ddr_mainsubctrl_reg.regValue =rtd_inl(MDOMAIN_DISP_DDR_MainSubCtrl_reg);
//		if((count&0xfff)==0)
//			pr_notice("[%d] line check (%x.%d.%d) \n", __LINE__, count, ((IoReg_Read32(0xb8022234)&0xfff0000)>>16), ((IoReg_Read32(0xb8028258)&0xfff0000)>>16));
	}

//	mdomain_cap_ddr_in1status_reg.regValue = IoReg_Read32(MDOMAIN_CAP_DDR_In1Status_reg);
//	mdomain_disp_ddr_mainstatus_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainStatus_reg);
//	pr_notice("[line:%d] cap/disp = (%d.%d) (count:%x)---  Mdisp apply 3 buf done (%d.%d)\n", __LINE__, mdomain_cap_ddr_in1status_reg.in1_block_select,
//																						mdomain_disp_ddr_mainstatus_reg.main_block_select,
//																						count,
//																						((IoReg_Read32(0xb8022234)&0xfff0000)>>16),
//																						((IoReg_Read32(0xb8028258)&0xfff0000)>>16));

/*
	//check cap/disp block select is correct
	count = 0x3ffffff;
	mdomain_cap_cap_ddr_fifostatus_reg.regValue = IoReg_Read32(MDOMAIN_CAP_Cap_DDR_FIFOStatus_reg);
	mdomain_cap_cap_ddr_fifostatus_reg.in1_cap_last_wr_flag = 1;
	IoReg_Write32(MDOMAIN_CAP_Cap_DDR_FIFOStatus_reg, mdomain_cap_cap_ddr_fifostatus_reg.regValue);

	mdomain_cap_cap_ddr_fifostatus_reg.regValue = IoReg_Read32(MDOMAIN_CAP_Cap_DDR_FIFOStatus_reg);
	while(!(mdomain_cap_cap_ddr_fifostatus_reg.in1_cap_last_wr_flag) && --count){
		mdomain_cap_cap_ddr_fifostatus_reg.regValue = IoReg_Read32(MDOMAIN_CAP_Cap_DDR_FIFOStatus_reg);
		if((count&0xfff)==0)
			pr_notice("[%d] line check (%x.%d.%d) \n", __LINE__, count, ((IoReg_Read32(0xb8022234)&0xfff0000)>>16), ((IoReg_Read32(0xb8028258)&0xfff0000)>>16));
	}
	mdomain_cap_ddr_in1status_reg.regValue = IoReg_Read32(MDOMAIN_CAP_DDR_In1Status_reg);
	mdomain_disp_ddr_mainstatus_reg.regValue = IoReg_Read32(MDOMAIN_DISP_DDR_MainStatus_reg);
	pr_notice("[line:%d] cap/disp = (%d.%d) (count:%x)---  check write done frame 1 (%d.%d)\n", __LINE__, mdomain_cap_ddr_in1status_reg.in1_block_select,
																						mdomain_disp_ddr_mainstatus_reg.main_block_select,
																						count,
																						((IoReg_Read32(0xb8022234)&0xfff0000)>>16),
																						((IoReg_Read32(0xb8028258)&0xfff0000)>>16));
*/
	scaler_vsc_set_vr360_block_mdomain_doublebuffer(FALSE);
}

#define NEW_FLL_SPEEDUP_BY_HW_MODE 1
#define NEW_FLL_PHASE_ERROR_THRESHOLD 10
#define NEW_FLL_24HZ_PHASE_ERROR_THRESHOLD 0x100

#define NEW_FLL_I2D_DLY_ADD_LINE_MAX 10
#define NEW_FLL_I2D_DLY_SUB_LINE_MAX 0
#define NEW_FLL_I2D_REALCINEMA_DLY_ADD_LINE_MAX 21
#define NEW_FLL_I2D_REALCINEMA_DLY_SUB_LINE_MAX 0
#define NEW_FLL_I2D_2_5_DLY_ADD_LINE_MAX 900
#define NEW_FLL_I2D_2_5_DLY_SUB_LINE_MAX 0
#define NEW_FLL_I2D_1_2_30HZ_DLY_ADD_LINE_MAX 450
#define NEW_FLL_I2D_1_2_30HZ_DLY_SUB_LINE_MAX 0
#define NEW_FLL_I2D_1_2_25HZ_DLY_ADD_LINE_MAX 0
#define NEW_FLL_I2D_1_2_25HZ_DLY_SUB_LINE_MAX 450
#define NEW_FLL_I2D_2_5_24HZ_120HZ_DLY_ADD_LINE_MAX 200
#define NEW_FLL_I2D_2_5_24HZ_120HZ_DLY_SUB_LINE_MAX 0

unsigned char fix_last_line_need_break_condition(void)
{//retunr TRUE: break    Return False: no break
	if(get_scaler_stop_flag(SLR_MAIN_DISPLAY) == TRUE)
	{
		rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "### FLL break for scaler stop flag##\n");
		return TRUE;
	}
	else if(DbgSclrFlgTkr.smoothtoggle_start_flag == TRUE)
	{
		rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "### FLL break for smt trigger##\n");
		return TRUE;
	}
	else if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_ACTIVE)
	{
		rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "### FLL break for search state#\n");
		return TRUE;
	}
	else if(smooth_toggle_game_mode_check_cnt != st_game_mode_cmd_pre)
	{
		rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "### FLL break for scaler_trigger smooth toggle in game mode# %d,%d\n",smooth_toggle_game_mode_check_cnt,st_game_mode_cmd_pre);
		return TRUE;
	}
	else if(disp_smooth_variable_setting_flag == _ENABLE)
	{
		rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "### FLL break for running disp_smooth_variable_setting#\n");
		return TRUE;
	}
	else if(Scaler_get_film_mode_change_type() == 1)
	{
		rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "### FLL break for film mode change type#\n");
		return TRUE;
	}
	else if(game_mode_cmd_check != game_mode_cmd_pre)
	{
		rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "### FLL break for game mode cmd again# %d,%d\n",game_mode_cmd_check,game_mode_cmd_pre);
		return TRUE;
	}
	else if((DbgSclrFlgTkr.game_mode_dynamic_flag) || (drv_memory_get_game_mode_dynamic() != drv_memory_get_game_mode_flag()))
	{
		rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "### FLL break for waiting game mode ready#\n");
		return TRUE;
	}
	else if(modestate_decide_display_timing() != DISPLAY_MODE_NEW_FLL_MODE)
	{
		rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "### FLL break for display timing mode isn't FLL#\n");
		return TRUE;
	}
	return FALSE;
}

unsigned char bEnableI2DTracking_in_realcinema = 0;

void scaler_set_I2D_tracking_in_realcinema(unsigned char bEnable)
{
	bEnableI2DTracking_in_realcinema = bEnable;
}

unsigned char scaler_get_I2D_tracking_in_realcinema(void)
{
	return bEnableI2DTracking_in_realcinema;
}

unsigned char bEnableI2DFreq_UpdateInISR = 0;

void scaler_set_I2D_pwm_frequency_update_in_isr(unsigned char bEnable)
{
	bEnableI2DFreq_UpdateInISR = bEnable;
}

unsigned char scaler_get_I2D_pwm_frequency_update_in_isr(void)
{
	return bEnableI2DFreq_UpdateInISR;
}

unsigned char bEnableVRRFreq_UpdateInISR = 0;

void scaler_set_VRR_pwm_frequency_update_in_isr(unsigned char bEnable)
{
	bEnableVRRFreq_UpdateInISR = bEnable;
}

unsigned char scaler_get_VRR_pwm_frequency_update_in_isr(void)
{
	return bEnableVRRFreq_UpdateInISR;
}

unsigned char bEnableI2DTracking_in_slow_mode = 0;

void scaler_set_I2D_tracking_in_slow_mode(unsigned char bEnable)
{
	bEnableI2DTracking_in_slow_mode = bEnable;
}

unsigned char scaler_get_I2D_tracking_in_slow_mode(void)
{
	return bEnableI2DTracking_in_slow_mode;
}

unsigned int scaler_get_I2D_tracking_phase_error_threadhold(void)
{
	if(((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)> 495)&&(Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)<505)) ||
		((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)> 595)&&(Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)<605)) ||
		((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)> 995)&&(Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)<1005)) ||
		((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)> 1195)&&(Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)<1205))
		)
	{
		return NEW_FLL_PHASE_ERROR_THRESHOLD;
	}
	else
		return NEW_FLL_24HZ_PHASE_ERROR_THRESHOLD;
}

void scaler_pwm_frequency_update_by_dvs(void)
{
	unsigned int frameRates = 0;
	unsigned int dvs_xtal = 0;
	unsigned int vtotal = 0;

	dvs_xtal = PPOVERLAY_DVS_cnt_get_dvs_cnt(IoReg_Read32(PPOVERLAY_DVS_cnt_reg));
	frameRates = 2700000000UL / dvs_xtal;
	vtotal = Get_DISPLAY_CLOCK_TYPICAL() / ((Get_DISP_HORIZONTAL_TOTAL()/100)*frameRates);
#ifdef CONFIG_RTK_KDRV_PWM
	rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),(vtotal-1)*100, 2, FALSE);
#endif
}

unsigned int scaler_get_I2D_tracking_vtotal_by_frameidx(unsigned char frameIdx)
{
	unsigned int vtotal = 0;

	if(!frameIdx)
		return 0;

	switch(frameIdx){
		case 1:
			vtotal = PPOVERLAY_I2D_MEAS_0_get_i2d_tune_res0(IoReg_Read32(PPOVERLAY_I2D_MEAS_0_reg));
			break;
		case 2:
			vtotal = PPOVERLAY_I2D_MEAS_0_get_i2d_tune_res1(IoReg_Read32(PPOVERLAY_I2D_MEAS_0_reg));
			break;
		case 3:
			vtotal = PPOVERLAY_I2D_MEAS_1_get_i2d_tune_res2(IoReg_Read32(PPOVERLAY_I2D_MEAS_1_reg));
			break;
		case 4:
			vtotal = PPOVERLAY_I2D_MEAS_1_get_i2d_tune_res3(IoReg_Read32(PPOVERLAY_I2D_MEAS_1_reg));
			break;
		case 5:
			vtotal = PPOVERLAY_I2D_MEAS_2_get_i2d_tune_res4(IoReg_Read32(PPOVERLAY_I2D_MEAS_2_reg));
			break;
		case 6:
			vtotal = PPOVERLAY_I2D_MEAS_2_get_i2d_tune_res5(IoReg_Read32(PPOVERLAY_I2D_MEAS_2_reg));
			break;
		case 7:
			vtotal = PPOVERLAY_I2D_MEAS_3_get_i2d_tune_res6(IoReg_Read32(PPOVERLAY_I2D_MEAS_3_reg));
			break;
		case 8:
			vtotal = PPOVERLAY_I2D_MEAS_3_get_i2d_tune_res7(IoReg_Read32(PPOVERLAY_I2D_MEAS_3_reg));
			break;
		default:
			vtotal = PPOVERLAY_I2D_MEAS_3_get_i2d_tune_res7(IoReg_Read32(PPOVERLAY_I2D_MEAS_3_reg));
	}
	return vtotal;
}

unsigned char pre_I2D_frameIdx=0;

void scaler_set_I2D_previous_frameIdx(unsigned char frameIdx)
{
#if 0	//debug by gpio trigger
	{
		IoReg_SetBits(0xb8060238, _BIT23|_BIT22|_BIT21|_BIT20);
		IoReg_Write32(0xb8061104, _BIT30|_BIT0);//GPIO

		if(frameIdx){
			IoReg_Write32(0xb806110c, _BIT30|_BIT0);//high
		}else{
			IoReg_Write32(0xb806110c, _BIT30);//low
		}
	}
#endif
	pre_I2D_frameIdx = frameIdx;
	rtd_printk(KERN_NOTICE, "I2D","scaler_set_I2D_previous_frameIdx =%d\n", frameIdx);
}

unsigned char scaler_get_I2D_previous_frameIdx(void)
{
	return pre_I2D_frameIdx;
}

void scaler_I2D_pwm_frequency_update(void)
{
	if(PPOVERLAY_I2D_CTRL_0_get_i2d_special_dly_en(IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg))==1){
		unsigned char cur_FrameIdx = (PPOVERLAY_I2D_MEAS_phase_get_i2d_frame_index(IoReg_Read32(PPOVERLAY_I2D_MEAS_phase_reg)));

		if(cur_FrameIdx!=0){
			unsigned int vtotal = 0;
			scaler_set_I2D_previous_frameIdx(cur_FrameIdx);
			vtotal = scaler_get_I2D_tracking_vtotal_by_frameidx(cur_FrameIdx);
#ifdef CONFIG_RTK_KDRV_PWM
			rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),vtotal*100, 2, FALSE);
#endif
			rtd_printk(KERN_NOTICE, "I2D","[T]frameIdx=%d,vtotal=%x\n", PPOVERLAY_I2D_MEAS_phase_get_i2d_frame_index(IoReg_Read32(PPOVERLAY_I2D_MEAS_phase_reg)),vtotal);
		}else if(scaler_get_I2D_previous_frameIdx()!=0){
#ifdef CONFIG_RTK_KDRV_PWM
			unsigned int vtotal = PPOVERLAY_DV_total_get_dv_total(IoReg_Read32(PPOVERLAY_DV_total_reg));
			rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),vtotal*100, 2, FALSE);
#endif
			scaler_set_I2D_previous_frameIdx(0);
			rtd_printk(KERN_NOTICE, "I2D","[F]frameIdx=%d\n", PPOVERLAY_I2D_MEAS_phase_get_i2d_frame_index(IoReg_Read32(PPOVERLAY_I2D_MEAS_phase_reg)));
		}
	}
}

void scaler_set_I2D_dly_offset(void)
{
	ppoverlay_i2d_ctrl_1_RBUS ppoverlay_i2d_ctrl_1_reg;

	ppoverlay_i2d_ctrl_1_reg.regValue = 0;

    if(scaler_get_I2D_tracking_in_slow_mode() == 1)
    {

		if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) > 235) && 		//24hz
			(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) < 245)){
	        if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAC_FS_REMOVE_RATIO)==2){
				//24hz to 60hz
	            ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_REALCINEMA_DLY_ADD_LINE_MAX;
	            ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_REALCINEMA_DLY_SUB_LINE_MAX;
	        }
		}else{
            ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_DLY_ADD_LINE_MAX+1;
            ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_DLY_SUB_LINE_MAX;
        }
    }else{
       if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) > 235) && 		//24hz
			(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) < 245)){
            if(scaler_get_I2D_tracking_in_realcinema() == TRUE){
				if(Scaler_DispGetInputInfoByDisp(0,SLR_INPUT_FRAC_FS_REMOVE_RATIO)==2){
					//24hz to 60hz
	                ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_REALCINEMA_DLY_ADD_LINE_MAX;
	                ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_REALCINEMA_DLY_SUB_LINE_MAX;
				}else{
					//24hz to 120hz
					ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_DLY_ADD_LINE_MAX+1;
					ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_DLY_SUB_LINE_MAX;
				}
            }else{
				if(Scaler_DispGetInputInfoByDisp(0,SLR_INPUT_FRAC_FS_REMOVE_RATIO)==2){
					//24hz to 60hz
					ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_2_5_DLY_ADD_LINE_MAX;
					ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_2_5_DLY_SUB_LINE_MAX;
				}else{
					//24hz to 120hz
	                ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_2_5_24HZ_120HZ_DLY_ADD_LINE_MAX;
	                ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_2_5_24HZ_120HZ_DLY_SUB_LINE_MAX;
				}
            }
        }
		else if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) > 245) && 		//25hz
			(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) < 255)){
			//25hz to 50hz or 25hz to 100hz
			ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_1_2_25HZ_DLY_ADD_LINE_MAX;
			ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_1_2_25HZ_DLY_SUB_LINE_MAX;
		}
		else if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) > 295) && 		//30hz
			(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) < 305))
		{
			//30hz to 60hz or 30hz to 120hz
			ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_1_2_30HZ_DLY_ADD_LINE_MAX;
			ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_1_2_30HZ_DLY_SUB_LINE_MAX;
		}
        else{  //50/60hz case
            ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = NEW_FLL_I2D_DLY_ADD_LINE_MAX+1;
            ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = NEW_FLL_I2D_DLY_SUB_LINE_MAX;
        }
    }

	IoReg_Write32(PPOVERLAY_I2D_CTRL_1_reg, ppoverlay_i2d_ctrl_1_reg.regValue);
	rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "scaler_set_I2D_dly_offset = %x \n", IoReg_Read32(PPOVERLAY_I2D_CTRL_1_reg));
}


static int fixlast_line_tsk(void *p)
{
 //   struct cpumask vsc_cpumask;
	static UINT8 checkStableCnt=0;
	unsigned int count2 = 0x3fffff;
	unsigned int ch1_line_cnt_lower = 0;
	unsigned int ch1_line_cnt_upper = 0;
	//ppoverlay_dtg_frame_cnt1_RBUS dtg_frame_cnt1_reg;
	//ppoverlay_new_meas0_linecnt_real_RBUS ppoverlay_new_meas0_linecnt_real_reg;
#ifndef NEW_FLL_SPEEDUP_BY_HW_MODE
	vgip_vgip_chn1_lc_RBUS vgip_chn1_lc_reg;
	UINT32 timeout=0;
	ppoverlay_new_meas2_linecnt_real_RBUS new_meas2_linecnt_real_reg;
	ppoverlay_uzudtg_dv_total_RBUS uzudtg_dv_total_reg;
#endif
	unsigned int vtotal = 0;
	unsigned int uzudtg_line_lower = FLL_UZUDTG_VSYNC_LINE_DELAY;
	unsigned int uzudtg_line_upper = FLL_UZUDTG_VSYNC_LINE_DELAY + FLL_UZUDTG_WAIT_LINE_RANGE;
#ifdef NEW_FLL_SPEEDUP_BY_HW_MODE
	ppoverlay_dv_total_RBUS dv_total_reg;
	ppoverlay_i2d_ctrl_0_RBUS ppoverlay_i2d_ctrl_0_reg;
	ppoverlay_i2d_ctrl_1_RBUS ppoverlay_i2d_ctrl_1_reg;
	ppoverlay_i2d_meas_phase_RBUS ppoverlay_i2d_meas_phase_reg;
	UINT32 lineDelay = 0;
#endif

#ifndef CONFIG_HW_SUPPORT_MEMC
		unsigned short input_framerate = 0;
#endif

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "fixlast_line_tsk()\n");
/*
    cpumask_clear(&vsc_cpumask);
    cpumask_set_cpu(0, &vsc_cpumask); // run task in core 0
    cpumask_set_cpu(2, &vsc_cpumask); // run task in core 2
    cpumask_set_cpu(3, &vsc_cpumask); // run task in core 3
    sched_setaffinity(0, &vsc_cpumask);
*/
	current->flags &= ~PF_NOFREEZE;


	while (1)
	{
#if 1
		if(IoReg_Read32(0xb8022288)&_BIT18){
			extern void gamemode_delaytime_print_msg(void);
			gamemode_delaytime_print_msg();
			drv_framesync_on_fixlastline_phaseErr_verify();
			msleep(20);
			IoReg_ClearBits(0xb8022288, _BIT18);
		}
		//for fixlastline phaseErr realtime debug
		//drv_framesync_on_fixlastline_phaseErr_verify();

//#ifdef UZU_60_24_MEMC_BYPASS_ENABLE
		if(IoReg_Read32(0xb8022288)&_BIT25) {
			extern void drivf_scaler_set_memc_bypass(void);
			drivf_scaler_set_memc_bypass();
			msleep(20);
			IoReg_ClearBits(0xb8022288, _BIT25);
		}
//#endif
		down(get_scaler_fll_running_semaphore());

		if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)&& (get_scaler_stop_flag(SLR_MAIN_DISPLAY)==FALSE)){
#ifndef CONFIG_HW_SUPPORT_MEMC
			input_framerate = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ);
#endif
			//down(&GameMode_Check_Semaphore);

			if(modestate_get_fll_running_flag()){
				if(checkStableCnt> 2){
#ifdef ENABLE_SCALER_DUMP_FRAME_INFO
					if (scaler_DumpCRC_Config.enable == 1) {
						drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
						drivf_scaler_reset_freerun();
					}
#endif
					if((modestate_decide_display_timing() == DISPLAY_MODE_NEW_FLL_MODE) &&
						(drvif_scaler_get_display_mode() != DISPLAY_MODE_NEW_FLL_MODE)){

						framesync_fixlastline_set_precision_vtotal();

						//down(&VSC_Semaphore);
						//Scaler_SetCurrentDispInfo(SLR_MAIN_DISPLAY);
						vtotal = Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_LEN);
						ch1_line_cnt_lower = vtotal - (vtotal * FLL_LOWER_DOUNDARY_PERCENT / 1000);//lower boundary is total line * 2.2%
						ch1_line_cnt_upper = (vtotal * FLL_UPPER_DOUNDARY_PERCENT / 1000);//upper boundary is total line's 4.4%
						//printk(KERN_EMERG"\n ch1_line_cnt_lower = %d, ch1_line_cnt_upper = %d\n", ch1_line_cnt_lower, ch1_line_cnt_upper);

						if((/*(DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_VDEC)||*/(DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_JPEG)) &&
							(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY,SLR_INPUT_FRAMESYNC)== FALSE)){
							//change to FLL
							rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "### set fll new mode 1.###\n");
							framesync_lastlinefinetune_at_new_mode();
							//modestate_set_display_timing(0);
							drvif_scaler_set_display_mode(DISPLAY_MODE_NEW_FLL_MODE);
							modestate_set_fll_running_flag(FALSE);
							checkStableCnt=0;
						}
                        else if((drv_memory_get_game_mode() == TRUE)&&(vbe_disp_gamemode_use_fixlastline()==TRUE)){
							//check smooth toggle already done
							Check_smooth_toggle_update_flag(SLR_MAIN_DISPLAY);

#ifdef NEW_FLL_SPEEDUP_BY_HW_MODE
							//get game mode line delay
							lineDelay = drv_framesync_get_gamemode_iv2dv_linedelay();
							//AV Gamemode need increase iv2pv delay to avoid hw noise
							//if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD)  && (get_AVD_Input_Source() != _SRC_TV)){
								//drv_AV_GameMode_reset_iv2pv_delay(lineDelay);
							//}

							//					 i2d_delay_lower |	 |i2d_delay_upper
							//		IVS 					 |---------------------------|
							//		DVS   |-----------------|-----------------|

							dv_total_reg.regValue = IoReg_Read32(PPOVERLAY_DV_total_reg);

							// FLL sync point parameters.
							ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
							ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_mode = 1; //continuous mode
							ppoverlay_i2d_ctrl_0_reg.i2d_dly_lower = (lineDelay-FLL_UZUDTG_WAIT_LINE_RANGE);
							ppoverlay_i2d_ctrl_0_reg.i2d_dly_upper = lineDelay;
							IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
							// speed up direction and capability (about 2Hz variations)
							// 594M / (4400*58) = 2327, 2327-2250 ~= 80
							ppoverlay_i2d_ctrl_1_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_1_reg);
#ifdef ENABLE_SCALER_DUMP_FRAME_INFO
							if (scaler_DumpCRC_Config.enable == 1) {
								ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = SCALAR_DUMP_NEW_FLL_I2D_DLY_ADD_LINE_MAX;
								ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = SCALAR_DUMP_NEW_FLL_I2D_DLY_SUB_LINE_MAX;
							} else
#endif
							{
								//set I2D hw tracking offset
								scaler_set_I2D_dly_offset();
							}
							//control localdimming freq. offset
							IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1+NEW_FLL_I2D_DLY_ADD_LINE_MAX)/2)-1)<<19); // repeat local dimming vsync
							//control pwm freq. offset
							if(scaler_get_I2D_tracking_in_slow_mode() == 1){
#ifdef CONFIG_RTK_KDRV_PWM
								rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),(dv_total_reg.dv_total+NEW_FLL_I2D_DLY_ADD_LINE_MAX)*100, 2, FALSE);
#endif
							}else{
								if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) > 235) && 		//24hz
									(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) < 245))
								{
	                                if(scaler_get_I2D_tracking_in_realcinema() == TRUE){
#ifdef CONFIG_RTK_KDRV_PWM
										rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),(dv_total_reg.dv_total+NEW_FLL_I2D_DLY_ADD_LINE_MAX)*100, 2, FALSE);
#endif
	                                    scaler_set_I2D_tracking_in_realcinema(FALSE);
	                                }else{
										scaler_set_I2D_previous_frameIdx(0);
									    scaler_set_I2D_pwm_frequency_update_in_isr(TRUE);
	                                }
								}else if(((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ)>245)&&(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) < 255)) ||
			  							((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ)>295)&&(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) < 305)))
								{
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(TRUE);
								}else{
#ifdef CONFIG_RTK_KDRV_PWM
									rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),(dv_total_reg.dv_total+NEW_FLL_I2D_DLY_ADD_LINE_MAX)*100, 2, FALSE);
#endif
								}
							}
							//enable FLL speed up by hw
							ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
							ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 1;
							IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
							//wait i2d enable
							msleep(10);

							count2 = 300;
							while(count2){
								if(fix_last_line_need_break_condition()){
									ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
									ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
									IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
									modestate_set_fll_running_flag(TRUE);
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(FALSE);
									//control localdimming freq. offset
									IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1)/2)-1)<<19); // repeat local dimming vsync
									//control pwm freq. offset
#ifdef CONFIG_RTK_KDRV_PWM
          							rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),dv_total_reg.dv_total*100, 2, FALSE);
#endif
									break;
								}

								ppoverlay_i2d_meas_phase_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_MEAS_phase_reg);
								if(ppoverlay_i2d_meas_phase_reg.i2d_phase_err < scaler_get_I2D_tracking_phase_error_threadhold()){
									//check right phase and enable fixlastline
									drvif_scaler_set_display_mode(DISPLAY_MODE_NEW_FLL_MODE);
									framesync_lastlinefinetune_at_new_mode();
									//Disable I2D
									ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
									ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
									IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
									//control localdimming freq. offset
									IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1)/2)-1)<<19); // repeat local dimming vsync
									//control pwm freq. offset
#ifdef CONFIG_RTK_KDRV_PWM
									rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),dv_total_reg.dv_total*100, 2, FALSE);
#endif
									modestate_set_fll_running_flag(FALSE);
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(FALSE);
									//change to 1-buffer after iv2dv done @Crixus 20170527
#if 0//ndef CONFIG_HW_SUPPORT_MEMC	//Eric@20180621 all framerate can support m domain single buffer without memc
									if(input_framerate >= 490)//50 60 framerate can support m domain single buffer without memc

#endif
									{//50 60 framerate can support m domain single buffer without memc
										down(&GameMode_Check_Semaphore);
										//avoid run smoothtoggle after scaler
										if(fix_last_line_need_break_condition()){
											modestate_set_fll_running_flag(FALSE);
											up(&GameMode_Check_Semaphore);
											break;
										}
										drv_memory_GameMode_Switch_SingleBuffer();
										up(&GameMode_Check_Semaphore);
									}
									checkStableCnt=0;
									rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "### set fll new mode 3. (count=%d)(phase_err=%d)###\n", count2,ppoverlay_i2d_meas_phase_reg.i2d_phase_err);
									break;

								}

								// DC off avoids this thread to lock vsc semaphore
								if(fix_last_line_need_break_condition()){
									ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
									ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
									IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
									modestate_set_fll_running_flag(TRUE);
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(FALSE);
									//control localdimming freq. offset
									IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1)/2)-1)<<19); // repeat local dimming vsync
									//control pwm freq. offset
#ifdef CONFIG_RTK_KDRV_PWM
									rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),dv_total_reg.dv_total*100, 2, FALSE);
#endif
									break;
								}

								//check game mode status to aviod mute on time too long @Crixus 20161219
								if(drv_memory_get_game_mode() == _DISABLE){
									rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "[FLL]game mode enable exit\n");
									//recovery
									ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
									ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
									IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
									modestate_set_fll_running_flag(TRUE);
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(FALSE);
									//control localdimming freq. offset
									IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1)/2)-1)<<19); // repeat local dimming vsync
									//control pwm freq. offset
#ifdef CONFIG_RTK_KDRV_PWM
									rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),dv_total_reg.dv_total*100, 2, FALSE);
#endif
									break;
								}

								msleep(10);
								count2--;
							}

							if(count2==0){
								ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
								ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
								ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_mode = 0; //continuous mode
								IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
								rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"func=%s, line=%d, timeout\n", __FUNCTION__, __LINE__);
								rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"fll meas= (%x.%x.%x.%x.%x)\n", IoReg_Read32(PPOVERLAY_I2D_MEAS_0_reg),IoReg_Read32(PPOVERLAY_I2D_MEAS_1_reg),
									IoReg_Read32(PPOVERLAY_I2D_MEAS_2_reg),IoReg_Read32(PPOVERLAY_I2D_MEAS_3_reg),IoReg_Read32(PPOVERLAY_I2D_MEAS_phase_reg));
							}

#else
							if(vsc_decide_fixlastline_speedup_enable() == TRUE){
								ppoverlay_dv_total_RBUS dv_total_reg;
								fwif_color_safe_od_enable(0);
								dv_total_reg.regValue = IoReg_Read32(PPOVERLAY_DV_total_reg);
								drvif_scaler_set_frc2fsync_recovery_vtotal(dv_total_reg.dv_total+1);
								rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"fll set recovery vtotal = %x", dv_total_reg.dv_total+1);
								drvif_scaler_set_fixlastline_vtotal_speedup_protect_on();
								rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"func=%s, line=%d\n", __FUNCTION__, __LINE__);
							}

							count2 = 0xa0000;

							while(count2){
								if(drv_framesync_check_iv2dv_phaseErr_on_fixlastline()==TRUE){
									//check right phase and enable fixlastline
									drvif_scaler_set_display_mode(DISPLAY_MODE_NEW_FLL_MODE);
									framesync_lastlinefinetune_at_new_mode();
									//wait speed up vtotal done
									timeout = 0x3fffff;
									new_meas2_linecnt_real_reg.regValue = IoReg_Read32(PPOVERLAY_new_meas2_linecnt_real_reg);
									while((new_meas2_linecnt_real_reg.uzudtg_dly_line_cnt_rt!=uzudtg_dv_total_reg.uzudtg_dv_total)&&(timeout--)){
										new_meas2_linecnt_real_reg.regValue = IoReg_Read32(PPOVERLAY_new_meas2_linecnt_real_reg);
									}
									if(timeout==0){
										pr_emerg("[drv_framesync_check_iv2dv_phaseErr_on_fixlastline] wait timeout. \n");
									}
									//recovory origin vtotal done
									if(vsc_decide_fixlastline_speedup_enable() == TRUE){
										drvif_scaler_set_frc2fsync_vtotal_protect_off();
										fwif_color_safe_od_enable(1);
									}
									modestate_set_fll_running_flag(FALSE);
									//change to 1-buffer after iv2dv done @Crixus 20170527
#ifndef CONFIG_HW_SUPPORT_MEMC
									if(input_framerate >= 490)//50 60 framerate can support m domain single buffer without memc

#endif
									{//50 60 framerate can support m domain single buffer without memc
											down(&GameMode_Check_Semaphore);
										drv_memory_GameMode_Switch_SingleBuffer();
											up(&GameMode_Check_Semaphore);
									}
									checkStableCnt=0;
									rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "### set fll new mode 3.###\n");
									break;
								}

								//check game mode status to aviod mute on time too long @Crixus 20161219
								if(drv_memory_get_game_mode() == _DISABLE){
									rtd_printk(KERN_EMERG, TAG_NAME_VSC, "[FLL]game mode Exit\n");
									//recovery
									if(vsc_decide_fixlastline_speedup_enable() == TRUE){
										drvif_scaler_set_frc2fsync_vtotal_protect_off();
										fwif_color_safe_od_enable(1);
									}
									modestate_set_fll_running_flag(FALSE);
									break;
								}


								// DC off avoids this thread to lock vsc semaphore
								if(fix_last_line_need_break_condition()){
									if(vsc_decide_fixlastline_speedup_enable() == TRUE){
										drvif_scaler_set_frc2fsync_vtotal_protect_off();
										fwif_color_safe_od_enable(1);
									}
									modestate_set_fll_running_flag(FALSE);
									break;
								}
								count2--;
							}
							if(count2 == 0){
								rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "count timeout !!!\n");
								//printk(KERN_EMERG"count timeout !!!\n");
								if(vsc_decide_fixlastline_speedup_enable() == TRUE){
									drvif_scaler_set_frc2fsync_vtotal_protect_off();
									fwif_color_safe_od_enable(1);
								}
							}
#endif

                        }else
						{
#ifdef NEW_FLL_SPEEDUP_BY_HW_MODE

							//			  i2d_delay_lower | |i2d_delay_upper
							//		IVS 					|---------------------------|
							//		DVS   |-----------------|-----------------|

							dv_total_reg.regValue = IoReg_Read32(PPOVERLAY_DV_total_reg);
							// FLL sync point parameters.
							ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
							//ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_mode = 0; //one-time mode
							ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_mode = 1; //continuous mode
							ppoverlay_i2d_ctrl_0_reg.i2d_dly_lower = dv_total_reg.dv_total-uzudtg_line_upper;
							ppoverlay_i2d_ctrl_0_reg.i2d_dly_upper = dv_total_reg.dv_total-uzudtg_line_lower;
							//AV source normal mode 50Hz need fine tune i2d_dly
							//if((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD)  && (get_AVD_Input_Source() != _SRC_TV)){
								//if((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) > 495) && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) < 505)){
									//ppoverlay_i2d_ctrl_0_reg.i2d_dly_lower = dv_total_reg.dv_total-uzudtg_line_upper - 752;
									//ppoverlay_i2d_ctrl_0_reg.i2d_dly_upper = dv_total_reg.dv_total-uzudtg_line_lower - 752;
								//}
							//}
							IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
							// speed up direction and capability (about 2Hz variations)
							// 594M / (4400*58) = 2327, 2327-2250 ~= 80
#ifdef ENABLE_SCALER_DUMP_FRAME_INFO
							if (scaler_DumpCRC_Config.enable == 1) {
								ppoverlay_i2d_ctrl_1_reg.i2d_dly_add_line_max = SCALAR_DUMP_NEW_FLL_I2D_DLY_ADD_LINE_MAX;
								ppoverlay_i2d_ctrl_1_reg.i2d_dly_sub_line_max = SCALAR_DUMP_NEW_FLL_I2D_DLY_SUB_LINE_MAX;
							} else
#endif
							{
								//set I2D hw tracking offset
								scaler_set_I2D_dly_offset();
							}
							//control localdimming freq. offset
							IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1+NEW_FLL_I2D_DLY_ADD_LINE_MAX)/2)-1)<<19); // repeat local dimming vsync
							//control pwm freq. offset
							if(scaler_get_I2D_tracking_in_slow_mode() == 1){
#ifdef CONFIG_RTK_KDRV_PWM
								rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),(dv_total_reg.dv_total+NEW_FLL_I2D_DLY_ADD_LINE_MAX)*100, 2, FALSE);
#endif
							}else{
								if((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) > 235) && 		//24hz
									(Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) < 245))
								{
	                                if(scaler_get_I2D_tracking_in_realcinema() == TRUE){
#ifdef CONFIG_RTK_KDRV_PWM
										rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),(dv_total_reg.dv_total+NEW_FLL_I2D_DLY_ADD_LINE_MAX)*100, 2, FALSE);
#endif
	                                    scaler_set_I2D_tracking_in_realcinema(FALSE);
	                                }else{
										scaler_set_I2D_previous_frameIdx(0);
									    scaler_set_I2D_pwm_frequency_update_in_isr(TRUE);
	                                }
								}else if(((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)>245)&&(Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) < 255)) ||
			  							((Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ)>295)&&(Scaler_DispGetInputInfo(SLR_INPUT_V_FREQ) < 305)))
								{
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(TRUE);
								}else{
#ifdef CONFIG_RTK_KDRV_PWM
									rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),(dv_total_reg.dv_total+NEW_FLL_I2D_DLY_ADD_LINE_MAX)*100, 2, FALSE);
#endif
								}
							}
							//enable FLL speed up by hw
							ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
							ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 1;
							IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
							//wait i2d enable
							msleep(10);

							count2 = 300;
							while(count2){
								if(fix_last_line_need_break_condition()){
									ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
									ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
									IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
									//control localdimming freq. offset
									IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1)/2)-1)<<19); // repeat local dimming vsync
									//control pwm freq. offset
#ifdef CONFIG_RTK_KDRV_PWM
									rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),dv_total_reg.dv_total*100, 2, FALSE);
#endif
									modestate_set_fll_running_flag(TRUE);
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(FALSE);
									break;
								}
								ppoverlay_i2d_meas_phase_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_MEAS_phase_reg);
								if(ppoverlay_i2d_meas_phase_reg.i2d_phase_err < scaler_get_I2D_tracking_phase_error_threadhold()){
									drvif_scaler_set_display_mode(DISPLAY_MODE_NEW_FLL_MODE);
									framesync_lastlinefinetune_at_new_mode();
									//modestate_set_display_timing(0);
									//Disable I2D
									ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
									ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
									IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
									//control localdimming freq. offset
									IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1)/2)-1)<<19); // repeat local dimming vsync
									//control pwm freq. offset
#ifdef CONFIG_RTK_KDRV_PWM
									rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),dv_total_reg.dv_total*100, 2, FALSE);
#endif
									modestate_set_fll_running_flag(FALSE);
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(FALSE);

									checkStableCnt=0;
									//change to FLL
									rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "### [HW] set fll new mode 1. (count=%d) ###\n", count2);
									//printk(KERN_EMERG"\n new_meas1_linecnt_real_reg.uzudtg_line_cnt_rt = %x\n", IoReg_Read32(0xb8028258));
									//printk(KERN_EMERG"\n vgip_chn1_lc_reg.ch1_line_cnt = %x\n", IoReg_Read32(0xb8022234));
									rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"\n fll meas= (%x.%x.%x.%x.%x)\n", IoReg_Read32(PPOVERLAY_I2D_MEAS_0_reg),IoReg_Read32(PPOVERLAY_I2D_MEAS_1_reg),
										IoReg_Read32(PPOVERLAY_I2D_MEAS_2_reg),IoReg_Read32(PPOVERLAY_I2D_MEAS_3_reg),IoReg_Read32(PPOVERLAY_I2D_MEAS_phase_reg));
									break;
								}

								//check game mode status to aviod mute on time too long @Crixus 20161219
								if(drv_memory_get_game_mode() == _ENABLE){
									rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "[FLL]game mode enable break\n");
									//recovery
									ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
									ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
									IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
									modestate_set_fll_running_flag(TRUE);
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(FALSE);
									//control localdimming freq. offset
									IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1)/2)-1)<<19); // repeat local dimming vsync
									//control pwm freq. offset
#ifdef CONFIG_RTK_KDRV_PWM
									rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),dv_total_reg.dv_total*100, 2, FALSE);
#endif
									break;
								}

								// DC off avoids this thread to lock vsc semaphore
								if(fix_last_line_need_break_condition()){
									rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"FUNC:%s, break due to scaler stop\n", __FUNCTION__);
									ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
									ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
									IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
									modestate_set_fll_running_flag(TRUE);
									scaler_set_I2D_previous_frameIdx(0);
									scaler_set_I2D_pwm_frequency_update_in_isr(FALSE);
									//control localdimming freq. offset
									IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1)/2)-1)<<19); // repeat local dimming vsync
									//control pwm freq. offset
#ifdef CONFIG_RTK_KDRV_PWM
									rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),dv_total_reg.dv_total*100, 2, FALSE);
#endif
									break;
								}
								msleep(10);
								count2--;
							}

							if(count2==0){
								ppoverlay_i2d_ctrl_0_reg.regValue = IoReg_Read32(PPOVERLAY_I2D_CTRL_0_reg);
								ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_en = 0;
								ppoverlay_i2d_ctrl_0_reg.i2d_special_dly_mode = 0; //continuous mode
								IoReg_Write32(PPOVERLAY_I2D_CTRL_0_reg, ppoverlay_i2d_ctrl_0_reg.regValue);
								//control localdimming freq. offset
								IoReg_Mask32(LDSPI_ld_spi_v_total_reg, 0x7ffff, (((dv_total_reg.dv_total+1)/2)-1)<<19); // repeat local dimming vsync
								//control pwm freq. offset
#ifdef CONFIG_RTK_KDRV_PWM
								rtk_pwm_set_scaler_source(Get_DISP_HORIZONTAL_TOTAL(),dv_total_reg.dv_total*100, 2, FALSE);
#endif
								rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"func=%s, line=%d, timeout\n", __FUNCTION__, __LINE__);
								rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"fll meas= (%x.%x.%x.%x.%x)\n", IoReg_Read32(PPOVERLAY_I2D_MEAS_0_reg),IoReg_Read32(PPOVERLAY_I2D_MEAS_1_reg),
									IoReg_Read32(PPOVERLAY_I2D_MEAS_2_reg),IoReg_Read32(PPOVERLAY_I2D_MEAS_3_reg),IoReg_Read32(PPOVERLAY_I2D_MEAS_phase_reg));
							}

#else
							count2 = 0x3fffff;
							/*speedup*/
							if(vsc_decide_fixlastline_speedup_enable() == TRUE){
								ppoverlay_dv_total_RBUS dv_total_reg;
								fwif_color_safe_od_enable(0);
								dv_total_reg.regValue = IoReg_Read32(PPOVERLAY_DV_total_reg);
								drvif_scaler_set_frc2fsync_recovery_vtotal(dv_total_reg.dv_total+1);
								rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"fll set recovery vtotal = %x", dv_total_reg.dv_total+1);
								drvif_scaler_set_fixlastline_vtotal_speedup_protect_on();
								rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"func=%s, line=%d\n", __FUNCTION__, __LINE__);
							}
							while(count2){
								new_meas2_linecnt_real_reg.regValue = IoReg_Read32(PPOVERLAY_new_meas2_linecnt_real_reg);
								vgip_chn1_lc_reg.regValue = IoReg_Read32(VGIP_VGIP_CHN1_LC_reg);
								/*wait uzu dtg Vsync and wait the vgip line cnt*/
								if(((new_meas2_linecnt_real_reg.uzudtg_dly_line_cnt_rt >= uzudtg_line_lower) && (new_meas2_linecnt_real_reg.uzudtg_dly_line_cnt_rt < uzudtg_line_upper))
								&& ((vgip_chn1_lc_reg.ch1_line_cnt >= ch1_line_cnt_lower) || (vgip_chn1_lc_reg.ch1_line_cnt <= ch1_line_cnt_upper))){
									/*recover*/
									if(vsc_decide_fixlastline_speedup_enable() == TRUE){
										drvif_scaler_set_frc2fsync_vtotal_protect_off();
										fwif_color_safe_od_enable(1);
									}
									framesync_lastlinefinetune_at_new_mode();
									//modestate_set_display_timing(0);
									drvif_scaler_set_display_mode(DISPLAY_MODE_NEW_FLL_MODE);
									modestate_set_fll_running_flag(FALSE);
									checkStableCnt=0;
									//change to FLL
									rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "### set fll new mode 1.###\n");

									//printk(KERN_EMERG"\n new_meas2_linecnt_real_reg.uzudtg_dly_line_cnt_rt = %d\n", new_meas2_linecnt_real_reg.uzudtg_dly_line_cnt_rt);
									//printk(KERN_EMERG"\n vgip_chn1_lc_reg.ch1_line_cnt = %d\n", vgip_chn1_lc_reg.ch1_line_cnt);
									break;
								}

								//check game mode status to aviod mute on time too long @Crixus 20161219
								if(drv_memory_get_game_mode() == _ENABLE){
									rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "[FLL]game mode enable break\n");
									//recovery
									if(vsc_decide_fixlastline_speedup_enable() == TRUE){
										drvif_scaler_set_frc2fsync_vtotal_protect_off();
										fwif_color_safe_od_enable(1);
									}
									modestate_set_fll_running_flag(FALSE);
									break;
								}

								// DC off avoids this thread to lock vsc semaphore
								if(fix_last_line_need_break_condition()){
									rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"FUNC:%s, break due to scaler stop\n", __FUNCTION__);
									if(vsc_decide_fixlastline_speedup_enable() == TRUE){
										drvif_scaler_set_frc2fsync_vtotal_protect_off();
										fwif_color_safe_od_enable(1);
									}
									modestate_set_fll_running_flag(FALSE);
									break;
								}
								count2--;
							}
							//printk(KERN_EMERG"count2 = %d\n", count2);

							if(count2 == 0){
								rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "count timeout !!!\n");
								//printk(KERN_EMERG"count timeout !!!\n");
								if(vsc_decide_fixlastline_speedup_enable() == TRUE){
									drvif_scaler_set_frc2fsync_vtotal_protect_off();
									fwif_color_safe_od_enable(1);
								}
							}
#endif
						}
						//up(&VSC_Semaphore);
					}
				}
				else{
					checkStableCnt++;
				}
			}else{
				//down(&VSC_Semaphore);
				if ((vbe_disp_get_adaptivestream_fs_mode() == 1) &&
					(Get_DISPLAY_PANEL_TYPE() != P_VBY1_TO_HDMI) &&
					(Get_DISPLAY_PANEL_TYPE() != P_VBY1_TO_LVDS_TO_HDMI)) {
					if(drvif_scaler_get_display_mode() != DISPLAY_MODE_FRAME_SYNC){

						pr_emerg("[fll]drvif_scaler_get_display_mode=%d\n", drvif_scaler_get_display_mode());
                        fwif_color_safe_od_enable(0);
						drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
						fwif_color_safe_od_enable(1);
					}
				}
#if 0 //def ENABLE_IMD_PST_SMOOTHTOGGLE
				else if(1){
					if(drvif_scaler_get_display_mode() != DISPLAY_MODE_FRAME_SYNC){
						rtd_printk(KERN_NOTICE, "VBE", "[%s][line:%d] PST smoothtoggle go fs\n", __FUNCTION__, __LINE__);
						fwif_color_safe_od_enable(0);
						drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
						fwif_color_safe_od_enable(1);
					}
					modestate_set_fll_running_flag(_DISABLE);
				}
#endif
				if(Get_DISPLAY_PANEL_OLED_TYPE()==TRUE){
					if((drv_memory_get_game_mode_dynamic() == _ENABLE)&&(drv_memory_get_game_mode() == TRUE)){
						if(drvif_scaler_get_display_mode() != DISPLAY_MODE_FRAME_SYNC){
							fwif_color_safe_od_enable(0);
							drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
							fwif_color_safe_od_enable(1);
						}
					}
				}
				//up(&VSC_Semaphore);
				checkStableCnt = 0;
			}
			//up(&GameMode_Check_Semaphore);
		}else{
			checkStableCnt = 0;
		}
		up(get_scaler_fll_running_semaphore());
#endif

		if (freezing(current))
		{
			try_to_freeze();
		}
		if (kthread_should_stop()) {
			break;
		}
		msleep(10);
	}

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,  "\r\n####fixlast_line_tsk: exit...####\n");
	do_exit(0);
	return 0;
}

static void create_fixlast_line_tsk(void)
{
	int err;
	if (fix_lastline_tsk_running_flag == FALSE) {
		p_fix_lastline_tsk = kthread_create(fixlast_line_tsk, NULL, "fix_lastline_tsk");

	    if (p_fix_lastline_tsk) {
			wake_up_process(p_fix_lastline_tsk);
			fix_lastline_tsk_running_flag = TRUE;
	    } else {
	    	err = PTR_ERR(p_fix_lastline_tsk);
	    	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Unable to start fixlast_line_tsk (err_id = %d)./n", err);
	    }
	}
}

static void delete_fix_lastline_tsk(void)
{
	int ret;
	if (fix_lastline_tsk_running_flag) {
 		ret = kthread_stop(p_fix_lastline_tsk);
 		if (!ret) {
 			p_fix_lastline_tsk = NULL;
 			fix_lastline_tsk_running_flag = FALSE;
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "fixlast_line_tsk thread stopped\n");
 		}
	}
}

static void create_localDimmingDemoCtrl_tsk(void)
{
	int err;
	if (localDimmingDemoCtrl_tsk_running_flag == FALSE) {
		p_localDimmingDemoCtrl_tsk = kthread_create(localDimmingDemoCtrl_tsk, NULL, "localDimmingDemoCtrl_tsk");

	    if (p_localDimmingDemoCtrl_tsk) {
			wake_up_process(p_localDimmingDemoCtrl_tsk);
			localDimmingDemoCtrl_tsk_running_flag = TRUE;
	    } else {
	    	err = PTR_ERR(p_localDimmingDemoCtrl_tsk);
	    	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Unable to start localDimmingDemoCtrl_tsk (err_id = %d)./n", err);
	    }
	}
}

static void delete_localDimmingDemoCtrl_tsk(void)
{
	int ret;
	if (localDimmingDemoCtrl_tsk_running_flag) {
 		ret = kthread_stop(p_localDimmingDemoCtrl_tsk);
 		if (!ret) {
 			p_localDimmingDemoCtrl_tsk = NULL;
 			localDimmingDemoCtrl_tsk_running_flag = FALSE;
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "localDimmingDemoCtrl_tsk thread stopped\n");
 		}
	}
}

void game_mode_set_ignore_cmd_check(unsigned char enable)
{
	game_mode_ignore_cmd_check = enable;
}

static bool game_mode_unmute_tsk_running_flag = FALSE;
static struct task_struct *p_game_mode_unmute_tsk = NULL;
extern void Scaler_wait_for_frc2fs_hw_lock_done(unsigned char display);

static int game_mode_unmute_tsk(void *p)
{
//	struct cpumask vsc_cpumask;
	static UINT8 checkStableCnt = 0;
	static UINT32 scaler_game_mode_cmd_pre = 0;

	static UINT8 CheckST_StableCnt = 0;
	static UINT32 ST_game_mode_cmd_pre = 0;
	unsigned int cmd_check_cnt = 0;
	unsigned int st_cmd_check_cnt = 0;
	ppoverlay_uzudtg_control1_RBUS uzudtg_control1_reg;
	ppoverlay_memcdtg_control3_RBUS memcdtg_control3_reg;
	ppoverlay_memc_mux_ctrl_RBUS memc_mux_ctrl_reg;
	unsigned int game_mode_wait_timeout = 40;//400ms
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "game_mode_unmute_tsk()\n");
/*
    cpumask_clear(&vsc_cpumask);
    cpumask_set_cpu(0, &vsc_cpumask); // run task in core 0
    cpumask_set_cpu(2, &vsc_cpumask); // run task in core 2
    cpumask_set_cpu(3, &vsc_cpumask); // run task in core 3
    sched_setaffinity(0, &vsc_cpumask);
*/
	current->flags &= ~PF_NOFREEZE;
	while (1)
	{
		cmd_check_cnt = game_mode_cmd_check;
		st_cmd_check_cnt = smooth_toggle_game_mode_check_cnt;
		//Game mode cmd checking flow @Cixus 20161204
		if ((Get_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_GameMode) == TRUE)
			&& (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
			&& (drv_memory_get_game_mode_dynamic() == drv_memory_get_game_mode_flag())) {
			memc_mux_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_MEMC_MUX_CTRL_reg);
			game_mode_wait_timeout = 40;
			if((get_vt_EnableFRCMode() != FALSE) && Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC) && drv_memory_get_game_mode_dynamic() &&
				memc_mux_ctrl_reg.memc_outmux_sel==0){
				//rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "[GAME MODE] HDMI wait game mode ready  %d\n",game_mode_wait_timeout);
				uzudtg_control1_reg.regValue = IoReg_Read32(PPOVERLAY_uzudtg_control1_reg);
				memcdtg_control3_reg.regValue = IoReg_Read32(PPOVERLAY_MEMCDTG_CONTROL3_reg);
				while(game_mode_wait_timeout--){
					if((uzudtg_control1_reg.dtgm2uzuvs_line == 0) && (memcdtg_control3_reg.dtgm2goldenpostvs_line == 0)){
						break;
					}
					memc_mux_ctrl_reg.regValue = IoReg_Read32(PPOVERLAY_MEMC_MUX_CTRL_reg);
					if (memc_mux_ctrl_reg.memc_outmux_sel!=0) {
						break;
					}
					uzudtg_control1_reg.regValue = IoReg_Read32(PPOVERLAY_uzudtg_control1_reg);
					memcdtg_control3_reg.regValue = IoReg_Read32(PPOVERLAY_MEMCDTG_CONTROL3_reg);
					//wait 10ms
					msleep(10);
				}
				//rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "[GAME MODE] HDMI wait game mode done  %d\n",game_mode_wait_timeout);
				if(game_mode_wait_timeout == 0)
					rtd_printk(KERN_NOTICE, TAG_NAME_VSC, "[GAME MODE] game mode wait golden vsync timeout = %d\n",game_mode_wait_timeout);
			}
			down(&GameMode_Check_Semaphore);
			//after scaler flow, do not check cmd to reduce mute time
			if(game_mode_ignore_cmd_check == _ENABLE){
				if((DbgSclrFlgTkr.game_mode_dynamic_flag == FALSE)){
					game_mode_ignore_cmd_check = _DISABLE;
					game_mode_cmd_pre = cmd_check_cnt;	//Update game_mode_cmd_pre to avoid fll task break.
					st_game_mode_cmd_pre = st_cmd_check_cnt;
					//smooth_toggle_game_mode_timeout_trigger_flag = _DISABLE;
					if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC)
						&&(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)
						&& ((Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) > 1920) && (Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN_PRE) > 1080))
						&& (((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) > 495) && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) < 605)) || Scaler_MEMC_get_Bypass_Status() == FALSE))
					{
							drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
							Scaler_wait_for_frc2fs_hw_lock_done(SLR_MAIN_DISPLAY);
							//IoReg_SetBits(VODMA_VODMA_CLKGEN_reg,VODMA_VODMA_CLKGEN_en_fifo_full_gate_mask);
                            scaler_set_full_gatting_rpc(true);
                            rtd_printk(KERN_EMERG, TAG_NAME_VSC, "1.game mode Enable Gating!\n");
					}else if (((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) &&  // VRR
					(vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag()))==1){
						drv_GameMode_iv2dv_delay(_ENABLE);
						rtd_printk(KERN_EMERG, TAG_NAME_VSC, "VRR after game mode set to timing sync!\n");
						drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
					}

					set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_GameMode, FALSE);
					/*K3LG-1445:sync crixus,willlin,qiangzhou,when gamemode re run scaler,open forcebg need check scaler status active*/
					if (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) {
						trigger_mute_off(SLR_MAIN_DISPLAY, 1);
					}
					printk(KERN_EMERG"[crixus]after scaler do not check timeout, game mode unmute!!\n");
				}
			}
			else{
				if(checkStableCnt < 30){
					if(scaler_game_mode_cmd_pre != cmd_check_cnt){
						checkStableCnt = 0;
						scaler_game_mode_cmd_pre = cmd_check_cnt;
						printk(KERN_EMERG"[crixus]game mode cmd again!! reset!! scaler_game_mode_cmd_pre = %d\n", scaler_game_mode_cmd_pre);
					}
					else{
						checkStableCnt++;
					}
					//printk(KERN_EMERG"[crixus]checkStableCnt = %d\n", checkStableCnt);
				}
				else{
					if((DbgSclrFlgTkr.game_mode_dynamic_flag == FALSE) && (scaler_game_mode_cmd_pre == cmd_check_cnt)){
						//game_mode_cmd_check = 0;	//Eric@20181113 No need to clear here, to avoid race condition
						game_mode_cmd_pre = cmd_check_cnt;	//Eric@20181113 No need to clear here, to avoid race condition
						checkStableCnt = 0;
                        if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_FRAMESYNC)
						&&(Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI)
						&& ((Scaler_DispGetInputInfo(SLR_INPUT_IPH_ACT_WID_PRE) > 1920) && (Scaler_DispGetInputInfo(SLR_INPUT_IPV_ACT_LEN_PRE) > 1080))
						&& (((Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) > 495) && (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_V_FREQ) < 605)) || Scaler_MEMC_get_Bypass_Status() == FALSE))
						{
								drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
								Scaler_wait_for_frc2fs_hw_lock_done(SLR_MAIN_DISPLAY);
								//IoReg_SetBits(VODMA_VODMA_CLKGEN_reg,VODMA_VODMA_CLKGEN_en_fifo_full_gate_mask);
                                scaler_set_full_gatting_rpc(true);
                                rtd_printk(KERN_EMERG, TAG_NAME_VSC, "2.game mode Enable Gating!\n");
						}else if (((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) &&  // VRR
						(vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag()))==1){
							drv_GameMode_iv2dv_delay(_ENABLE);
							rtd_printk(KERN_EMERG, TAG_NAME_VSC, "VRR after game mode set to timing sync!\n");
							drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
						}
						set_display_forcebg_mask(SLR_MAIN_DISPLAY, SLR_FORCE_BG_TYPE_GameMode, FALSE);
						/*K3LG-1445:sync crixus,willlin,qiangzhou,when gamemode re run scaler,open forcebg need check scaler status active*/
						if (Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE) {
							trigger_mute_off(SLR_MAIN_DISPLAY, 1);
						}
						printk(KERN_EMERG"[crixus]game mode unmute!!\n");
					}
					else{
						if(scaler_game_mode_cmd_pre != cmd_check_cnt){
							checkStableCnt = 0;
							printk(KERN_EMERG"[crixus]2. game mode cmd again!! reset!! game_mode_cmd_pre = %d\n", game_mode_cmd_pre);
						}
						printk(KERN_EMERG"[crixus]wait game mode done!!\n");
					}

				}
			}
			up(&GameMode_Check_Semaphore);
		}

		//check smooth toggle done
		if(smooth_toggle_game_mode_timeout_trigger_flag){
			down(&GameMode_Check_Semaphore);
			//printk(KERN_EMERG"[crixus]ST CheckST_StableCnt = %d\n", CheckST_StableCnt);
			//printk(KERN_EMERG"[crixus]ST ST_game_mode_cmd_pre = %d\n", ST_game_mode_cmd_pre);
			//printk(KERN_EMERG"[crixus]ST smooth_toggle_game_mode_check_cnt = %d\n", smooth_toggle_game_mode_check_cnt);
			if(CheckST_StableCnt < 100){
				if(ST_game_mode_cmd_pre != st_cmd_check_cnt){
					CheckST_StableCnt = 0;
					ST_game_mode_cmd_pre = st_cmd_check_cnt;
					printk(KERN_EMERG"[crixus]ST game mode cmd again!! reset!! ST_game_mode_cmd_pre = %d\n", ST_game_mode_cmd_pre);
				}
				else{
					CheckST_StableCnt++;
					//printk(KERN_EMERG"[crixus]ST CheckST_StableCnt = %d\n", CheckST_StableCnt);
				}
			}
			else{
				//reture to game mode setting
				if(drv_memory_get_game_mode()){
					smooth_toggle_game_mode_timeout_trigger_flag = _DISABLE;
					st_game_mode_cmd_pre = st_cmd_check_cnt;
					CheckST_StableCnt = 0;
					if((vbe_disp_gamemode_use_fixlastline()==TRUE) && !((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) && vbe_disp_get_VRR_timingMode_flag())){
						//down(&VSC_Semaphore);
						zoom_update_scaler_info_from_vo_smooth_toggle(SLR_MAIN_DISPLAY);//sync smooth toggle timing info
						drv_game_mode_disp_smooth_variable_setting(GAME_MODE_NEW_FLL);
						//up(&VSC_Semaphore);
					}else{
						//-> iv2dv delay -> frc2fsync  -> single buffer
						//update the iv2pv delay
						if(!Scaler_DispGetInputInfo(SLR_INPUT_FRAMESYNC)){
							drv_GameMode_iv2dv_delay(_ENABLE);
						}

						if (((Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_HDMI) &&  // VRR
						(vbe_disp_get_VRR_timingMode_flag() || vbe_disp_get_freesync_mode_flag()))==1){
							drv_GameMode_iv2dv_delay(_ENABLE);
							rtd_printk(KERN_EMERG, TAG_NAME_VSC, "VRR after game mode set to timing sync!\n");
							drvif_scaler_set_display_mode(DISPLAY_MODE_FRAME_SYNC);
						}
						else{
							//change to timing sync
							//down(&VSC_Semaphore);
							fwif_color_safe_od_enable(0);
							drv_game_mode_disp_smooth_variable_setting(GAME_MODE_FRAME_SYNC);
							fwif_color_safe_od_enable(1);
							//up(&VSC_Semaphore);
						}
					}
					//change to 1-buffer after iv2dv delay done

					printk(KERN_EMERG"[crixus]ST game mode resume done!!\n");
				}
			}
			up(&GameMode_Check_Semaphore);
		}
		else{
			if(st_game_mode_cmd_pre != st_cmd_check_cnt){
				down(&GameMode_Check_Semaphore);
				st_game_mode_cmd_pre = st_cmd_check_cnt;
				up(&GameMode_Check_Semaphore);
			}
		}


		if (freezing(current))
		{
			try_to_freeze();
		}
		if (kthread_should_stop()) {
			break;
		}
		msleep(10);
	}

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,  "\r\n####game_mode_unmute_tsk: exit...####\n");
	do_exit(0);
	return 0;
}

static void create_game_mode_unmute_tsk(void)
{
	int err;
	if (game_mode_unmute_tsk_running_flag == FALSE) {
		p_game_mode_unmute_tsk = kthread_create(game_mode_unmute_tsk, NULL, "game_mode_unmute_tsk");

	    if (p_game_mode_unmute_tsk) {
			wake_up_process(p_game_mode_unmute_tsk);
			game_mode_unmute_tsk_running_flag = TRUE;
	    } else {
	    	err = PTR_ERR(p_game_mode_unmute_tsk);
	    	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Unable to start game_mode_unmute_tsk (err_id = %d)./n", err);
	    }
	}
}

static void delete_game_mode_unmute_tsk(void)
{
	int ret;
	if (game_mode_unmute_tsk_running_flag) {
 		ret = kthread_stop(p_game_mode_unmute_tsk);
 		if (!ret) {
 			p_game_mode_unmute_tsk = NULL;
 			game_mode_unmute_tsk_running_flag = FALSE;
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "game_mode_unmute_tsk thread stopped\n");
 		}
	}
}


#ifdef BRING_UP_AUTO_FLOW/*This is only for bring up use demoap*/
#ifdef AUTO_BRINGUP_SOURCE
void vsc_source_bringup_force_connect(void)
{//force connect ADC source
	KADP_VSC_INPUT_SRC_INFO_T InputsourceInfo = {KADP_VSC_INPUTSRC_MAXN, 0 , 0};
	if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
	{
		return;
	}
#ifdef CONFIG_DUAL_CHANNEL
	if(Sub_DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
	{
		return;
	}
#endif

	switch(AUTO_BRINGUP_SOURCE)
	{
		case _SRC_YPBPR:
		case _SRC_VGA:
		InputsourceInfo.type = KADP_VSC_INPUTSRC_ADC;
		break;

		case _SRC_TV:
		case _SRC_CVBS:
		case _SRC_SV:
		InputsourceInfo.type = KADP_VSC_INPUTSRC_AVD;
		break;

		case _SRC_HDMI:
		InputsourceInfo.type = KADP_VSC_INPUTSRC_HDMI;
		break;

		case _SRC_VO:
		InputsourceInfo.type = KADP_VSC_INPUTSRC_VDEC;
		break;

		default:
			break;

	}

	rtk_hal_vsc_initialize();
	if(InputsourceInfo.type != KADP_VSC_INPUTSRC_MAXN)
	{
		rtk_hal_vsc_open(VIDEO_WID_0);
		rtk_hal_vsc_Connect(VIDEO_WID_0, InputsourceInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
		printk(KERN_EMERG "#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
	}

#ifdef CONFIG_DUAL_CHANNEL
	switch(AUTO_BRINGUP_SOURCE_SUB)
	{
		case _SRC_YPBPR:
		case _SRC_VGA:
		InputsourceInfo.type = KADP_VSC_INPUTSRC_ADC;
		break;

		case _SRC_TV:
		case _SRC_CVBS:
		case _SRC_SV:
		InputsourceInfo.type = KADP_VSC_INPUTSRC_AVD;
		break;

		case _SRC_HDMI:
		InputsourceInfo.type = KADP_VSC_INPUTSRC_HDMI;
		break;

		case _SRC_VO:
		InputsourceInfo.type = KADP_VSC_INPUTSRC_VDEC;
		break;

		default:
			return;
	}
	rtk_hal_vsc_open(VIDEO_WID_1);
	rtk_hal_vsc_Connect(VIDEO_WID_1, InputsourceInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
	printk(KERN_EMERG "#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
#endif
}
#endif

unsigned char bringup_verify_timing_ready(unsigned char source)
{
	StructDisplayInfo *timing_info = NULL;
	switch(source)
	{
		case KADP_VSC_INPUTSRC_ADC:
			timing_info = Get_ADC_Dispinfo();
			if((timing_info->IPH_ACT_WID_PRE == 0) || (timing_info->IPV_ACT_LEN_PRE == 0) || (timing_info->IHFreq == 0) || (timing_info->IVFreq == 0))
				return FALSE;
			else
				return TRUE;

		break;

		case KADP_VSC_INPUTSRC_AVD:
			timing_info = Get_AVD_ScalerDispinfo();
			if((timing_info->IPH_ACT_WID_PRE == 0) || (timing_info->IPV_ACT_LEN_PRE == 0) || (timing_info->IHFreq == 0) || (timing_info->IVFreq == 0))
				return FALSE;
			else
				return TRUE;

		break;

		case KADP_VSC_INPUTSRC_HDMI:
			if((Scaler_ModeGet_Hdmi_ModeInfo(SLR_MODE_IHWID) == 0) || (Scaler_ModeGet_Hdmi_ModeInfo(SLR_MODE_IVHEIGHT) == 0)
				 || (Scaler_ModeGet_Hdmi_ModeInfo(SLR_MODE_IHFREQ) == 0) || (Scaler_ModeGet_Hdmi_ModeInfo(SLR_MODE_IVFREQ) == 0)
			)
				return FALSE;
			else
				return TRUE;
		break;

		default:
			return FALSE;
	}
}

static bool bring_up_vsc_running_flag = FALSE;
static struct task_struct *p_bring_up_vsc_tsk = NULL;

unsigned char rtk_bring_up_connect(void)
{/*This is for source check signal stable or not. Must be _MODE_STATE_ACTIVE*/
	VIDEO_RECT_T  inregion = {0, 0, 0, 0};
	KADP_VIDEO_RECT_T outregion = {0, 0, 0, 0};
	static int flag = 0;

	if(flag == 0)
	{
#ifdef CONFIG_DUAL_CHANNEL
		flag = 1;
#endif
		if(DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_MAXN)
		{
			return false;
		}
		if(DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_VDEC || DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_JPEG)
		{
			down(get_vo_infosemaphore());
			if(get_vo_change_flag(DisplayModeInputInfo.resourceIndex))
			{
				Scaler_DispSetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE,  _MODE_STATE_SEARCH);
			}
			else
			{
				up(get_vo_infosemaphore());
				return false;
			}
			up(get_vo_infosemaphore());
		}

		if(Scaler_DispGetInputInfoByDisp(SLR_MAIN_DISPLAY, SLR_INPUT_STATE) != _MODE_STATE_SEARCH)
		{
			//printk(KERN_EMERG "#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
			return false;
		}

		switch(DisplayModeInputInfo.type)
		{
			case KADP_VSC_INPUTSRC_ADC:
				if(!bringup_verify_timing_ready(KADP_VSC_INPUTSRC_ADC)){
					printk(KERN_EMERG "#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
					return false;
				}
				break;

			case KADP_VSC_INPUTSRC_AVD:
				if(!bringup_verify_timing_ready(KADP_VSC_INPUTSRC_AVD)){
					printk(KERN_EMERG "#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
					return false;
				}
				break;

			case KADP_VSC_INPUTSRC_HDMI:
				if(!bringup_verify_timing_ready(KADP_VSC_INPUTSRC_HDMI))
					return false;
				break;

			default:

				break;

		}
		inregion.w = 3840;/*default*/
		inregion.h = 2160;/*default*/
		outregion.w = _DISP_WID;
		outregion.h = _DISP_LEN;
		rtk_hal_vsc_SetInputRegionEx(VIDEO_WID_0, inregion, inregion);
		//rtk_hal_vsc_SetInputRegion(KADP_VIDEO_WID_0, inregion);
		rtk_hal_vsc_SetOutputRegion(VIDEO_WID_0, outregion, 0, 0);
		return rtk_hal_vsc_SetWinBlank(VIDEO_WID_0, 0, KADP_VIDEO_DDI_WIN_COLOR_BLACK);
	}
#ifdef CONFIG_DUAL_CHANNEL
	else
	{
		flag = 0;
		if(Sub_DisplayModeInputInfo.type == KADP_VSC_INPUTSRC_MAXN)
		{
			//printk(KERN_EMERG "#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
			return false;
		}
		if(Scaler_DispGetInputInfoByDisp(SLR_SUB_DISPLAY, SLR_INPUT_STATE) == _MODE_STATE_ACTIVE)
		{
			//printk(KERN_EMERG "#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
			return false;
		}

		switch(Sub_DisplayModeInputInfo.type)
		{
			case KADP_VSC_INPUTSRC_ADC:
				if(!bringup_verify_timing_ready(KADP_VSC_INPUTSRC_ADC)){
					printk(KERN_EMERG "#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
					return false;
				}
				break;

			case KADP_VSC_INPUTSRC_AVD:
				if(!bringup_verify_timing_ready(KADP_VSC_INPUTSRC_AVD)){
					printk(KERN_EMERG "#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
					return false;
				}
				break;

			case KADP_VSC_INPUTSRC_HDMI:
				if(!bringup_verify_timing_ready(KADP_VSC_INPUTSRC_HDMI))
					return false;
				break;

			default:

				break;

		}

		inregion.w = 3840;/*default*/
		inregion.h = 2160;/*default*/
		outregion.w = _DISP_WID/2;
		outregion.h = _DISP_LEN/2;
		rtk_hal_vsc_SetInputRegionEx(VIDEO_WID_1, inregion, inregion);
		rtk_hal_vsc_SetOutputRegion(VIDEO_WID_1, outregion, 0, 0);
		return rtk_hal_vsc_SetWinBlank(VIDEO_WID_1, 0, KADP_VIDEO_DDI_WIN_COLOR_BLACK);
	}
#else
	return TRUE;

#endif
}

static int bring_up_vsc_tsk(void *p)
{/* only for bring up test */
    rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "bring_up_vsc_tsk()\n");
	current->flags &= ~PF_NOFREEZE;
    while (1)
    {
    	msleep(1000);

#ifdef AUTO_BRINGUP_SOURCE
		vsc_source_bringup_force_connect();
#endif

#ifdef CONFIG_DUAL_CHANNEL
		if ((DbgSclrFlgTkr.OuputDisplayMode == TRUE) || (DbgSclrFlgTkr.Sub_OuputDisplayMode == TRUE)){
			//printk(KERN_EMERG "#####[Bring-up][%s(%d)]\n",__func__,__LINE__);
			rtk_bring_up_connect();
		}
#else
		if (DbgSclrFlgTkr.OuputDisplayMode == TRUE)
			rtk_bring_up_connect();
#endif
		if (freezing(current))
        {
			try_to_freeze();
        }
		if (kthread_should_stop()) {
         	break;
      	}
    }

    rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####bring_up_vsc_tsk: exit...####\n");
    do_exit(0);
    return 0;
}

static void create_bring_up_vsc_tsk(void)
{
	int err;
	if (bring_up_vsc_running_flag == FALSE) {
		p_bring_up_vsc_tsk = kthread_create(bring_up_vsc_tsk, NULL, "bring_up_vsc_tsk");

	    if (p_bring_up_vsc_tsk) {
			wake_up_process(p_bring_up_vsc_tsk);
			bring_up_vsc_running_flag = TRUE;
	    } else {
	    	err = PTR_ERR(p_bring_up_vsc_tsk);
	    	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Unable to start bring_up_vsc_tsk (err_id = %d)./n", err);
	    }
	}
}

static void delete_bring_up_vsc_tsk(void)
{
	int ret;
	if (bring_up_vsc_running_flag) {
 		ret = kthread_stop(p_bring_up_vsc_tsk);
 		if (!ret) {
 			p_bring_up_vsc_tsk = NULL;
 			bring_up_vsc_running_flag = FALSE;
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "bring_up_vsc_tsk thread stopped\n");
 		}
	}
}
#endif// #ifdef BRING_UP_AUTO_FLOW/*This is only for bring up use demoap*/



#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG//This is for new inut task
static bool arc_tsk_running_flag = FALSE;//for arc control tsk
static struct task_struct *p_arc_control_tsk = NULL;//for arc control tsk


static void update_arc_cmd_to_ring_buffer_sharemem(unsigned char display, KADP_VIDEO_RECT_T inregion, KADP_VIDEO_RECT_T originalInput, KADP_VIDEO_RECT_T outregion)
{//update ara parameter to sharememory. for SCALERIOC_MAIN_INPUT_OUTPUT_BUFFER_INFO and SCALERIOC_SUB_INPUT_OUTPUT_BUFFER_INFO
	INPUT_OUTPUT_RINGBUFFER_INFO_T *p_ring_buffer_addr;
	unsigned short updateindex;
	unsigned char overflow_status = FALSE;

#ifdef WIN_DELAY_CALLBACK_PROFILE
	gCallback_profile.OutputRegion.x = outregion.x;
	gCallback_profile.OutputRegion.y = outregion.y;
	gCallback_profile.OutputRegion.w = outregion.w;
	gCallback_profile.OutputRegion.h = outregion.h;
	gCallback_profile._90k_cnt = IoReg_Read32(TIMER_SCPU_CLK90K_LO_reg);
	gCallback_profile.uzulcnt = PPOVERLAY_new_meas2_linecnt_real_get_uzudtg_dly_line_cnt_rt(IoReg_Read32(PPOVERLAY_new_meas2_linecnt_real_reg));
#endif

	if(display == SLR_MAIN_DISPLAY)
	{
		p_ring_buffer_addr = (INPUT_OUTPUT_RINGBUFFER_INFO_T *)Scaler_GetShareMemVirAddr(SCALERIOC_MAIN_INPUT_OUTPUT_BUFFER_INFO);
		if(((Scaler_ChangeUINT16Endian(p_ring_buffer_addr->write_idx) + 1) % INPUT_OUTPUT_SHAREMEM_RING_BUFFER_SIZE) == Scaler_ChangeUINT16Endian(p_ring_buffer_addr->read_idx))
		{//over flow case
			updateindex = Scaler_ChangeUINT16Endian(p_ring_buffer_addr->write_idx);
			overflow_status = TRUE;
		}
		else
			updateindex = ((Scaler_ChangeUINT16Endian(p_ring_buffer_addr->write_idx) + 1) % INPUT_OUTPUT_SHAREMEM_RING_BUFFER_SIZE);
		//update input region
		p_ring_buffer_addr->in_out_data[updateindex].input_x = Scaler_ChangeUINT16Endian(inregion.x);
		p_ring_buffer_addr->in_out_data[updateindex].input_y = Scaler_ChangeUINT16Endian(inregion.y);
		p_ring_buffer_addr->in_out_data[updateindex].input_w = Scaler_ChangeUINT16Endian(inregion.w);
		p_ring_buffer_addr->in_out_data[updateindex].input_h = Scaler_ChangeUINT16Endian(inregion.h);

		//update output region
		p_ring_buffer_addr->in_out_data[updateindex].output_x = Scaler_ChangeUINT16Endian(outregion.x);
		p_ring_buffer_addr->in_out_data[updateindex].output_y = Scaler_ChangeUINT16Endian(outregion.y);
		p_ring_buffer_addr->in_out_data[updateindex].output_w = Scaler_ChangeUINT16Endian(outregion.w);
		p_ring_buffer_addr->in_out_data[updateindex].output_h = Scaler_ChangeUINT16Endian(outregion.h);

		//update original input. input resolution
		p_ring_buffer_addr->in_out_data[updateindex].ori_input_w = Scaler_ChangeUINT16Endian(originalInput.w);
		p_ring_buffer_addr->in_out_data[updateindex].ori_input_h = Scaler_ChangeUINT16Endian(originalInput.h);

		p_ring_buffer_addr->write_idx = Scaler_ChangeUINT16Endian(updateindex);

		if(overflow_status)
			printk(KERN_ERR "\r\n#### update_arc_cmd_to_ring_buffer_sharemem over flow main path####\r\n");

	}
#ifdef CONFIG_DUAL_CHANNEL
#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_SUPPORT_SUB
	else if(display == SLR_SUB_DISPLAY)
	{
		p_ring_buffer_addr = (INPUT_OUTPUT_RINGBUFFER_INFO_T *)Scaler_GetShareMemVirAddr(SCALERIOC_SUB_INPUT_OUTPUT_BUFFER_INFO);
		if(((Scaler_ChangeUINT16Endian(p_ring_buffer_addr->write_idx) + 1) % INPUT_OUTPUT_SHAREMEM_RING_BUFFER_SIZE) == Scaler_ChangeUINT16Endian(p_ring_buffer_addr->read_idx))
		{//over flow case
			updateindex = Scaler_ChangeUINT16Endian(p_ring_buffer_addr->write_idx);
			overflow_status = TRUE;
		}
		else
			updateindex = ((Scaler_ChangeUINT16Endian(p_ring_buffer_addr->write_idx) + 1) % INPUT_OUTPUT_SHAREMEM_RING_BUFFER_SIZE);
		//update input region
		p_ring_buffer_addr->in_out_data[updateindex].input_x = Scaler_ChangeUINT16Endian(inregion.x);
		p_ring_buffer_addr->in_out_data[updateindex].input_y = Scaler_ChangeUINT16Endian(inregion.y);
		p_ring_buffer_addr->in_out_data[updateindex].input_w = Scaler_ChangeUINT16Endian(inregion.w);
		p_ring_buffer_addr->in_out_data[updateindex].input_h = Scaler_ChangeUINT16Endian(inregion.h);

		//update output region
		p_ring_buffer_addr->in_out_data[updateindex].output_x = Scaler_ChangeUINT16Endian(outregion.x);
		p_ring_buffer_addr->in_out_data[updateindex].output_y = Scaler_ChangeUINT16Endian(outregion.y);
		p_ring_buffer_addr->in_out_data[updateindex].output_w = Scaler_ChangeUINT16Endian(outregion.w);
		p_ring_buffer_addr->in_out_data[updateindex].output_h = Scaler_ChangeUINT16Endian(outregion.h);

		//update original input. input resolution
		p_ring_buffer_addr->in_out_data[updateindex].ori_input_w = Scaler_ChangeUINT16Endian(originalInput.w);
		p_ring_buffer_addr->in_out_data[updateindex].ori_input_h = Scaler_ChangeUINT16Endian(originalInput.h);

		p_ring_buffer_addr->write_idx = Scaler_ChangeUINT16Endian(updateindex);

		if(overflow_status)
			printk(KERN_ERR "\r\n#### update_arc_cmd_to_ring_buffer_sharemem over flow sub path####\r\n");
	}
#endif
#endif
}



static int arc_control_tsk(void *p)//control new input parameter
{/* for new input hal */
	KADP_VSC_ROTATE_T local_main_rotate_type_parm;//for new input output. /for main path
	VIDEO_RECT_T local_main_inregion_parm;//for new input output. main path ap parameter
	VIDEO_RECT_T local_main_originalInput_parm;//for new input output. main path ap input resolution parameter
	KADP_VIDEO_RECT_T local_main_outregion_parm;//for new input output. main path ap input resolution parameter
#ifdef CONFIG_DUAL_CHANNEL
	VIDEO_RECT_T local_sub_inregion_parm;//for new input output. sub path ap parameter
	VIDEO_RECT_T local_sub_originalInput_parm;//for new input output. sub path ap input resolution parameter
	KADP_VIDEO_RECT_T local_sub_outregion_parm;//for new input output. sub path ap input resolution parameter
#endif

    rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "arc_control_tsk()\n");
	current->flags &= ~PF_NOFREEZE;
    while (1)
    {
#ifdef CONFIG_DUAL_CHANNEL
		wait_event_freezable(ARC_CONTROL_WAIT_QUEUE, main_arc_change_flag || sub_arc_change_flag);
#else
		wait_event_freezable(ARC_CONTROL_WAIT_QUEUE, main_arc_change_flag);
#endif
		if(main_arc_change_flag)
		{
			unsigned long flags;//for spin_lock_irqsave
			spin_lock_irqsave(&Main_ARC_Parm_Spinlock, flags);
			local_main_rotate_type_parm = ap_rotate_type_parm;//copy rotate type

			//copy input region
			local_main_inregion_parm.x = ap_main_inregion_parm.x;
			local_main_inregion_parm.y = ap_main_inregion_parm.y;
			local_main_inregion_parm.w = ap_main_inregion_parm.w;
			local_main_inregion_parm.h = ap_main_inregion_parm.h;

            //copy original input. input source resolution
			local_main_originalInput_parm.x = ap_main_originalInput_parm.x;
			local_main_originalInput_parm.y = ap_main_originalInput_parm.y;
			local_main_originalInput_parm.w = ap_main_originalInput_parm.w;
			local_main_originalInput_parm.h = ap_main_originalInput_parm.h;

			//copy output region
			local_main_outregion_parm.x = ap_main_outregion_parm.x;
			local_main_outregion_parm.y = ap_main_outregion_parm.y;
			local_main_outregion_parm.w = ap_main_outregion_parm.w;
			local_main_outregion_parm.h = ap_main_outregion_parm.h;
			main_arc_change_flag = FALSE;
			spin_unlock_irqrestore(&Main_ARC_Parm_Spinlock, flags);


#ifdef CONFIG_ENABLE_SE_ROTATE_M_DOMAIN_BLOCK_MODE
			//rotate part
			down(&SetMainOutPutRegion_Semaphore);
			rotate_mode_pre = rotate_mode;
			rotate_mode = local_main_rotate_type_parm;
			up(&SetMainOutPutRegion_Semaphore);
#endif
			virtual_w = true_wide;//magnify and livezoom use
			virtual_h = true_high;//magnify and livezoom use
			if((vbe_disp_oled_orbit_mode ==_VBE_PANEL_ORBIT_AUTO_MODE|| vbe_disp_oled_orbit_mode ==_VBE_PANEL_ORBIT_STORE_MODE) && vbe_disp_oled_orbit_enable)
			{
                vbe_disp_orbit_set_vo_overscan_state(1);
                rtd_printk(KERN_INFO, TAG_NAME_VSC, "vbe_disp_orbit_set_vo_overscan_state enable\n");
			}
			rtk_hal_vsc_SetInputRegionEx(VIDEO_WID_0, local_main_inregion_parm, local_main_originalInput_parm);
			rtk_hal_vsc_SetOutputRegion(VIDEO_WID_0, local_main_outregion_parm, virtual_w, virtual_h);
		}
#ifdef CONFIG_DUAL_CHANNEL
		if(sub_arc_change_flag)
		{
			unsigned long flags;//for spin_lock_irqsave
			spin_lock_irqsave(&Sub_ARC_Parm_Spinlock, flags);
			//copy input region
			local_sub_inregion_parm.x = ap_sub_inregion_parm.x;
			local_sub_inregion_parm.y = ap_sub_inregion_parm.y;
			local_sub_inregion_parm.w = ap_sub_inregion_parm.w;
			local_sub_inregion_parm.h = ap_sub_inregion_parm.h;

            //copy original input. input source resolution
			local_sub_originalInput_parm.x = ap_sub_originalInput_parm.x;
			local_sub_originalInput_parm.y = ap_sub_originalInput_parm.y;
			local_sub_originalInput_parm.w = ap_sub_originalInput_parm.w;
			local_sub_originalInput_parm.h = ap_sub_originalInput_parm.h;

			//copy output region
			local_sub_outregion_parm.x = ap_sub_outregion_parm.x;
			local_sub_outregion_parm.y = ap_sub_outregion_parm.y;
			local_sub_outregion_parm.w = ap_sub_outregion_parm.w;
			local_sub_outregion_parm.h = ap_sub_outregion_parm.h;
			sub_arc_change_flag = FALSE;
			spin_unlock_irqrestore(&Sub_ARC_Parm_Spinlock, flags);

			virtual_w = true_wide;//magnify and livezoom use
			virtual_h = true_high;//magnify and livezoom use

			rtk_hal_vsc_SetInputRegionEx(VIDEO_WID_1, local_sub_inregion_parm, local_sub_originalInput_parm);
			rtk_hal_vsc_SetOutputRegion(VIDEO_WID_1, local_sub_outregion_parm, virtual_w, virtual_h);
		}
#endif
		if (freezing(current))
        {
			try_to_freeze();
        }
		if (kthread_should_stop()) {
         	break;
      	}
    }

    rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####arc_control_tsk: exit...####\n");
    do_exit(0);
    return 0;
}

static void create_arc_control_tsk(void)
{
	int err;
	if (arc_tsk_running_flag == FALSE) {
		p_arc_control_tsk = kthread_create(arc_control_tsk, NULL, "arc_control_tsk");

	    if (p_arc_control_tsk) {
			wake_up_process(p_arc_control_tsk);
			arc_tsk_running_flag = TRUE;
	    } else {
	    	err = PTR_ERR(p_arc_control_tsk);
	    	rtd_printk(KERN_ERR, TAG_NAME_VSC, "Unable to start arc_control_tsk (err_id = %d)./n", err);
	    }
	}
}

static void delete_arc_control_tsk(void)
{
	int ret;
	if (arc_tsk_running_flag) {
 		ret = kthread_stop(p_arc_control_tsk);
 		if (!ret) {
 			p_arc_control_tsk = NULL;
 			arc_tsk_running_flag = FALSE;
			rtd_printk(KERN_ERR, TAG_NAME_VSC, "arc_control_tsk thread stopped\n");
 		}
	}
}
#endif// #ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG//This is for new inut task








struct file_operations vsc_fops= {
	.owner =    THIS_MODULE,
	.open  =    vsc_open,
	.release =  vsc_release,
	.read  =    vsc_read,
	.write = 	vsc_write,
	.unlocked_ioctl =    vsc_ioctl,
#if defined(CONFIG_COMPAT) && defined(CONFIG_ARM64)
      .compat_ioctl = vsc_compat_ioctl,
#endif
	.poll  =    vsc_poll,
};

#ifdef CONFIG_DUMP_REGISTER
static bool dump_register_vsc_running_flag = FALSE;
static struct task_struct *p_dump_register_vsc_tsk = NULL;
extern void register_dump_test(void);
extern void register_dump_data_to_file(void);
static int dump_register_vsc_tsk(void *p)
{
    rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "dump_register_vsc_tsk()\n");
	current->flags &= ~PF_NOFREEZE;
    while (1)
    {
		msleep(200);
	//pr_emerg("dump_register_vsc_tsk\n");
#ifdef CONFIG_DUMP_REGISTER
		register_dump_test();
		register_dump_data_to_file();
		//pr_emerg("test_vsc_tsk********\n");
		//pr_emerg("test_vsc_tsk********\n");
#endif

		if (freezing(current))
        {
			try_to_freeze();
        }
		if (kthread_should_stop()) {
			break;
		}
	}

    rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\r\n####dump_register_vsc_tsk: exit...####\n");
    do_exit(0);
    return 0;
}
static void create_dump_register_vsc_tsk(void)
{
	int err;
	if (dump_register_vsc_running_flag == FALSE) {
		p_dump_register_vsc_tsk = kthread_create(dump_register_vsc_tsk, NULL, "dump_register_vsc_tsk");

	    if (p_dump_register_vsc_tsk) {
			wake_up_process(p_dump_register_vsc_tsk);
			dump_register_vsc_running_flag = TRUE;
	    } else {
			err = PTR_ERR(p_dump_register_vsc_tsk);
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "Unable to start dump_register_vsc_tsk (err_id = %d)./n", err);
	    }
	}
}
static void delete_dump_register_vsc_tsk(void)
{
	int ret;
	if (dump_register_vsc_running_flag) {
		ret = kthread_stop(p_dump_register_vsc_tsk);
		if (!ret) {
			p_dump_register_vsc_tsk = NULL;
			dump_register_vsc_running_flag = FALSE;
			rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "dump_register_vsc_tsk thread stopped\n");
		}
	}
}
#endif

int vsc_major   = VSC_MAJOR;
int vsc_minor   = 0 ;
int vsc_nr_devs = VSC_NR_DEVS;

module_param(vsc_major, int, S_IRUGO);
module_param(vsc_minor, int, S_IRUGO);
module_param(vsc_nr_devs, int, S_IRUGO);


static struct class *vsc_class = NULL;
static struct platform_device *vsc_platform_devs = NULL;

#ifdef CONFIG_PM
static const struct dev_pm_ops vsc_pm_ops =
{
	.suspend    = vsc_suspend,
	.resume     = vsc_resume,
#ifdef CONFIG_HIBERNATION
	.freeze 	= vsc_suspend,
	.thaw		= vsc_resume_std,
	.poweroff	= vsc_suspend,
	.restore	= vsc_resume_std,
#endif

};
#endif

static struct platform_driver vsc_device_driver = {
    .driver = {
        .name       = VSC_DEVICE_NAME,
        .bus        = &platform_bus_type,
#ifdef CONFIG_PM
	.pm 		= &vsc_pm_ops,
#endif

    },
} ;


static char *vsc_devnode(struct device *dev, mode_t *mode)
{
	*mode = 0666;
	return NULL;
}

#ifdef CONFIG_RTK_KDRV_DC_MEMORY_TRASH_DETCTER
static void sb2_i3ddma_debug_info(void)
{
	dcmt_trap_info trap_info;
	//check trash module
	if(!isDcmtTrap("TVSB2_I3DDMA"))  //"SB3_MD_SCPU"?trap ip,ip?????rtk_dc_mt.c??module_info[]
	{
		printk(KERN_ERR "not TVSB2_I3DDMA module!\n");
		return;
	}

	get_dcmt_trap_info(&trap_info);  //get dcmt trap information (include trash_addr,module_id,rw_type)
	printk(KERN_ERR "TVSB2_I3DDMA module trashed somewhere!\n");

	// i3ddma setting
	printk(KERN_ERR "i3ddma setting 0xb8025810=%x\n", IoReg_Read32(0xb8025810));
	// i3ddma status
	printk(KERN_ERR "Cap_Status 0xb8025838=%x\n", IoReg_Read32(0xb8025838));

	//Cap_BoundaryAddr & start address
	printk(KERN_ERR "Cap_BoundaryAddr1 0xb8025818=%x\n", IoReg_Read32(0xb8025818));
	printk(KERN_ERR "Cap_BoundaryAddr2 0xb802581c=%x\n", IoReg_Read32(0xb802581c));
	printk(KERN_ERR "Cap_L1_Start 0xb8025820=%x\n", IoReg_Read32(0xb8025820));
	printk(KERN_ERR "Cap_L2_Start 0xb8025824=%x\n", IoReg_Read32(0xb8025824));
	printk(KERN_ERR "Cap_R1_Start 0xb8025828=%x\n", IoReg_Read32(0xb8025828));
	printk(KERN_ERR "Cap_R2_Start 0xb802582c=%x\n", IoReg_Read32(0xb802582c));
	printk(KERN_ERR "Cap_L3_Start 0xb8025884=%x\n", IoReg_Read32(0xb8025884));
	printk(KERN_ERR "Cap_R3_Start 0xb8025888=%x\n", IoReg_Read32(0xb8025888));
	printk(KERN_ERR "Cap_L4_Start 0xb802588c=%x\n", IoReg_Read32(0xb802588c));
	printk(KERN_ERR "Cap_R4_Start 0xb8025890=%x\n", IoReg_Read32(0xb8025890));

	//md setting & start address
	printk(KERN_ERR "Cap_CTL2 0xb8025894=%x\n", IoReg_Read32(0xb8025894));
	printk(KERN_ERR "md_m1_Start 0xb8025898=%x\n", IoReg_Read32(0xb8025898));
	printk(KERN_ERR "md_m2_Start 0xb8025898=%x\n", IoReg_Read32(0xb802589c));
	printk(KERN_ERR "md_m3_Start 0xb8025898=%x\n", IoReg_Read32(0xb80258a0));
	printk(KERN_ERR "md_m4_Start 0xb8025898=%x\n", IoReg_Read32(0xb80258a4));

	return;
}

static void sb2_di_debug_info(void)
{
	dcmt_trap_info trap_info;
	unsigned int i = 0;
	//check trash module
	if(!isDcmtTrap("TVSB2_DIW"))  //"SB3_MD_SCPU"?trap ip,ip?????rtk_dc_mt.c??module_info[]
	{
		printk(KERN_ERR "not TVSB2_DIW module!\n");
		return;
	}

	get_dcmt_trap_info(&trap_info);  //get dcmt trap information (include trash_addr,module_id,rw_type)
	printk(KERN_ERR "TVSB2_DIW module trashed somewhere!\n");
	printk(KERN_ERR "0xb8024000=%x\n", IoReg_Read32(0xb8024000));
	printk(KERN_ERR "0xb8024538=%x\n", IoReg_Read32(0xb8024538));

	for (i = 0xb8024400; i <=0xb8024440; i=i+4)
	{
		printk(KERN_ERR "%x=%x\n", i, IoReg_Read32(i));
	}
	return;
}

static void sb2_m_cap_debug_info(void)
{
	dcmt_trap_info trap_info;
	unsigned int i = 0;
	//check trash module
	if(!isDcmtTrap("TVSB2_M_CAP"))  //"SB3_MD_SCPU"?trap ip,ip?????rtk_dc_mt.c??module_info[]
	{
		printk(KERN_ERR "not TVSB2_M_CAP module!\n");
		return;
	}

	get_dcmt_trap_info(&trap_info);  //get dcmt trap information (include trash_addr,module_id,rw_type)
	printk(KERN_ERR "TVSB2_M_CAP module trashed somewhere!\n");

	//m-cap address and control
	for (i = 0xb8027200; i <=0xb8027228; i=i+4)
	{
		printk(KERN_ERR "%x=%x\n", i, IoReg_Read32(i));
	}

	// Double buffer
	printk(KERN_ERR "Double buffer 0xb802726c=%x\n", IoReg_Read32(0xb802726c));

	// Boundary down limit
	printk(KERN_ERR "Boundary down limit 0xb8027278=%x\n", IoReg_Read32(0xb8027278));
	// Boundary up limit
	printk(KERN_ERR "Boundary up limit 0xb802727c=%x\n", IoReg_Read32(0xb802727c));

	// Boundary status
	printk(KERN_ERR "Boundary status 0xb8027280=%x\n", IoReg_Read32(0xb8027280));

	return;
}


static void sb2_vo1_y_debug_info(void)
{
	dcmt_trap_info trap_info;
	//check trash module
	if(!isDcmtTrap("TVSB2_VO1_Y"))
	{
		printk(KERN_ERR "not TVSB2_VO1_Y module!\n");
		return;
	}

	get_dcmt_trap_info(&trap_info);  //get dcmt trap information (include trash_addr,module_id,rw_type)
	printk(KERN_ERR "TVSB2_VO1_Y module trashed somewhere!\n");

	printk(KERN_ERR "VODMA_V1_DCFG 0xb8005000=%x\n", IoReg_Read32(0xb8005000));
	printk(KERN_ERR "VODMA_REG_DB_CTRL 0xb8005054=%x\n", IoReg_Read32(0xb8005054));
	printk(KERN_ERR "VODMA_V1_DSIZE 0xb8005004=%x\n", IoReg_Read32(0xb8005004));
	printk(KERN_ERR "VODMA_V1_SEQ 0xb800500C=%x\n", IoReg_Read32(0xb800500C));
	printk(KERN_ERR "VODMA_V1_SEQ_3D_L1 0xb800501C=%x\n", IoReg_Read32(0xb800501C));
	printk(KERN_ERR "VODMA_V1_SEQ_3D_R1 0xb8005020=%x\n", IoReg_Read32(0xb8005020));
	printk(KERN_ERR "VODMA_V1_SEQ_3D_L2 0xb8005024=%x\n", IoReg_Read32(0xb8005024));
	printk(KERN_ERR "VODMA_V1_SEQ_3D_R2 0xb8005028=%x\n", IoReg_Read32(0xb8005028));
	printk(KERN_ERR "VODMA_V1_V_FLIP 0xb800502C=%x\n", IoReg_Read32(0xb800502C));
	printk(KERN_ERR "VODMA_V1_SEQ_3D_L3 0xb80051C0=%x\n", IoReg_Read32(0xb80051C0));
	printk(KERN_ERR "VODMA_V1_SEQ_3D_R3 0xb80051C4=%x\n", IoReg_Read32(0xb80051C4));
	printk(KERN_ERR "VODMA_V1_SEQ_3D_L4 0xb80051C8=%x\n", IoReg_Read32(0xb80051C8));
	printk(KERN_ERR "VODMA_V1_SEQ_3D_R4 0xb80051CC=%x\n", IoReg_Read32(0xb80051CC));
	printk(KERN_ERR "VODMA_TaBSbS_merge 0xb80050E0=%x\n", IoReg_Read32(0xb80050E0));
	printk(KERN_ERR "VODMA_TaBSbS_SEQ 0xb80050E4=%x\n", IoReg_Read32(0xb80050E4));
	printk(KERN_ERR "VODMA_3D_CS_1 0xb80050C4=%x\n", IoReg_Read32(0xb80050C4));
	printk(KERN_ERR "VODMA_3D_CS_2 0xb80050C8=%x\n", IoReg_Read32(0xb80050C8));
	printk(KERN_ERR "VODMA_dma_option 0xb80050DC=%x\n", IoReg_Read32(0xb80050DC));
	printk(KERN_ERR "DECOMP_CTRL0 0xb8005100=%x\n", IoReg_Read32(0xb8005100));
	printk(KERN_ERR "DECOMP_PIC_SET 0xb8005118=%x\n", IoReg_Read32(0xb8005118));
	printk(KERN_ERR "DECOMP_READ_Y 0xb800511C=%x\n", IoReg_Read32(0xb800511C));
	printk(KERN_ERR "DECOMP_READ_C 0xb8005120=%x\n", IoReg_Read32(0xb8005120));
	printk(KERN_ERR "DECOMP_X_WID_Y 0xb8005124=%x\n", IoReg_Read32(0xb8005124));
	printk(KERN_ERR "DECOMP_X_WID_C 0xb8005128=%x\n", IoReg_Read32(0xb8005128));
	printk(KERN_ERR "vodma_i2rnd 0xb8005200=%x\n", IoReg_Read32(0xb8005200));

	return;
}


#endif
/******************DCMT declare callback func******************/
DCMT_DEBUG_INFO_DECLARE(sb2_di_mdscpu, sb2_di_debug_info);
DCMT_DEBUG_INFO_DECLARE(sb2_m_cap_mdscpu, sb2_m_cap_debug_info);
DCMT_DEBUG_INFO_DECLARE(sb2_vo1_y_mdscpu, sb2_vo1_y_debug_info);
DCMT_DEBUG_INFO_DECLARE(sb2_i3ddma_mdscpu, sb2_i3ddma_debug_info);

int vsc_init_module(void)
{
	int result;
  	int devno;
	dev_t dev = 0;

#ifdef CONFIG_RTK_KDRV_DC_MEMORY_TRASH_DETCTER
	/******************DCMT register callback func in init flow******************/
	DCMT_DEBUG_INFO_REGISTER(sb2_di_mdscpu, sb2_di_debug_info);
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "DCMT_DEBUG_INFO_REGISTER(sb2_di_mdscpu,sb2_di_debug_info)\n");
	DCMT_DEBUG_INFO_REGISTER(sb2_m_cap_mdscpu, sb2_m_cap_debug_info);
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "DCMT_DEBUG_INFO_REGISTER(sb2_m_cap_mdscpu, sb2_m_cap_debug_info)\n");
	DCMT_DEBUG_INFO_REGISTER(sb2_vo1_y_mdscpu, sb2_vo1_y_debug_info);
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "DCMT_DEBUG_INFO_REGISTER(sb2_vo1_y_mdscpu, sb2_vo1_y_debug_info)\n");
	DCMT_DEBUG_INFO_REGISTER(sb2_i3ddma_mdscpu, sb2_i3ddma_debug_info);
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "DCMT_DEBUG_INFO_REGISTER(sb2_i3ddma_mdscpu, sb2_i3ddma_debug_info)\n");
#endif

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "\n\n\n\n *****************  vsc init module  *********************\n\n\n\n");
	if (vsc_major) {
		dev = MKDEV(vsc_major, vsc_minor);
		result = register_chrdev_region(dev, vsc_nr_devs, VSC_DEVICE_NAME);
	} else {
		result = alloc_chrdev_region(&dev, vsc_minor, vsc_nr_devs,VSC_DEVICE_NAME);
		vsc_major = MAJOR(dev);
	}
	if (result < 0) {
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, KERN_WARNING "vsc: can't get major %d\n", vsc_major);
		return result;
	}

	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "vsc init module major number = %d\n", vsc_major);

	vsc_class = class_create(THIS_MODULE,VSC_DEVICE_NAME);

	if (IS_ERR(vsc_class))
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scalevsc: can not create class...\n");
		result = PTR_ERR(vsc_class);
		goto fail_class_create;
	}

	vsc_class->devnode = (void *)vsc_devnode;

	vsc_platform_devs = platform_device_register_simple(VSC_DEVICE_NAME, -1, NULL, 0);

	if((result = platform_driver_register(&vsc_device_driver)) != 0){
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scalevsc: can not register platform driver...\n");
		result = -ENOMEM;
		goto fail_platform_driver_register;
	}

    devno = MKDEV(vsc_major, vsc_minor);
    cdev_init(&vsc_cdev, &vsc_fops);
    vsc_cdev.owner = THIS_MODULE;
   	vsc_cdev.ops = &vsc_fops;
	result = cdev_add (&vsc_cdev, devno, 1);
	if (result<0)
	{
		rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "scalevsc: can not add character device...\n");
		goto fail_cdev_init;
	}

    device_create(vsc_class, NULL, MKDEV(vsc_major, 0), NULL, VSC_DEVICE_NAME);
   	sema_init(&VSC_Semaphore, 1);
	sema_init(&MagMsg_Semaphore, 1);
	sema_init(&Magnifier_Semaphore, 1);
	sema_init(&SetMainOutPutRegion_Semaphore, 1);
	sema_init(&Main_ResetMode_Semaphore, 1);
	sema_init(&DM_HDR_Semaphore, 1);
	sema_init(&Force_Run_Idma_Semaphore, 1);
	sema_init(&Low_Delay_Semaphore, 1);
	sema_init(&Memc_Realcinema_Semaphore, 1);
	sema_init(&Iv2dv_Slow_Tuning_Semaphore, 1);
	sema_init(&VPQ_ld_running_Semaphore, 1);
	sema_init(&VPQ_DeXC_MEM_Semaphore, 1);
	sema_init(&Double_buffer_Semaphore, 1);
	sema_init(&GameMode_Check_Semaphore, 1);
	sema_init(&muteoff_cb_sem, 1);
    sema_init(&HDMI_4K120_MEMORY_PROTECTION_Semaphore, 1);////For 4k120 se buffer protection
	sema_init(&GameMode_SCALER_SYNC_Semaphore, 1);//initial GameMode_SCALER_SYNC_Semaphore
	//sema_init(&delay_info_cb_sem, 1);
	sema_init(&set_vsc_film_mode_semaphore, 1);
	init_scaler_verifymode_semaphore();//initial scaler verify mode ctrl related semaphore
#ifdef CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT
	init_dolby_vision_dm_path_sem();
#endif

#ifdef CONFIG_HDR_SDR_SEAMLESS
	sema_init(&HDR_Setting_Semaphore, 1);

#ifdef CONFIG_HDR_SDR_SEAMLESS
#if defined(CONFIG_ENABLE_HDR10_HDMI_AUTO_DETECT)|| defined(CONFIG_ENABLE_DOLBY_VISION_HDMI_AUTO_DETECT)
	initial_i3ddma_reg_Semaphore();//init i3ddma_reg_Semaphore
#endif
#endif

#endif
#ifdef CONFIG_DUAL_CHANNEL
	sema_init(&SetSubOutPutRegion_Semaphore, 1);
	sema_init(&Sub_ResetMode_Semaphore, 1);
#endif
#ifdef CONFIG_ORBIT_PIXEL_SHIFT_ALGO
	sema_init(&Orbit_algo_Semaphore, 1);
#endif
	sema_init	(&I2RND_Semaphore, 1);
	sema_init(&vsc_src_verify_num_ctrl_sem, 1);//initial the Semaphore for vsc source verify
	sema_init	(&I2RND_display_Semaphore, 1);
	forcebg_semaphore_init();//Init force semaphore
	DI_semaphore_init();//Init force semaphore
	initial_sub_window_ctrl_semaphore();//initial sub window ctrl semaphore
	DbgSclrFlgTkr.VSC_Device_Init_Done = TRUE;
	PcbSource_Init();
	drvif_memory_init();
	create_vsc_tsk();/*Create VSC task*/
	create_magnifier_tsk();
	/*Panel_LVDS_To_Hdmi_Converter_Parameter();*/
#ifdef BRING_UP_AUTO_FLOW
	create_bring_up_vsc_tsk();/*Create bring up vsc tsk*/
#endif
	create_forcebg_tsk();//Create forcebg task
	create_fixlast_line_tsk(); //Create fix last line tsk
	create_localDimmingDemoCtrl_tsk();
	create_game_mode_unmute_tsk(); //Create game mode unmute tsk
	create_variable_refresh_rate_tsk();
#ifdef CONFIG_DUMP_REGISTER
	create_dump_register_vsc_tsk();
#endif
	create_scaler_verify_tsk();//creat scaler verify task
#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG//This is for new inut task
	create_arc_control_tsk();//create arc control tsk
#endif
	create_film_mode_change_task();
	create_hdmi_4k120_se_task();
#if FREEZE_MUTE_IMPLEMENT_STATE == H5X_MDOMAIN && defined(CONFIG_RTK_8KCODEC_INTERFACE)
	create_merlin5DolbyCRCCallH5X_task();//Create merlin5DolbyCRCCallH5X task
#endif

#if 1//FIXME @Crixus for K3L bringup
	IoReg_Write32(0xb8000118, _BIT24 | _BIT25 | _BIT0);
 	IoReg_Write32(0xb8000108, _BIT24 | _BIT25 | _BIT0);
#endif

#ifdef BRING_UP_K4L_TEST
       create_new_game_mode_tsk();//20170524 pinyen create new game mode tsk
#endif

	//ECN item new mode. will add for MAC6-566
	enable_clock_mux_new_mode();

#ifdef ENABLE_SCALER_DUMP_FRAME_INFO
	// dump Scaler frame CRC info
	rtkscaler_dump_init();
#endif

sema_init(&new_input_output_main_sem, 1);//for main path new input out ap parameter semaphore
#ifdef CONFIG_DUAL_CHANNEL
sema_init(&new_input_output_sub_sem, 1);//for sub path new input out ap parameter semaphore
#endif
    sema_init(&vsc_initial_ctrl_semaphore, 1);//for call  rtk_hal_vsc_initialize use


	return 0;	//success

fail_cdev_init:
	platform_driver_unregister(&vsc_device_driver);
fail_platform_driver_register:
	platform_device_unregister(vsc_platform_devs);
	vsc_platform_devs = NULL;
	class_destroy(vsc_class);
fail_class_create:
	vsc_class = NULL;
	unregister_chrdev_region(vsc_devno, 1);
	return result;
}



void __exit vsc_cleanup_module(void)
{
	dev_t devno = MKDEV(vsc_major, vsc_minor);
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC, "rtice clean module vsc_major = %d\n", vsc_major);
	delete_vsc_tsk();/*Delete VSC task*/
	delete_forcebg_tsk();
	delete_fix_lastline_tsk();
	delete_localDimmingDemoCtrl_tsk();
	delete_game_mode_unmute_tsk();
	delete_film_mode_change_task();
	delete_hdmi_4k120_se_task();
#if FREEZE_MUTE_IMPLEMENT_STATE == H5X_MDOMAIN && defined(CONFIG_RTK_8KCODEC_INTERFACE)
	delete_merlin5DolbyCRCCallH5X_task();
#endif
#ifdef NEW_INPUT_OUTPUT_BUFFER_FLOW_CONFIG//This is for new inut task
	delete_arc_control_tsk();//delete arc control tsk
#endif

	delete_magnifier_tsk();
#ifdef BRING_UP_AUTO_FLOW
	delete_bring_up_vsc_tsk();/*Delete bring up vsc tsk*/
#endif
#ifdef CONFIG_DUMP_REGISTER
	delete_dump_register_vsc_tsk();
#endif
  	device_destroy(vsc_class, MKDEV(vsc_major, 0));
  	class_destroy(vsc_class);
	vsc_class = NULL;
	cdev_del(&vsc_cdev);
   	/* device driver removal */
	if(vsc_platform_devs) {
		platform_device_unregister(vsc_platform_devs);
		vsc_platform_devs = NULL;
	}
  	platform_driver_unregister(&vsc_device_driver);
	/* cleanup_module is never called if registering failed */
	unregister_chrdev_region(devno, vsc_nr_devs);
	DbgSclrFlgTkr.VSC_Device_Init_Done = FALSE;
	drvif_memory_release();
}
struct semaphore* get_vsc_semaphore(void)
{
	return &VSC_Semaphore;
}

unsigned char Get_AVD_display(unsigned char display)
{

	if (Get_DisplayMode_Src(display) == VSC_INPUTSRC_AVD)
		return TRUE;
	else
		return FALSE;
}


unsigned char VSC_Check_AVD_Connected(void)
{
	if (Get_DisplayMode_Src(SLR_MAIN_DISPLAY) == VSC_INPUTSRC_AVD
	  ||Get_DisplayMode_Src(SLR_SUB_DISPLAY) == VSC_INPUTSRC_AVD)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

void fw_scalerip_set_di_gamemode_flag(unsigned char bflag)
{
	if(DbgSclrFlgTkr.DI_low_delay_flag != bflag) {

		down(&Low_Delay_Semaphore);
		DbgSclrFlgTkr.DI_low_delay_flag = bflag;
		up(&Low_Delay_Semaphore);

	}
}


unsigned char fw_scalerip_get_di_gamemode_flag(void)
{
	return DbgSclrFlgTkr.DI_low_delay_flag;
}

void fw_set_vsc_GameMode(unsigned char b_vscGameMode_OnOff)
{
	enable_VSC_GameMode = b_vscGameMode_OnOff;
}

unsigned char fw_get_vsc_GameMode(void)
{
	return enable_VSC_GameMode;
}

#ifdef CONFIG_ORBIT_PIXEL_SHIFT_ALGO

unsigned int ORBIT_TIME = 180;//default 3min
static unsigned char orbit_shift_index=0;
static unsigned char start_orbit_algo=FALSE;

/*api which have protect by forcebg_semaphore*/
void Scaler_start_orbit_algo(unsigned char b_enable)
{

//	if((b_enable != start_orbit_algo)&&(b_enable)){
//		Scaler_reset_orbit();
//	}
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"start_orbit_algo(%d)\n", b_enable);
	start_orbit_algo = b_enable;
}

unsigned char Scaler_get_orbit_algo_status(void)
{
	if(vbe_disp_get_orbit()== TRUE)
		return start_orbit_algo;
	else
		return FALSE;
}
/*api which have protect by forcebg_semaphore*/
void Scaler_reset_orbit(void)
{
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"Scaler_reset_orbit\n");

	down(&Orbit_algo_Semaphore);
	orbit_shift_index = 0;
	vbe_disp_orbit_position_update(0xff, 0); // force update

	if (!OrbitTimerList.function)
		Scaler_Orbit_Timer_Init();

	mod_timer(&OrbitTimerList, jiffies + ORBIT_TIME*HZ);
	up(&Orbit_algo_Semaphore);
}

void force_change_orbit_timer_time(void)
{
	down(&Orbit_algo_Semaphore);
	mod_timer(&OrbitTimerList, jiffies + ORBIT_TIME*HZ);
	up(&Orbit_algo_Semaphore);
}
void OrbitTimer_Info_update(unsigned char force_update)
{//orbit timer inof update
    //down(&Orbit_algo_Semaphore);
    if(!force_update)
	{
		if(Scaler_get_orbit_algo_status() == TRUE){
			if(orbit_shift_index < vbe_disp_orbit_get_max_table_index()){
				orbit_shift_index++;
			}else{
				orbit_shift_index=0;
			}
		}else{
			orbit_shift_index=0;
		}
	}
	vbe_disp_orbit_position_update(orbit_shift_index,force_update);
	mod_timer(&OrbitTimerList, jiffies + ORBIT_TIME*HZ);;
}

void ScalerForceUpdateOrbit(unsigned char force_update)
{//timer unit is 10 ms
    unsigned long flags;//for spin_lock_irqsave
    spin_lock_irqsave(&orbit_timer_update_spinlock, flags);
    //saler_need_wait_orbit_ready = TRUE;
    OrbitTimer_Info_update(force_update);
    spin_unlock_irqrestore(&orbit_timer_update_spinlock, flags);

    rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"ScalerForceUpdateOrbit\n");
}
unsigned char ScalerCheckOrbitFinish(void)
{
    SCALER_ORBIT_SHIFT_INFO *orbit_shift_info = NULL;
    orbit_shift_info = (SCALER_ORBIT_SHIFT_INFO*)Scaler_GetShareMemVirAddr(SCALERIOC_ORBIT_SHIFT_INFO);
    if(!(orbit_shift_info->active_state))
        return TRUE;
    else
        return FALSE;
}

void OrbitTimer()
{
    unsigned long flags;//for spin_lock_irqsave
    rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"OrbitTimer\n");

    //down(&Orbit_algo_Semaphore);

    spin_lock_irqsave(&orbit_timer_update_spinlock, flags);
    OrbitTimer_Info_update(0);
    spin_unlock_irqrestore(&orbit_timer_update_spinlock, flags);
    //up(&Orbit_algo_Semaphore);
    //OrbitTimerList.expires = jiffies + HZ;
    //add_timer(&OrbitTimerList);
}


void Scaler_Orbit_Timer_Init(void)
{
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"Scaler_Orbit_Timer_Init\n");

	g_ucTimerInitCount++;

	if (timer_pending(&OrbitTimerList))
	{
		rtd_printk(KERN_EMERG, TAG_NAME_VSC,"Error! Scaler_Orbit_Timer_Init more than twice. g_ucTimerInitCount=%d\n", g_ucTimerInitCount);
		dump_stack();

		return;
	}

	BUG_ON(timer_pending(&OrbitTimerList));


#if 0
	/* timer init*/
	init_timer(&OrbitTimerList);
	OrbitTimerList.data = ((unsigned long) 0);
	OrbitTimerList.function = (void *)OrbitTimer;
	OrbitTimerList.expires = jiffies + ORBIT_TIME*HZ;
	/*add timer*/
	add_timer(&OrbitTimerList);
#else
	/** If only 1 instance is allowed, using mod_timer().
	 * Otherwise, add_timer() will trap the occurance of racing,
	 * with built-in timer_pending() check.
	 **/
	mod_timer(&OrbitTimerList, jiffies + ORBIT_TIME*HZ);
#endif
}

void Scaler_Orbit_Timer_Delete(void)
{
	rtd_printk(KERN_DEBUG, TAG_NAME_VSC,"Scaler_Orbit_Timer_Delete\n");
	/* delete timer */
	del_timer_sync(&OrbitTimerList);
}
#endif


//this is for verify mode used
static KADP_VSC_INPUT_SRC_INFO_T RecordModeInputInfo = {KADP_VSC_INPUTSRC_MAXN,0,0};//record ap connect source for verify mode used
static unsigned char RecordVscInitdone_Flag = FALSE;
void verify_source_force_connect(void)
{//force connect ADC source
	KADP_VSC_INPUT_SRC_INFO_T verifyInputsourceInfo = {KADP_VSC_INPUTSRC_ADC, 0 , 0};
	if(DisplayModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
	{
		RecordModeInputInfo = DisplayModeInputInfo;
		rtk_hal_vsc_Disconnect(VIDEO_WID_0, DisplayModeInputInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
		rtk_hal_vsc_close(VIDEO_WID_0);
	}
	if(VscInitdone_Flag == FALSE)
	{
		RecordVscInitdone_Flag = FALSE;
		rtk_hal_vsc_initialize();
	}
	else
		RecordVscInitdone_Flag = TRUE;
	rtk_hal_vsc_open(VIDEO_WID_0);
	rtk_hal_vsc_Connect(VIDEO_WID_0, verifyInputsourceInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
}

void source_restore_from_verify_source(void)
{
	rtk_hal_vsc_Disconnect(VIDEO_WID_0, DisplayModeInputInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
	rtk_hal_vsc_close(VIDEO_WID_0);
	//if(RecordVscInitdone_Flag == FALSE)
		//rtk_hal_vsc_uninitialize();
	if(RecordModeInputInfo.type != KADP_VSC_INPUTSRC_MAXN)
	{
		rtk_hal_vsc_open(VIDEO_WID_0);
		rtk_hal_vsc_Connect(VIDEO_WID_0, RecordModeInputInfo, KADP_VSC_OUTPUT_DISPLAY_MODE);
	}
}



//20171018 pinyen add to fix ML3RTANDN-418
void wait_game_mode_frame_delay_done(void)
{
       /*enter or exit game mode need to wait buffer write done to avoid garbage happen after unmute screen*/

       unsigned char game_mode_wait_frame = 1;// wait 1 frame to avoid gargabe happen when buffer switch
       rtd_printk(KERN_NOTICE, TAG_NAME_VSC,"[GameMode][M-doamin]wait buffer write done!!\n");

       //Update the M-domain last done
       drv_memory_wait_cap_last_write_done(SLR_MAIN_DISPLAY, game_mode_wait_frame, TRUE);//game mode wait
}

#ifdef ENABLE_SCALER_DUMP_FRAME_INFO
// Dump VO frame CRC info to file
static int rtkscaler_dumpcrc_thread(void *arg)
{
	unsigned long magic, size, wr, rd;
	unsigned char *wrPtr, *rdPtr, *basePtr, *limitPtr;

	for (;;) {
		if (kthread_should_stop()) break;
		if (scalerfile_DumpCRC != 0 && scaler_DumpCRC_Config.enable) {
			SCALER_DUMP_BUFFER_HEADER *header;
			header = (SCALER_DUMP_BUFFER_HEADER*) scaler_g_pDumpCRC.Memory;
			magic = ntohl(header->magic) ;
			size  = ntohl(header->size) ;
			rd    = ntohl(header->rd) ;
			wr    = ntohl(header->wr) ;
			wrPtr = (unsigned char *)(scaler_g_pDumpCRC.Memory + wr - scaler_g_pDumpCRC.PhyAddr); /* make virtual address */
			rdPtr = (unsigned char *)(scaler_g_pDumpCRC.Memory + rd - scaler_g_pDumpCRC.PhyAddr); /* make virtual address */
			basePtr  = (unsigned char *)(scaler_g_pDumpCRC.Memory + sizeof(SCALER_DUMP_BUFFER_HEADER));
			size -= sizeof(SCALER_DUMP_BUFFER_HEADER);
			limitPtr = basePtr+ size;

                #if 0 // TEST
                    static unsigned long last_wr=0;
                    if(last_wr != wr){
                        pr_notice("[vo] Header %x, m=%x size=%x r(%x) w(%x)\n", (unsigned int)header, (unsigned int)magic, (unsigned int)size, (unsigned int)rd, (unsigned int)wr);
                        pr_notice("[vo] Ptr w(%x) r(%x) b(%x) (%x), offset=%x\n", (unsigned int)wrPtr, (unsigned int)rdPtr, (unsigned int)basePtr, (unsigned int)limitPtr, (unsigned int)f_offset_dumpcrc);
                        last_wr = wr;
                    }
                #endif

			if (wrPtr < rdPtr) {
				wrPtr = wrPtr + size;
			}

			if (wrPtr > rdPtr) {
				if (wrPtr > limitPtr) {
					file_write(scalerfile_DumpCRC, f_offset_dumpcrc, rdPtr, limitPtr -rdPtr) ;
					f_offset_dumpcrc += limitPtr -rdPtr ;
					file_write(scalerfile_DumpCRC, f_offset_dumpcrc, basePtr, wrPtr - limitPtr) ;
					f_offset_dumpcrc += wrPtr - limitPtr ;
				}
				else {
					file_write(scalerfile_DumpCRC, f_offset_dumpcrc, rdPtr, wrPtr - rdPtr) ;
					f_offset_dumpcrc += wrPtr - rdPtr ;
				}
				header->rd = htonl(wr) ;
                #if 0 // TEST
                         pr_notice("[vo] f_offset_dumpcrc=%x\n", (unsigned int)f_offset_dumpcrc);
                #endif
			}
		}

		msleep(100); /* sleep 10 ms */
	}

	/* pr_debug("rtkvdec_dumpes_thread break\n"); */
	pr_err("rtkscaler_dumpcrc_thread break\n");
	return 0;
}


static void rtkscaler_dump_init(void)
{
#ifndef CONFIG_ANDROID
	unsigned char default_file_name3[30] = "/tmp/video_dumpscalercrc.bin" ;
#else
	unsigned char default_file_name3[36] = "/data/data/video_dumpscalercrc.bin" ;
#endif

	scaler_DumpCRC_Config.enable = 0 ;
	scaler_DumpCRC_Config.mem_size = DUMP_ES_SIZE ;

#ifndef CONFIG_ANDROID
	memset((void *)scaler_DumpCRC_Config.file_name, '\0', FILE_NAME_SIZE );
	memcpy((void *)scaler_DumpCRC_Config.file_name, (void *)default_file_name3, 21);
#else
	memset((void *)scaler_DumpCRC_Config.file_name, '\0', 27 + 1 );
	memcpy((void *)scaler_DumpCRC_Config.file_name, (void *)default_file_name3, 27);
#endif

	scaler_g_pDumpCRC.Memory = scaler_g_pDumpCRC.PhyAddr = scaler_g_pDumpCRC.VirtAddr = 0 ;
	scaler_g_pDumpCRC_Send.Memory = scaler_g_pDumpCRC_Send.PhyAddr = scaler_g_pDumpCRC_Send.VirtAddr = 0 ;
}



int rtkscaler_dumpCRC_enable(const char *pattern, int length)
{
#ifdef CONFIG_RTK_KDRV_RPC
	//unsigned long return_value ;
#endif
	VO_DUMP_BUFFER_HEADER *header;
	unsigned long vir_addr ;

	if (length > FILE_NAME_SIZE - 1) {
		pr_warn("rtkscaler: file name is too long(<%d).\n", FILE_NAME_SIZE - 1);
		return 0;
	}
	else if (length > 0) {
		memset((void *)scaler_DumpCRC_Config.file_name, '\0', length+1);
		memcpy((void *)scaler_DumpCRC_Config.file_name, (void *)pattern, length);
	}

	pr_notice("rtkscaler: dumpes_file_name(%s)\n", scaler_DumpCRC_Config.file_name);

	if (scaler_DumpCRC_Config.enable) {
		pr_notice("rtkscaler: es dump already enable!\n");
		return 0 ;
	}

	scalerfile_DumpCRC = file_open((char *)(scaler_DumpCRC_Config.file_name), O_TRUNC | O_RDWR | O_CREAT,0x755) ;
	if (scalerfile_DumpCRC == 0) {
		pr_err("[%s %d]open log file fail\n",__FUNCTION__,__LINE__);
		return -ENOMEM;
	}

	/* allocate debug memory */
	  #ifndef CONFIG_KDRIVER_USE_NEW_COMMON
	  //#FixMe, 20190912
	vir_addr = (unsigned long)dvr_malloc_uncached_specific(sizeof(VO_RPC_DEBUG_MEMORY)+256, GFP_DCU1, (void **)(&scaler_g_pDumpCRC_Send.Memory));
	  #endif
	if (!vir_addr) {
		pr_err("[%s %d]alloc debug memory fail\n",__FUNCTION__,__LINE__);
		return -ENOMEM;
	}
	scaler_g_pDumpCRC_Send.PhyAddr = (unsigned long)dvr_to_phys((void*)vir_addr);
	scaler_g_pDumpCRC_Send.VirtAddr = vir_addr ;
	pr_notice("Alloc DVOCRCME v(%lx) p(%lx) vn(%lx)\n", vir_addr, scaler_g_pDumpCRC_Send.PhyAddr, scaler_g_pDumpCRC_Send.Memory);

	if ((scalerfile_DumpCRC != 0) && (scaler_DumpCRC_Config.mem_size > 0)) {
		/* alocate dump memory */
		vir_addr = (unsigned long)dvr_malloc_uncached_specific(scaler_DumpCRC_Config.mem_size, GFP_DCU1, (void **)(&scaler_g_pDumpCRC.Memory));
		if (!vir_addr) {
			vir_addr = scaler_g_pDumpCRC_Send.VirtAddr ;
			dvr_free((void*)vir_addr);
			pr_err("[%s %d]alloc debug memory fail\n",__FUNCTION__,__LINE__);
			return -ENOMEM;
		}
		scaler_g_pDumpCRC.PhyAddr = (unsigned long)dvr_to_phys((void*)vir_addr);
		scaler_g_pDumpCRC.VirtAddr = vir_addr ;

		pr_notice("Alloc DUMPVOME v(%lx) p(%lx) vn(%lx)\n", vir_addr, scaler_g_pDumpCRC.PhyAddr, scaler_g_pDumpCRC.Memory);

		/* setup dump es ring buffer header */
		header = (VO_DUMP_BUFFER_HEADER*) scaler_g_pDumpCRC.Memory;
		header->magic = htonl(0xdeadcafe) ;
		header->size = htonl(scaler_DumpCRC_Config.mem_size) ;
		header->rd = htonl(scaler_g_pDumpCRC.PhyAddr + sizeof(VO_DUMP_BUFFER_HEADER)) ;
		header->wr = htonl(scaler_g_pDumpCRC.PhyAddr + sizeof(VO_DUMP_BUFFER_HEADER)) ;

		*(unsigned long *)scaler_g_pDumpCRC_Send.Memory = htonl(scaler_g_pDumpCRC.PhyAddr) ;

		pr_notice("[scaler] Header %lx, m=%x size=%x r(%x) w(%x)\n", (unsigned long)header, header->magic, header->size, header->rd, header->wr);
	}
	else {
		pr_notice("rtkscaler: no allocate debug dump ring buffer!\n");
		return 0 ;
	}

	rtkscaler_dumpcrc_tsk = kthread_create(rtkscaler_dumpcrc_thread, &data, "rtkscaler_dumpcrc_thread");
	if (IS_ERR(rtkscaler_dumpcrc_tsk)) {
		rtkscaler_dumpcrc_tsk = NULL;
		return -1 ;
	}
	wake_up_process(rtkscaler_dumpcrc_tsk);

	scaler_DumpCRC_Config.enable = 1 ;
#ifdef CONFIG_RTK_KDRV_RPC
	// FixMe, 20190920
	#if 0
	if (send_rpc_command(RPC_VIDEO, VIDEO_RPC_ToAgent_DumpScalerMDCRCInfo, (unsigned long)scaler_g_pDumpCRC_Send.PhyAddr, _ENABLE, &return_value)){
            pr_err("rtkscaler: VIDEO_RPC_ToAgent_DumpScalerMDCRCInfo fail %ld\n", return_value);
            rtkscaler_dumpCRC_disable();
            return -1;
       }
	#endif
#endif
	return 0 ;
}


void rtkscaler_dumpCRC_disable(void)
{
#ifdef CONFIG_RTK_KDRV_RPC
	//unsigned long return_value ;
#endif
	int ret = 0;
	unsigned long vir_addr ;
	SCALER_DUMP_BUFFER_HEADER *header;

	if (!scaler_DumpCRC_Config.enable) {
		pr_notice("rtkvo: es dump not enable!\n");
		return ;
	}

	scaler_DumpCRC_Config.enable = 0 ;
	/* setup debug dump ring buffer header */
	header = (SCALER_DUMP_BUFFER_HEADER*) scaler_g_pDumpCRC.Memory;
	header->magic = htonl(0xdeadcafe) ;
	header->size = htonl(16) ;
	header->rd = htonl(scaler_g_pDumpCRC.PhyAddr + sizeof(SCALER_DUMP_BUFFER_HEADER)) ;
	header->wr = htonl(scaler_g_pDumpCRC.PhyAddr + sizeof(SCALER_DUMP_BUFFER_HEADER)) ;
	*(unsigned long *)scaler_g_pDumpCRC_Send.Memory = htonl(scaler_g_pDumpCRC.PhyAddr) ;

#ifdef CONFIG_RTK_KDRV_RPC
	// FixMe, 20190920
	#if 0
	if (send_rpc_command(RPC_VIDEO, VIDEO_RPC_ToAgent_DumpScalerMDCRCInfo, 0, 0, &return_value))
		pr_err("rtkscaler: VIDEO_RPC_ToAgent_DumpScalerMDCRCInfo fail %ld\n", return_value);
	#endif
#endif

	ret = kthread_stop(rtkscaler_dumpcrc_tsk);
	if (!ret)
		pr_debug("rtkscaler dumpes thread stopped\n");

	f_offset_dumpcrc = 0 ;
	if (scaler_g_pDumpCRC.PhyAddr) {
		vir_addr = scaler_g_pDumpCRC.VirtAddr;
		dvr_free((void*)vir_addr);
		scaler_g_pDumpCRC.Memory = scaler_g_pDumpCRC.PhyAddr = scaler_g_pDumpCRC.VirtAddr = 0 ;
	}

	if (scaler_g_pDumpCRC_Send.PhyAddr) {
		vir_addr = scaler_g_pDumpCRC_Send.VirtAddr;
		dvr_free((void*)vir_addr);
		scaler_g_pDumpCRC_Send.Memory = scaler_g_pDumpCRC_Send.PhyAddr = scaler_g_pDumpCRC_Send.VirtAddr = 0 ;
	}

	if (scalerfile_DumpCRC)
		file_close(scalerfile_DumpCRC) ;
	scalerfile_DumpCRC = 0 ;
}
#endif

module_init(vsc_init_module) ;
module_exit(vsc_cleanup_module) ;
