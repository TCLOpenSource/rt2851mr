/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <memory.h> /* for memset */
#include <SecureRPC_System.h>
#include <ClientStub.h>

#include <RPCBaseDS.h>
#include <SecureRPCBaseDS.h>

HRESULT *
SECURE_RPC_ToAgent_PlayReady_0(RPC_tee_rpc_cmd_t *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(RPC_tee_rpc_cmd_t );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_PlayReady, clnt->sendMode,
		(xdrproc_t) xdr_RPC_tee_rpc_cmd_t, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

long *
SECURE_RPC_ToAgent_GetTeeManagerPid_0(long *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	long * result = NULL ;
	long args_size = sizeof(long );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (long *) malloc(sizeof(long ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_GetTeeManagerPid, clnt->sendMode,
		(xdrproc_t) xdr_long, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (long *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(long), XDR_DECODE);
		 if(!xdr_long(&xdrs, result))
			 return (long *)-1;
		return result;
	}

	return 0;

}

long *
SECURE_RPC_ToAgent_ForkProcessByName_0(RPC_tee_manager_cmd_t *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	long * result = NULL ;
	long args_size = sizeof(RPC_tee_manager_cmd_t );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (long *) malloc(sizeof(long ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_ForkProcessByName, clnt->sendMode,
		(xdrproc_t) xdr_RPC_tee_manager_cmd_t, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (long *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(long), XDR_DECODE);
		 if(!xdr_long(&xdrs, result))
			 return (long *)-1;
		return result;
	}

	return 0;

}

HRESULT *
SECURE_RPC_ToAgent_DeleteProcessByName_0(RPC_tee_manager_cmd_t *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(RPC_tee_manager_cmd_t );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_DeleteProcessByName, clnt->sendMode,
		(xdrproc_t) xdr_RPC_tee_manager_cmd_t, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
SECURE_RPC_ToAgent_SetSystemTime_0(RPC_tee_manager_time_t *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(RPC_tee_manager_time_t );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_SetSystemTime, clnt->sendMode,
		(xdrproc_t) xdr_RPC_tee_manager_time_t, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
SECURE_RPC_ToAgent_PrepareKStoreEnv_0(RPC_tee_manager_key_t *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(RPC_tee_manager_key_t );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_PrepareKStoreEnv, clnt->sendMode,
		(xdrproc_t) xdr_RPC_tee_manager_key_t, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
SECURE_RPC_ToAgent_DeleteMemoryInKcup_0(RPC_tee_manager_memInfo_t *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(RPC_tee_manager_memInfo_t );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_DeleteMemoryInKcup, clnt->sendMode,
		(xdrproc_t) xdr_RPC_tee_manager_memInfo_t, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

long *
SECURE_RPC_ToAgent_AllocateMemoryInKcup_0(RPC_tee_manager_memInfo_t *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	long * result = NULL ;
	long args_size = sizeof(RPC_tee_manager_memInfo_t );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (long *) malloc(sizeof(long ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_AllocateMemoryInKcup, clnt->sendMode,
		(xdrproc_t) xdr_RPC_tee_manager_memInfo_t, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (long *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(long), XDR_DECODE);
		 if(!xdr_long(&xdrs, result))
			 return (long *)-1;
		return result;
	}

	return 0;

}

long *
SECURE_RPC_ToAgent_SetTeeProtection_0(RPC_tee_protection_cmd_t *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	long * result = NULL ;
	long args_size = sizeof(RPC_tee_protection_cmd_t );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (long *) malloc(sizeof(long ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_SetTeeProtection, clnt->sendMode,
		(xdrproc_t) xdr_RPC_tee_protection_cmd_t, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (long *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(long), XDR_DECODE);
		 if(!xdr_long(&xdrs, result))
			 return (long *)-1;
		return result;
	}

	return 0;

}

HRESULT *
SECURE_RPC_ToAgent_DtvApi_SS_0(SECURE_RPC_DTVAPI_SS *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(SECURE_RPC_DTVAPI_SS );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_DtvApi_SS, clnt->sendMode,
		(xdrproc_t) xdr_SECURE_RPC_DTVAPI_SS, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
SECURE_RPC_ToAgent_Sstore_Cypto_0(RPC_sstore_rpc_cmd_t *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(RPC_sstore_rpc_cmd_t );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_Sstore_Cypto, clnt->sendMode,
		(xdrproc_t) xdr_RPC_sstore_rpc_cmd_t, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
SECURE_RPC_ToAgent_DtvApi_S_0(SECURE_RPC_DTVAPI_S *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(SECURE_RPC_DTVAPI_S );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_DtvApi_S, clnt->sendMode,
		(xdrproc_t) xdr_SECURE_RPC_DTVAPI_S, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
SECURE_RPC_ToAgent_DtvApi_M_0(SECURE_RPC_DTVAPI_M *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(SECURE_RPC_DTVAPI_M );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_DtvApi_M, clnt->sendMode,
		(xdrproc_t) xdr_SECURE_RPC_DTVAPI_M, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
SECURE_RPC_ToAgent_DtvApi_MM_0(SECURE_RPC_DTVAPI_MM *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(SECURE_RPC_DTVAPI_MM );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_DtvApi_MM, clnt->sendMode,
		(xdrproc_t) xdr_SECURE_RPC_DTVAPI_MM, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
SECURE_RPC_ToAgent_DtvApi_L_0(SECURE_RPC_DTVAPI_L *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(SECURE_RPC_DTVAPI_L );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_DtvApi_L, clnt->sendMode,
		(xdrproc_t) xdr_SECURE_RPC_DTVAPI_L, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

RPCRES_LONG *
SECURE_RPC_ToAgent_DtvApiWithRes_0(SECURE_RPC_DTVAPI_SS *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	RPCRES_LONG * result = NULL ;
	long args_size = sizeof(SECURE_RPC_DTVAPI_SS );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (RPCRES_LONG *) malloc(sizeof(RPCRES_LONG ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_DtvApiWithRes, clnt->sendMode,
		(xdrproc_t) xdr_SECURE_RPC_DTVAPI_SS, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (RPCRES_LONG *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(RPCRES_LONG), XDR_DECODE);
		 if(!xdr_RPCRES_LONG(&xdrs, result))
			 return (RPCRES_LONG *)-1;
		return result;
	}

	return 0;

}

RPCRES_LONG *
SECURE_RPC_ToAgent_DtvApiWithRes_rl_S_0(SECURE_RPC_DTVAPI_S *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	RPCRES_LONG * result = NULL ;
	long args_size = sizeof(SECURE_RPC_DTVAPI_S );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (RPCRES_LONG *) malloc(sizeof(RPCRES_LONG ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_DtvApiWithRes_rl_S, clnt->sendMode,
		(xdrproc_t) xdr_SECURE_RPC_DTVAPI_S, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (RPCRES_LONG *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(RPCRES_LONG), XDR_DECODE);
		 if(!xdr_RPCRES_LONG(&xdrs, result))
			 return (RPCRES_LONG *)-1;
		return result;
	}

	return 0;

}

RPCRES_LONG *
SECURE_RPC_ToAgent_DtvApiWithRes_rl_M_0(SECURE_RPC_DTVAPI_M *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	RPCRES_LONG * result = NULL ;
	long args_size = sizeof(SECURE_RPC_DTVAPI_M );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (RPCRES_LONG *) malloc(sizeof(RPCRES_LONG ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_DtvApiWithRes_rl_M, clnt->sendMode,
		(xdrproc_t) xdr_SECURE_RPC_DTVAPI_M, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (RPCRES_LONG *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(RPCRES_LONG), XDR_DECODE);
		 if(!xdr_RPCRES_LONG(&xdrs, result))
			 return (RPCRES_LONG *)-1;
		return result;
	}

	return 0;

}

RPCRES_LONG *
SECURE_RPC_ToAgent_DtvApiWithRes_rl_MM_0(SECURE_RPC_DTVAPI_MM *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	RPCRES_LONG * result = NULL ;
	long args_size = sizeof(SECURE_RPC_DTVAPI_MM );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (RPCRES_LONG *) malloc(sizeof(RPCRES_LONG ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_DtvApiWithRes_rl_MM, clnt->sendMode,
		(xdrproc_t) xdr_SECURE_RPC_DTVAPI_MM, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (RPCRES_LONG *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(RPCRES_LONG), XDR_DECODE);
		 if(!xdr_RPCRES_LONG(&xdrs, result))
			 return (RPCRES_LONG *)-1;
		return result;
	}

	return 0;

}

RPCRES_LONG *
SECURE_RPC_ToAgent_DtvApiWithRes_rl_L_0(SECURE_RPC_DTVAPI_L *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	RPCRES_LONG * result = NULL ;
	long args_size = sizeof(SECURE_RPC_DTVAPI_L );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (RPCRES_LONG *) malloc(sizeof(RPCRES_LONG ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_DtvApiWithRes_rl_L, clnt->sendMode,
		(xdrproc_t) xdr_SECURE_RPC_DTVAPI_L, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (RPCRES_LONG *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(RPCRES_LONG), XDR_DECODE);
		 if(!xdr_RPCRES_LONG(&xdrs, result))
			 return (RPCRES_LONG *)-1;
		return result;
	}

	return 0;

}

RPCRES_LONG *
SECURE_RPC_ToAgent_DtvApiWithRes_rl_LL_0(SECURE_RPC_DTVAPI_LL *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	RPCRES_LONG * result = NULL ;
	long args_size = sizeof(SECURE_RPC_DTVAPI_LL );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (RPCRES_LONG *) malloc(sizeof(RPCRES_LONG ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_DtvApiWithRes_rl_LL, clnt->sendMode,
		(xdrproc_t) xdr_SECURE_RPC_DTVAPI_LL, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (RPCRES_LONG *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(RPCRES_LONG), XDR_DECODE);
		 if(!xdr_RPCRES_LONG(&xdrs, result))
			 return (RPCRES_LONG *)-1;
		return result;
	}

	return 0;

}

RPCRES_SS *
SECURE_RPC_ToAgent_DtvApiWithRes_rss_0(SECURE_RPC_DTVAPI_SS *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	RPCRES_SS * result = NULL ;
	long args_size = sizeof(SECURE_RPC_DTVAPI_SS );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (RPCRES_SS *) malloc(sizeof(RPCRES_SS ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_DtvApiWithRes_rss, clnt->sendMode,
		(xdrproc_t) xdr_SECURE_RPC_DTVAPI_SS, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (RPCRES_SS *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(RPCRES_SS), XDR_DECODE);
		 if(!xdr_RPCRES_SS(&xdrs, result))
			 return (RPCRES_SS *)-1;
		return result;
	}

	return 0;

}

RPCRES_SS *
SECURE_RPC_ToAgent_DtvApiWithRes_rss_S_0(SECURE_RPC_DTVAPI_S *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	RPCRES_SS * result = NULL ;
	long args_size = sizeof(SECURE_RPC_DTVAPI_S );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (RPCRES_SS *) malloc(sizeof(RPCRES_SS ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_DtvApiWithRes_rss_S, clnt->sendMode,
		(xdrproc_t) xdr_SECURE_RPC_DTVAPI_S, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (RPCRES_SS *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(RPCRES_SS), XDR_DECODE);
		 if(!xdr_RPCRES_SS(&xdrs, result))
			 return (RPCRES_SS *)-1;
		return result;
	}

	return 0;

}

RPCRES_SS *
SECURE_RPC_ToAgent_DtvApiWithRes_rss_M_0(SECURE_RPC_DTVAPI_M *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	RPCRES_SS * result = NULL ;
	long args_size = sizeof(SECURE_RPC_DTVAPI_M );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (RPCRES_SS *) malloc(sizeof(RPCRES_SS ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_DtvApiWithRes_rss_M, clnt->sendMode,
		(xdrproc_t) xdr_SECURE_RPC_DTVAPI_M, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (RPCRES_SS *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(RPCRES_SS), XDR_DECODE);
		 if(!xdr_RPCRES_SS(&xdrs, result))
			 return (RPCRES_SS *)-1;
		return result;
	}

	return 0;

}

RPCRES_SS *
SECURE_RPC_ToAgent_DtvApiWithRes_rss_MM_0(SECURE_RPC_DTVAPI_MM *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	RPCRES_SS * result = NULL ;
	long args_size = sizeof(SECURE_RPC_DTVAPI_MM );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (RPCRES_SS *) malloc(sizeof(RPCRES_SS ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_DtvApiWithRes_rss_MM, clnt->sendMode,
		(xdrproc_t) xdr_SECURE_RPC_DTVAPI_MM, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (RPCRES_SS *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(RPCRES_SS), XDR_DECODE);
		 if(!xdr_RPCRES_SS(&xdrs, result))
			 return (RPCRES_SS *)-1;
		return result;
	}

	return 0;

}

RPCRES_SS *
SECURE_RPC_ToAgent_DtvApiWithRes_rss_L_0(SECURE_RPC_DTVAPI_L *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	RPCRES_SS * result = NULL ;
	long args_size = sizeof(SECURE_RPC_DTVAPI_L );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (RPCRES_SS *) malloc(sizeof(RPCRES_SS ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_DtvApiWithRes_rss_L, clnt->sendMode,
		(xdrproc_t) xdr_SECURE_RPC_DTVAPI_L, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (RPCRES_SS *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(RPCRES_SS), XDR_DECODE);
		 if(!xdr_RPCRES_SS(&xdrs, result))
			 return (RPCRES_SS *)-1;
		return result;
	}

	return 0;

}

RPCRES_S *
SECURE_RPC_ToAgent_DtvApiWithRes_S_0(SECURE_RPC_DTVAPI_SS *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	RPCRES_S * result = NULL ;
	long args_size = sizeof(SECURE_RPC_DTVAPI_SS );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (RPCRES_S *) malloc(sizeof(RPCRES_S ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_DtvApiWithRes_S, clnt->sendMode,
		(xdrproc_t) xdr_SECURE_RPC_DTVAPI_SS, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (RPCRES_S *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(RPCRES_S), XDR_DECODE);
		 if(!xdr_RPCRES_S(&xdrs, result))
			 return (RPCRES_S *)-1;
		return result;
	}

	return 0;

}

RPCRES_M *
SECURE_RPC_ToAgent_DtvApiWithRes_M_0(SECURE_RPC_DTVAPI_SS *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	RPCRES_M * result = NULL ;
	long args_size = sizeof(SECURE_RPC_DTVAPI_SS );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (RPCRES_M *) malloc(sizeof(RPCRES_M ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_DtvApiWithRes_M, clnt->sendMode,
		(xdrproc_t) xdr_SECURE_RPC_DTVAPI_SS, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (RPCRES_M *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(RPCRES_M), XDR_DECODE);
		 if(!xdr_RPCRES_M(&xdrs, result))
			 return (RPCRES_M *)-1;
		return result;
	}

	return 0;

}

RPCRES_MM *
SECURE_RPC_ToAgent_DtvApiWithRes_MM_0(SECURE_RPC_DTVAPI_SS *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	RPCRES_MM * result = NULL ;
	long args_size = sizeof(SECURE_RPC_DTVAPI_SS );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (RPCRES_MM *) malloc(sizeof(RPCRES_MM ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_DtvApiWithRes_MM, clnt->sendMode,
		(xdrproc_t) xdr_SECURE_RPC_DTVAPI_SS, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (RPCRES_MM *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(RPCRES_MM), XDR_DECODE);
		 if(!xdr_RPCRES_MM(&xdrs, result))
			 return (RPCRES_MM *)-1;
		return result;
	}

	return 0;

}

RPCRES_L *
SECURE_RPC_ToAgent_DtvApiWithRes_L_0(SECURE_RPC_DTVAPI_SS *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	RPCRES_L * result = NULL ;
	long args_size = sizeof(SECURE_RPC_DTVAPI_SS );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (RPCRES_L *) malloc(sizeof(RPCRES_L ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_DtvApiWithRes_L, clnt->sendMode,
		(xdrproc_t) xdr_SECURE_RPC_DTVAPI_SS, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (RPCRES_L *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(RPCRES_L), XDR_DECODE);
		 if(!xdr_RPCRES_L(&xdrs, result))
			 return (RPCRES_L *)-1;
		return result;
	}

	return 0;

}

RPCRES_L *
SECURE_RPC_ToAgent_DtvApiWithRes_L_L_0(SECURE_RPC_DTVAPI_L *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	RPCRES_L * result = NULL ;
	long args_size = sizeof(SECURE_RPC_DTVAPI_L );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (RPCRES_L *) malloc(sizeof(RPCRES_L ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_DtvApiWithRes_L_L, clnt->sendMode,
		(xdrproc_t) xdr_SECURE_RPC_DTVAPI_L, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (RPCRES_L *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(RPCRES_L), XDR_DECODE);
		 if(!xdr_RPCRES_L(&xdrs, result))
			 return (RPCRES_L *)-1;
		return result;
	}

	return 0;

}

int *
SECURE_RPC_ToAgent_SecureKeyBox_0(RPC_tee_rpc_cmd_t *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	int * result = NULL ;
	long args_size = sizeof(RPC_tee_rpc_cmd_t );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (int *) malloc(sizeof(int ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, SECURE_RPC_ToAgent_SecureKeyBox, clnt->sendMode,
		(xdrproc_t) xdr_RPC_tee_rpc_cmd_t, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (int *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(int), XDR_DECODE);
		 if(!xdr_int(&xdrs, result))
			 return (int *)-1;
		return result;
	}

	return 0;

}
