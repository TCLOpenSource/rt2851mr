/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <AudioRPC_Agent.h>
#include <rt/misc/ClientStub.h>

#include <RPCBaseDS.h>
#include <AudioRPCBaseDS.h>

void * AllocateMem(int c, void *s);

#define INT8U unsigned char
INT8U ReleaseMem(void *msg);

HRESULT *
AUDIO_RPC_ToSystem_ErrorStatus_0(AUDIO_RPC_ERROR *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_ERROR );
	unsigned char pool;


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) AllocateMem(sizeof(HRESULT ), &pool);
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToSystem_ErrorStatus, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_ERROR, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			ReleaseMem(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToSystem_DeliverFlush_0(AUDIO_RPC_SENDIO *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_SENDIO );
	unsigned char pool;


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) AllocateMem(sizeof(HRESULT ), &pool);
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToSystem_DeliverFlush, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_SENDIO, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			ReleaseMem(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToSystem_EndOfStream_0(AUDIO_RPC_SENDPIN_LONG *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_SENDPIN_LONG );
	unsigned char pool;


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) AllocateMem(sizeof(HRESULT ), &pool);
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToSystem_EndOfStream, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_SENDPIN_LONG, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			ReleaseMem(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToSystem_ENC_GeneralInfo_0(long *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(long );
	unsigned char pool;


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) AllocateMem(sizeof(HRESULT ), &pool);
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToSystem_ENC_GeneralInfo, clnt->sendMode,
		(xdrproc_t) xdr_long, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			ReleaseMem(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToSystem_ENC_FrameInfo_0(long *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(long );
	unsigned char pool;


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) AllocateMem(sizeof(HRESULT ), &pool);
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToSystem_ENC_FrameInfo, clnt->sendMode,
		(xdrproc_t) xdr_long, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			ReleaseMem(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToSystem_ENC_EndOfStream_0(long *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(long );
	unsigned char pool;


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) AllocateMem(sizeof(HRESULT ), &pool);
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToSystem_ENC_EndOfStream, clnt->sendMode,
		(xdrproc_t) xdr_long, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			ReleaseMem(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToSystem_DEC_GeneralInfo_0(AUDIO_RPC_DEC_GENERAL_INFO *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_DEC_GENERAL_INFO );
	unsigned char pool;


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) AllocateMem(sizeof(HRESULT ), &pool);
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToSystem_DEC_GeneralInfo, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_DEC_GENERAL_INFO, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			ReleaseMem(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToSystem_DEC_FrameInfo_0(AUDIO_RPC_DEC_GENERAL_INFO *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_DEC_GENERAL_INFO );
	unsigned char pool;


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) AllocateMem(sizeof(HRESULT ), &pool);
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToSystem_DEC_FrameInfo, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_DEC_GENERAL_INFO, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			ReleaseMem(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToSystem_AIN_FrameInfo_0(long *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(long );
	unsigned char pool;


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) AllocateMem(sizeof(HRESULT ), &pool);
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToSystem_AIN_FrameInfo, clnt->sendMode,
		(xdrproc_t) xdr_long, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			ReleaseMem(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToSystem_AO_KaraokeModeIndicate_0(long *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(long );
	unsigned char pool;


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) AllocateMem(sizeof(HRESULT ), &pool);
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToSystem_AO_KaraokeModeIndicate, clnt->sendMode,
		(xdrproc_t) xdr_long, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			ReleaseMem(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToSystem_AO_ReportSPDIFStatus_0(AUDIO_RPC_SPDIF_CHANNEL_STATUS *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_SPDIF_CHANNEL_STATUS );
	unsigned char pool;


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) AllocateMem(sizeof(HRESULT ), &pool);
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToSystem_AO_ReportSPDIFStatus, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_SPDIF_CHANNEL_STATUS, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			ReleaseMem(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToSystem_AO_PostMastership_0(AUDIO_RPC_MASTERSHIP *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_MASTERSHIP );
	unsigned char pool;


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) AllocateMem(sizeof(HRESULT ), &pool);
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToSystem_AO_PostMastership, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_MASTERSHIP, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			ReleaseMem(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToSystem_AO_ConfigDACDone_0(long *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(long );
	unsigned char pool;


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) AllocateMem(sizeof(HRESULT ), &pool);
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToSystem_AO_ConfigDACDone, clnt->sendMode,
		(xdrproc_t) xdr_long, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			ReleaseMem(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToSystem_DAC_HardwareMute_0(long *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(long );
	unsigned char pool;


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) AllocateMem(sizeof(HRESULT ), &pool);
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToSystem_DAC_HardwareMute, clnt->sendMode,
		(xdrproc_t) xdr_long, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			ReleaseMem(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToSystem_ADC_HardwareMute_0(long *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(long );
	unsigned char pool;


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) AllocateMem(sizeof(HRESULT ), &pool);
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToSystem_ADC_HardwareMute, clnt->sendMode,
		(xdrproc_t) xdr_long, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			ReleaseMem(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

RPCRES_LONG *
AUDIO_RPC_ToSystem_HashCheck_0(AUDIO_RPC_HASH *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	RPCRES_LONG * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_HASH );
	unsigned char pool;


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (RPCRES_LONG *) AllocateMem(sizeof(RPCRES_LONG ), &pool);
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToSystem_HashCheck, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_HASH, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			ReleaseMem(result);
		return (RPCRES_LONG *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(RPCRES_LONG), XDR_DECODE);
		 if(!xdr_RPCRES_LONG(&xdrs, result))
			 return (RPCRES_LONG *)-1;
		return result;
	}

	return 0;

}

AUDIO_RPC_IOBUFFER *
AUDIO_RPC_ToSystem_CreateIOBuf_0(long *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	AUDIO_RPC_IOBUFFER * result = NULL ;
	long args_size = sizeof(long );
	unsigned char pool;


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (AUDIO_RPC_IOBUFFER *) AllocateMem(sizeof(AUDIO_RPC_IOBUFFER ), &pool);
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToSystem_CreateIOBuf, clnt->sendMode,
		(xdrproc_t) xdr_long, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			ReleaseMem(result);
		return (AUDIO_RPC_IOBUFFER *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(AUDIO_RPC_IOBUFFER), XDR_DECODE);
		 if(!xdr_AUDIO_RPC_IOBUFFER(&xdrs, result))
			 return (AUDIO_RPC_IOBUFFER *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToSystem_FreeIOBuf_0(long *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(long );
	unsigned char pool;


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) AllocateMem(sizeof(HRESULT ), &pool);
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToSystem_FreeIOBuf, clnt->sendMode,
		(xdrproc_t) xdr_long, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			ReleaseMem(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

AUDIO_RPC_BUFFER *
AUDIO_RPC_ToSystem_CreateBuf_0(long *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	AUDIO_RPC_BUFFER * result = NULL ;
	long args_size = sizeof(long );
	unsigned char pool;


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (AUDIO_RPC_BUFFER *) AllocateMem(sizeof(AUDIO_RPC_BUFFER ), &pool);
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToSystem_CreateBuf, clnt->sendMode,
		(xdrproc_t) xdr_long, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			ReleaseMem(result);
		return (AUDIO_RPC_BUFFER *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(AUDIO_RPC_BUFFER), XDR_DECODE);
		 if(!xdr_AUDIO_RPC_BUFFER(&xdrs, result))
			 return (AUDIO_RPC_BUFFER *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToSystem_FreeBuf_0(long *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(long );
	unsigned char pool;


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) AllocateMem(sizeof(HRESULT ), &pool);
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToSystem_FreeBuf, clnt->sendMode,
		(xdrproc_t) xdr_long, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			ReleaseMem(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

SYSTEM_PROCESS_RES *
AUDIO_RPC_ToSystem_Process_Open_0(SYSTEM_PROCESS_INFO *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	SYSTEM_PROCESS_RES * result = NULL ;
	long args_size = sizeof(SYSTEM_PROCESS_INFO );
	unsigned char pool;


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (SYSTEM_PROCESS_RES *) AllocateMem(sizeof(SYSTEM_PROCESS_RES ), &pool);
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToSystem_Process_Open, clnt->sendMode,
		(xdrproc_t) xdr_SYSTEM_PROCESS_INFO, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			ReleaseMem(result);
		return (SYSTEM_PROCESS_RES *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(SYSTEM_PROCESS_RES), XDR_DECODE);
		 if(!xdr_SYSTEM_PROCESS_RES(&xdrs, result))
			 return (SYSTEM_PROCESS_RES *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToSystem_Process_Close_0(SYSTEM_PROCESS_INFO *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(SYSTEM_PROCESS_INFO );
	unsigned char pool;


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) AllocateMem(sizeof(HRESULT ), &pool);
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToSystem_Process_Close, clnt->sendMode,
		(xdrproc_t) xdr_SYSTEM_PROCESS_INFO, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			ReleaseMem(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToSystem_HDMI_Mute_0(long *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(long );
	unsigned char pool;


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) AllocateMem(sizeof(HRESULT ), &pool);
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToSystem_HDMI_Mute, clnt->sendMode,
		(xdrproc_t) xdr_long, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			ReleaseMem(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToSystem_HDMI_Setting_0(struct AUDIO_HDMI_SETTING_INFO *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(struct AUDIO_HDMI_SETTING_INFO );
	unsigned char pool;


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) AllocateMem(sizeof(HRESULT ), &pool);
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToSystem_HDMI_Setting, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_HDMI_SETTING_INFO, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			ReleaseMem(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToSystem_AudioHaltDone_0(long *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(long );
	unsigned char pool;


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) AllocateMem(sizeof(HRESULT ), &pool);
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToSystem_AudioHaltDone, clnt->sendMode,
		(xdrproc_t) xdr_long, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			ReleaseMem(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToSystem_PrivateInfo_0(AUDIO_RPC_PRIVATEINFO_TO_SYS *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_PRIVATEINFO_TO_SYS );
	unsigned char pool;


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) AllocateMem(sizeof(HRESULT ), &pool);
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToSystem_PrivateInfo, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_PRIVATEINFO_TO_SYS, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			ReleaseMem(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToKernel_SimpleCommand_0(AUDIO_RPC_TO_KERNEL_PARAMETER *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_TO_KERNEL_PARAMETER );
	unsigned char pool;


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) AllocateMem(sizeof(HRESULT ), &pool);
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToKernel_SimpleCommand, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_TO_KERNEL_PARAMETER, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			ReleaseMem(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}
